import { type EntryCreateParams } from "../schema";

// TODO:
// Postgres
// Dropbox?
// Terminal?
// Stripe
// Obsidian
// Playwright

// Gmail
// Google Drive
// Google Calendar
// Google Maps

// All of these servers work. To add a new one, add it to this list.
// Please test it with bin/test-entry.ts before merging to main
export const entries: any[] = [
  {
    name: "github",
    title: "GitHub",
    description:
      "Provides seamless integration with GitHub APIs, enabling advanced automation and interaction capabilities for developers and tools.",
    isOfficial: true,
    icon: "https://registry.director.run/github.svg",
    homepage: "https://github.com/github/github-mcp-server",
    transport: {
      type: "http",
      url: "https://api.githubcopilot.com/mcp/",
      headers: {
        Authorization: "Bearer <github-personal-access-token>",
      },
    },
    parameters: [
      {
        name: "github-personal-access-token",
        description:
          "Get a personal access token from [GitHub Settings](https://github.com/settings/tokens)",
        type: "string",
        password: true,
        required: true,
      },
    ],
  },
  {
    name: "makenotion-notion-mcp-server",
    title: "Notion",
    description:
      "Connect to Notion API, enabling advanced automation and interaction capabilities for developers and tools.",
    isOfficial: true,
    icon: "https://registry.director.run/notion.svg",
    homepage: "https://github.com/makenotion/notion-mcp-server",
    transport: {
      type: "stdio",
      command: "npx",
      args: ["-y", "@notionhq/notion-mcp-server"],
      env: {
        OPENAPI_MCP_HEADERS:
          '{"Authorization": "Bearer <notion-bearer-token>", "Notion-Version": "2022-06-28" }',
      },
    },
    parameters: [
      {
        name: "notion-bearer-token",
        description:
          "Get a bearer token from [Notion Settings](https://www.notion.so/profile/integrations)",
        type: "string",
        required: true,
        password: true,
      },
    ],
    "tools": [
      {
        "name": "API-get-user",
        "description": "Retrieve a user\nError Responses:\n400: 400",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user_id": {
              "type": "string",
              "format": "uuid"
            }
          },
          "required": [
            "user_id"
          ]
        }
      },
      {
        "name": "API-get-users",
        "description": "List all users\nError Responses:\n400: 400",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_size": {
              "type": "integer",
              "default": 100,
              "description": "The number of items from the full list desired in the response. Maximum: 100"
            },
            "start_cursor": {
              "type": "string",
              "description": "If supplied, this endpoint will return a page of results starting after the cursor provided. If not supplied, this endpoint will return the first page of results."
            }
          },
          "required": []
        }
      },
      {
        "name": "API-get-self",
        "description": "Retrieve your token's bot user",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "API-post-database-query",
        "description": "Query a database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sorts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "property",
                  "direction"
                ],
                "properties": {
                  "property": {
                    "type": "string"
                  },
                  "direction": {
                    "enum": [
                      "ascending",
                      "descending"
                    ],
                    "type": "string"
                  }
                },
                "additionalProperties": true
              },
              "description": "When supplied, orders the results based on the provided [sort criteria](ref:post-database-query-sort)."
            },
            "filter": {
              "type": "object",
              "description": "When supplied, limits which pages are returned based on the [filter conditions](ref:post-database-query-filter).",
              "additionalProperties": true
            },
            "archived": {
              "type": "boolean"
            },
            "in_trash": {
              "type": "boolean"
            },
            "page_size": {
              "type": "integer",
              "default": 100,
              "description": "The number of items from the full list desired in the response. Maximum: 100"
            },
            "database_id": {
              "type": "string",
              "description": "Identifier for a Notion database."
            },
            "start_cursor": {
              "type": "string",
              "description": "When supplied, returns a page of results starting after the cursor provided. If not supplied, this endpoint will return the first page of results."
            },
            "filter_properties": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of page property value IDs associated with the database. Use this param to limit the response to a specific page property value or values for pages that meet the `filter` criteria."
            }
          },
          "required": [
            "database_id"
          ]
        }
      },
      {
        "name": "API-post-search",
        "description": "Search by title",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "type": "object",
              "properties": {
                "direction": {
                  "type": "string",
                  "description": "The direction to sort. Possible values include `ascending` and `descending`."
                },
                "timestamp": {
                  "type": "string",
                  "description": "The name of the timestamp to sort against. Possible values include `last_edited_time`."
                }
              },
              "description": "A set of criteria, `direction` and `timestamp` keys, that orders the results. The **only** supported timestamp value is `\"last_edited_time\"`. Supported `direction` values are `\"ascending\"` and `\"descending\"`. If `sort` is not provided, then the most recently edited results are returned first.",
              "additionalProperties": true
            },
            "query": {
              "type": "string",
              "description": "The text that the API compares page and database titles against."
            },
            "filter": {
              "type": "object",
              "properties": {
                "value": {
                  "type": "string",
                  "description": "The value of the property to filter the results by.  Possible values for object type include `page` or `database`.  **Limitation**: Currently the only filter allowed is `object` which will filter by type of object (either `page` or `database`)"
                },
                "property": {
                  "type": "string",
                  "description": "The name of the property to filter by. Currently the only property you can filter by is the object type.  Possible values include `object`.   Limitation: Currently the only filter allowed is `object` which will filter by type of object (either `page` or `database`)"
                }
              },
              "description": "A set of criteria, `value` and `property` keys, that limits the results to either only pages or only databases. Possible `value` values are `\"page\"` or `\"database\"`. The only supported `property` value is `\"object\"`.",
              "additionalProperties": true
            },
            "page_size": {
              "type": "integer",
              "format": "int32",
              "default": 100,
              "description": "The number of items from the full list to include in the response. Maximum: `100`."
            },
            "start_cursor": {
              "type": "string",
              "description": "A `cursor` value returned in a previous response that If supplied, limits the response to results starting after the `cursor`. If not supplied, then the first page of results is returned. Refer to [pagination](https://developers.notion.com/reference/intro#pagination) for more details."
            }
          },
          "required": []
        }
      },
      {
        "name": "API-get-block-children",
        "description": "Retrieve block children",
        "inputSchema": {
          "type": "object",
          "properties": {
            "block_id": {
              "type": "string",
              "description": "Identifier for a [block](ref:block)"
            },
            "page_size": {
              "type": "integer",
              "format": "int32",
              "default": 100,
              "description": "The number of items from the full list desired in the response. Maximum: 100"
            },
            "start_cursor": {
              "type": "string",
              "description": "If supplied, this endpoint will return a page of results starting after the cursor provided. If not supplied, this endpoint will return the first page of results."
            }
          },
          "required": [
            "block_id"
          ]
        }
      },
      {
        "name": "API-patch-block-children",
        "description": "Append block children",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string",
              "description": "The ID of the existing block that the new block should be appended after."
            },
            "block_id": {
              "type": "string",
              "description": "Identifier for a [block](ref:block). Also accepts a [page](ref:page) ID."
            },
            "children": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "enum": [
                      "paragraph",
                      "bulleted_list_item"
                    ],
                    "type": "string"
                  },
                  "paragraph": {
                    "type": "object",
                    "required": [
                      "rich_text"
                    ],
                    "properties": {
                      "rich_text": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": [
                            "text"
                          ],
                          "properties": {
                            "text": {
                              "type": "object",
                              "required": [
                                "content"
                              ],
                              "properties": {
                                "link": {
                                  "type": [
                                    "object",
                                    "null"
                                  ]
                                },
                                "content": {
                                  "type": "string"
                                }
                              },
                              "additionalProperties": false
                            },
                            "type": {
                              "enum": [
                                "text"
                              ],
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        }
                      }
                    },
                    "additionalProperties": false
                  },
                  "bulleted_list_item": {
                    "type": "object",
                    "required": [
                      "rich_text"
                    ],
                    "properties": {
                      "rich_text": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "required": [
                            "text"
                          ],
                          "properties": {
                            "text": {
                              "type": "object",
                              "required": [
                                "content"
                              ],
                              "properties": {
                                "link": {
                                  "type": [
                                    "object",
                                    "null"
                                  ]
                                },
                                "content": {
                                  "type": "string"
                                }
                              },
                              "additionalProperties": false
                            },
                            "type": {
                              "enum": [
                                "text"
                              ],
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        }
                      }
                    },
                    "additionalProperties": false
                  }
                },
                "additionalProperties": false
              },
              "description": "Child content to append to a container block as an array of [block objects](ref:block)"
            }
          },
          "required": [
            "block_id",
            "children"
          ]
        }
      },
      {
        "name": "API-retrieve-a-block",
        "description": "Retrieve a block",
        "inputSchema": {
          "type": "object",
          "properties": {
            "block_id": {
              "type": "string",
              "description": "Identifier for a Notion block"
            }
          },
          "required": [
            "block_id"
          ]
        }
      },
      {
        "name": "API-update-a-block",
        "description": "Update a block",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "object",
              "properties": {},
              "description": "The [block object `type`](ref:block#block-object-keys) value with the properties to be updated. Currently only `text` (for supported block types) and `checked` (for `to_do` blocks) fields can be updated.",
              "additionalProperties": true
            },
            "archived": {
              "type": "boolean",
              "default": true,
              "description": "Set to true to archive (delete) a block. Set to false to un-archive (restore) a block."
            },
            "block_id": {
              "type": "string",
              "description": "Identifier for a Notion block"
            }
          },
          "required": [
            "block_id"
          ]
        }
      },
      {
        "name": "API-delete-a-block",
        "description": "Delete a block",
        "inputSchema": {
          "type": "object",
          "properties": {
            "block_id": {
              "type": "string",
              "description": "Identifier for a Notion block"
            }
          },
          "required": [
            "block_id"
          ]
        }
      },
      {
        "name": "API-retrieve-a-page",
        "description": "Retrieve a page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string",
              "description": "Identifier for a Notion page"
            },
            "filter_properties": {
              "type": "string",
              "description": "A list of page property value IDs associated with the page. Use this param to limit the response to a specific page property value or values. To retrieve multiple properties, specify each page property ID. For example: `?filter_properties=iAk8&filter_properties=b7dh`."
            }
          },
          "required": [
            "page_id"
          ]
        }
      },
      {
        "name": "API-patch-page",
        "description": "Update page properties",
        "inputSchema": {
          "type": "object",
          "properties": {
            "icon": {
              "type": "object",
              "required": [
                "emoji"
              ],
              "properties": {
                "emoji": {
                  "type": "string"
                }
              },
              "description": "A page icon for the page. Supported types are [external file object](https://developers.notion.com/reference/file-object) or [emoji object](https://developers.notion.com/reference/emoji-object).",
              "additionalProperties": false
            },
            "cover": {
              "type": "object",
              "required": [
                "external"
              ],
              "properties": {
                "type": {
                  "enum": [
                    "external"
                  ],
                  "type": "string"
                },
                "external": {
                  "type": "object",
                  "required": [
                    "url"
                  ],
                  "properties": {
                    "url": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "description": "A cover image for the page. Only [external file objects](https://developers.notion.com/reference/file-object) are supported.",
              "additionalProperties": false
            },
            "page_id": {
              "type": "string",
              "description": "The identifier for the Notion page to be updated."
            },
            "archived": {
              "type": "boolean"
            },
            "in_trash": {
              "type": "boolean",
              "default": false,
              "description": "Set to true to delete a block. Set to false to restore a block."
            },
            "properties": {
              "type": "object",
              "required": [
                "title"
              ],
              "properties": {
                "type": {
                  "enum": [
                    "title"
                  ],
                  "type": "string"
                },
                "title": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "text"
                    ],
                    "properties": {
                      "text": {
                        "type": "object",
                        "required": [
                          "content"
                        ],
                        "properties": {
                          "link": {
                            "type": [
                              "object",
                              "null"
                            ]
                          },
                          "content": {
                            "type": "string"
                          }
                        },
                        "additionalProperties": false
                      },
                      "type": {
                        "enum": [
                          "text"
                        ],
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  }
                }
              },
              "description": "The property values to update for the page. The keys are the names or IDs of the property and the values are property values. If a page property ID is not included, then it is not changed.",
              "additionalProperties": false
            }
          },
          "required": [
            "page_id"
          ]
        }
      },
      {
        "name": "API-post-page",
        "description": "Create a page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "icon": {
              "type": "string",
              "format": "json",
              "description": "The icon of the new page. Either an [emoji object](https://developers.notion.com/reference/emoji-object) or an [external file object](https://developers.notion.com/reference/file-object).."
            },
            "cover": {
              "type": "string",
              "format": "json",
              "description": "The cover image of the new page, represented as a [file object](https://developers.notion.com/reference/file-object)."
            },
            "parent": {
              "type": "object",
              "required": [
                "page_id"
              ],
              "properties": {
                "page_id": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "additionalProperties": true
            },
            "children": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The content to be rendered on the new page, represented as an array of [block objects](https://developers.notion.com/reference/block)."
            },
            "properties": {
              "type": "object",
              "required": [
                "title"
              ],
              "properties": {
                "type": {
                  "enum": [
                    "title"
                  ],
                  "type": "string"
                },
                "title": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "text"
                    ],
                    "properties": {
                      "text": {
                        "type": "object",
                        "required": [
                          "content"
                        ],
                        "properties": {
                          "content": {
                            "type": "string"
                          }
                        },
                        "additionalProperties": true
                      }
                    },
                    "additionalProperties": true
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "parent",
            "properties"
          ]
        }
      },
      {
        "name": "API-create-a-database",
        "description": "Create a database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "text"
                ],
                "properties": {
                  "text": {
                    "type": "object",
                    "required": [
                      "content"
                    ],
                    "properties": {
                      "link": {
                        "type": [
                          "object",
                          "null"
                        ]
                      },
                      "content": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "type": {
                    "enum": [
                      "text"
                    ],
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "parent": {
              "type": "object",
              "required": [
                "type",
                "page_id"
              ],
              "properties": {
                "type": {
                  "enum": [
                    "page_id"
                  ],
                  "type": "string"
                },
                "page_id": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "additionalProperties": true
            },
            "properties": {
              "type": "object",
              "description": "Property schema of database. The keys are the names of properties as they appear in Notion and the values are [property schema objects](https://developers.notion.com/reference/property-schema-object).",
              "additionalProperties": {
                "oneOf": [
                  {
                    "type": "object",
                    "required": [
                      "title"
                    ],
                    "properties": {
                      "title": {
                        "type": "object",
                        "properties": {},
                        "additionalProperties": false
                      },
                      "description": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  }
                ]
              }
            }
          },
          "required": [
            "parent",
            "properties"
          ]
        }
      },
      {
        "name": "API-update-a-database",
        "description": "Update a database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "text"
                ],
                "properties": {
                  "text": {
                    "type": "object",
                    "required": [
                      "content"
                    ],
                    "properties": {
                      "link": {
                        "type": [
                          "object",
                          "null"
                        ]
                      },
                      "content": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "type": {
                    "enum": [
                      "text"
                    ],
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "description": "An array of [rich text objects](https://developers.notion.com/reference/rich-text) that represents the title of the database that is displayed in the Notion UI. If omitted, then the database title remains unchanged."
            },
            "properties": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string"
                }
              },
              "description": "Property schema of database. The keys are the names of properties as they appear in Notion and the values are [property schema objects](https://developers.notion.com/reference/property-schema-object).",
              "additionalProperties": true
            },
            "database_id": {
              "type": "string",
              "description": "identifier for a Notion database"
            },
            "description": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "text"
                ],
                "properties": {
                  "text": {
                    "type": "object",
                    "required": [
                      "content"
                    ],
                    "properties": {
                      "link": {
                        "type": [
                          "object",
                          "null"
                        ]
                      },
                      "content": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "type": {
                    "enum": [
                      "text"
                    ],
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "description": "An array of [rich text objects](https://developers.notion.com/reference/rich-text) that represents the description of the database that is displayed in the Notion UI. If omitted, then the database description remains unchanged."
            }
          },
          "required": [
            "database_id"
          ]
        }
      },
      {
        "name": "API-retrieve-a-database",
        "description": "Retrieve a database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database_id": {
              "type": "string",
              "description": "An identifier for the Notion database."
            }
          },
          "required": [
            "database_id"
          ]
        }
      },
      {
        "name": "API-retrieve-a-page-property",
        "description": "Retrieve a page property item",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string",
              "description": "Identifier for a Notion page"
            },
            "page_size": {
              "type": "integer",
              "format": "int32",
              "description": "For paginated properties. The max number of property item objects on a page. The default size is 100"
            },
            "property_id": {
              "type": "string",
              "description": "Identifier for a page [property](https://developers.notion.com/reference/page#all-property-values)"
            },
            "start_cursor": {
              "type": "string",
              "description": "For paginated properties."
            }
          },
          "required": [
            "page_id",
            "property_id"
          ]
        }
      },
      {
        "name": "API-retrieve-a-comment",
        "description": "Retrieve comments",
        "inputSchema": {
          "type": "object",
          "properties": {
            "block_id": {
              "type": "string",
              "description": "Identifier for a Notion block or page"
            },
            "page_size": {
              "type": "integer",
              "format": "int32",
              "description": "The number of items from the full list desired in the response. Maximum: 100"
            },
            "start_cursor": {
              "type": "string",
              "description": "If supplied, this endpoint will return a page of results starting after the cursor provided. If not supplied, this endpoint will return the first page of results."
            }
          },
          "required": [
            "block_id"
          ]
        }
      },
      {
        "name": "API-create-a-comment",
        "description": "Create comment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "parent": {
              "type": "object",
              "required": [
                "page_id"
              ],
              "properties": {
                "page_id": {
                  "type": "string",
                  "description": "the page ID"
                }
              },
              "description": "The page that contains the comment",
              "additionalProperties": true
            },
            "rich_text": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "text"
                ],
                "properties": {
                  "text": {
                    "type": "object",
                    "required": [
                      "content"
                    ],
                    "properties": {
                      "content": {
                        "type": "string",
                        "description": "The content of the comment"
                      }
                    },
                    "additionalProperties": true
                  }
                },
                "additionalProperties": true
              }
            }
          },
          "required": [
            "parent",
            "rich_text"
          ]
        }
      }
    ]
  },
  {
    name: "hackernews",
    title: "Hackernews",
    description: "Provides tools for fetching information from Hacker News.",
    isOfficial: false,
    icon: "https://registry.director.run/hackernews.svg",
    homepage: "https://github.com/erithwik/mcp-hn",
    transport: {
      type: "stdio",
      command: "uvx",
      args: ["--from", "git+https://github.com/erithwik/mcp-hn", "mcp-hn"],
    },
    parameters: [],
  },
  {
    name: "git",
    title: "Git",
    description:
      "Provides tools to read, search, and manipulate Git repositories.",
    isOfficial: false,
    icon: "https://registry.director.run/git.svg",
    homepage:
      "https://github.com/modelcontextprotocol/servers/tree/main/src/git",
    transport: {
      type: "stdio",
      command: "uvx",
      args: ["mcp-server-git"],
    },
    parameters: [],
  },
  {
    name: "filesystem",
    title: "Filesystem",
    description: "Secure file operations with configurable access controls.",
    isOfficial: false,
    icon: "https://registry.director.run/mcp.svg",
    homepage:
      "https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem",
    transport: {
      type: "stdio",
      command: "npx",
      args: [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "<fs-allowed-path>",
      ],
    },
    parameters: [
      {
        name: "fs-allowed-path",
        description:
          "The path to the directory to allow filesystem operations in.",
        type: "string",
        required: true,
      },
    ],
  },
  {
    name: "fetch",
    title: "Fetch",
    description: "Retrieves and converts web content for efficient LLM usage.",
    isOfficial: false,
    icon: "https://registry.director.run/mcp.svg",
    homepage:
      "https://github.com/modelcontextprotocol/servers/tree/main/src/fetch",
    transport: {
      args: ["mcp-server-fetch"],
      type: "stdio",
      command: "uvx",
    },
    parameters: [],
  },
  {
    name: "memory",
    title: "Memory",
    description: "Knowledge graph-based persistent memory system.",
    isOfficial: false,
    icon: "https://registry.director.run/mcp.svg",
    homepage:
      "https://github.com/modelcontextprotocol/servers/tree/main/src/memory",
    transport: {
      type: "stdio",
      command: "npx",
      args: ["-y", "@modelcontextprotocol/server-memory"],
    },
    parameters: [],
  },
  {
    name: "sequential-thinking",
    title: "Sequential Thinking",
    description:
      "Dynamic and reflective problem-solving through a structured thinking process.",
    isOfficial: false,
    icon: "https://registry.director.run/mcp.svg",
    homepage:
      "https://github.com/modelcontextprotocol/servers/tree/main/src/sequentialthinking",
    transport: {
      type: "stdio",
      command: "npx",
      args: ["-y", "@modelcontextprotocol/server-sequential-thinking"],
    },
    parameters: [],
  },
  {
    name: "time",
    title: "Time",
    description: "Time and timezone conversion capabilities.",
    isOfficial: false,
    icon: "https://registry.director.run/mcp.svg",
    homepage:
      "https://github.com/modelcontextprotocol/servers/tree/main/src/time",
    transport: {
      type: "stdio",
      command: "uvx",
      args: ["mcp-server-time"],
    },
    parameters: [],
  },
  {
    name: "slack",
    title: "Slack",
    description: "Allows you to interact with the Slack API.",
    isOfficial: true,
    icon: "https://registry.director.run/slack.svg",
    homepage:
      "https://github.com/modelcontextprotocol/servers-archived/tree/main/src/slack",
    transport: {
      type: "stdio",
      command: "npx",
      args: ["-y", "@modelcontextprotocol/server-slack"],
      env: {
        SLACK_BOT_TOKEN: "<slack-bot-token>",
        SLACK_TEAM_ID: "<slack-team-id>",
        SLACK_CHANNEL_IDS: "<slack-channel-ids>", // C01234567, C76543210
      },
    },
    parameters: [
      {
        name: "slack-bot-token",
        description: "Slack Bot Token (e.g. 'xoxb-1234..').",
        type: "string",
        required: true,
        password: true,
      },
      {
        name: "slack-team-id",
        description: "Slack Team ID. (e.g. 'T01234567')",
        type: "string",
        required: true,
      },
      {
        name: "slack-channel-ids",
        description:
          "Channel IDs, comma separated. (e.g. 'C01234567, C76543210')",
        type: "string",
        required: true,
      },
    ],
  },
  {
    name: "google-calendar",
    title: "Google Calendar",
    description: "Allows you to interact with Google Calendar integration.",
    isOfficial: false,
    icon: "https://registry.director.run/google-calendar.png",
    homepage: "https://github.com/nspady/google-calendar-mcp",
    transport: {
      type: "stdio",
      command: "npx",
      args: ["@cocal/google-calendar-mcp"],
      env: {
        GOOGLE_OAUTH_CREDENTIALS: "<google-oauth-credentials-file>",
      },
    },
    parameters: [
      {
        name: "google-oauth-credentials-file",
        description: "Full path to the Google OAuth credentials JSON file.",
        type: "string",
        required: true,
      },
    ],
  },
  {
    name: "context-7",
    title: "Context 7",
    description:
      "Context7 MCP pulls up-to-date, version-specific documentation and code examples straight from the source — and places them directly into your prompt.",
    isOfficial: true,
    icon: "https://registry.director.run/context7.svg",
    homepage: "https://github.com/upstash/context7",
    transport: {
      type: "stdio",
      command: "npx",
      args: ["-y", "@upstash/context7-mcp"],
    },
    parameters: [],
  },
  {
    name: "playwright",
    title: "Playwright",
    description:
      "Interact with web pages through structured accessibility snapshots, bypassing the need for screenshots or visually-tuned models.",
    isOfficial: true,
    icon: "https://registry.director.run/playwright.svg",
    homepage: "https://github.com/microsoft/playwright-mcp",
    transport: {
      type: "stdio",
      command: "npx",
      args: ["@playwright/mcp@latest"],
    },
    parameters: [],
  },
  {
    name: "supabase",
    title: "Supabase",
    description: "Connect your AI tools to Supabase.",
    isOfficial: true,
    icon: "https://registry.director.run/supabase.svg",
    homepage: "https://supabase.com/docs/guides/getting-started/mcp",
    transport: {
      type: "stdio",
      command: "npx",
      args: [
        "-y",
        "@supabase/mcp-server-supabase@latest",
        "--read-only",
        "--project-ref=<supabase-project-ref>",
      ],
      env: {
        SUPABASE_ACCESS_TOKEN: "<supabase-personal-access-token>",
      },
    },
    parameters: [
      {
        name: "supabase-project-ref",
        description: "Supabase project reference.",
        type: "string",
        required: true,
      },
      {
        name: "supabase-personal-access-token",
        description: "Personal access token for Supabase.",
        type: "string",
        required: true,
        password: true,
      },
    ],
  },
  {
    "name": "aashari-mcp-server-atlassian-bitbucket",
    "title": "Atlassian Bitbucket MCP Server",
    "description": "An integration tool that enables AI assistants like Claude to directly access and interact with Bitbucket repositories, pull requests, and code without requiring copy/paste operations.",
    "icon": "https://avatars.githubusercontent.com/aashari",
    "isOfficial": false,
    "homepage": "https://github.com/aashari/mcp-server-atlassian-bitbucket",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@aashari/mcp-server-atlassian-bitbucket"
      ],
      "env": {
        "DEBUG": "<debug>",
        "ATLASSIAN_API_TOKEN": "<atlassian-api-token>",
        "ATLASSIAN_SITE_NAME": "<atlassian-site-name>",
        "ATLASSIAN_USER_EMAIL": "<atlassian-user-email>",
        "ATLASSIAN_BITBUCKET_USERNAME": "<atlassian-bitbucket-username>",
        "ATLASSIAN_BITBUCKET_APP_PASSWORD": "<atlassian-bitbucket-app-password>"
      }
    },
    "parameters": [
      {
        "name": "DEBUG",
        "description": "Enable debug logging",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ATLASSIAN_API_TOKEN",
        "description": "The API token created in your Atlassian account",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ATLASSIAN_SITE_NAME",
        "description": "Your Atlassian site name (e.g., for example.atlassian.net, enter example)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ATLASSIAN_USER_EMAIL",
        "description": "Your Atlassian account email address",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ATLASSIAN_BITBUCKET_USERNAME",
        "description": "Your Bitbucket username",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ATLASSIAN_BITBUCKET_APP_PASSWORD",
        "description": "The app password created in your Bitbucket account",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "list_workspaces",
        "description": "List Bitbucket workspaces accessible to the authenticated user, with optional pagination.\n\n        PURPOSE: Discover available workspaces and retrieve their slugs, names, and basic metadata. Essential for finding the correct 'workspaceSlug' needed as input for repository-related tools (list_repositories, get_repository, list_pull_requests, get_pull_request).\n\n        WHEN TO USE:\n        - To find the 'workspaceSlug' for a known workspace name.\n        - To explore all workspaces you have access to.\n        - To get a high-level overview before diving into specific repositories.\n        - When you don't know the exact slug required by other tools.\n\n        WHEN NOT TO USE:\n        - When you already have the 'workspaceSlug'.\n        - When you need detailed information about a *single* workspace (use 'get_workspace').\n        - When you need repository or pull request information (use repository/pull_request tools with a known 'workspaceSlug').\n\n        RETURNS: Formatted list of workspace memberships, including workspace name, slug, UUID, your permission level, and access dates. Includes pagination details if applicable.\n\n        EXAMPLES:\n        - List all accessible workspaces: {}\n        - Paginate results: { limit: 10, cursor: \"some-cursor-value\" }\n\n        ERRORS:\n        - Authentication failures: Check Bitbucket credentials.\n        - No workspaces found: You may not have access to any workspaces.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "maximum": 100,
              "description": "Maximum number of items to return (1-100). Controls the response size. Defaults to 25 if omitted.",
              "exclusiveMinimum": 0
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for retrieving the next set of results. Obtained from previous response when more results are available."
            }
          }
        }
      },
      {
        "name": "get_workspace",
        "description": "Get detailed information about a specific Bitbucket workspace using its slug.\n\n        PURPOSE: Retrieves comprehensive metadata for a *known* workspace, including UUID, name, type, creation date, and links to related resources like repositories and projects.\n\n        WHEN TO USE:\n        - When you need full details about a *specific* workspace and you already know its 'workspaceSlug'.\n        - After using 'list_workspaces' to identify the target workspace slug.\n        - To get quick links to a workspace's repositories, projects, or members page.\n\n        WHEN NOT TO USE:\n        - When you don't know the workspace slug (use 'list_workspaces' first).\n        - When you only need a list of workspaces (use 'list_workspaces').\n        - When you need information about repositories *within* the workspace (use repository tools).\n\n        RETURNS: Detailed workspace information including slug, name, UUID, type, creation date, and links. Fetches all available details by default.\n\n        EXAMPLES:\n        - Get details for a workspace: { workspaceSlug: \"my-dev-team\" }\n\n        ERRORS:\n        - Workspace not found: Verify the 'workspaceSlug' is correct and exists.\n        - Permission errors: Ensure you have access to view the specified workspace.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "workspaceSlug": {
              "type": "string",
              "minLength": 1,
              "description": "Workspace slug to retrieve detailed information for. Must be a valid workspace slug from your Bitbucket account. Example: \"myteam\""
            }
          },
          "required": [
            "workspaceSlug"
          ]
        }
      },
      {
        "name": "list_repositories",
        "description": "List repositories within a specific Bitbucket workspace, with optional filtering and pagination. Requires 'workspaceSlug'.\n\n        PURPOSE: Discover repositories within a given workspace and retrieve their slugs, names, owners, and basic metadata. Essential for finding the 'repoSlug' needed for repository or pull request details tools.\n\n        WHEN TO USE:\n        - To find the 'repoSlug' for a known repository name within a specific workspace.\n        - To explore all repositories within a known workspace ('workspaceSlug' is required).\n        - To filter repositories based on name ('query'), your role ('role'), or sort them ('sort').\n        - Before using 'get_repository' or pull request tools if the 'repoSlug' is unknown.\n\n        WHEN NOT TO USE:\n        - When you don't know the 'workspaceSlug' (use 'list_workspaces' first).\n        - When you already have the 'repoSlug' and need full details (use 'get_repository').\n        - When you need pull request information (use pull request tools).\n\n        RETURNS: Formatted list of repositories including name, full name, owner, description, privacy status, dates, and URL. Includes pagination details if applicable.\n\n        EXAMPLES:\n        - List repositories in a workspace: { workspaceSlug: \"my-team\" }\n        - Filter by name fragment: { workspaceSlug: \"my-team\", query: \"backend-api\" }\n        - Filter by your role: { workspaceSlug: \"my-team\", role: \"contributor\" }\n        - Sort by last update (descending): { workspaceSlug: \"my-team\", sort: \"-updated_on\" }\n        - Paginate results: { workspaceSlug: \"my-team\", limit: 10, cursor: \"next-page-token\" }\n\n        ERRORS:\n        - Workspace not found: Verify the 'workspaceSlug' is correct.\n        - Authentication failures: Check Bitbucket credentials.\n        - No repositories found: Workspace might be empty, filters too restrictive, or permissions lacking.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "role": {
              "type": "string",
              "description": "Filter repositories by the authenticated user's role. Common values: \"owner\", \"admin\", \"contributor\", \"member\". If omitted, returns repositories of all roles."
            },
            "sort": {
              "type": "string",
              "description": "Field to sort results by. Common values: \"name\", \"created_on\", \"updated_on\". Prefix with \"-\" for descending order. Example: \"-updated_on\" for most recently updated first."
            },
            "limit": {
              "type": "integer",
              "maximum": 100,
              "description": "Maximum number of items to return (1-100). Controls the response size. Defaults to 25 if omitted.",
              "exclusiveMinimum": 0
            },
            "query": {
              "type": "string",
              "description": "Query string to filter repositories by name or other properties (text search). Example: \"api\" for repositories with \"api\" in the name/description. If omitted, returns all repositories."
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for retrieving the next set of results. Obtained from previous response when more results are available."
            },
            "workspaceSlug": {
              "type": "string",
              "minLength": 1,
              "description": "Workspace slug containing the repositories. Must be a valid workspace slug from your Bitbucket account. Example: \"myteam\""
            }
          },
          "required": [
            "workspaceSlug"
          ]
        }
      },
      {
        "name": "get_repository",
        "description": "Get detailed information about a specific Bitbucket repository using its workspace and repository slugs. Requires 'workspaceSlug' and 'repoSlug'.\n\n        PURPOSE: Retrieves comprehensive metadata for a *known* repository, including UUID, owner, description, language, size, creation/update dates, and links.\n\n        WHEN TO USE:\n        - When you need full details about a *specific* repository and you know its 'workspaceSlug' and 'repoSlug'.\n        - After using 'list_repositories' to identify the target repository slugs.\n        - To get repository metadata before analyzing its pull requests or content.\n\n        WHEN NOT TO USE:\n        - When you don't know the 'workspaceSlug' or 'repoSlug' (use 'list_workspaces' and/or 'list_repositories' first).\n        - When you only need a list of repositories (use 'list_repositories').\n        - When you need pull request information (use pull request tools).\n\n        RETURNS: Detailed repository information including name, full name, UUID, description, language, size, owner, dates, and links. Fetches all available details by default.\n\n        EXAMPLES:\n        - Get details for a repository: { workspaceSlug: \"my-team\", repoSlug: \"backend-api\" }\n\n        ERRORS:\n        - Repository not found: Verify the 'workspaceSlug' and 'repoSlug' are correct and the repository exists.\n        - Permission errors: Ensure you have access to view the specified repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repoSlug": {
              "type": "string",
              "minLength": 1,
              "description": "Repository slug to retrieve. This must be a valid repository in the specified workspace. Example: \"project-api\""
            },
            "workspaceSlug": {
              "type": "string",
              "minLength": 1,
              "description": "Workspace slug containing the repository. Must be a valid workspace slug from your Bitbucket account. Example: \"myteam\""
            }
          },
          "required": [
            "workspaceSlug",
            "repoSlug"
          ]
        }
      },
      {
        "name": "list_pull_requests",
        "description": "List pull requests for a specific Bitbucket repository, with optional filtering by state or query text. Requires 'workspaceSlug' and 'repoSlug'.\n\n        PURPOSE: Discover pull requests within a given repository and retrieve their IDs, titles, states, authors, and branches. Essential for finding the 'prId' needed for the 'get_pull_request' tool.\n\n        WHEN TO USE:\n        - To find open, merged, declined, or superseded pull requests within a specific repository.\n        - To get a list of recent PR activity for a repository.\n        - To search for PRs containing specific text in their title or description ('query' parameter).\n        - To obtain 'prId' values for use with 'get_pull_request'.\n        - Requires known 'workspaceSlug' and 'repoSlug'.\n\n        WHEN NOT TO USE:\n        - When you don't know the 'workspaceSlug' or 'repoSlug' (use workspace/repository listing tools first).\n        - When you already have the 'prId' and need full details (use 'get_pull_request').\n        - When you need repository information (use repository tools).\n\n        RETURNS: Formatted list of pull requests including ID, title, state, author, source/destination branches, a snippet of the description, and URL. Includes pagination details if applicable.\n\n        EXAMPLES:\n        - List open PRs: { workspaceSlug: \"my-team\", repoSlug: \"backend-api\", state: \"OPEN\" }\n        - List merged PRs: { workspaceSlug: \"my-team\", repoSlug: \"backend-api\", state: \"MERGED\" }\n        - Search PR titles/descriptions: { workspaceSlug: \"my-team\", repoSlug: \"backend-api\", query: \"bugfix\" }\n        - Paginate results: { workspaceSlug: \"my-team\", repoSlug: \"backend-api\", limit: 10, cursor: \"next-page-token\" }\n\n        ERRORS:\n        - Repository not found: Verify 'workspaceSlug' and 'repoSlug'.\n        - Permission errors: Ensure access to the repository's pull requests.\n        - Invalid state: Ensure 'state' is one of OPEN, MERGED, DECLINED, SUPERSEDED.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "maximum": 100,
              "description": "Maximum number of items to return (1-100). Controls the response size. Defaults to 25 if omitted.",
              "exclusiveMinimum": 0
            },
            "query": {
              "type": "string",
              "description": "Filter pull requests by title, description, or author (text search). Uses Bitbucket query syntax."
            },
            "state": {
              "enum": [
                "OPEN",
                "MERGED",
                "DECLINED",
                "SUPERSEDED"
              ],
              "type": "string",
              "description": "Filter pull requests by state. Options: \"OPEN\" (active PRs), \"MERGED\" (completed PRs), \"DECLINED\" (rejected PRs), or \"SUPERSEDED\" (replaced PRs). If omitted, defaults to showing all states."
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for retrieving the next set of results. Obtained from previous response when more results are available."
            },
            "repoSlug": {
              "type": "string",
              "minLength": 1,
              "description": "Repository slug containing the pull requests. This must be a valid repository in the specified workspace. Example: \"project-api\""
            },
            "workspaceSlug": {
              "type": "string",
              "minLength": 1,
              "description": "Workspace slug containing the repository. Must be a valid workspace slug from your Bitbucket account. Example: \"myteam\""
            }
          },
          "required": [
            "workspaceSlug",
            "repoSlug"
          ]
        }
      },
      {
        "name": "get_pull_request",
        "description": "Get detailed information about a specific Bitbucket pull request using its workspace slug, repository slug, and pull request ID. Requires 'workspaceSlug', 'repoSlug', and 'prId'.\n\n        PURPOSE: Retrieves comprehensive details for a *known* pull request, including its full description, state, author, reviewers, source/destination branches, and links to related resources like commits and diffs.\n\n        WHEN TO USE:\n        - When you need the full context, description, or reviewer list for a *specific* pull request.\n        - After using 'list_pull_requests' to identify the target 'prId'.\n        - To get links to view the PR diff, commits, or comments in the browser.\n        - Requires known 'workspaceSlug', 'repoSlug', and 'prId'.\n\n        WHEN NOT TO USE:\n        - When you don't know the 'prId' (use 'list_pull_requests' first).\n        - When you only need a list of pull requests (use 'list_pull_requests').\n        - When you need repository information (use repository tools).\n\n        RETURNS: Detailed pull request information including title, full description, state, author, reviewers, branches, and links. Fetches all available details by default.\n\n        EXAMPLES:\n        - Get details for a specific PR: { workspaceSlug: \"my-team\", repoSlug: \"backend-api\", prId: \"42\" }\n\n        ERRORS:\n        - Pull Request not found: Verify 'workspaceSlug', 'repoSlug', and 'prId' are correct.\n        - Repository not found: Verify 'workspaceSlug' and 'repoSlug'.\n        - Permission errors: Ensure access to view the specified pull request.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prId": {
              "type": [
                "string",
                "number"
              ],
              "description": "Numeric ID of the pull request to retrieve. Must be a valid pull request ID in the specified repository. Example: 42"
            },
            "repoSlug": {
              "type": "string",
              "minLength": 1,
              "description": "Repository slug containing the pull request. This must be a valid repository in the specified workspace. Example: \"project-api\""
            },
            "workspaceSlug": {
              "type": "string",
              "minLength": 1,
              "description": "Workspace slug containing the repository. Must be a valid workspace slug from your Bitbucket account. Example: \"myteam\""
            }
          },
          "required": [
            "workspaceSlug",
            "repoSlug",
            "prId"
          ]
        }
      },
      {
        "name": "list_pr_comments",
        "description": "List comments on a specific Bitbucket pull request using its workspace slug, repository slug, and pull request ID. Requires 'workspaceSlug', 'repoSlug', and 'prId'.\n\n        PURPOSE: View all review feedback, discussions, and task comments on a pull request to understand code review context without accessing the web UI.\n\n        WHEN TO USE:\n        - To see what reviewers have said about a pull request.\n        - To find inline code comments and their context (file, line number).\n        - After identifying a PR of interest via 'list_pull_requests'.\n        - When you need to understand review history, discussions, and decisions.\n        - Requires known 'workspaceSlug', 'repoSlug', and 'prId'.\n\n        WHEN NOT TO USE:\n        - When you don't know the pull request ID (use 'list_pull_requests' first).\n        - When you need the PR's metadata but not comments (use 'get_pull_request').\n        - When you need to post new comments (not supported).\n\n        RETURNS: Formatted list of comments with author, date, content, and for inline comments: the file path and line numbers. General and inline comments are included.\n\n        EXAMPLES:\n        - List all comments on a PR: { workspaceSlug: \"my-team\", repoSlug: \"backend-api\", prId: \"42\" }\n        - Paginate results: { workspaceSlug: \"my-team\", repoSlug: \"backend-api\", prId: \"42\", limit: 25, cursor: \"next-page-token\" }\n\n        ERRORS:\n        - Pull Request not found: Verify 'workspaceSlug', 'repoSlug', and 'prId' are correct.\n        - Repository not found: Verify 'workspaceSlug' and 'repoSlug'.\n        - Permission errors: Ensure access to view the specified pull request comments.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prId": {
              "type": [
                "string",
                "number"
              ],
              "description": "Numeric ID of the pull request to retrieve comments from. Must be a valid pull request ID in the specified repository. Example: 42"
            },
            "limit": {
              "type": "integer",
              "maximum": 100,
              "description": "Maximum number of items to return (1-100). Controls the response size. Defaults to 25 if omitted.",
              "exclusiveMinimum": 0
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for retrieving the next set of results. Obtained from previous response when more results are available."
            },
            "repoSlug": {
              "type": "string",
              "minLength": 1,
              "description": "Repository slug containing the pull request. This must be a valid repository in the specified workspace. Example: \"project-api\""
            },
            "workspaceSlug": {
              "type": "string",
              "minLength": 1,
              "description": "Workspace slug containing the repository. Must be a valid workspace slug from your Bitbucket account. Example: \"myteam\""
            }
          },
          "required": [
            "workspaceSlug",
            "repoSlug",
            "prId"
          ]
        }
      }
    ]
  },
  {
    "name": "abhaybabbar-retellai-mcp-server",
    "title": "RetellAI MCP Server",
    "description": "A Model Context Protocol server implementation that enables AI assistants to interact with RetellAI's voice services for managing calls, agents, phone numbers, and voice options.",
    "icon": "https://avatars.githubusercontent.com/abhaybabbar",
    "isOfficial": false,
    "homepage": "https://github.com/abhaybabbar/retellai-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@abhaybabbar/retellai-mcp-server"
      ],
      "env": {
        "RETELL_API_KEY": "<retell-api-key>"
      }
    },
    "parameters": [
      {
        "name": "RETELL_API_KEY",
        "description": "Your RetellAI API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "create_phone_call",
        "description": "Creates a new phone call",
        "inputSchema": {
          "type": "object",
          "properties": {
            "metadata": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "toNumber": {
              "type": "string",
              "description": "The phone number to call to"
            },
            "direction": {
              "enum": [
                "inbound",
                "outbound"
              ],
              "type": "string",
              "default": "outbound"
            },
            "fromNumber": {
              "type": "string",
              "description": "The phone number to call from"
            },
            "optInSignedUrl": {
              "type": "boolean"
            },
            "overrideAgentId": {
              "type": "string",
              "description": "For this particular call, override the agent used with this agent id"
            },
            "overrideAgentVersion": {
              "type": "number",
              "description": "For this particular call, override the agent version used with this version"
            },
            "retellLlmDynamicVariables": {
              "type": "object",
              "description": "Dynamic variables to pass to the LLM in key-value pairs",
              "additionalProperties": {
                "type": "string"
              }
            },
            "optOutSensitiveDataStorage": {
              "type": "boolean"
            }
          },
          "required": [
            "fromNumber",
            "toNumber"
          ]
        }
      },
      {
        "name": "create_web_call",
        "description": "Creates a new web call",
        "inputSchema": {
          "type": "object",
          "properties": {
            "agentId": {
              "type": "string",
              "description": "The ID of the agent to use for the call"
            },
            "metadata": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "optInSignedUrl": {
              "type": "boolean"
            },
            "retellLlmDynamicVariables": {
              "type": "object",
              "description": "Dynamic variables to pass to the LLM in key-value pairs",
              "additionalProperties": {
                "type": "string"
              }
            },
            "optOutSensitiveDataStorage": {
              "type": "boolean"
            }
          },
          "required": [
            "agentId"
          ]
        }
      },
      {
        "name": "get_call",
        "description": "Gets a call by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "callId": {
              "type": "string",
              "description": "The ID of the call to retrieve"
            }
          },
          "required": [
            "callId"
          ]
        }
      },
      {
        "name": "list_calls",
        "description": "Lists all calls",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of calls to return"
            },
            "offset": {
              "type": "number",
              "description": "Number of calls to skip"
            },
            "agentId": {
              "type": "string",
              "description": "Filter calls by agent ID"
            },
            "endTimestamp": {
              "type": "number",
              "description": "Filter calls before this timestamp"
            },
            "startTimestamp": {
              "type": "number",
              "description": "Filter calls after this timestamp"
            }
          }
        }
      },
      {
        "name": "update_call",
        "description": "Updates an existing call",
        "inputSchema": {
          "type": "object",
          "properties": {
            "callId": {
              "type": "string",
              "description": "The ID of the call to update"
            },
            "metadata": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "dynamicVariables": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          },
          "required": [
            "callId"
          ]
        }
      },
      {
        "name": "delete_call",
        "description": "Deletes a call",
        "inputSchema": {
          "type": "object",
          "properties": {
            "callId": {
              "type": "string",
              "description": "The ID of the call to delete"
            }
          },
          "required": [
            "callId"
          ]
        }
      },
      {
        "name": "list_agents",
        "description": "Lists all Retell agents",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_agent",
        "description": "Creates a new Retell agent",
        "inputSchema": {
          "type": "object",
          "properties": {
            "language": {
              "enum": [
                "en-US",
                "en-IN",
                "en-GB",
                "en-AU",
                "en-NZ",
                "de-DE",
                "es-ES",
                "es-419",
                "hi-IN",
                "fr-FR",
                "fr-CA",
                "ja-JP",
                "pt-PT",
                "pt-BR",
                "zh-CN",
                "ru-RU",
                "it-IT",
                "ko-KR"
              ],
              "type": "string"
            },
            "voice_id": {
              "type": "string",
              "description": "ID of the voice to use"
            },
            "agent_name": {
              "type": "string",
              "description": "Name of the agent"
            },
            "voice_model": {
              "enum": [
                "eleven_turbo_v2",
                "eleven_flash_v2",
                "eleven_turbo_v2_5",
                "eleven_flash_v2_5",
                "eleven_multilingual_v2",
                "Play3.0-mini",
                "PlayDialog"
              ],
              "type": "string"
            },
            "response_engine": {
              "type": "object",
              "required": [
                "type",
                "llm_id"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "const": "retell-llm"
                },
                "llm_id": {
                  "type": "string",
                  "description": "ID of the Retell LLM Response Engine, if llm_id not mentioned by user, create a new one"
                },
                "version": {
                  "type": "number"
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "response_engine",
            "voice_id"
          ]
        }
      },
      {
        "name": "get_agent",
        "description": "Gets a Retell agent by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "agentId": {
              "type": "string",
              "description": "The ID of the agent to retrieve"
            }
          },
          "required": [
            "agentId"
          ]
        }
      },
      {
        "name": "update_agent",
        "description": "Updates an existing Retell agent",
        "inputSchema": {
          "type": "object",
          "properties": {
            "volume": {
              "type": "number"
            },
            "agentId": {
              "type": "string",
              "description": "The ID of the agent to update"
            },
            "language": {
              "type": "string"
            },
            "stt_mode": {
              "enum": [
                "fast",
                "accurate"
              ],
              "type": "string"
            },
            "voice_id": {
              "type": "string"
            },
            "agent_name": {
              "type": "string"
            },
            "voice_model": {
              "type": "string"
            },
            "voice_speed": {
              "type": "number"
            },
            "webhook_url": {
              "type": "string"
            },
            "ambient_sound": {
              "type": "string"
            },
            "responsiveness": {
              "type": "number"
            },
            "response_engine": {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "const": "retell-llm"
                },
                "llm_id": {
                  "type": "string"
                },
                "version": {
                  "type": "number"
                }
              },
              "additionalProperties": false
            },
            "boosted_keywords": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "ring_duration_ms": {
              "type": "number"
            },
            "backchannel_words": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "opt_in_signed_url": {
              "type": "boolean"
            },
            "voice_temperature": {
              "type": "number"
            },
            "voicemail_message": {
              "type": "string"
            },
            "enable_backchannel": {
              "type": "boolean"
            },
            "fallback_voice_ids": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "reminder_max_count": {
              "type": "number"
            },
            "reminder_trigger_ms": {
              "type": "number"
            },
            "ambient_sound_volume": {
              "type": "number"
            },
            "max_call_duration_ms": {
              "type": "number"
            },
            "normalize_for_speech": {
              "type": "boolean"
            },
            "backchannel_frequency": {
              "type": "number"
            },
            "begin_message_delay_ms": {
              "type": "number"
            },
            "post_call_analysis_data": {
              "type": "array",
              "items": {
                "anyOf": [
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "name",
                      "description",
                      "examples"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string",
                        "const": "string"
                      },
                      "examples": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "description": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "name",
                      "description",
                      "examples",
                      "choices"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string",
                        "const": "enum"
                      },
                      "choices": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "examples": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "description": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "name",
                      "description",
                      "examples"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string",
                        "const": "boolean"
                      },
                      "examples": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "description": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "name",
                      "description",
                      "examples"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string",
                        "const": "number"
                      },
                      "examples": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "description": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  }
                ]
              }
            },
            "interruption_sensitivity": {
              "type": "number"
            },
            "post_call_analysis_model": {
              "enum": [
                "gpt-4o-mini",
                "gpt-4o"
              ],
              "type": "string"
            },
            "pronunciation_dictionary": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "word",
                  "alphabet",
                  "phoneme"
                ],
                "properties": {
                  "word": {
                    "type": "string"
                  },
                  "phoneme": {
                    "type": "string"
                  },
                  "alphabet": {
                    "enum": [
                      "ipa",
                      "cmu"
                    ],
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "end_call_after_silence_ms": {
              "type": "number"
            },
            "enable_voicemail_detection": {
              "type": "boolean"
            },
            "opt_out_sensitive_data_storage": {
              "type": "boolean"
            },
            "voicemail_detection_timeout_ms": {
              "type": "number"
            },
            "enable_transcription_formatting": {
              "type": "boolean"
            }
          },
          "required": [
            "agentId"
          ]
        }
      },
      {
        "name": "delete_agent",
        "description": "Deletes a Retell agent",
        "inputSchema": {
          "type": "object",
          "properties": {
            "agentId": {
              "type": "string",
              "description": "The ID of the agent to retrieve"
            }
          },
          "required": [
            "agentId"
          ]
        }
      },
      {
        "name": "get_agent_versions",
        "description": "Gets all versions of a Retell agent",
        "inputSchema": {
          "type": "object",
          "properties": {
            "agentId": {
              "type": "string",
              "description": "The ID of the agent to retrieve"
            }
          },
          "required": [
            "agentId"
          ]
        }
      },
      {
        "name": "list_phone_numbers",
        "description": "Lists all Retell phone numbers",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_phone_number",
        "description": "Creates a new phone number",
        "inputSchema": {
          "type": "object",
          "properties": {
            "areaCode": {
              "type": "number",
              "description": "Area code of the number to obtain"
            },
            "nickname": {
              "type": "string"
            },
            "inboundAgentId": {
              "type": "string"
            },
            "outboundAgentId": {
              "type": "string"
            },
            "inboundWebhookUrl": {
              "type": "string"
            }
          },
          "required": [
            "areaCode"
          ]
        }
      },
      {
        "name": "get_phone_number",
        "description": "Gets details of a specific phone number",
        "inputSchema": {
          "type": "object",
          "properties": {
            "phoneNumber": {
              "type": "string",
              "description": "The phone number to retrieve"
            }
          },
          "required": [
            "phoneNumber"
          ]
        }
      },
      {
        "name": "update_phone_number",
        "description": "Updates a phone number",
        "inputSchema": {
          "type": "object",
          "properties": {
            "nickname": {
              "type": "string"
            },
            "phoneNumber": {
              "type": "string",
              "description": "The phone number to update"
            },
            "inboundAgentId": {
              "type": "string"
            },
            "outboundAgentId": {
              "type": "string"
            },
            "inboundWebhookUrl": {
              "type": "string"
            }
          },
          "required": [
            "phoneNumber"
          ]
        }
      },
      {
        "name": "delete_phone_number",
        "description": "Deletes a phone number",
        "inputSchema": {
          "type": "object",
          "properties": {
            "phoneNumber": {
              "type": "string",
              "description": "The phone number to retrieve"
            }
          },
          "required": [
            "phoneNumber"
          ]
        }
      },
      {
        "name": "list_voices",
        "description": "Lists all available Retell voices",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_voice",
        "description": "Gets details of a specific voice",
        "inputSchema": {
          "type": "object",
          "properties": {
            "voiceId": {
              "type": "string",
              "description": "The ID of the voice to retrieve"
            }
          },
          "required": [
            "voiceId"
          ]
        }
      },
      {
        "name": "list_retell_llms",
        "description": "Lists all Retell LLMs",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_retell_llm",
        "description": "Creates a new Retell LLM",
        "inputSchema": {
          "type": "object",
          "properties": {
            "model": {
              "enum": [
                "gpt-4o",
                "gpt-4o-mini",
                "gpt-4.1",
                "gpt-4.1-mini",
                "gpt-4.1-nano",
                "claude-3.7-sonnet",
                "claude-3.5-haiku",
                "gemini-2.0-flash",
                "gemini-2.0-flash-lite"
              ],
              "type": "string",
              "description": "Select the underlying text LLM. If not set, would default to gpt-4o"
            },
            "states": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "name",
                  "state_prompt"
                ],
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "edges": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "destination_state_name",
                        "description"
                      ],
                      "properties": {
                        "parameters": {
                          "type": "object",
                          "required": [
                            "type",
                            "properties",
                            "required"
                          ],
                          "properties": {
                            "type": {
                              "type": "string",
                              "const": "object"
                            },
                            "required": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            },
                            "properties": {
                              "type": "object",
                              "additionalProperties": {}
                            }
                          },
                          "additionalProperties": false
                        },
                        "description": {
                          "type": "string"
                        },
                        "destination_state_name": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  },
                  "tools": {
                    "type": "array",
                    "items": {
                      "anyOf": [
                        {
                          "type": "object",
                          "required": [
                            "type",
                            "name",
                            "description"
                          ],
                          "properties": {
                            "name": {
                              "type": "string"
                            },
                            "type": {
                              "type": "string",
                              "const": "end_call"
                            },
                            "description": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        {
                          "type": "object",
                          "required": [
                            "type",
                            "name",
                            "description",
                            "transfer_destination"
                          ],
                          "properties": {
                            "name": {
                              "type": "string"
                            },
                            "type": {
                              "type": "string",
                              "const": "transfer_call"
                            },
                            "description": {
                              "type": "string"
                            },
                            "transfer_destination": {
                              "anyOf": [
                                {
                                  "type": "object",
                                  "required": [
                                    "type",
                                    "value",
                                    "number"
                                  ],
                                  "properties": {
                                    "type": {
                                      "type": "string",
                                      "const": "predefined"
                                    },
                                    "value": {
                                      "enum": [
                                        "voicemail",
                                        "operator"
                                      ],
                                      "type": "string"
                                    },
                                    "number": {
                                      "type": "string"
                                    }
                                  },
                                  "additionalProperties": false
                                },
                                {
                                  "type": "object",
                                  "required": [
                                    "type",
                                    "description",
                                    "prompt"
                                  ],
                                  "properties": {
                                    "type": {
                                      "type": "string",
                                      "const": "inferred"
                                    },
                                    "prompt": {
                                      "type": "string"
                                    },
                                    "description": {
                                      "type": "string"
                                    }
                                  },
                                  "additionalProperties": false
                                }
                              ]
                            }
                          },
                          "additionalProperties": false
                        },
                        {
                          "type": "object",
                          "required": [
                            "type",
                            "name",
                            "description",
                            "calendar_url",
                            "cal_api_key",
                            "event_type_id"
                          ],
                          "properties": {
                            "name": {
                              "type": "string"
                            },
                            "type": {
                              "type": "string",
                              "const": "check_availability_cal"
                            },
                            "cal_api_key": {
                              "type": "string"
                            },
                            "description": {
                              "type": "string"
                            },
                            "calendar_url": {
                              "type": "string"
                            },
                            "event_type_id": {
                              "type": "number"
                            }
                          },
                          "additionalProperties": false
                        },
                        {
                          "type": "object",
                          "required": [
                            "type",
                            "name",
                            "description",
                            "calendar_url",
                            "cal_api_key",
                            "event_type_id"
                          ],
                          "properties": {
                            "name": {
                              "type": "string"
                            },
                            "type": {
                              "type": "string",
                              "const": "book_appointment_cal"
                            },
                            "cal_api_key": {
                              "type": "string"
                            },
                            "description": {
                              "type": "string"
                            },
                            "calendar_url": {
                              "type": "string"
                            },
                            "event_type_id": {
                              "type": "number"
                            }
                          },
                          "additionalProperties": false
                        },
                        {
                          "type": "object",
                          "required": [
                            "type",
                            "name",
                            "description",
                            "digit"
                          ],
                          "properties": {
                            "name": {
                              "type": "string"
                            },
                            "type": {
                              "type": "string",
                              "const": "press_digit"
                            },
                            "digit": {
                              "type": "string"
                            },
                            "description": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        {
                          "type": "object",
                          "required": [
                            "type",
                            "name",
                            "description",
                            "speak_after_execution",
                            "speak_during_execution",
                            "url"
                          ],
                          "properties": {
                            "url": {
                              "type": "string"
                            },
                            "name": {
                              "type": "string"
                            },
                            "type": {
                              "type": "string",
                              "const": "custom"
                            },
                            "description": {
                              "type": "string"
                            },
                            "speak_after_execution": {
                              "type": "boolean"
                            },
                            "speak_during_execution": {
                              "type": "boolean"
                            }
                          },
                          "additionalProperties": false
                        }
                      ]
                    }
                  },
                  "state_prompt": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "description": "States of the LLM"
            },
            "version": {
              "type": "number",
              "description": "Version of the Retell LLM"
            },
            "s2s_model": {
              "enum": [
                "gpt-4o-realtime",
                "gpt-4o-mini-realtime"
              ],
              "type": "string",
              "description": "Select the underlying speech to speech model. Can only set this or model, not both"
            },
            "begin_message": {
              "type": "string",
              "description": "First utterance said by the agent in the call"
            },
            "general_tools": {
              "type": "array",
              "items": {
                "anyOf": [
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "name",
                      "description"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string",
                        "const": "end_call"
                      },
                      "description": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "name",
                      "description",
                      "transfer_destination"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string",
                        "const": "transfer_call"
                      },
                      "description": {
                        "type": "string"
                      },
                      "transfer_destination": {
                        "anyOf": [
                          {
                            "type": "object",
                            "required": [
                              "type",
                              "value",
                              "number"
                            ],
                            "properties": {
                              "type": {
                                "type": "string",
                                "const": "predefined"
                              },
                              "value": {
                                "enum": [
                                  "voicemail",
                                  "operator"
                                ],
                                "type": "string"
                              },
                              "number": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          },
                          {
                            "type": "object",
                            "required": [
                              "type",
                              "description",
                              "prompt"
                            ],
                            "properties": {
                              "type": {
                                "type": "string",
                                "const": "inferred"
                              },
                              "prompt": {
                                "type": "string"
                              },
                              "description": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          }
                        ]
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "name",
                      "description",
                      "calendar_url",
                      "cal_api_key",
                      "event_type_id"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string",
                        "const": "check_availability_cal"
                      },
                      "cal_api_key": {
                        "type": "string"
                      },
                      "description": {
                        "type": "string"
                      },
                      "calendar_url": {
                        "type": "string"
                      },
                      "event_type_id": {
                        "type": "number"
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "name",
                      "description",
                      "calendar_url",
                      "cal_api_key",
                      "event_type_id"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string",
                        "const": "book_appointment_cal"
                      },
                      "cal_api_key": {
                        "type": "string"
                      },
                      "description": {
                        "type": "string"
                      },
                      "calendar_url": {
                        "type": "string"
                      },
                      "event_type_id": {
                        "type": "number"
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "name",
                      "description",
                      "digit"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string",
                        "const": "press_digit"
                      },
                      "digit": {
                        "type": "string"
                      },
                      "description": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "name",
                      "description",
                      "speak_after_execution",
                      "speak_during_execution",
                      "url"
                    ],
                    "properties": {
                      "url": {
                        "type": "string"
                      },
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string",
                        "const": "custom"
                      },
                      "description": {
                        "type": "string"
                      },
                      "speak_after_execution": {
                        "type": "boolean"
                      },
                      "speak_during_execution": {
                        "type": "boolean"
                      }
                    },
                    "additionalProperties": false
                  }
                ]
              },
              "description": "A list of tools the model may call"
            },
            "general_prompt": {
              "type": "string",
              "description": "Prompt for the agent to follow"
            },
            "starting_state": {
              "type": "string",
              "description": "Name of the starting state. Required if states is not empty"
            },
            "model_temperature": {
              "type": "number",
              "description": "If set, will control the randomness of the response. Value ranging from [0,1]"
            },
            "knowledge_base_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of knowledge base ids to use for this resource"
            },
            "model_high_priority": {
              "type": "boolean",
              "description": "If set to true, will use high priority pool with more dedicated resource"
            },
            "tool_call_strict_mode": {
              "type": "boolean",
              "description": "Only applicable when model is gpt-4o or gpt-4o mini. If set to true, will use structured output"
            },
            "default_dynamic_variables": {
              "type": "object",
              "description": "Default dynamic variables represented as key-value pairs of strings",
              "additionalProperties": {
                "type": "string"
              }
            }
          },
          "required": [
            "general_prompt"
          ]
        }
      },
      {
        "name": "get_retell_llm",
        "description": "Gets a Retell LLM by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "llmId": {
              "type": "string",
              "description": "The ID of the Retell LLM to retrieve"
            }
          },
          "required": [
            "llmId"
          ]
        }
      },
      {
        "name": "update_retell_llm",
        "description": "Updates an existing Retell LLM",
        "inputSchema": {
          "type": "object",
          "properties": {
            "llmId": {
              "type": "string",
              "description": "The ID of the Retell LLM to update"
            },
            "model": {
              "enum": [
                "gpt-4o",
                "gpt-4o-mini",
                "gpt-4.1",
                "gpt-4.1-mini",
                "gpt-4.1-nano",
                "claude-3.7-sonnet",
                "claude-3.5-haiku",
                "gemini-2.0-flash",
                "gemini-2.0-flash-lite"
              ],
              "type": "string"
            },
            "version": {
              "type": "number"
            },
            "s2s_model": {
              "enum": [
                "gpt-4o-realtime",
                "gpt-4o-mini-realtime"
              ],
              "type": "string"
            },
            "begin_message": {
              "type": "string"
            },
            "general_tools": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "type",
                  "name",
                  "description"
                ],
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "type": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "general_prompt": {
              "type": "string"
            },
            "model_temperature": {
              "type": "number"
            },
            "knowledge_base_ids": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "model_high_priority": {
              "type": "boolean"
            },
            "tool_call_strict_mode": {
              "type": "boolean"
            },
            "default_dynamic_variables": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          },
          "required": [
            "llmId"
          ]
        }
      },
      {
        "name": "delete_retell_llm",
        "description": "Deletes a Retell LLM",
        "inputSchema": {
          "type": "object",
          "properties": {
            "llmId": {
              "type": "string",
              "description": "The ID of the Retell LLM to retrieve"
            }
          },
          "required": [
            "llmId"
          ]
        }
      }
    ]
  },
  {
    "name": "abhishekjairath-sonic-pi-mcp",
    "title": "Sonic Pi MCP",
    "description": "A Model Context Protocol server that allows AI assistants like Claude and Cursor to create music and control Sonic Pi programmatically through OSC messages.",
    "icon": "https://avatars.githubusercontent.com/abhishekjairath",
    "isOfficial": false,
    "homepage": "https://github.com/abhishekjairath/sonic-pi-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "sonic-pi-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "play_note",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "note": {
              "type": "number",
              "maximum": 127,
              "minimum": 0,
              "description": "MIDI note number (0-127)"
            },
            "synth": {
              "type": "string",
              "description": "Synth to use (e.g. :saw, :beep, :prophet)"
            },
            "cutoff": {
              "type": "number",
              "description": "Filter cutoff frequency"
            },
            "sustain": {
              "type": "number",
              "description": "Note duration in seconds"
            }
          },
          "required": [
            "note"
          ]
        }
      },
      {
        "name": "run_code",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "Sonic Pi code to execute"
            }
          },
          "required": [
            "code"
          ]
        }
      }
    ]
  },
  {
    "name": "abhiz123-todoist-mcp-server",
    "title": "Todoist MCP Server",
    "description": "An MCP server that integrates Claude with Todoist, enabling natural language task management including creating, updating, completing, and deleting tasks.",
    "icon": "https://avatars.githubusercontent.com/abhiz123",
    "isOfficial": false,
    "homepage": "https://github.com/abhiz123/todoist-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@abhiz123/todoist-mcp-server"
      ],
      "env": {
        "TODOIST_API_TOKEN": "<todoist-api-token>"
      }
    },
    "parameters": [
      {
        "name": "TODOIST_API_TOKEN",
        "description": "Your Todoist API token obtained from Todoist Settings → Integrations → Developer",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "todoist_create_task",
        "description": "Create a new task in Todoist with optional description, due date, and priority",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The content/title of the task"
            },
            "priority": {
              "enum": [
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "Task priority from 1 (normal) to 4 (urgent) (optional)"
            },
            "due_string": {
              "type": "string",
              "description": "Natural language due date like 'tomorrow', 'next Monday', 'Jan 23' (optional)"
            },
            "description": {
              "type": "string",
              "description": "Detailed description of the task (optional)"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "todoist_get_tasks",
        "description": "Get a list of tasks from Todoist with various filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of tasks to return (optional)"
            },
            "filter": {
              "type": "string",
              "description": "Natural language filter like 'today', 'tomorrow', 'next week', 'priority 1', 'overdue' (optional)"
            },
            "priority": {
              "enum": [
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "Filter by priority level (1-4) (optional)"
            },
            "project_id": {
              "type": "string",
              "description": "Filter tasks by project ID (optional)"
            }
          }
        }
      },
      {
        "name": "todoist_update_task",
        "description": "Update an existing task in Todoist by searching for it by name and then updating it",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "New content/title for the task (optional)"
            },
            "priority": {
              "enum": [
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "New priority level from 1 (normal) to 4 (urgent) (optional)"
            },
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to search for and update"
            },
            "due_string": {
              "type": "string",
              "description": "New due date in natural language like 'tomorrow', 'next Monday' (optional)"
            },
            "description": {
              "type": "string",
              "description": "New description for the task (optional)"
            }
          },
          "required": [
            "task_name"
          ]
        }
      },
      {
        "name": "todoist_delete_task",
        "description": "Delete a task from Todoist by searching for it by name",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to search for and delete"
            }
          },
          "required": [
            "task_name"
          ]
        }
      },
      {
        "name": "todoist_complete_task",
        "description": "Mark a task as complete by searching for it by name",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to search for and complete"
            }
          },
          "required": [
            "task_name"
          ]
        }
      }
    ]
  },
  {
    "name": "adepanges-teamretro-mcp-server",
    "title": "TeamRetro MCP Server",
    "description": "An unofficial MCP server that enables Claude to interact with TeamRetro.com's API for team retrospective management, providing direct pass-through to TeamRetro's public API endpoints with multiple authentication options.",
    "icon": "https://avatars.githubusercontent.com/adepanges",
    "isOfficial": false,
    "homepage": "https://github.com/adepanges/teamretro-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "teamretro-mcp-server"
      ],
      "env": {
        "TEAMRETRO_TOKEN": "<teamretro-token>",
        "TEAMRETRO_API_KEY": "<teamretro-api-key>",
        "TEAMRETRO_BASE_URL": "<teamretro-base-url>",
        "TEAMRETRO_PASSWORD": "<teamretro-password>",
        "TEAMRETRO_USERNAME": "<teamretro-username>",
        "TEAMRETRO_AUTH_TYPE": "<teamretro-auth-type>"
      }
    },
    "parameters": [
      {
        "name": "TEAMRETRO_TOKEN",
        "description": "Your TeamRetro bearer token for bearer authentication",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TEAMRETRO_API_KEY",
        "description": "Your TeamRetro API key for apiKey authentication",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TEAMRETRO_BASE_URL",
        "description": "Base URL for TeamRetro API",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TEAMRETRO_PASSWORD",
        "description": "Your TeamRetro password for basic authentication",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TEAMRETRO_USERNAME",
        "description": "Your TeamRetro username for basic authentication",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TEAMRETRO_AUTH_TYPE",
        "description": "Authentication type (apiKey, basic, or bearer)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "list_users",
        "description": "List users with pagination using offset and limit parameters to control the number of results returned",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "default": 1000,
              "maximum": 1000,
              "minimum": 1,
              "description": "number"
            },
            "offset": {
              "type": "integer",
              "default": 0,
              "minimum": 0,
              "description": "number"
            }
          }
        }
      },
      {
        "name": "add_user",
        "description": "Add a new user or update an existing user's information by their email address, specifying optional name and emailAddress",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "maxLength": 64,
              "minLength": 1,
              "description": "string"
            },
            "email": {
              "type": "string",
              "format": "email",
              "description": "email"
            }
          },
          "required": [
            "email"
          ]
        }
      },
      {
        "name": "update_user",
        "description": "Update an existing user's details, such as their name and emailAddress, by providing their current email",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "maxLength": 64,
              "minLength": 1,
              "description": "string"
            },
            "email": {
              "type": "string",
              "format": "email",
              "description": "email"
            },
            "emailAddress": {
              "type": "string",
              "format": "email",
              "description": "email"
            }
          },
          "required": [
            "email",
            "emailAddress"
          ]
        }
      },
      {
        "name": "delete_user",
        "description": "Delete a user by their email address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "format": "email",
              "description": "email"
            }
          },
          "required": [
            "email"
          ]
        }
      },
      {
        "name": "get_user",
        "description": "Retrieve detailed information about a single user by their email address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "format": "email",
              "description": "email"
            }
          },
          "required": [
            "email"
          ]
        }
      },
      {
        "name": "list_teams",
        "description": "List teams from TeamRetro with filtering by tags and IDs, and pagination using offset and limit parameters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "default": 1000,
              "maximum": 1000,
              "minimum": 1,
              "description": "number"
            },
            "offset": {
              "type": "integer",
              "default": 0,
              "minimum": 0,
              "description": "number"
            },
            "teamIds": {
              "type": "string",
              "pattern": "^([a-zA-Z0-9]{22})?(,[a-zA-Z0-9]{22})*$",
              "description": "id,id,..."
            },
            "teamTags": {
              "type": "string",
              "description": "tag,tag,other tag,..."
            }
          }
        }
      },
      {
        "name": "detail_team",
        "description": "Retrieve detailed information about a single team by its unique ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "update_team",
        "description": "Update an existing team's details, such as its name and associated tags, by providing the team's ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            },
            "name": {
              "type": "string",
              "maxLength": 64,
              "minLength": 1,
              "description": "string"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string",
                "maxLength": 16,
                "minLength": 0,
                "description": "string"
              },
              "description": "string[]"
            }
          },
          "required": [
            "id",
            "name"
          ]
        }
      },
      {
        "name": "create_team",
        "description": "Create a new team with a required name, and optional tags and members",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "maxLength": 64,
              "minLength": 1,
              "description": "string"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string",
                "maxLength": 16,
                "minLength": 0,
                "description": "string"
              },
              "description": "string[]"
            },
            "members": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "email",
                  "name"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "maxLength": 64,
                    "minLength": 1,
                    "description": "string"
                  },
                  "email": {
                    "type": "string",
                    "format": "email",
                    "description": "email"
                  },
                  "teamAdmin": {
                    "type": "boolean",
                    "default": false,
                    "description": "boolean"
                  }
                },
                "additionalProperties": false
              },
              "description": "{ email: email, name?: string, teamAdmin: boolean }[]"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "delete_team",
        "description": "Delete an existing team by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "teamId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "teamId"
          ]
        }
      },
      {
        "name": "list_team_members",
        "description": "Retrieve a list of team members for a specified team ID with pagination controls for offset and limit.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "default": 1000,
              "maximum": 1000,
              "minimum": 1,
              "description": "number"
            },
            "offset": {
              "type": "integer",
              "default": 0,
              "minimum": 0,
              "description": "number"
            },
            "teamId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "teamId"
          ]
        }
      },
      {
        "name": "get_team_member",
        "description": "Fetch a team member by their email address within a specified team.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "format": "email",
              "description": "email"
            },
            "teamId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "teamId",
            "email"
          ]
        }
      },
      {
        "name": "update_team_member",
        "description": "Update a team member's details, such as their name or team admin status, by their email address within a specified team.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "format": "email",
              "description": "email"
            },
            "teamId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            },
            "teamAdmin": {
              "type": "boolean",
              "default": false,
              "description": "boolean"
            }
          },
          "required": [
            "teamId",
            "email"
          ]
        }
      },
      {
        "name": "remove_team_member",
        "description": "Remove a team member from a team by their email address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "format": "email",
              "description": "email"
            },
            "teamId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "teamId",
            "email"
          ]
        }
      },
      {
        "name": "add_team_member",
        "description": "Add a new team member to a team by their email address, with optional specification of team admin status.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "format": "email",
              "description": "email"
            },
            "teamId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            },
            "teamAdmin": {
              "type": "boolean",
              "default": false,
              "description": "boolean"
            }
          },
          "required": [
            "teamId",
            "email"
          ]
        }
      },
      {
        "name": "list_actions",
        "description": "Retrieve a list of actions from TeamRetro with optional filtering by team tags and team IDs, and pagination controls for offset and limit.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "default": 1000,
              "maximum": 1000,
              "minimum": 1,
              "description": "number"
            },
            "offset": {
              "type": "integer",
              "default": 0,
              "minimum": 0,
              "description": "number"
            },
            "teamIds": {
              "type": "string",
              "pattern": "^([a-zA-Z0-9]{22})?(,[a-zA-Z0-9]{22})*$",
              "description": "id,id,..."
            },
            "teamTags": {
              "type": "string",
              "description": "tag,tag,other tag,..."
            }
          }
        }
      },
      {
        "name": "create_action",
        "description": "Create a new action in TeamRetro with required details such as team ID, title, due date, completion status, and assigned user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "due": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "iso datetime"
                },
                {
                  "type": "null"
                }
              ],
              "description": "iso datetime"
            },
            "title": {
              "type": "string",
              "maxLength": 10000,
              "minLength": 1
            },
            "teamId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            },
            "complete": {
              "type": "string",
              "format": "date-time",
              "description": "iso datetime"
            },
            "assignedTo": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "email"
                ],
                "properties": {
                  "email": {
                    "type": "string",
                    "format": "email",
                    "description": "email"
                  }
                },
                "additionalProperties": false
              },
              "default": [],
              "maxItems": 16,
              "description": "{ email: string }[]"
            }
          },
          "required": [
            "teamId",
            "title"
          ]
        }
      },
      {
        "name": "get_action",
        "description": "Fetch a single action by its unique ID from TeamRetro.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "update_action",
        "description": "Update an existing action in TeamRetro with new details such as title, due date, completion status, priority, and assigned user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "due": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "iso datetime"
                },
                {
                  "type": "null"
                }
              ],
              "description": "iso datetime"
            },
            "title": {
              "type": "string",
              "maxLength": 10000,
              "minLength": 1
            },
            "teamId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            },
            "actionId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            },
            "complete": {
              "type": "string",
              "format": "date-time",
              "description": "iso datetime"
            },
            "priority": {
              "enum": [
                "low",
                "medium",
                "high"
              ],
              "type": "string"
            },
            "assignedTo": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "email"
                ],
                "properties": {
                  "email": {
                    "type": "string",
                    "format": "email",
                    "description": "email"
                  }
                },
                "additionalProperties": false
              },
              "default": [],
              "maxItems": 16,
              "description": "{ email: string }[]"
            }
          },
          "required": [
            "actionId",
            "teamId",
            "title"
          ]
        }
      },
      {
        "name": "delete_action",
        "description": "Delete an existing action from TeamRetro by its action ID.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "actionId": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "actionId"
          ]
        }
      },
      {
        "name": "list_retrospectives",
        "description": "List retrospectives from TeamRetro with filtering by team tags and IDs, and pagination using offset and limit parameters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "default": 1000,
              "maximum": 1000,
              "minimum": 1,
              "description": "number"
            },
            "offset": {
              "type": "integer",
              "default": 0,
              "minimum": 0,
              "description": "number"
            },
            "teamIds": {
              "type": "string",
              "pattern": "^([a-zA-Z0-9]{22})?(,[a-zA-Z0-9]{22})*$",
              "description": "id,id,..."
            },
            "teamTags": {
              "type": "string",
              "description": "tag,tag,other tag,..."
            }
          }
        }
      },
      {
        "name": "get_retrospective",
        "description": "Retrieve detailed information about a single retrospective by its unique ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "delete_retrospective",
        "description": "Delete an existing retrospective by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "delete_agreement",
        "description": "Delete an existing agreement by specifying its unique identifier",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "update_agreement",
        "description": "Update an existing agreement's details such as its title or associated team. Provide the agreement ID and the fields you wish to update.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            },
            "team": {
              "type": "object",
              "required": [
                "id",
                "name"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "pattern": "^[a-zA-Z0-9]{22}$",
                  "description": "id"
                },
                "name": {
                  "type": "string",
                  "maxLength": 64,
                  "minLength": 1,
                  "description": "string"
                },
                "tags": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "maxLength": 16,
                    "minLength": 0,
                    "description": "string"
                  },
                  "description": "string[]"
                }
              },
              "additionalProperties": false
            },
            "title": {
              "type": "string",
              "maxLength": 10000,
              "minLength": 1
            }
          },
          "required": [
            "id",
            "team",
            "title"
          ]
        }
      },
      {
        "name": "get_agreement",
        "description": "Retrieve a single agreement by its unique identifier. This will return the agreement's details including its title, associated team, and creation date.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "create_agreement",
        "description": "Create a new agreement in TeamRetro by specifying the team it belongs to and its title. This will return the newly created agreement with its unique identifier and other details.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "team": {
              "type": "object",
              "required": [
                "id",
                "name"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "pattern": "^[a-zA-Z0-9]{22}$",
                  "description": "id"
                },
                "name": {
                  "type": "string",
                  "maxLength": 64,
                  "minLength": 1,
                  "description": "string"
                },
                "tags": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "maxLength": 16,
                    "minLength": 0,
                    "description": "string"
                  },
                  "description": "string[]"
                }
              },
              "additionalProperties": false
            },
            "title": {
              "type": "string",
              "maxLength": 10000,
              "minLength": 1
            }
          },
          "required": [
            "team",
            "title"
          ]
        }
      },
      {
        "name": "list_agreements",
        "description": "List agreements from TeamRetro with optional filtering by team tags and team IDs, as well as pagination controls. This allows for retrieving a specific subset of agreements based on the provided criteria.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "default": 1000,
              "maximum": 1000,
              "minimum": 1,
              "description": "number"
            },
            "offset": {
              "type": "integer",
              "default": 0,
              "minimum": 0,
              "description": "number"
            },
            "teamIds": {
              "type": "string",
              "pattern": "^([a-zA-Z0-9]{22})?(,[a-zA-Z0-9]{22})*$",
              "description": "id,id,..."
            },
            "teamTags": {
              "type": "string",
              "description": "tag,tag,other tag,..."
            }
          }
        }
      },
      {
        "name": "get_health_model",
        "description": "Retrieve a single health model by its unique identifier. This will return the health model's details including its name, dimensions, and creation date.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_health_models",
        "description": "List health models from TeamRetro with pagination controls. This allows for retrieving a specific subset of health models based on the provided offset and limit parameters.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "default": 1000,
              "maximum": 1000,
              "minimum": 1,
              "description": "number"
            },
            "offset": {
              "type": "integer",
              "default": 0,
              "minimum": 0,
              "description": "number"
            }
          }
        }
      },
      {
        "name": "delete_health_check",
        "description": "Delete an existing health check by specifying its unique identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_health_check",
        "description": "Retrieve a single health check by its unique identifier with optional attributes to include. This will return the health check's details including its title, date, team, health model, and status.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{22}$",
              "description": "id"
            },
            "include": {
              "type": "string",
              "description": "Comma delimited list of attributes to include (comments, ratings)"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_health_checks",
        "description": "List health checks from TeamRetro with optional filtering by health model IDs, team tags, and team IDs, as well as pagination controls. This allows for retrieving a specific subset of health checks based on the provided criteria.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "default": 1000,
              "maximum": 1000,
              "minimum": 1,
              "description": "number"
            },
            "offset": {
              "type": "integer",
              "default": 0,
              "minimum": 0,
              "description": "number"
            },
            "include": {
              "type": "string",
              "description": "Comma delimited list of attributes to include (comments, ratings)"
            },
            "teamIds": {
              "type": "string",
              "pattern": "^([a-zA-Z0-9]{22})?(,[a-zA-Z0-9]{22})*$",
              "description": "id,id,..."
            },
            "teamTags": {
              "type": "string",
              "description": "tag,tag,other tag,..."
            },
            "healthModelIds": {
              "type": "string",
              "pattern": "^([a-zA-Z0-9]{22})?(,[a-zA-Z0-9]{22})*$",
              "description": "id,id,..."
            }
          }
        }
      }
    ]
  },
  {
    "name": "agentmode-server",
    "title": "AgentMode",
    "description": "An all-in-one Model Context Protocol (MCP) server that connects your coding AI to numerous databases, data warehouses, data pipelines, and cloud services, streamlining development workflow through seamless integrations.",
    "icon": "https://avatars.githubusercontent.com/agentmode",
    "isOfficial": true,
    "homepage": "https://github.com/agentmode/server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "agentmode"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "ahonn-mcp-server-gsc",
    "title": "Google Search Console MCP Server",
    "description": "A server that provides access to Google Search Console data through the Model Context Protocol, allowing users to retrieve and analyze search analytics data with customizable dimensions and reporting periods.",
    "icon": "https://avatars.githubusercontent.com/ahonn",
    "isOfficial": false,
    "homepage": "https://github.com/ahonn/mcp-server-gsc",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-server-gsc"
      ],
      "env": {
        "GOOGLE_APPLICATION_CREDENTIALS": "<google-application-credentials>"
      }
    },
    "parameters": [
      {
        "name": "GOOGLE_APPLICATION_CREDENTIALS",
        "description": "Path to the Google Service Account credentials JSON file with Search Console API access",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "list_sites",
        "description": "List all sites in Google Search Console",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "search_analytics",
        "description": "Get search performance data from Google Search Console",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "web",
                "image",
                "video",
                "news"
              ],
              "type": "string",
              "description": "Type of search to filter by, such as web, image, video, news"
            },
            "endDate": {
              "type": "string",
              "description": "End date in YYYY-MM-DD format"
            },
            "siteUrl": {
              "type": "string",
              "description": "The site URL as defined in Search Console. Example: sc-domain:example.com (for domain resources) or http://www.example.com/ (for site prefix resources)"
            },
            "rowLimit": {
              "type": "number",
              "default": 1000,
              "description": "Maximum number of rows to return"
            },
            "startDate": {
              "type": "string",
              "description": "Start date in YYYY-MM-DD format"
            },
            "dimensions": {
              "type": "string",
              "description": "Comma-separated list of dimensions to break down results by, such as query, page, country, device, searchAppearance"
            },
            "aggregationType": {
              "enum": [
                "auto",
                "byNewsShowcasePanel",
                "byProperty",
                "byPage"
              ],
              "type": "string",
              "description": "Type of aggregation, such as auto, byNewsShowcasePanel, byProperty, byPage"
            }
          },
          "required": [
            "siteUrl",
            "startDate",
            "endDate"
          ]
        }
      },
      {
        "name": "index_inspect",
        "description": "Inspect a URL to see if it is indexed or can be indexed",
        "inputSchema": {
          "type": "object",
          "properties": {
            "siteUrl": {
              "type": "string",
              "description": "The site URL as defined in Search Console. Example: sc-domain:example.com (for domain resources) or http://www.example.com/ (for site prefix resources)"
            },
            "languageCode": {
              "type": "string",
              "default": "en-US",
              "description": "An IETF BCP-47 language code representing the language of the requested translated issue messages, such as \"en-US\" or \"de-CH\". Default is \"en-US\""
            },
            "inspectionUrl": {
              "type": "string",
              "description": "The fully-qualified URL to inspect. Must be under the property specified in \"siteUrl\""
            }
          },
          "required": [
            "siteUrl",
            "inspectionUrl"
          ]
        }
      },
      {
        "name": "list_sitemaps",
        "description": "List sitemaps for a site in Google Search Console",
        "inputSchema": {
          "type": "object",
          "properties": {
            "siteUrl": {
              "type": "string",
              "description": "The site's URL, including protocol. For example: http://www.example.com/"
            },
            "sitemapIndex": {
              "type": "string",
              "description": "A URL of a site's sitemap index. For example: http://www.example.com/sitemapindex.xml"
            }
          }
        }
      },
      {
        "name": "get_sitemap",
        "description": "Get a sitemap for a site in Google Search Console",
        "inputSchema": {
          "type": "object",
          "properties": {
            "siteUrl": {
              "type": "string",
              "description": "The site's URL, including protocol. For example: http://www.example.com/"
            },
            "feedpath": {
              "type": "string",
              "description": "The URL of the actual sitemap. For example: http://www.example.com/sitemap.xml"
            }
          }
        }
      },
      {
        "name": "submit_sitemap",
        "description": "Submit a sitemap for a site in Google Search Console",
        "inputSchema": {
          "type": "object",
          "properties": {
            "siteUrl": {
              "type": "string",
              "description": "The site's URL, including protocol. For example: http://www.example.com/"
            },
            "feedpath": {
              "type": "string",
              "description": "The URL of the sitemap to add. For example: http://www.example.com/sitemap.xml"
            }
          },
          "required": [
            "feedpath",
            "siteUrl"
          ]
        }
      }
    ]
  },
  {
    "name": "ahujasid-ableton-mcp",
    "title": "AbletonMCP",
    "description": "Connects Ableton Live to Claude AI through the Model Context Protocol, enabling AI-assisted music production by allowing Claude to directly interact with and control Ableton Live sessions.",
    "icon": "https://avatars.githubusercontent.com/ahujasid",
    "isOfficial": false,
    "homepage": "https://github.com/ahujasid/ableton-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "ableton-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_session_info",
        "description": "Get detailed information about the current Ableton session",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_track_info",
        "description": "\n    Get detailed information about a specific track in Ableton.\n    \n    Parameters:\n    - track_index: The index of the track to get information about\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "track_index": {
              "type": "integer",
              "title": "Track Index"
            }
          },
          "required": [
            "track_index"
          ]
        }
      },
      {
        "name": "create_midi_track",
        "description": "\n    Create a new MIDI track in the Ableton session.\n    \n    Parameters:\n    - index: The index to insert the track at (-1 = end of list)\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "index": {
              "type": "integer",
              "title": "Index",
              "default": -1
            }
          }
        }
      },
      {
        "name": "set_track_name",
        "description": "\n    Set the name of a track.\n    \n    Parameters:\n    - track_index: The index of the track to rename\n    - name: The new name for the track\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "track_index": {
              "type": "integer",
              "title": "Track Index"
            }
          },
          "required": [
            "track_index",
            "name"
          ]
        }
      },
      {
        "name": "create_clip",
        "description": "\n    Create a new MIDI clip in the specified track and clip slot.\n    \n    Parameters:\n    - track_index: The index of the track to create the clip in\n    - clip_index: The index of the clip slot to create the clip in\n    - length: The length of the clip in beats (default: 4.0)\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "length": {
              "type": "number",
              "title": "Length",
              "default": 4
            },
            "clip_index": {
              "type": "integer",
              "title": "Clip Index"
            },
            "track_index": {
              "type": "integer",
              "title": "Track Index"
            }
          },
          "required": [
            "track_index",
            "clip_index"
          ]
        }
      },
      {
        "name": "add_notes_to_clip",
        "description": "\n    Add MIDI notes to a clip.\n    \n    Parameters:\n    - track_index: The index of the track containing the clip\n    - clip_index: The index of the clip slot containing the clip\n    - notes: List of note dictionaries, each with pitch, start_time, duration, velocity, and mute\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notes": {
              "type": "array",
              "items": {
                "type": "object",
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    }
                  ]
                }
              },
              "title": "Notes"
            },
            "clip_index": {
              "type": "integer",
              "title": "Clip Index"
            },
            "track_index": {
              "type": "integer",
              "title": "Track Index"
            }
          },
          "required": [
            "track_index",
            "clip_index",
            "notes"
          ]
        }
      },
      {
        "name": "set_clip_name",
        "description": "\n    Set the name of a clip.\n    \n    Parameters:\n    - track_index: The index of the track containing the clip\n    - clip_index: The index of the clip slot containing the clip\n    - name: The new name for the clip\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "clip_index": {
              "type": "integer",
              "title": "Clip Index"
            },
            "track_index": {
              "type": "integer",
              "title": "Track Index"
            }
          },
          "required": [
            "track_index",
            "clip_index",
            "name"
          ]
        }
      },
      {
        "name": "set_tempo",
        "description": "\n    Set the tempo of the Ableton session.\n    \n    Parameters:\n    - tempo: The new tempo in BPM\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tempo": {
              "type": "number",
              "title": "Tempo"
            }
          },
          "required": [
            "tempo"
          ]
        }
      },
      {
        "name": "load_instrument_or_effect",
        "description": "\n    Load an instrument or effect onto a track using its URI.\n    \n    Parameters:\n    - track_index: The index of the track to load the instrument on\n    - uri: The URI of the instrument or effect to load (e.g., 'query:Synths#Instrument%20Rack:Bass:FileId_5116')\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "uri": {
              "type": "string",
              "title": "Uri"
            },
            "track_index": {
              "type": "integer",
              "title": "Track Index"
            }
          },
          "required": [
            "track_index",
            "uri"
          ]
        }
      },
      {
        "name": "fire_clip",
        "description": "\n    Start playing a clip.\n    \n    Parameters:\n    - track_index: The index of the track containing the clip\n    - clip_index: The index of the clip slot containing the clip\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clip_index": {
              "type": "integer",
              "title": "Clip Index"
            },
            "track_index": {
              "type": "integer",
              "title": "Track Index"
            }
          },
          "required": [
            "track_index",
            "clip_index"
          ]
        }
      },
      {
        "name": "stop_clip",
        "description": "\n    Stop playing a clip.\n    \n    Parameters:\n    - track_index: The index of the track containing the clip\n    - clip_index: The index of the clip slot containing the clip\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clip_index": {
              "type": "integer",
              "title": "Clip Index"
            },
            "track_index": {
              "type": "integer",
              "title": "Track Index"
            }
          },
          "required": [
            "track_index",
            "clip_index"
          ]
        }
      },
      {
        "name": "start_playback",
        "description": "Start playing the Ableton session.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "stop_playback",
        "description": "Stop playing the Ableton session.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_browser_tree",
        "description": "\n    Get a hierarchical tree of browser categories from Ableton.\n    \n    Parameters:\n    - category_type: Type of categories to get ('all', 'instruments', 'sounds', 'drums', 'audio_effects', 'midi_effects')\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category_type": {
              "type": "string",
              "title": "Category Type",
              "default": "all"
            }
          }
        }
      },
      {
        "name": "get_browser_items_at_path",
        "description": "\n    Get browser items at a specific path in Ableton's browser.\n    \n    Parameters:\n    - path: Path in the format \"category/folder/subfolder\"\n            where category is one of the available browser categories in Ableton\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "title": "Path"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "load_drum_kit",
        "description": "\n    Load a drum rack and then load a specific drum kit into it.\n    \n    Parameters:\n    - track_index: The index of the track to load on\n    - rack_uri: The URI of the drum rack to load (e.g., 'Drums/Drum Rack')\n    - kit_path: Path to the drum kit inside the browser (e.g., 'drums/acoustic/kit1')\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "kit_path": {
              "type": "string",
              "title": "Kit Path"
            },
            "rack_uri": {
              "type": "string",
              "title": "Rack Uri"
            },
            "track_index": {
              "type": "integer",
              "title": "Track Index"
            }
          },
          "required": [
            "track_index",
            "rack_uri",
            "kit_path"
          ]
        }
      }
    ]
  },
  {
    "name": "aindreyway-mcp-codex-keeper",
    "title": "mcp-codex-keeper",
    "description": "Serves as a guardian of development knowledge, providing AI assistants with curated access to latest documentation and best practices.",
    "icon": "https://avatars.githubusercontent.com/aindreyway",
    "isOfficial": false,
    "homepage": "https://github.com/aindreyway/mcp-codex-keeper",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@aindreyway/mcp-codex-keeper"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "list_documentation",
        "description": "List all available documentation sources. Use this tool to discover relevant documentation before starting tasks to ensure best practices and standards compliance.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "Filter documentation by tag"
            },
            "category": {
              "type": "string",
              "description": "Filter documentation by category"
            }
          }
        }
      },
      {
        "name": "add_documentation",
        "description": "Add a new documentation source. When working on tasks, add any useful documentation you discover to help maintain a comprehensive knowledge base.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the documentation"
            },
            "name": {
              "type": "string",
              "description": "Name of the documentation"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tags for additional categorization"
            },
            "version": {
              "type": "string",
              "description": "Version information"
            },
            "category": {
              "type": "string",
              "description": "Category of the documentation"
            },
            "description": {
              "type": "string",
              "description": "Description of the documentation"
            }
          },
          "required": [
            "name",
            "url",
            "category"
          ]
        }
      },
      {
        "name": "update_documentation",
        "description": "Update documentation content from source. Always update relevant documentation before starting a task to ensure you have the latest information and best practices.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the documentation to update"
            },
            "force": {
              "type": "boolean",
              "description": "Force update even if recently updated"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "search_documentation",
        "description": "Search through documentation content. Use this to find specific information, best practices, or guidelines relevant to your current task. Remember to check documentation before making important decisions.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "Filter by tag"
            },
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "category": {
              "type": "string",
              "description": "Filter by category"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "remove_documentation",
        "description": "Remove a documentation source. Use this when you no longer need specific documentation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the documentation to remove"
            }
          },
          "required": [
            "name"
          ]
        }
      }
    ]
  },
  {
    "name": "aindreyway-mcp-neurolora",
    "title": "mcp-neurolora",
    "description": "Provides tools for collecting and documenting code from directories.",
    "icon": "https://avatars.githubusercontent.com/aindreyway",
    "isOfficial": false,
    "homepage": "https://github.com/aindreyway/mcp-neurolora",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@aindreyway/mcp-neurolora"
      ],
      "env": {
        "NODE_OPTIONS": "<node-options>",
        "OPENAI_API_KEY": "<openai-api-key>"
      }
    },
    "parameters": [
      {
        "name": "NODE_OPTIONS",
        "description": "Node.js runtime options",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OPENAI_API_KEY",
        "description": "Your OpenAI API key needed for code analysis functionality",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "aipotheosis-labs-aci-mcp",
    "title": "ACI MCP Server",
    "description": "MCP server providing access to ACI.dev managed functions (tools) either directly from specific apps or through meta functions that dynamically discover and execute any available function based on user intent.",
    "icon": "https://avatars.githubusercontent.com/aipotheosis-labs",
    "isOfficial": false,
    "homepage": "https://github.com/aipotheosis-labs/aci-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "aipolabs-mcp"
      ],
      "env": {
        "ACI_API_KEY": "<aci-api-key>",
        "LINKED_ACCOUNT_OWNER_ID": "<linked-account-owner-id>"
      }
    },
    "parameters": [
      {
        "name": "ACI_API_KEY",
        "description": "The API key for your ACI.dev project",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "LINKED_ACCOUNT_OWNER_ID",
        "description": "The ID of the account that you want to use to access the functions",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "ACI_SEARCH_FUNCTIONS",
        "description": "This function allows you to find relevant executable functions and their schemas that can help complete your tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "intent": {
              "type": "string",
              "description": "Use this to find relevant functions you might need. Returned results of this function will be sorted by relevance to the intent."
            }
          },
          "required": []
        }
      },
      {
        "name": "ACI_EXECUTE_FUNCTION",
        "description": "Execute a specific retrieved function. Provide the executable function name, and the required function parameters for that function based on function definition retrieved.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "function_name": {
              "type": "string",
              "description": "The name of the function to execute"
            },
            "function_arguments": {
              "type": "object",
              "description": "A dictionary containing key-value pairs of input parameters required by the specified function. The parameter names and types must match those defined in the function definition previously retrieved. If the function requires no parameters, provide an empty object.",
              "additionalProperties": true
            }
          },
          "required": [
            "function_name",
            "function_arguments"
          ]
        }
      }
    ]
  },
  {
    "name": "ai-zerolab-mcp-email-server",
    "title": "MCP Email Server",
    "description": "Provides IMAP and SMTP capabilities, enabling developers to manage email services with seamless integration and automated workflows.",
    "icon": "https://avatars.githubusercontent.com/ai-zerolab",
    "isOfficial": false,
    "homepage": "https://github.com/ai-zerolab/mcp-email-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-email-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "list_available_accounts",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "add_email_account",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "$ref": "#/$defs/EmailSettings"
            }
          },
          "required": [
            "email"
          ]
        }
      },
      {
        "name": "page_email",
        "description": "Paginate emails, page start at 1, before and since as UTC datetime.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Body",
              "default": null
            },
            "page": {
              "type": "integer",
              "title": "Page",
              "default": 1
            },
            "text": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Text",
              "default": null
            },
            "since": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Since",
              "default": null
            },
            "before": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Before",
              "default": null
            },
            "subject": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Subject",
              "default": null
            },
            "page_size": {
              "type": "integer",
              "title": "Page Size",
              "default": 10
            },
            "to_address": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "To Address",
              "default": null
            },
            "account_name": {
              "type": "string",
              "title": "Account Name"
            },
            "from_address": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "From Address",
              "default": null
            }
          },
          "required": [
            "account_name"
          ]
        }
      },
      {
        "name": "send_email",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "title": "Body"
            },
            "subject": {
              "type": "string",
              "title": "Subject"
            },
            "recipient": {
              "type": "string",
              "title": "Recipient"
            },
            "account_name": {
              "type": "string",
              "title": "Account Name"
            }
          },
          "required": [
            "account_name",
            "recipient",
            "subject",
            "body"
          ]
        }
      }
    ]
  },
  {
    "name": "ai-zerolab-mcp-toolbox",
    "title": "MCP Toolbox",
    "description": "A comprehensive toolkit that enhances LLM capabilities through the Model Context Protocol, allowing LLMs to interact with external services including command-line operations, file management, Figma integration, and audio processing.",
    "icon": "https://avatars.githubusercontent.com/ai-zerolab",
    "isOfficial": false,
    "homepage": "https://github.com/ai-zerolab/mcp-toolbox",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-toolbox"
      ],
      "env": {
        "FIGMA_API_KEY": "<figma-api-key>"
      }
    },
    "parameters": [
      {
        "name": "FIGMA_API_KEY",
        "description": "API key for Figma integration",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "execute_command",
        "description": "Execute a command line instruction. Args: command (required, The command to execute as a list of strings), timeout_seconds (optional, Maximum execution time in seconds), working_dir (optional, Directory to execute the command in)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "Command"
            },
            "working_dir": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Working Dir",
              "default": null
            },
            "timeout_seconds": {
              "type": "integer",
              "title": "Timeout Seconds",
              "default": 30
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "figma_get_file",
        "description": "Get a Figma file by key. Args: fileKey (required, The key of the file to get), version (optional, A specific version ID to get), depth (optional, Depth of nodes to return 1-4), branch_data (optional, Include branch data if true)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "depth": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Depth",
              "default": null
            },
            "fileKey": {
              "type": "string",
              "title": "Filekey"
            },
            "version": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Version",
              "default": null
            },
            "branch_data": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Branch Data",
              "default": null
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_get_file_nodes",
        "description": "Get specific nodes from a Figma file. Args: fileKey (required, The key of the file to get nodes from), node_ids (required, Array of node IDs to get), depth (optional, Depth of nodes to return 1-4), version (optional, A specific version ID to get)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "depth": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Depth",
              "default": null
            },
            "fileKey": {
              "type": "string",
              "title": "Filekey"
            },
            "version": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Version",
              "default": null
            },
            "node_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "Node Ids"
            }
          },
          "required": [
            "fileKey",
            "node_ids"
          ]
        }
      },
      {
        "name": "figma_get_image",
        "description": "Get images for nodes in a Figma file. Args: fileKey (required, The key of the file to get images from), ids (required, Array of node IDs to render), scale (optional, Scale factor to render at 0.01-4), format_type (optional, Image format jpg/png/svg/pdf), svg_include_id (optional, Include IDs in SVG output), svg_simplify_stroke (optional, Simplify strokes in SVG output), use_absolute_bounds (optional, Use absolute bounds)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "Ids"
            },
            "scale": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Scale",
              "default": null
            },
            "fileKey": {
              "type": "string",
              "title": "Filekey"
            },
            "format_type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Format Type",
              "default": null
            },
            "svg_include_id": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Svg Include Id",
              "default": null
            },
            "svg_simplify_stroke": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Svg Simplify Stroke",
              "default": null
            },
            "use_absolute_bounds": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Use Absolute Bounds",
              "default": null
            }
          },
          "required": [
            "fileKey",
            "ids"
          ]
        }
      },
      {
        "name": "figma_get_image_fills",
        "description": "Get URLs for images used in a Figma file. Args: fileKey (required, The key of the file to get image fills from)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "title": "Filekey"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_get_comments",
        "description": "Get comments on a Figma file. Args: fileKey (required, The key of the file to get comments from)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "title": "Filekey"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_post_comment",
        "description": "Post a comment on a Figma file. Args: fileKey (required, The key of the file to comment on), message (required, Comment message text), client_meta (optional, Position of the comment x/y/node_id/node_offset), comment_id (optional, ID of comment to reply to)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "title": "Filekey"
            },
            "message": {
              "type": "string",
              "title": "Message"
            },
            "comment_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Comment Id",
              "default": null
            },
            "client_meta": {
              "anyOf": [
                {
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Client Meta",
              "default": null
            }
          },
          "required": [
            "fileKey",
            "message"
          ]
        }
      },
      {
        "name": "figma_delete_comment",
        "description": "Delete a comment from a Figma file. Args: fileKey (required, The key of the file to delete a comment from), comment_id (required, ID of the comment to delete)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "title": "Filekey"
            },
            "comment_id": {
              "type": "string",
              "title": "Comment Id"
            }
          },
          "required": [
            "fileKey",
            "comment_id"
          ]
        }
      },
      {
        "name": "figma_get_team_projects",
        "description": "Get projects for a team. Args: team_id (required, The team ID), page_size (optional, Number of items per page), cursor (optional, Cursor for pagination)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "team_id": {
              "type": "string",
              "title": "Team Id"
            },
            "page_size": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page Size",
              "default": null
            }
          },
          "required": [
            "team_id"
          ]
        }
      },
      {
        "name": "figma_get_project_files",
        "description": "Get files for a project. Args: project_id (required, The project ID), page_size (optional, Number of items per page), cursor (optional, Cursor for pagination), branch_data (optional, Include branch data if true)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "page_size": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page Size",
              "default": null
            },
            "project_id": {
              "type": "string",
              "title": "Project Id"
            },
            "branch_data": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Branch Data",
              "default": null
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "figma_get_team_components",
        "description": "Get components for a team. Args: team_id (required, The team ID), page_size (optional, Number of items per page), cursor (optional, Cursor for pagination)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "team_id": {
              "type": "string",
              "title": "Team Id"
            },
            "page_size": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page Size",
              "default": null
            }
          },
          "required": [
            "team_id"
          ]
        }
      },
      {
        "name": "figma_get_file_components",
        "description": "Get components from a file. Args: fileKey (required, The key of the file to get components from)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "title": "Filekey"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_get_component",
        "description": "Get a component by key. Args: key (required, The component key)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "title": "Key"
            }
          },
          "required": [
            "key"
          ]
        }
      },
      {
        "name": "figma_get_team_component_sets",
        "description": "Get component sets for a team. Args: team_id (required, The team ID), page_size (optional, Number of items per page), cursor (optional, Cursor for pagination)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "team_id": {
              "type": "string",
              "title": "Team Id"
            },
            "page_size": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page Size",
              "default": null
            }
          },
          "required": [
            "team_id"
          ]
        }
      },
      {
        "name": "figma_get_team_styles",
        "description": "Get styles for a team. Args: team_id (required, The team ID), page_size (optional, Number of items per page), cursor (optional, Cursor for pagination)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "team_id": {
              "type": "string",
              "title": "Team Id"
            },
            "page_size": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page Size",
              "default": null
            }
          },
          "required": [
            "team_id"
          ]
        }
      },
      {
        "name": "figma_get_file_styles",
        "description": "Get styles from a file. Args: fileKey (required, The key of the file to get styles from)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "title": "Filekey"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_get_style",
        "description": "Get a style by key. Args: key (required, The style key)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "title": "Key"
            }
          },
          "required": [
            "key"
          ]
        }
      },
      {
        "name": "read_file_content",
        "description": "Read file content. Args: path (required, Path to the file to read), encoding (optional, File encoding)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "title": "Path"
            },
            "encoding": {
              "type": "string",
              "title": "Encoding",
              "default": "utf-8"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "write_file_content",
        "description": "Write content to a file. Args: path (required, Path to the file to write), content (required, Content to write), encoding (optional, File encoding), append (optional, Whether to append to the file)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "title": "Path"
            },
            "append": {
              "type": "boolean",
              "title": "Append",
              "default": false
            },
            "content": {
              "type": "string",
              "title": "Content"
            },
            "encoding": {
              "type": "string",
              "title": "Encoding",
              "default": "utf-8"
            }
          },
          "required": [
            "path",
            "content"
          ]
        }
      },
      {
        "name": "replace_in_file",
        "description": "Replace content in a file using regular expressions. Args: path (required, Path to the file), pattern (required, Regular expression pattern), replacement (required, Replacement string), encoding (optional, File encoding), count (optional, Maximum number of replacements)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "title": "Path"
            },
            "count": {
              "type": "integer",
              "title": "Count",
              "default": 0
            },
            "pattern": {
              "type": "string",
              "title": "Pattern"
            },
            "encoding": {
              "type": "string",
              "title": "Encoding",
              "default": "utf-8"
            },
            "replacement": {
              "type": "string",
              "title": "Replacement"
            }
          },
          "required": [
            "path",
            "pattern",
            "replacement"
          ]
        }
      },
      {
        "name": "list_directory",
        "description": "List directory contents with detailed information. Args: path (required, Directory path), recursive (optional, Whether to list recursively), max_depth (optional, Maximum recursion depth), include_hidden (optional, Whether to include hidden files)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "title": "Path"
            },
            "max_depth": {
              "type": "integer",
              "title": "Max Depth",
              "default": -1
            },
            "recursive": {
              "type": "boolean",
              "title": "Recursive",
              "default": false
            },
            "include_hidden": {
              "type": "boolean",
              "title": "Include Hidden",
              "default": false
            }
          },
          "required": [
            "path"
          ]
        }
      }
    ]
  },
  {
    "name": "alaturqua-mcp-trino-python",
    "title": "MCP Trino Server",
    "description": "A Model Context Protocol server that provides seamless integration with Trino and Iceberg, enabling data exploration, querying, and table maintenance through a standard interface.",
    "icon": "https://avatars.githubusercontent.com/alaturqua",
    "isOfficial": false,
    "homepage": "https://github.com/alaturqua/mcp-trino-python",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-trino-python"
      ],
      "env": {
        "TRINO_AUTH": "<trino-auth>",
        "TRINO_HOST": "<trino-host>",
        "TRINO_PORT": "<trino-port>",
        "TRINO_USER": "<trino-user>",
        "TRINO_SCHEMA": "<trino-schema>",
        "TRINO_CATALOG": "<trino-catalog>",
        "TRINO_HTTP_SCHEME": "<trino-http-scheme>"
      }
    },
    "parameters": [
      {
        "name": "TRINO_AUTH",
        "description": "Authentication method",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TRINO_HOST",
        "description": "Trino server hostname",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TRINO_PORT",
        "description": "Trino server port",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TRINO_USER",
        "description": "Trino username",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TRINO_SCHEMA",
        "description": "Default schema",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TRINO_CATALOG",
        "description": "Default catalog",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TRINO_HTTP_SCHEME",
        "description": "HTTP scheme (http/https)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "show_create_table",
        "description": "Show the CREATE TABLE statement for a specific table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table": {
              "type": "string",
              "title": "Table"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Schema",
              "default": null
            },
            "catalog": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Catalog",
              "default": null
            }
          },
          "required": [
            "table"
          ]
        }
      },
      {
        "name": "show_create_view",
        "description": "Show the CREATE VIEW statement for a specific view",
        "inputSchema": {
          "type": "object",
          "properties": {
            "view": {
              "type": "string",
              "title": "View"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Schema",
              "default": null
            },
            "catalog": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Catalog",
              "default": null
            }
          },
          "required": [
            "view"
          ]
        }
      },
      {
        "name": "execute_query",
        "description": "Execute a SQL query and return results in a readable format",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "optimize",
        "description": "Optimize an Iceberg table's data files",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table": {
              "type": "string",
              "title": "Table"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Schema",
              "default": null
            },
            "catalog": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Catalog",
              "default": null
            }
          },
          "required": [
            "table"
          ]
        }
      },
      {
        "name": "optimize_manifests",
        "description": "Optimize manifest files for an Iceberg table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table": {
              "type": "string",
              "title": "Table"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Schema",
              "default": null
            },
            "catalog": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Catalog",
              "default": null
            }
          },
          "required": [
            "table"
          ]
        }
      },
      {
        "name": "expire_snapshots",
        "description": "Remove old snapshots from an Iceberg table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table": {
              "type": "string",
              "title": "Table"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Schema",
              "default": null
            },
            "catalog": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Catalog",
              "default": null
            },
            "retention_threshold": {
              "type": "string",
              "title": "Retention Threshold",
              "default": "7d"
            }
          },
          "required": [
            "table"
          ]
        }
      },
      {
        "name": "show_stats",
        "description": "Show statistics for a table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table": {
              "type": "string",
              "title": "Table"
            },
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Schema",
              "default": null
            },
            "catalog": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Catalog",
              "default": null
            }
          },
          "required": [
            "table"
          ]
        }
      },
      {
        "name": "show_query_history",
        "description": "Get the history of executed queries",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Limit",
              "default": null
            }
          }
        }
      },
      {
        "name": "show_catalog_tree",
        "description": "Show a hierarchical tree view of catalogs, schemas, and tables",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "alexbakers-mcp-ipfs",
    "title": "mcp-ipfs",
    "description": "🪐 MCP IPFS Server\n\nThis server empowers language models 🤖 and other MCP clients to manage storacha.network spaces, upload/download data, manage delegations, and perform various other tasks by seamlessly wrapping w3 commands.",
    "icon": "https://avatars.githubusercontent.com/alexbakers",
    "isOfficial": false,
    "homepage": "https://github.com/alexbakers/mcp-ipfs",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-ipfs"
      ],
      "env": {
        "W3_LOGIN_EMAIL": "<w3-login-email>"
      }
    },
    "parameters": [
      {
        "name": "W3_LOGIN_EMAIL",
        "description": "The email address used for w3 login, must be the same as the one used for 'w3 login'",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "w3_account_ls",
        "description": "Lists all accounts the current agent is **authorized** for. Use this command after `w3_login` and email validation to confirm the agent is successfully linked to your storacha.network account(s). **Note:** Agent state may be ephemeral (e.g., in Docker). Check authorization status with this command after (re)connecting, and use `w3_login` if needed.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "w3_bridge_generate_tokens",
        "description": "Generates authentication tokens for using the UCAN-HTTP bridge.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "json": {
              "type": "boolean",
              "default": true,
              "description": "Output JSON suitable for fetch headers (default: true)."
            },
            "expiration": {
              "type": "integer",
              "description": "Unix timestamp (in seconds) for expiration. Zero means no expiration.",
              "exclusiveMinimum": 0
            },
            "capabilities": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "One or more capabilities to delegate (e.g., ['space/info'])."
            }
          },
          "required": [
            "capabilities"
          ]
        }
      },
      {
        "name": "w3_can_access_claim",
        "description": "Claims delegated capabilities for the authorized account using a provided proof.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "proof": {
              "type": "string",
              "description": "Delegation proof (e.g., path to CAR file or base64 CID string) containing capabilities to claim."
            }
          },
          "required": [
            "proof"
          ]
        }
      },
      {
        "name": "w3_can_blob_add",
        "description": "Stores a single file as a blob directly with the service. Requires ABSOLUTE paths for file arguments.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "ABSOLUTE path to the blob file to store."
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "w3_can_blob_ls",
        "description": "Lists blobs stored in the current space.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "json": {
              "type": "boolean",
              "default": true,
              "description": "Format output as newline delimited JSON (default: true)."
            },
            "size": {
              "type": "integer",
              "description": "Desired number of results to return.",
              "exclusiveMinimum": 0
            },
            "cursor": {
              "type": "string",
              "description": "Opaque cursor string from a previous response for pagination."
            }
          }
        }
      },
      {
        "name": "w3_can_blob_rm",
        "description": "Removes a blob from the store by its base58btc encoded multihash.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "multihash": {
              "type": "string",
              "description": "Base58btc encoded multihash of the blob to remove."
            }
          },
          "required": [
            "multihash"
          ]
        }
      },
      {
        "name": "w3_can_filecoin_info",
        "description": "Gets Filecoin deal information for a given Piece CID (advanced use).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pieceCid": {
              "type": "string",
              "description": "The Piece CID to get Filecoin information for."
            }
          },
          "required": [
            "pieceCid"
          ]
        }
      },
      {
        "name": "w3_can_index_add",
        "description": "Registers an index CID with the service (advanced use). Please refer to storacha.network documentation for details on indices.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cid": {
              "type": "string",
              "description": "CID of the index to add."
            }
          },
          "required": [
            "cid"
          ]
        }
      },
      {
        "name": "w3_can_store_add",
        "description": "Stores a CAR file with the service (advanced use). This is often a prerequisite for `w3_can_upload_add`. Requires ABSOLUTE paths for file arguments.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "ABSOLUTE path to the CAR file to store."
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "w3_can_store_ls",
        "description": "Lists stored CAR files (shards) in the current space (advanced use).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "json": {
              "type": "boolean",
              "default": true,
              "description": "Format output as newline delimited JSON (default: true)."
            },
            "size": {
              "type": "integer",
              "description": "Desired number of results to return.",
              "exclusiveMinimum": 0
            },
            "cursor": {
              "type": "string",
              "description": "Opaque cursor string from a previous response for pagination."
            }
          }
        }
      },
      {
        "name": "w3_can_store_rm",
        "description": "Removes a stored CAR shard by its CID (advanced use). Use with extreme caution, as this deletes the underlying data shard.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "carCid": {
              "type": "string",
              "description": "CID of the CAR shard to remove from the store."
            }
          },
          "required": [
            "carCid"
          ]
        }
      },
      {
        "name": "w3_can_upload_add",
        "description": "Manually registers an upload DAG by its root CID and shard CIDs (advanced use). This is typically used after storing CAR shards manually.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "rootCid": {
              "type": "string",
              "description": "Root data CID of the DAG to register."
            },
            "shardCids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "One or more shard CIDs where the DAG data is stored."
            }
          },
          "required": [
            "rootCid",
            "shardCids"
          ]
        }
      },
      {
        "name": "w3_can_upload_ls",
        "description": "Lists uploads registered in the current space (advanced view, shows underlying structure).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pre": {
              "type": "boolean",
              "default": false,
              "description": "Return the page of results preceding the cursor."
            },
            "json": {
              "type": "boolean",
              "default": true,
              "description": "Format output as newline delimited JSON (default: true)."
            },
            "size": {
              "type": "integer",
              "description": "Desired number of results to return.",
              "exclusiveMinimum": 0
            },
            "cursor": {
              "type": "string",
              "description": "Opaque cursor string from a previous response for pagination."
            },
            "shards": {
              "type": "boolean",
              "default": false,
              "description": "Pretty print with shards in output (ignored if --json is true)."
            }
          }
        }
      },
      {
        "name": "w3_can_upload_rm",
        "description": "Removes an upload listing by its root CID (advanced use). Does not remove the underlying blobs/shards.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "rootCid": {
              "type": "string",
              "description": "Root CID of the upload to remove from the list."
            }
          },
          "required": [
            "rootCid"
          ]
        }
      },
      {
        "name": "w3_coupon_create",
        "description": "Attempts to create/claim a coupon using a claim code.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "claimCode": {
              "type": "string",
              "description": "The claim code for the coupon."
            }
          },
          "required": [
            "claimCode"
          ]
        }
      },
      {
        "name": "w3_delegation_create",
        "description": "Tool for w3_delegation_create operation. Requires ABSOLUTE paths for file arguments.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Human-readable name for the audience."
            },
            "type": {
              "enum": [
                "device",
                "app",
                "service"
              ],
              "type": "string",
              "description": "Type of the audience."
            },
            "base64": {
              "type": "boolean",
              "default": false,
              "description": "Format output as base64 identity CID string instead of writing to a file."
            },
            "output": {
              "type": "string",
              "description": "ABSOLUTE path of file to write the exported delegation CAR file to."
            },
            "audienceDid": {
              "type": "string",
              "description": "The DID of the audience receiving the delegation (e.g., did:key:...)."
            },
            "capabilities": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "One or more capabilities to delegate (e.g., ['space/*', 'upload/*'])."
            }
          },
          "required": [
            "audienceDid",
            "capabilities"
          ]
        }
      },
      {
        "name": "w3_delegation_ls",
        "description": "Tool for w3_delegation_ls operation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "json": {
              "type": "boolean",
              "default": true,
              "description": "Format output as newline delimited JSON (default: true)."
            }
          }
        }
      },
      {
        "name": "w3_delegation_revoke",
        "description": "Tool for w3_delegation_revoke operation. Requires ABSOLUTE paths for file arguments.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "proof": {
              "type": "string",
              "description": "ABSOLUTE path to a file containing the delegation and any additional proofs needed."
            },
            "delegationCid": {
              "type": "string",
              "description": "The CID of the delegation to revoke."
            }
          },
          "required": [
            "delegationCid"
          ]
        }
      },
      {
        "name": "w3_key_create",
        "description": "Generates and prints a new ed25519 key pair. Does not automatically use it for the agent.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "json": {
              "type": "boolean",
              "default": false,
              "description": "Export the new key pair as dag-json (default: false)."
            }
          }
        }
      },
      {
        "name": "w3_login",
        "description": "Initiates the w3 login process using the pre-configured email (W3_LOGIN_EMAIL env var). IMPORTANT: The command expects email confirmation, so before running the `w3_login` tool, emphasize ATTENTION to the user in large letters + emoji that they MUST check email to complete authentication. If the final output includes 'Agent was authorized by', the user has already clicked the link and is successfully authorized, CONTINUE using mcp-ipfs tools. 'Too Many Requests': wait a moment before requesting it again.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "w3_ls",
        "description": "Tool for w3_ls operation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "json": {
              "type": "boolean",
              "default": true,
              "description": "Format output as newline delimited JSON (default: true)."
            }
          }
        }
      },
      {
        "name": "w3_open",
        "description": "Tool for w3_open operation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cid": {
              "type": "string",
              "description": "The CID of the content to open."
            },
            "path": {
              "type": "string",
              "description": "Optional path within the content to append to the URL."
            }
          },
          "required": [
            "cid"
          ]
        }
      },
      {
        "name": "w3_plan_get",
        "description": "Displays the plan associated with the current or specified account.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "accountId": {
              "type": "string",
              "description": "Optional account ID to get plan for (defaults to current authorized account)."
            }
          }
        }
      },
      {
        "name": "w3_proof_add",
        "description": "Tool for w3_proof_add operation. Requires ABSOLUTE paths for file arguments.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "proofPath": {
              "type": "string",
              "description": "ABSOLUTE path to the CAR encoded proof file delegated to this agent."
            }
          },
          "required": [
            "proofPath"
          ]
        }
      },
      {
        "name": "w3_proof_ls",
        "description": "Tool for w3_proof_ls operation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "json": {
              "type": "boolean",
              "default": true,
              "description": "Format output as newline delimited JSON (default: true)."
            }
          }
        }
      },
      {
        "name": "w3_reset",
        "description": "DANGEROUS: Resets the agent state, removing all proofs and delegations but retaining the agent DID. Requires explicit confirmation argument.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "confirmReset": {
              "type": "string",
              "const": "yes-i-am-sure",
              "description": "Must be exactly 'yes-i-am-sure' to confirm resetting agent state (removes proofs/delegations)."
            }
          },
          "required": [
            "confirmReset"
          ]
        }
      },
      {
        "name": "w3_rm",
        "description": "Tool for w3_rm operation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cid": {
              "type": "string",
              "description": "Root Content CID (e.g., bafy...) to remove from the uploads listing."
            },
            "removeShards": {
              "type": "boolean",
              "default": false,
              "description": "Also remove underlying shards from the store (default: false). Use with caution."
            }
          },
          "required": [
            "cid"
          ]
        }
      },
      {
        "name": "w3_space_add",
        "description": "Tool for w3_space_add operation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "proof": {
              "type": "string",
              "description": "Filesystem path to a CAR encoded UCAN proof, or a base64 identity CID string."
            }
          },
          "required": [
            "proof"
          ]
        }
      },
      {
        "name": "w3_space_create",
        "description": "Creates a new space with a user-friendly name. NOTE: `w3 space create` cannot be run via MCP due to interactive recovery key prompts. Please run this command manually in your terminal.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "An optional user-friendly name for the new space."
            }
          }
        }
      },
      {
        "name": "w3_space_info",
        "description": "Tool for w3_space_info operation. NOTE: `no current space and no space given` or `{\"spaces\":[]}` first make sure you are logged in before using other tools.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "json": {
              "type": "boolean",
              "default": true,
              "description": "Format output as newline delimited JSON (default: true)."
            },
            "spaceDid": {
              "type": "string",
              "pattern": "^did\\:key\\:",
              "description": "Optional DID of the space to get info for (defaults to current space)."
            }
          }
        }
      },
      {
        "name": "w3_space_ls",
        "description": "Tool for w3_space_ls operation. NOTE: `no current space and no space given` or `{\"spaces\":[]}` first make sure you are logged in before using other tools.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "w3_space_provision",
        "description": "Associates a space with a customer/billing account.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceDid": {
              "type": "string",
              "pattern": "^did\\:key\\:",
              "description": "The DID of the space to provision."
            },
            "customerId": {
              "type": "string",
              "description": "Customer identifier (e.g., email or account DID) to associate the space with."
            }
          },
          "required": [
            "customerId",
            "spaceDid"
          ]
        }
      },
      {
        "name": "w3_space_use",
        "description": "Tool for w3_space_use operation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceDid": {
              "type": "string",
              "pattern": "^did\\:key\\:",
              "description": "The DID of the space to select (e.g., did:key:...)."
            }
          },
          "required": [
            "spaceDid"
          ]
        }
      },
      {
        "name": "w3_up",
        "description": "Generates and prints a new ed25519 key pair. Does not automatically use it for the agent. Requires ABSOLUTE paths for file arguments.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "Array of one or more ABSOLUTE paths to files or directories to upload."
            },
            "hidden": {
              "type": "boolean",
              "default": false,
              "description": "Include paths starting with '.'."
            },
            "noWrap": {
              "type": "boolean",
              "default": false,
              "description": "Don't wrap input files with a directory."
            }
          },
          "required": [
            "paths"
          ]
        }
      },
      {
        "name": "w3_usage_report",
        "description": "Displays a storage usage report for the current or specified space.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "json": {
              "type": "boolean",
              "default": true,
              "description": "Format output as JSON (default: true)."
            },
            "spaceDid": {
              "type": "string",
              "pattern": "^did\\:key\\:",
              "description": "Optional DID of the space to get usage for (defaults to current space)."
            }
          }
        }
      }
    ]
  },
  {
    "name": "aliyun-alibabacloud-adb-mysql-mcp-server",
    "title": "Adb MySQL MCP Server",
    "description": "A universal interface that enables AI Agents to seamlessly communicate with Adb MySQL databases, allowing them to retrieve database metadata and execute SQL operations.",
    "icon": "https://avatars.githubusercontent.com/aliyun",
    "isOfficial": true,
    "homepage": "https://github.com/aliyun/alibabacloud-adb-mysql-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "adb-mysql-mcp-server"
      ],
      "env": {
        "ADB_MYSQL_HOST": "<adb-mysql-host>",
        "ADB_MYSQL_PORT": "<adb-mysql-port>",
        "ADB_MYSQL_USER": "<adb-mysql-user>",
        "ADB_MYSQL_DATABASE": "<adb-mysql-database>",
        "ADB_MYSQL_PASSWORD": "<adb-mysql-password>"
      }
    },
    "parameters": [
      {
        "name": "ADB_MYSQL_HOST",
        "description": "The Adb MySQL database host",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "ADB_MYSQL_PORT",
        "description": "The Adb MySQL database port",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "ADB_MYSQL_USER",
        "description": "The Adb MySQL database user",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "ADB_MYSQL_DATABASE",
        "description": "The Adb MySQL database name",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "ADB_MYSQL_PASSWORD",
        "description": "The Adb MySQL database password",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "execute_sql",
        "description": "Execute a SQL query in the Adb MySQL Cluster",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_query_plan",
        "description": "Get the query plan for a SQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to analyze"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_execution_plan",
        "description": "Get the actual execution plan with runtime statistics for a SQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to analyze"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "amidabuddha-unichat-mcp-server",
    "title": "Unichat MCP Server",
    "description": "Send requests to OpenAI, MistralAI, Anthropic, xAI, or Google AI using MCP protocol via tool or predefined prompts. Vendor API key required",
    "icon": "https://avatars.githubusercontent.com/amidabuddha",
    "isOfficial": false,
    "homepage": "https://github.com/amidabuddha/unichat-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "unichat-mcp-server"
      ],
      "env": {
        "UNICHAT_MODEL": "<unichat-model>",
        "UNICHAT_API_KEY": "<unichat-api-key>"
      }
    },
    "parameters": [
      {
        "name": "UNICHAT_MODEL",
        "description": "The Unichat model to use (e.g., gpt-4o-mini)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "UNICHAT_API_KEY",
        "description": "Your API key for the selected model's provider (OpenAI, MistralAI, Anthropic, xAI, Google AI or DeepSeek)",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "amidabuddha-unichat-ts-mcp-server",
    "title": "unichat-ts-mcp-server",
    "description": "Send requests to OpenAI, MistralAI, Anthropic, xAI, or Google AI using MCP protocol via tool or predefined prompts. Vendor API key required.\n\nBoth STDIO and SSE transport mechanisms are supported via arguments.",
    "icon": "https://avatars.githubusercontent.com/amidabuddha",
    "isOfficial": false,
    "homepage": "https://github.com/amidabuddha/unichat-ts-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "unichat-ts-mcp-server"
      ],
      "env": {
        "UNICHAT_MODEL": "<unichat-model>",
        "UNICHAT_API_KEY": "<unichat-api-key>"
      }
    },
    "parameters": [
      {
        "name": "UNICHAT_MODEL",
        "description": "Your preferred model name to be used by the Unichat MCP Server.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "UNICHAT_API_KEY",
        "description": "Your vendor API key required to send requests to OpenAI, MistralAI, Anthropic, xAI, or Google AI.",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "anaisbetts-mcp-youtube",
    "title": "YouTube MCP Server",
    "description": "Uses yt-dlp to download subtitles from YouTube and connects it to claude.ai via Model Context Protocol.",
    "icon": "https://avatars.githubusercontent.com/anaisbetts",
    "isOfficial": false,
    "homepage": "https://github.com/anaisbetts/mcp-youtube",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@anaisbetts/mcp-youtube"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "andybrandt-mcp-simple-arxiv",
    "title": "mcp-simple-arxiv",
    "description": "An MCP server that provides access to arXiv papers through their API.",
    "icon": "https://avatars.githubusercontent.com/andybrandt",
    "isOfficial": false,
    "homepage": "https://github.com/andybrandt/mcp-simple-arxiv",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-simple-arxiv"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "andybrandt-mcp-simple-openai-assistant",
    "title": "MCP Simple OpenAI Assistant",
    "description": "A simple MCP server for interacting with OpenAI assistants. This server allows other tools (like Claude Desktop) to create and interact with OpenAI assistants through the Model Context Protocol.",
    "icon": "https://avatars.githubusercontent.com/andybrandt",
    "isOfficial": false,
    "homepage": "https://github.com/andybrandt/mcp-simple-openai-assistant",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-simple-openai-assistant"
      ],
      "env": {
        "OPENAI_API_KEY": "<openai-api-key>"
      }
    },
    "parameters": [
      {
        "name": "OPENAI_API_KEY",
        "description": "Your OpenAI API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "andybrandt-mcp-simple-pubmed",
    "title": "mcp-simple-pubmed",
    "description": "An MCP server that provides access to PubMed articles through the Entrez API.",
    "icon": "https://avatars.githubusercontent.com/andybrandt",
    "isOfficial": false,
    "homepage": "https://github.com/andybrandt/mcp-simple-pubmed",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-simple-pubmed"
      ],
      "env": {
        "PUBMED_EMAIL": "<pubmed-email>",
        "PUBMED_API_KEY": "<pubmed-api-key>"
      }
    },
    "parameters": [
      {
        "name": "PUBMED_EMAIL",
        "description": "Your email address (required by NCBI)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "PUBMED_API_KEY",
        "description": "Optional API key for higher rate limits (10 requests/second instead of 3 requests/second)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "andybrandt-mcp-simple-timeserver",
    "title": "MCP Simple Timeserver",
    "description": "An MCP server that allows checking local time on the client machine or current UTC time from an NTP server",
    "icon": "https://avatars.githubusercontent.com/andybrandt",
    "isOfficial": false,
    "homepage": "https://github.com/andybrandt/mcp-simple-timeserver",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-simple-timeserver"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "angiejones-mcp-selenium",
    "title": "MCP Selenium",
    "description": "Enables browser automation using the Selenium WebDriver through MCP, supporting browser management, element location, and both basic and advanced user interactions.",
    "icon": "https://avatars.githubusercontent.com/angiejones",
    "isOfficial": false,
    "homepage": "https://github.com/angiejones/mcp-selenium",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@angiejones/mcp-selenium"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "anirbanbasu-frankfurtermcp",
    "title": "FrankfurterMCP",
    "description": "A MCP server for the Frankfurter API for currency exchange rates.",
    "icon": "https://avatars.githubusercontent.com/anirbanbasu",
    "isOfficial": false,
    "homepage": "https://github.com/anirbanbasu/frankfurtermcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "frankfurtermcp"
      ],
      "env": {
        "SSL_CERT_DIR": "<ssl-cert-dir>",
        "FAST_MCP_HOST": "<fast-mcp-host>",
        "FAST_MCP_PORT": "<fast-mcp-port>",
        "HTTPX_TIMEOUT": "<httpx-timeout>",
        "SSL_CERT_FILE": "<ssl-cert-file>",
        "HTTPX_VERIFY_SSL": "<httpx-verify-ssl>",
        "FRANKFURTER_API_URL": "<frankfurter-api-url>",
        "MCP_SERVER_TRANSPORT": "<mcp-server-transport>",
        "MCP_SERVER_INCLUDE_METADATA_IN_RESPONSE": "<mcp-server-include-metadata-in-response>"
      }
    },
    "parameters": [
      {
        "name": "SSL_CERT_DIR",
        "description": "Path to SSL certificate directory for self-signed certificates.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "FAST_MCP_HOST",
        "description": "This variable specifies which host the MCP server must bind to unless the server transport is set to stdio.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "FAST_MCP_PORT",
        "description": "This variable specifies which port the MCP server must listen on unless the server transport is set to stdio.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "HTTPX_TIMEOUT",
        "description": "The time for the underlying HTTP client to wait, in seconds, for a response.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "SSL_CERT_FILE",
        "description": "Path to SSL certificate file for self-signed certificates.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "HTTPX_VERIFY_SSL",
        "description": "This variable can be set to False to turn off SSL certificate verification. Setting this to False is advised against: instead, use the SSL_CERT_FILE and SSL_CERT_DIR variables.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "FRANKFURTER_API_URL",
        "description": "If you are self-hosting the Frankfurter API, you should change this to the API endpoint address of your deployment.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_SERVER_TRANSPORT",
        "description": "The acceptable options are stdio, sse or streamable-http.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_SERVER_INCLUDE_METADATA_IN_RESPONSE",
        "description": "An experimental feature to include additional metadata to the MCP type TextContent that wraps the response data from each tool call.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get_supported_currencies",
        "description": "Returns a list of three-letter currency codes for the supported currencies.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_latest_exchange_rates",
        "description": "Returns the latest exchange rates for specific currencies. The\nsymbols can be used to filter the results to specific currencies.\nIf symbols is not provided, all supported currencies will be returned.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Symbols",
              "default": null,
              "description": "A list of target currency codes for which rates against the base currency will be provided. If not provided, all supported currencies will be shown."
            },
            "base_currency": {
              "type": "string",
              "title": "Base Currency",
              "description": "A base currency code for which rates are to be requested."
            }
          },
          "required": [
            "base_currency"
          ]
        }
      },
      {
        "name": "convert_currency_latest",
        "description": "Converts an amount from one currency to another using the latest exchange rates.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "amount": {
              "type": "number",
              "title": "Amount",
              "description": "The amount in the source currency to convert."
            },
            "to_currency": {
              "type": "string",
              "title": "To Currency",
              "description": "The target currency code."
            },
            "from_currency": {
              "type": "string",
              "title": "From Currency",
              "description": "The source currency code."
            }
          },
          "required": [
            "amount",
            "from_currency",
            "to_currency"
          ]
        }
      },
      {
        "name": "get_historical_exchange_rates",
        "description": "Returns historical exchange rates for a specific date or date range.\nIf the exchange rates for a specified date is not available, the rates available for\nthe closest date before the specified date will be provided.\nEither a specific date, a start date, or a date range must be provided.\nThe symbols can be used to filter the results to specific currencies.\nIf symbols are not provided, all supported currencies will be returned.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Symbols",
              "default": null,
              "description": "A list of target currency codes for which rates against the base currency will be provided. If not provided, all supported currencies will be shown."
            },
            "end_date": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date"
                },
                {
                  "type": "null"
                }
              ],
              "title": "End Date",
              "default": null,
              "description": "The end date, of a date range, for which the historical rates are requested in the YYYY-MM-DD format."
            },
            "start_date": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Start Date",
              "default": null,
              "description": "The start date, of a date range, for which the historical rates are requested in the YYYY-MM-DD format."
            },
            "base_currency": {
              "type": "string",
              "title": "Base Currency",
              "description": "A base currency code for which rates are to be requested."
            },
            "specific_date": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Specific Date",
              "default": null,
              "description": "The specific date for which the historical rates are requested in the YYYY-MM-DD format."
            }
          },
          "required": [
            "base_currency"
          ]
        }
      },
      {
        "name": "convert_currency_specific_date",
        "description": "Convert an amount from one currency to another using the exchange rates for a specific date.\nIf there is no exchange rate available for the specific date, the rate for the closest available date before\nthe specified date will be used.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "amount": {
              "type": "number",
              "title": "Amount",
              "description": "The amount in the source currency to convert."
            },
            "to_currency": {
              "type": "string",
              "title": "To Currency",
              "description": "The target currency code."
            },
            "from_currency": {
              "type": "string",
              "title": "From Currency",
              "description": "The source currency code."
            },
            "specific_date": {
              "type": "string",
              "title": "Specific Date",
              "format": "date",
              "description": "The specific date for which the conversion is requested in the YYYY-MM-DD format."
            }
          },
          "required": [
            "amount",
            "from_currency",
            "to_currency",
            "specific_date"
          ]
        }
      }
    ]
  },
  {
    "name": "anpigon-mcp-server-obsidian-omnisearch",
    "title": "Obsidian Omnisearch MCP Server",
    "description": "Provides programmatic search functionality for Obsidian vaults through a REST API interface, allowing external applications to search through notes and retrieve absolute paths to matching documents.",
    "icon": "https://avatars.githubusercontent.com/anpigon",
    "isOfficial": false,
    "homepage": "https://github.com/anpigon/mcp-server-obsidian-omnisearch",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-obsidian-omnisearch"
      ],
      "env": {
        "OBSIDIAN_VAULT_PATH": "<obsidian-vault-path>"
      }
    },
    "parameters": [
      {
        "name": "OBSIDIAN_VAULT_PATH",
        "description": "Absolute path to your Obsidian vault",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "obsidian_notes_search",
        "description": "Search Obsidian(옵시디언) notes and return absolute paths to the matching notes.\n        The returned paths can be used with the read_note tool to view the note contents.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "read_note",
        "description": "Read and return the contents of an Obsidian note file.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            }
          },
          "required": [
            "filepath"
          ]
        }
      }
    ]
  },
  {
    "name": "antvis-mcp-server-chart",
    "title": "MCP Server Chart",
    "description": "mcp-server-chart",
    "icon": "https://avatars.githubusercontent.com/antvis",
    "isOfficial": true,
    "homepage": "https://github.com/antvis/mcp-server-chart",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@antv/mcp-server-chart"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "generate_area_chart",
        "description": "Generate a area chart to show data trends under continuous independent variables and observe the overall data trend, such as, displacement = velocity (average or instantaneous) × time: s = v × t. If the x-axis is time (t) and the y-axis is velocity (v) at each moment, an area chart allows you to observe the trend of velocity over time and infer the distance traveled by the area's size.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "time",
                  "value"
                ],
                "properties": {
                  "time": {
                    "type": "string"
                  },
                  "group": {
                    "type": "string"
                  },
                  "value": {
                    "type": "number"
                  }
                }
              },
              "minItems": 1,
              "description": "Data for area chart, such as, [{ time: '2018', value: 99.9 }]."
            },
            "stack": {
              "type": "boolean",
              "default": false,
              "description": "Whether stacking is enabled. When enabled, area charts require a 'group' field in the data."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "axisXTitle": {
              "type": "string",
              "default": "",
              "description": "Set the x-axis title of chart."
            },
            "axisYTitle": {
              "type": "string",
              "default": "",
              "description": "Set the y-axis title of chart."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_bar_chart",
        "description": "Generate a bar chart to show data for numerical comparisons among different categories, such as, comparing categorical data and for horizontal comparisons.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "category",
                  "value"
                ],
                "properties": {
                  "group": {
                    "type": "string"
                  },
                  "value": {
                    "type": "number"
                  },
                  "category": {
                    "type": "string"
                  }
                }
              },
              "minItems": 1,
              "description": "Data for bar chart, such as, [{ category: '分类一', value: 10 }]."
            },
            "group": {
              "type": "boolean",
              "default": false,
              "description": "Whether grouping is enabled. When enabled, bar charts require a 'group' field in the data. When `group` is true, `stack` should be false."
            },
            "stack": {
              "type": "boolean",
              "default": true,
              "description": "Whether stacking is enabled. When enabled, bar charts require a 'group' field in the data. When `stack` is true, `group` should be false."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "axisXTitle": {
              "type": "string",
              "default": "",
              "description": "Set the x-axis title of chart."
            },
            "axisYTitle": {
              "type": "string",
              "default": "",
              "description": "Set the y-axis title of chart."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_boxplot_chart",
        "description": "Generate a boxplot chart to show data for statistical summaries among different categories, such as, comparing the distribution of data points across categories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "category",
                  "value"
                ],
                "properties": {
                  "group": {
                    "type": "string",
                    "description": "Optional group for the data point, used for grouping in the boxplot."
                  },
                  "value": {
                    "type": "number",
                    "description": "Value of the data point, such as 10."
                  },
                  "category": {
                    "type": "string",
                    "description": "Category of the data point, such as '分类一'."
                  }
                }
              },
              "minItems": 1,
              "description": "Data for boxplot chart, such as, [{ category: '分类一', value: 10 }] or [{ category: '分类二', value: 20, group: '组别一' }]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "axisXTitle": {
              "type": "string",
              "default": "",
              "description": "Set the x-axis title of chart."
            },
            "axisYTitle": {
              "type": "string",
              "default": "",
              "description": "Set the y-axis title of chart."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_column_chart",
        "description": "Generate a column chart, which are best for comparing categorical data, such as, when values are close, column charts are preferable because our eyes are better at judging height than other visual elements like area or angles.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "category",
                  "value"
                ],
                "properties": {
                  "group": {
                    "type": "string"
                  },
                  "value": {
                    "type": "number"
                  },
                  "category": {
                    "type": "string"
                  }
                }
              },
              "minItems": 1,
              "description": "Data for column chart, such as, [{ category: '北京', value: 825, group: '油车' }]."
            },
            "group": {
              "type": "boolean",
              "default": true,
              "description": "Whether grouping is enabled. When enabled, column charts require a 'group' field in the data. When `group` is true, `stack` should be false."
            },
            "stack": {
              "type": "boolean",
              "default": false,
              "description": "Whether stacking is enabled. When enabled, column charts require a 'group' field in the data. When `stack` is true, `group` should be false."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "axisXTitle": {
              "type": "string",
              "default": "",
              "description": "Set the x-axis title of chart."
            },
            "axisYTitle": {
              "type": "string",
              "default": "",
              "description": "Set the y-axis title of chart."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_district_map",
        "description": "Generates regional distribution maps, which are usually used to show the administrative divisions and coverage of a dataset. It is not suitable for showing the distribution of specific locations, such as urban administrative divisions, GDP distribution maps of provinces and cities across the country, etc. This tool is limited to generating data maps within China.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Keywords for the Chinese name of an administrative region (must be within China), and must be one of China, province, city, district, or county. The name should be more specific and add attributive descriptions, for example, \"西安市\" is better than \"西安\", \"杭州西湖区\" is better than \"西湖区\". It cannot be a specific place name or a vague name, such as \"其它\"."
                },
                "style": {
                  "type": "object",
                  "properties": {
                    "fillColor": {
                      "type": "string",
                      "description": "Fill color, rgb or rgba format."
                    }
                  },
                  "description": "Style settings."
                },
                "colors": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "default": [
                    "#1783FF",
                    "#00C9C9",
                    "#F0884D",
                    "#D580FF",
                    "#7863FF",
                    "#60C42D",
                    "#BD8F24",
                    "#FF80CA",
                    "#2491B3",
                    "#17C76F"
                  ],
                  "description": "Data color list, in rgb or rgba format."
                },
                "dataType": {
                  "enum": [
                    "number",
                    "enum"
                  ],
                  "type": "string",
                  "description": "The type of the data value, numeric or enumeration type"
                },
                "dataLabel": {
                  "type": "string",
                  "description": "Data label, such as \"GDP\""
                },
                "dataValue": {
                  "type": "string",
                  "description": "Data value, numeric string or enumeration string."
                },
                "subdistricts": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "name": {
                        "$ref": "#/properties/data/properties/name"
                      },
                      "style": {
                        "$ref": "#/properties/data/properties/style"
                      },
                      "dataValue": {
                        "type": "string",
                        "description": "Data value, numeric string or enumeration string."
                      }
                    }
                  },
                  "description": "Sub-administrative regions are used to display the regional composition or regional distribution of related data."
                },
                "dataValueUnit": {
                  "type": "string",
                  "description": "Data unit, such as \"万亿\""
                },
                "showAllSubdistricts": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to display all subdistricts."
                }
              },
              "description": "Administrative division data, lower-level administrative divisions are optional. There are usually two scenarios: one is to simply display the regional composition, only `fillColor` needs to be configured, and all administrative divisions are consistent, representing that all blocks are connected as one; the other is the regional data distribution scenario, first determine the `dataType`, `dataValueUnit` and `dataLabel` configurations, `dataValue` should be a meaningful value and consistent with the meaning of dataType, and then determine the style configuration. The `fillColor` configuration represents the default fill color for areas without data. Lower-level administrative divisions do not need `fillColor` configuration, and their fill colors are determined by the `colors` configuration (If `dataType` is \"number\", only one base color (warm color) is needed in the list to calculate the continuous data mapping color band; if `dataType` is \"enum\", the number of color values in the list is equal to the number of enumeration values (contrast colors)). If `subdistricts` has a value, `showAllSubdistricts` must be set to true. For example, {\"title\": \"陕西省地级市分布图\", \"data\": {\"name\": \"陕西省\", \"showAllSubdistricts\": true, \"dataLabel\": \"城市\", \"dataType\": \"enum\", \"colors\": [\"#4ECDC4\", \"#A5D8FF\"], \"subdistricts\": [{\"name\": \"西安市\", \"dataValue\": \"省会\"}, {\"name\": \"宝鸡市\", \"dataValue\": \"地级市\"}, {\"name\": \"咸阳市\", \"dataValue\": \"地级市\"}, {\"name\": \"铜川市\", \"dataValue\": \"地级市\"}, {\"name\": \"渭南市\", \"dataValue\": \"地级市\"}, {\"name\": \"延安市\", \"dataValue\": \"地级市\"}, {\"name\": \"榆林市\", \"dataValue\": \"地级市\"}, {\"name\": \"汉中市\", \"dataValue\": \"地级市\"}, {\"name\": \"安康市\", \"dataValue\": \"地级市\"}, {\"name\": \"商洛市\", \"dataValue\": \"地级市\"}]}, \"width\": 1000, \"height\": 1000}."
            },
            "title": {
              "type": "string",
              "description": "The map title should not exceed 16 characters. The content should be consistent with the information the map wants to convey and should be accurate, rich, creative, and attractive."
            },
            "width": {
              "type": "number",
              "default": 1600,
              "description": "Set the width of map, default is 1600."
            },
            "height": {
              "type": "number",
              "default": 1000,
              "description": "Set the height of map, default is 1000."
            }
          },
          "required": [
            "title",
            "data"
          ]
        }
      },
      {
        "name": "generate_dual_axes_chart",
        "description": "Generate a dual axes chart which is a combination chart that integrates two different chart types, typically combining a bar chart with a line chart to display both the trend and comparison of data, such as, the trend of sales and profit over time.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "series": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "type",
                  "data"
                ],
                "properties": {
                  "data": {
                    "type": "array",
                    "items": {
                      "type": "number"
                    },
                    "description": "When type is column, the data represents quantities, such as [91.9, 99.1, 101.6, 114.4, 121]. When type is line, the data represents ratios and its values are recommended to be less than 1, such as [0.055, 0.06, 0.062, 0.07, 0.075]."
                  },
                  "type": {
                    "enum": [
                      "column",
                      "line"
                    ],
                    "type": "string",
                    "description": "The optional value can be 'column' or 'line'."
                  },
                  "axisYTitle": {
                    "type": "string",
                    "default": "",
                    "description": "Set the y-axis title of the chart series, such as, axisYTitle: '销售额'."
                  }
                }
              },
              "minItems": 1,
              "description": "Series for dual axes chart, such as, [{ type: 'column', data: [91.9, 99.1, 101.6, 114.4, 121], axisYTitle: '销售额' }, { type: 'line', data: [0.055, 0.06, 0.062, 0.07, 0.075], 'axisYTitle': '利润率' }]."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "axisXTitle": {
              "type": "string",
              "default": "",
              "description": "Set the x-axis title of chart."
            },
            "categories": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "Categories for dual axes chart, such as, ['2015', '2016', '2017']."
            }
          },
          "required": [
            "categories",
            "series"
          ]
        }
      },
      {
        "name": "generate_fishbone_diagram",
        "description": "Generate a fishbone diagram chart to uses a fish skeleton, like structure to display the causes or effects of a core problem, with the problem as the fish head and the causes/effects as the fish bones. It suits problems that can be split into multiple related factors.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "type": "string"
                },
                "children": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "children": {
                        "type": "array",
                        "items": {
                          "$ref": "#/properties/data/properties/children/items"
                        }
                      }
                    }
                  }
                }
              },
              "description": "Data for fishbone diagram chart, such as, { name: 'main topic', children: [{ name: 'topic 1', children: [{ name: 'subtopic 1-1' }] }."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_flow_diagram",
        "description": "Generate a flow diagram chart to show the steps and decision points of a process or system, such as, scenarios requiring linear process presentation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "nodes",
                "edges"
              ],
              "properties": {
                "edges": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "source",
                      "target"
                    ],
                    "properties": {
                      "name": {
                        "type": "string",
                        "default": ""
                      },
                      "source": {
                        "type": "string"
                      },
                      "target": {
                        "type": "string"
                      }
                    }
                  }
                },
                "nodes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      }
                    }
                  },
                  "minItems": 1
                }
              },
              "description": "Data for flow diagram chart, such as, { nodes: [{ name: 'node1' }, { name: 'node2' }], edges: [{ source: 'node1', target: 'node2', name: 'edge1' }] }."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_funnel_chart",
        "description": "Generate a funnel chart to visualize the progressive reduction of data as it passes through stages, such as, the conversion rates of users from visiting a website to completing a purchase.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "category",
                  "value"
                ],
                "properties": {
                  "value": {
                    "type": "number"
                  },
                  "category": {
                    "type": "string"
                  }
                }
              },
              "minItems": 1,
              "description": "Data for funnel chart, such as, [{ category: '浏览网站', value: 50000 }, { category: '放入购物车', value: 35000 }, { category: '生成订单', value: 25000 }, { category: '支付订单', value: 15000 }, { category: '完成交易', value: 8000 }]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_histogram_chart",
        "description": "Generate a histogram chart to show the frequency of data points within a certain range. It can observe data distribution, such as, normal and skewed distributions, and identify data concentration areas and extreme points.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "minItems": 1,
              "description": "Data for histogram chart, such as, [78, 88, 60, 100, 95]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "binNumber": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "not": {}
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Number of intervals to define the number of intervals in a histogram."
            },
            "axisXTitle": {
              "type": "string",
              "default": "",
              "description": "Set the x-axis title of chart."
            },
            "axisYTitle": {
              "type": "string",
              "default": "",
              "description": "Set the y-axis title of chart."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_line_chart",
        "description": "Generate a line chart to show trends over time, such as, the ratio of Apple computer sales to Apple's profits changed from 2000 to 2016.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "time",
                  "value"
                ],
                "properties": {
                  "time": {
                    "type": "string"
                  },
                  "value": {
                    "type": "number"
                  }
                }
              },
              "minItems": 1,
              "description": "Data for line chart, such as, [{ time: '2015', value: 23 }]."
            },
            "stack": {
              "type": "boolean",
              "default": false,
              "description": "Whether stacking is enabled. When enabled, line charts require a 'group' field in the data."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "axisXTitle": {
              "type": "string",
              "default": "",
              "description": "Set the x-axis title of chart."
            },
            "axisYTitle": {
              "type": "string",
              "default": "",
              "description": "Set the y-axis title of chart."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_liquid_chart",
        "description": "Generate a liquid chart to visualize a single value as a percentage, such as, the current occupancy rate of a reservoir or the completion percentage of a project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "shape": {
              "enum": [
                "circle",
                "rect",
                "pin",
                "triangle"
              ],
              "type": "string",
              "default": "circle",
              "description": "The shape of the liquid chart, can be 'circle', 'rect', 'pin', or 'triangle'. Default is 'circle'."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "percent": {
              "type": "number",
              "maximum": 1,
              "minimum": 0,
              "description": "The percentage value to display in the liquid chart, should be a number between 0 and 1, where 1 represents 100%. For example, 0.75 represents 75%."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "percent"
          ]
        }
      },
      {
        "name": "generate_mind_map",
        "description": "Generate a mind map chart to organizes and presents information in a hierarchical structure with branches radiating from a central topic, such as, a diagram showing the relationship between a main topic and its subtopics.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "type": "string"
                },
                "children": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "children": {
                        "type": "array",
                        "items": {
                          "$ref": "#/properties/data/properties/children/items"
                        }
                      }
                    }
                  }
                }
              },
              "description": "Data for mind map chart, such as, { name: 'main topic', children: [{ name: 'topic 1', children: [{ name:'subtopic 1-1' }] }."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_network_graph",
        "description": "Generate a network graph chart to show relationships (edges) between entities (nodes), such as, relationships between people in social networks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "nodes",
                "edges"
              ],
              "properties": {
                "edges": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "source",
                      "target"
                    ],
                    "properties": {
                      "name": {
                        "type": "string",
                        "default": ""
                      },
                      "source": {
                        "type": "string"
                      },
                      "target": {
                        "type": "string"
                      }
                    }
                  }
                },
                "nodes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      }
                    }
                  },
                  "minItems": 1
                }
              },
              "description": "Data for network graph chart, such as, { nodes: [{ name: 'node1' }, { name: 'node2' }], edges: [{ source: 'node1', target: 'node2', name: 'edge1' }] }"
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_organization_chart",
        "description": "Generate an organization chart to visualize the hierarchical structure of an organization, such as, a diagram showing the relationship between a CEO and their direct reports.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "type": "string"
                },
                "children": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "name": {
                        "type": "string"
                      },
                      "children": {
                        "type": "array",
                        "items": {
                          "$ref": "#/properties/data/properties/children/items"
                        }
                      },
                      "description": {
                        "type": "string"
                      }
                    }
                  }
                },
                "description": {
                  "type": "string"
                }
              },
              "description": "Data for organization chart, such as, { name: 'CEO', description: 'Chief Executive Officer', children: [{ name: 'CTO', description: 'Chief Technology Officer', children: [{ name: 'Dev Manager', description: 'Development Manager' }] }] }."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "orient": {
              "enum": [
                "horizontal",
                "vertical"
              ],
              "type": "string",
              "default": "vertical",
              "description": "Orientation of the organization chart, either horizontal or vertical. Default is vertical, when the level of the chart is more than 3, it is recommended to use horizontal orientation."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_path_map",
        "description": "Generate a route map to display the user's planned route, such as travel guide routes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "data"
                ],
                "properties": {
                  "data": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "minItems": 1,
                    "description": "A list of keywords for the names of points of interest (POIs) in Chinese. These POIs usually contain a group of places with similar locations, so the names should be more descriptive, must adding attributives to indicate that they are different places in the same area, such as \"北京市\" is better than \"北京\", \"杭州西湖\" is better than \"西湖\"; in addition, if you can determine that a location may appear in multiple areas, you can be more specific, such as \"杭州西湖的苏堤春晓\" is better than \"苏堤春晓\". The tool will use these keywords to search for specific POIs and query their detailed data, such as latitude and longitude, location photos, etc. For example, [\"西安钟楼\", \"西安大唐不夜城\", \"西安大雁塔\"]."
                  }
                },
                "description": "The route and places along it."
              },
              "minItems": 1,
              "description": "Routes, each group represents all POIs along a route. For example, [{ \"data\": [\"西安钟楼\", \"西安大唐不夜城\", \"西安大雁塔\"] }, { \"data\": [\"西安曲江池公园\", \"西安回民街\"] }]"
            },
            "title": {
              "type": "string",
              "description": "The map title should not exceed 16 characters. The content should be consistent with the information the map wants to convey and should be accurate, rich, creative, and attractive."
            },
            "width": {
              "type": "number",
              "default": 1600,
              "description": "Set the width of map, default is 1600."
            },
            "height": {
              "type": "number",
              "default": 1000,
              "description": "Set the height of map, default is 1000."
            }
          },
          "required": [
            "title",
            "data"
          ]
        }
      },
      {
        "name": "generate_pie_chart",
        "description": "Generate a pie chart to show the proportion of parts, such as, market share and budget allocation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "category",
                  "value"
                ],
                "properties": {
                  "value": {
                    "type": "number"
                  },
                  "category": {
                    "type": "string"
                  }
                }
              },
              "minItems": 1,
              "description": "Data for pie chart, such as, [{ category: '分类一', value: 27 }]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "innerRadius": {
              "type": "number",
              "default": 0,
              "description": "Set the innerRadius of pie chart, the value between 0 and 1. Set the pie chart as a donut chart. Set the value to 0.6 or number in [0 ,1] to enable it."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_pin_map",
        "description": "Generate a point map to display the location and distribution of point data on the map, such as the location distribution of attractions, hospitals, supermarkets, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "A list of keywords for the names of points of interest (POIs) in Chinese. These POIs usually contain a group of places with similar locations, so the names should be more descriptive, must adding attributives to indicate that they are different places in the same area, such as \"北京市\" is better than \"北京\", \"杭州西湖\" is better than \"西湖\"; in addition, if you can determine that a location may appear in multiple areas, you can be more specific, such as \"杭州西湖的苏堤春晓\" is better than \"苏堤春晓\". The tool will use these keywords to search for specific POIs and query their detailed data, such as latitude and longitude, location photos, etc. For example, [\"西安钟楼\", \"西安大唐不夜城\", \"西安大雁塔\"]."
            },
            "title": {
              "type": "string",
              "description": "The map title should not exceed 16 characters. The content should be consistent with the information the map wants to convey and should be accurate, rich, creative, and attractive."
            },
            "width": {
              "type": "number",
              "default": 1600,
              "description": "Set the width of map, default is 1600."
            },
            "height": {
              "type": "number",
              "default": 1000,
              "description": "Set the height of map, default is 1000."
            },
            "markerPopup": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "default": "image",
                  "description": "Must be \"image\"."
                },
                "width": {
                  "type": "number",
                  "default": 40,
                  "description": "Width of the photo."
                },
                "height": {
                  "type": "number",
                  "default": 40,
                  "description": "Height of the photo."
                },
                "borderRadius": {
                  "type": "number",
                  "default": 8,
                  "description": "Border radius of the photo."
                }
              },
              "description": "Marker type, one is simple mode, which is just an icon and does not require `markerPopup` configuration; the other is image mode, which displays location photos and requires `markerPopup` configuration. Among them, `width`/`height`/`borderRadius` can be combined to realize rectangular photos and square photos. In addition, when `borderRadius` is half of the width and height, it can also be a circular photo."
            }
          },
          "required": [
            "title",
            "data"
          ]
        }
      },
      {
        "name": "generate_radar_chart",
        "description": "Generate a radar chart to display multidimensional data (four dimensions or more), such as, evaluate Huawei and Apple phones in terms of five dimensions: ease of use, functionality, camera, benchmark scores, and battery life.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "name",
                  "value"
                ],
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "group": {
                    "type": "string"
                  },
                  "value": {
                    "type": "number"
                  }
                }
              },
              "minItems": 1,
              "description": "Data for radar chart, such as, [{ name: 'Design', value: 70 }]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_sankey_chart",
        "description": "Generate a sankey chart to visualize the flow of data between different stages or categories, such as, the user journey from landing on a page to completing a purchase.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "source",
                  "target",
                  "value"
                ],
                "properties": {
                  "value": {
                    "type": "number"
                  },
                  "source": {
                    "type": "string"
                  },
                  "target": {
                    "type": "string"
                  }
                }
              },
              "minItems": 1,
              "description": "Date for sankey chart, such as, [{ source: 'Landing Page', target: 'Product Page', value: 50000 }, { source: 'Product Page', target: 'Add to Cart', value: 35000 }, { source: 'Add to Cart', target: 'Checkout', value: 25000 }, { source: 'Checkout', target: 'Payment', value: 15000 }, { source: 'Payment', target: 'Purchase Completed', value: 8000 }]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "nodeAlign": {
              "enum": [
                "left",
                "right",
                "justify",
                "center"
              ],
              "type": "string",
              "default": "center",
              "description": "Alignment of nodes in the sankey chart, such as, 'left', 'right', 'justify', or 'center'."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_scatter_chart",
        "description": "Generate a scatter chart to show the relationship between two variables, helps discover their relationship or trends, such as, the strength of correlation, data distribution patterns.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "x",
                  "y"
                ],
                "properties": {
                  "x": {
                    "type": "number"
                  },
                  "y": {
                    "type": "number"
                  }
                }
              },
              "minItems": 1,
              "description": "Data for scatter chart, such as, [{ x: 10, y: 15 }]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "axisXTitle": {
              "type": "string",
              "default": "",
              "description": "Set the x-axis title of chart."
            },
            "axisYTitle": {
              "type": "string",
              "default": "",
              "description": "Set the y-axis title of chart."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_treemap_chart",
        "description": "Generate a treemap chart to display hierarchical data and can intuitively show comparisons between items at the same level, such as, show disk space usage with treemap.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "name",
                  "value"
                ],
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "value": {
                    "type": "number"
                  },
                  "children": {
                    "type": "array",
                    "items": {
                      "$ref": "#/properties/data/items"
                    }
                  }
                }
              },
              "minItems": 1,
              "description": "Data for treemap chart, such as, [{ name: 'Design', value: 70, children: [{ name: 'Tech', value: 20 }] }]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_venn_chart",
        "description": "Generate a Venn diagram to visualize the relationships between different sets, showing how they intersect and overlap, such as the commonalities and differences between various groups.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "value",
                  "sets"
                ],
                "properties": {
                  "sets": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "Array of set names that this segment belongs to, such as ['A', 'B'] for an intersection between sets A and B."
                  },
                  "label": {
                    "type": "string",
                    "description": "Label for the venn chart segment, such as 'A', 'B', or 'C'."
                  },
                  "value": {
                    "type": "number",
                    "description": "Value for the venn chart segment, such as 10, 20, or 30."
                  }
                }
              },
              "minItems": 1,
              "description": "Data for venn chart, such as, [{ label: 'A', value: 10, sets: ['A'] }, { label: 'B', value: 20, sets: ['B'] }, { label: 'C', value: 30, sets: ['C'] }, { label: 'AB', value: 5, sets: ['A', 'B'] }]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_violin_chart",
        "description": "Generate a violin chart to show data for statistical summaries among different categories, such as, comparing the distribution of data points across categories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "category",
                  "value"
                ],
                "properties": {
                  "group": {
                    "type": "string",
                    "description": "Optional group for the data point, used for grouping in the violin chart."
                  },
                  "value": {
                    "type": "number",
                    "description": "Value of the data point, such as 10."
                  },
                  "category": {
                    "type": "string",
                    "description": "Category of the data point, such as '分类一'."
                  }
                }
              },
              "minItems": 1,
              "description": "Data for violin chart, such as, [{ category: '分类一', value: 10 }] or [{ category: '分类二', value: 20, group: '组别一' }]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            },
            "axisXTitle": {
              "type": "string",
              "default": "",
              "description": "Set the x-axis title of chart."
            },
            "axisYTitle": {
              "type": "string",
              "default": "",
              "description": "Set the y-axis title of chart."
            }
          },
          "required": [
            "data"
          ]
        }
      },
      {
        "name": "generate_word_cloud_chart",
        "description": "Generate a word cloud chart to show word frequency or weight through text size variation, such as, analyzing common words in social media, reviews, or feedback.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "text",
                  "value"
                ],
                "properties": {
                  "text": {
                    "type": "string"
                  },
                  "value": {
                    "type": "number"
                  }
                }
              },
              "minItems": 1,
              "description": "Data for word cloud chart, such as, [{ value: 4.272, text: '形成' }]."
            },
            "theme": {
              "enum": [
                "default",
                "academy"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the theme for the chart, optional, default is 'default'."
            },
            "title": {
              "type": "string",
              "default": "",
              "description": "Set the title of chart."
            },
            "width": {
              "type": "number",
              "default": 600,
              "description": "Set the width of chart, default is 600."
            },
            "height": {
              "type": "number",
              "default": 400,
              "description": "Set the height of chart, default is 400."
            },
            "texture": {
              "enum": [
                "default",
                "rough"
              ],
              "type": "string",
              "default": "default",
              "description": "Set the texture for the chart, optional, default is 'default'. 'rough' refers to hand-drawn style."
            }
          },
          "required": [
            "data"
          ]
        }
      }
    ]
  },
  {
    "name": "api7-apisix-mcp",
    "title": "APISIX-MCP",
    "description": "The APISIX Model Context Protocol (MCP) server bridges large language models (LLMs) with the APISIX Admin API.",
    "icon": "https://avatars.githubusercontent.com/api7",
    "isOfficial": false,
    "homepage": "https://github.com/api7/apisix-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "apisix-mcp"
      ],
      "env": {
        "APISIX_ADMIN_KEY": "<apisix-admin-key>",
        "APISIX_SERVER_HOST": "<apisix-server-host>",
        "APISIX_ADMIN_API_PORT": "<apisix-admin-api-port>",
        "APISIX_ADMIN_API_PREFIX": "<apisix-admin-api-prefix>"
      }
    },
    "parameters": [
      {
        "name": "APISIX_ADMIN_KEY",
        "description": "Admin API authentication key",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "APISIX_SERVER_HOST",
        "description": "Host that have access to your APISIX server",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "APISIX_ADMIN_API_PORT",
        "description": "Admin API port",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "APISIX_ADMIN_API_PREFIX",
        "description": "Admin API prefix",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get_resource",
        "description": "Get resource details by ID or list all resources",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "resource id"
            },
            "uri": {
              "type": "string",
              "description": "filter uri"
            },
            "name": {
              "type": "string",
              "description": "filter name"
            },
            "page": {
              "type": "number",
              "default": 1,
              "description": "page number"
            },
            "type": {
              "enum": [
                "routes",
                "services",
                "upstreams",
                "consumers",
                "ssls",
                "consumer_groups",
                "plugin_configs",
                "global_rules",
                "stream_routes",
                "protos",
                "plugin_configs"
              ],
              "type": "string",
              "description": "resource type"
            },
            "labels": {
              "type": "object",
              "description": "filter labels",
              "additionalProperties": {
                "type": "string"
              }
            },
            "page_size": {
              "type": "number",
              "default": 50,
              "maximum": 500,
              "minimum": 10,
              "description": "page size"
            }
          },
          "required": [
            "type"
          ]
        }
      },
      {
        "name": "delete_resource",
        "description": "Delete a resource by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "resource id"
            },
            "type": {
              "enum": [
                "routes",
                "services",
                "upstreams",
                "consumers",
                "ssls",
                "consumer_groups",
                "plugin_configs",
                "global_rules",
                "stream_routes",
                "protos",
                "plugin_configs"
              ],
              "type": "string",
              "description": "resource type"
            }
          },
          "required": [
            "id",
            "type"
          ]
        }
      },
      {
        "name": "create_route",
        "description": "Create a route",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "route id"
            },
            "route": {
              "type": "object",
              "required": [
                "uri"
              ],
              "properties": {
                "uri": {
                  "type": "string",
                  "description": "route path"
                },
                "desc": {
                  "type": "string",
                  "maxLength": 256,
                  "description": "route description"
                },
                "host": {
                  "type": "string",
                  "description": "route host"
                },
                "name": {
                  "type": "string",
                  "description": "route name"
                },
                "uris": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "multiple route paths"
                },
                "vars": {
                  "type": "array",
                  "items": {
                    "type": "array"
                  },
                  "description": "route match variables"
                },
                "hosts": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "allowed hosts"
                },
                "labels": {
                  "type": "object",
                  "description": "route labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "script": {
                  "type": "object",
                  "description": "route script configuration",
                  "additionalProperties": {}
                },
                "status": {
                  "enum": [
                    0,
                    1
                  ],
                  "type": "number",
                  "description": "route status"
                },
                "methods": {
                  "type": "array",
                  "items": {
                    "enum": [
                      "GET",
                      "POST",
                      "PUT",
                      "DELETE",
                      "PATCH",
                      "HEAD",
                      "OPTIONS",
                      "TRACE",
                      "CONNECT",
                      "PURGE"
                    ],
                    "type": "string"
                  },
                  "description": "allowed HTTP methods"
                },
                "plugins": {
                  "type": "object",
                  "description": "plugins",
                  "additionalProperties": {}
                },
                "priority": {
                  "type": "number",
                  "default": 0,
                  "description": "route priority"
                },
                "upstream": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string",
                      "description": "hash key for chash algorithm"
                    },
                    "tls": {
                      "type": "object",
                      "properties": {
                        "verify": {
                          "type": "boolean",
                          "description": "TLS verification"
                        },
                        "client_key": {
                          "type": "string",
                          "description": "TLS key"
                        },
                        "client_cert": {
                          "type": "string",
                          "description": "TLS certificate"
                        },
                        "client_cert_id": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          },
                          "description": "TLS certificate id"
                        }
                      },
                      "description": "TLS configuration",
                      "additionalProperties": false
                    },
                    "desc": {
                      "type": "string",
                      "maxLength": 256,
                      "description": "upstream description"
                    },
                    "name": {
                      "type": "string",
                      "description": "upstream name"
                    },
                    "type": {
                      "enum": [
                        "roundrobin",
                        "chash",
                        "ewma",
                        "least_conn"
                      ],
                      "type": "string",
                      "default": "roundrobin",
                      "description": "load balancing algorithm"
                    },
                    "nodes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": [
                          "host",
                          "port"
                        ],
                        "properties": {
                          "host": {
                            "type": "string",
                            "description": "upstream host"
                          },
                          "port": {
                            "type": "number",
                            "description": "upstream port"
                          },
                          "weight": {
                            "type": "number",
                            "minimum": 0,
                            "description": "upstream weight"
                          },
                          "priority": {
                            "type": "number",
                            "minimum": 0,
                            "description": "upstream priority"
                          }
                        },
                        "additionalProperties": false
                      },
                      "description": "upstream nodes with weights"
                    },
                    "checks": {
                      "type": "object",
                      "properties": {
                        "active": {
                          "type": "object",
                          "properties": {
                            "host": {
                              "type": "string",
                              "description": "host for health check"
                            },
                            "port": {
                              "type": "number",
                              "description": "port for health check"
                            },
                            "healthy": {
                              "type": "object",
                              "properties": {
                                "interval": {
                                  "type": "number",
                                  "description": "check interval for healthy status"
                                },
                                "successes": {
                                  "type": "number",
                                  "description": "success count threshold"
                                }
                              },
                              "additionalProperties": false
                            },
                            "timeout": {
                              "type": "number",
                              "description": "timeout for health check"
                            },
                            "http_path": {
                              "type": "string",
                              "description": "HTTP path for health check"
                            },
                            "unhealthy": {
                              "type": "object",
                              "properties": {
                                "interval": {
                                  "type": "number",
                                  "description": "check interval for unhealthy status"
                                },
                                "http_failures": {
                                  "type": "number",
                                  "description": "HTTP failure count threshold"
                                }
                              },
                              "additionalProperties": false
                            },
                            "https_verify_certificate": {
                              "type": "boolean",
                              "description": "verify HTTPS certificate"
                            }
                          },
                          "description": "active health check configuration",
                          "additionalProperties": false
                        },
                        "passive": {
                          "type": "object",
                          "properties": {
                            "healthy": {
                              "type": "object",
                              "properties": {
                                "successes": {
                                  "type": "number",
                                  "description": "success count threshold"
                                },
                                "http_statuses": {
                                  "type": "array",
                                  "items": {
                                    "type": "number"
                                  },
                                  "description": "HTTP status codes for healthy state"
                                }
                              },
                              "additionalProperties": false
                            },
                            "unhealthy": {
                              "type": "object",
                              "properties": {
                                "timeout": {
                                  "type": "number",
                                  "description": "timeout threshold"
                                },
                                "http_failures": {
                                  "type": "number",
                                  "description": "HTTP failure count threshold"
                                },
                                "http_statuses": {
                                  "type": "array",
                                  "items": {
                                    "type": "number"
                                  },
                                  "description": "HTTP status codes for unhealthy state"
                                }
                              },
                              "additionalProperties": false
                            }
                          },
                          "description": "passive health check configuration",
                          "additionalProperties": false
                        }
                      },
                      "description": "health check configuration",
                      "additionalProperties": false
                    },
                    "labels": {
                      "type": "object",
                      "description": "upstream labels",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "scheme": {
                      "enum": [
                        "http",
                        "https",
                        "grpc",
                        "grpcs",
                        "tcp",
                        "tls",
                        "udp",
                        "kafka"
                      ],
                      "type": "string",
                      "default": "http",
                      "description": "upstream scheme"
                    },
                    "hash_on": {
                      "enum": [
                        "vars",
                        "header",
                        "cookie",
                        "consumer",
                        "vars_combinations"
                      ],
                      "type": "string",
                      "description": "hash on type for chash algorithm"
                    },
                    "retries": {
                      "type": "number",
                      "minimum": 0,
                      "description": "retry count"
                    },
                    "timeout": {
                      "type": "object",
                      "properties": {
                        "read": {
                          "type": "number",
                          "description": "read timeout in seconds"
                        },
                        "send": {
                          "type": "number",
                          "description": "send timeout in seconds"
                        },
                        "connect": {
                          "type": "number",
                          "description": "connection timeout in seconds"
                        }
                      },
                      "description": "timeout configuration",
                      "additionalProperties": false
                    },
                    "pass_host": {
                      "enum": [
                        "pass",
                        "node",
                        "rewrite"
                      ],
                      "type": "string",
                      "default": "pass",
                      "description": "host passing mode"
                    },
                    "retry_timeout": {
                      "type": "number",
                      "minimum": 0,
                      "description": "retry timeout"
                    },
                    "upstream_host": {
                      "type": "string",
                      "description": "upstream host for rewrite mode"
                    },
                    "keepalive_pool": {
                      "type": "object",
                      "properties": {
                        "size": {
                          "type": "number",
                          "default": 320,
                          "description": "size"
                        },
                        "requests": {
                          "type": "number",
                          "default": 1000,
                          "description": "requests"
                        },
                        "idle_timeout": {
                          "type": "number",
                          "default": 60,
                          "description": "idle timeout"
                        }
                      },
                      "description": "keepalive pool configuration",
                      "additionalProperties": false
                    }
                  },
                  "description": "upstream configuration",
                  "additionalProperties": true
                },
                "service_id": {
                  "type": "string",
                  "description": "service id"
                },
                "filter_func": {
                  "type": "string",
                  "description": "route filter function"
                },
                "remote_addr": {
                  "type": "string",
                  "description": "allowed remote address"
                },
                "upstream_id": {
                  "type": "string",
                  "description": "upstream id"
                },
                "remote_addrs": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "allowed remote addresses"
                },
                "enable_websocket": {
                  "type": "boolean",
                  "description": "enable websocket"
                },
                "service_protocol": {
                  "type": "string",
                  "description": "service protocol"
                }
              },
              "description": "route configuration",
              "additionalProperties": true
            }
          },
          "required": [
            "route"
          ]
        }
      },
      {
        "name": "update_route",
        "description": "Update specific attributes of an existing route",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "route id"
            },
            "route": {
              "type": "object",
              "properties": {
                "uri": {
                  "type": "string",
                  "description": "route path"
                },
                "desc": {
                  "type": "string",
                  "maxLength": 256,
                  "description": "route description"
                },
                "host": {
                  "type": "string",
                  "description": "route host"
                },
                "name": {
                  "type": "string",
                  "description": "route name"
                },
                "uris": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "multiple route paths"
                },
                "vars": {
                  "type": "array",
                  "items": {
                    "type": "array"
                  },
                  "description": "route match variables"
                },
                "hosts": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "allowed hosts"
                },
                "labels": {
                  "type": "object",
                  "description": "route labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "script": {
                  "type": "object",
                  "description": "route script configuration",
                  "additionalProperties": {}
                },
                "status": {
                  "enum": [
                    0,
                    1
                  ],
                  "type": "number",
                  "description": "route status"
                },
                "methods": {
                  "type": "array",
                  "items": {
                    "enum": [
                      "GET",
                      "POST",
                      "PUT",
                      "DELETE",
                      "PATCH",
                      "HEAD",
                      "OPTIONS",
                      "TRACE",
                      "CONNECT",
                      "PURGE"
                    ],
                    "type": "string"
                  },
                  "description": "allowed HTTP methods"
                },
                "plugins": {
                  "type": "object",
                  "description": "plugins",
                  "additionalProperties": {}
                },
                "priority": {
                  "type": "number",
                  "default": 0,
                  "description": "route priority"
                },
                "upstream": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string",
                      "description": "hash key for chash algorithm"
                    },
                    "tls": {
                      "type": "object",
                      "properties": {
                        "verify": {
                          "type": "boolean",
                          "description": "TLS verification"
                        },
                        "client_key": {
                          "type": "string",
                          "description": "TLS key"
                        },
                        "client_cert": {
                          "type": "string",
                          "description": "TLS certificate"
                        },
                        "client_cert_id": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          },
                          "description": "TLS certificate id"
                        }
                      },
                      "description": "TLS configuration",
                      "additionalProperties": false
                    },
                    "desc": {
                      "type": "string",
                      "maxLength": 256,
                      "description": "upstream description"
                    },
                    "name": {
                      "type": "string",
                      "description": "upstream name"
                    },
                    "type": {
                      "enum": [
                        "roundrobin",
                        "chash",
                        "ewma",
                        "least_conn"
                      ],
                      "type": "string",
                      "default": "roundrobin",
                      "description": "load balancing algorithm"
                    },
                    "nodes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": [
                          "host",
                          "port"
                        ],
                        "properties": {
                          "host": {
                            "type": "string",
                            "description": "upstream host"
                          },
                          "port": {
                            "type": "number",
                            "description": "upstream port"
                          },
                          "weight": {
                            "type": "number",
                            "minimum": 0,
                            "description": "upstream weight"
                          },
                          "priority": {
                            "type": "number",
                            "minimum": 0,
                            "description": "upstream priority"
                          }
                        },
                        "additionalProperties": false
                      },
                      "description": "upstream nodes with weights"
                    },
                    "checks": {
                      "type": "object",
                      "properties": {
                        "active": {
                          "type": "object",
                          "properties": {
                            "host": {
                              "type": "string",
                              "description": "host for health check"
                            },
                            "port": {
                              "type": "number",
                              "description": "port for health check"
                            },
                            "healthy": {
                              "type": "object",
                              "properties": {
                                "interval": {
                                  "type": "number",
                                  "description": "check interval for healthy status"
                                },
                                "successes": {
                                  "type": "number",
                                  "description": "success count threshold"
                                }
                              },
                              "additionalProperties": false
                            },
                            "timeout": {
                              "type": "number",
                              "description": "timeout for health check"
                            },
                            "http_path": {
                              "type": "string",
                              "description": "HTTP path for health check"
                            },
                            "unhealthy": {
                              "type": "object",
                              "properties": {
                                "interval": {
                                  "type": "number",
                                  "description": "check interval for unhealthy status"
                                },
                                "http_failures": {
                                  "type": "number",
                                  "description": "HTTP failure count threshold"
                                }
                              },
                              "additionalProperties": false
                            },
                            "https_verify_certificate": {
                              "type": "boolean",
                              "description": "verify HTTPS certificate"
                            }
                          },
                          "description": "active health check configuration",
                          "additionalProperties": false
                        },
                        "passive": {
                          "type": "object",
                          "properties": {
                            "healthy": {
                              "type": "object",
                              "properties": {
                                "successes": {
                                  "type": "number",
                                  "description": "success count threshold"
                                },
                                "http_statuses": {
                                  "type": "array",
                                  "items": {
                                    "type": "number"
                                  },
                                  "description": "HTTP status codes for healthy state"
                                }
                              },
                              "additionalProperties": false
                            },
                            "unhealthy": {
                              "type": "object",
                              "properties": {
                                "timeout": {
                                  "type": "number",
                                  "description": "timeout threshold"
                                },
                                "http_failures": {
                                  "type": "number",
                                  "description": "HTTP failure count threshold"
                                },
                                "http_statuses": {
                                  "type": "array",
                                  "items": {
                                    "type": "number"
                                  },
                                  "description": "HTTP status codes for unhealthy state"
                                }
                              },
                              "additionalProperties": false
                            }
                          },
                          "description": "passive health check configuration",
                          "additionalProperties": false
                        }
                      },
                      "description": "health check configuration",
                      "additionalProperties": false
                    },
                    "labels": {
                      "type": "object",
                      "description": "upstream labels",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "scheme": {
                      "enum": [
                        "http",
                        "https",
                        "grpc",
                        "grpcs",
                        "tcp",
                        "tls",
                        "udp",
                        "kafka"
                      ],
                      "type": "string",
                      "default": "http",
                      "description": "upstream scheme"
                    },
                    "hash_on": {
                      "enum": [
                        "vars",
                        "header",
                        "cookie",
                        "consumer",
                        "vars_combinations"
                      ],
                      "type": "string",
                      "description": "hash on type for chash algorithm"
                    },
                    "retries": {
                      "type": "number",
                      "minimum": 0,
                      "description": "retry count"
                    },
                    "timeout": {
                      "type": "object",
                      "properties": {
                        "read": {
                          "type": "number",
                          "description": "read timeout in seconds"
                        },
                        "send": {
                          "type": "number",
                          "description": "send timeout in seconds"
                        },
                        "connect": {
                          "type": "number",
                          "description": "connection timeout in seconds"
                        }
                      },
                      "description": "timeout configuration",
                      "additionalProperties": false
                    },
                    "pass_host": {
                      "enum": [
                        "pass",
                        "node",
                        "rewrite"
                      ],
                      "type": "string",
                      "default": "pass",
                      "description": "host passing mode"
                    },
                    "retry_timeout": {
                      "type": "number",
                      "minimum": 0,
                      "description": "retry timeout"
                    },
                    "upstream_host": {
                      "type": "string",
                      "description": "upstream host for rewrite mode"
                    },
                    "keepalive_pool": {
                      "type": "object",
                      "properties": {
                        "size": {
                          "type": "number",
                          "default": 320,
                          "description": "size"
                        },
                        "requests": {
                          "type": "number",
                          "default": 1000,
                          "description": "requests"
                        },
                        "idle_timeout": {
                          "type": "number",
                          "default": 60,
                          "description": "idle timeout"
                        }
                      },
                      "description": "keepalive pool configuration",
                      "additionalProperties": false
                    }
                  },
                  "description": "upstream configuration",
                  "additionalProperties": true
                },
                "service_id": {
                  "type": "string",
                  "description": "service id"
                },
                "filter_func": {
                  "type": "string",
                  "description": "route filter function"
                },
                "remote_addr": {
                  "type": "string",
                  "description": "allowed remote address"
                },
                "upstream_id": {
                  "type": "string",
                  "description": "upstream id"
                },
                "remote_addrs": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "allowed remote addresses"
                },
                "enable_websocket": {
                  "type": "boolean",
                  "description": "enable websocket"
                },
                "service_protocol": {
                  "type": "string",
                  "description": "service protocol"
                }
              },
              "description": "route configuration",
              "additionalProperties": true
            }
          },
          "required": [
            "id",
            "route"
          ]
        }
      },
      {
        "name": "create_service",
        "description": "Create a service",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "service id"
            },
            "service": {
              "type": "object",
              "properties": {
                "desc": {
                  "type": "string",
                  "maxLength": 256,
                  "description": "service description"
                },
                "name": {
                  "type": "string",
                  "maxLength": 100,
                  "minLength": 1,
                  "description": "service name"
                },
                "vars": {
                  "type": "array",
                  "items": {
                    "type": "array"
                  },
                  "description": "service match variables"
                },
                "hosts": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "allowed hosts"
                },
                "labels": {
                  "type": "object",
                  "description": "service labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "script": {
                  "type": "object",
                  "description": "service script configuration",
                  "additionalProperties": {}
                },
                "plugins": {
                  "type": "object",
                  "description": "plugins",
                  "additionalProperties": {}
                },
                "upstream": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string",
                      "description": "hash key for chash algorithm"
                    },
                    "tls": {
                      "type": "object",
                      "properties": {
                        "verify": {
                          "type": "boolean",
                          "description": "TLS verification"
                        },
                        "client_key": {
                          "type": "string",
                          "description": "TLS key"
                        },
                        "client_cert": {
                          "type": "string",
                          "description": "TLS certificate"
                        },
                        "client_cert_id": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          },
                          "description": "TLS certificate id"
                        }
                      },
                      "description": "TLS configuration",
                      "additionalProperties": false
                    },
                    "desc": {
                      "type": "string",
                      "maxLength": 256,
                      "description": "upstream description"
                    },
                    "name": {
                      "type": "string",
                      "description": "upstream name"
                    },
                    "type": {
                      "enum": [
                        "roundrobin",
                        "chash",
                        "ewma",
                        "least_conn"
                      ],
                      "type": "string",
                      "default": "roundrobin",
                      "description": "load balancing algorithm"
                    },
                    "nodes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": [
                          "host",
                          "port"
                        ],
                        "properties": {
                          "host": {
                            "type": "string",
                            "description": "upstream host"
                          },
                          "port": {
                            "type": "number",
                            "description": "upstream port"
                          },
                          "weight": {
                            "type": "number",
                            "minimum": 0,
                            "description": "upstream weight"
                          },
                          "priority": {
                            "type": "number",
                            "minimum": 0,
                            "description": "upstream priority"
                          }
                        },
                        "additionalProperties": false
                      },
                      "description": "upstream nodes with weights"
                    },
                    "checks": {
                      "type": "object",
                      "properties": {
                        "active": {
                          "type": "object",
                          "properties": {
                            "host": {
                              "type": "string",
                              "description": "host for health check"
                            },
                            "port": {
                              "type": "number",
                              "description": "port for health check"
                            },
                            "healthy": {
                              "type": "object",
                              "properties": {
                                "interval": {
                                  "type": "number",
                                  "description": "check interval for healthy status"
                                },
                                "successes": {
                                  "type": "number",
                                  "description": "success count threshold"
                                }
                              },
                              "additionalProperties": false
                            },
                            "timeout": {
                              "type": "number",
                              "description": "timeout for health check"
                            },
                            "http_path": {
                              "type": "string",
                              "description": "HTTP path for health check"
                            },
                            "unhealthy": {
                              "type": "object",
                              "properties": {
                                "interval": {
                                  "type": "number",
                                  "description": "check interval for unhealthy status"
                                },
                                "http_failures": {
                                  "type": "number",
                                  "description": "HTTP failure count threshold"
                                }
                              },
                              "additionalProperties": false
                            },
                            "https_verify_certificate": {
                              "type": "boolean",
                              "description": "verify HTTPS certificate"
                            }
                          },
                          "description": "active health check configuration",
                          "additionalProperties": false
                        },
                        "passive": {
                          "type": "object",
                          "properties": {
                            "healthy": {
                              "type": "object",
                              "properties": {
                                "successes": {
                                  "type": "number",
                                  "description": "success count threshold"
                                },
                                "http_statuses": {
                                  "type": "array",
                                  "items": {
                                    "type": "number"
                                  },
                                  "description": "HTTP status codes for healthy state"
                                }
                              },
                              "additionalProperties": false
                            },
                            "unhealthy": {
                              "type": "object",
                              "properties": {
                                "timeout": {
                                  "type": "number",
                                  "description": "timeout threshold"
                                },
                                "http_failures": {
                                  "type": "number",
                                  "description": "HTTP failure count threshold"
                                },
                                "http_statuses": {
                                  "type": "array",
                                  "items": {
                                    "type": "number"
                                  },
                                  "description": "HTTP status codes for unhealthy state"
                                }
                              },
                              "additionalProperties": false
                            }
                          },
                          "description": "passive health check configuration",
                          "additionalProperties": false
                        }
                      },
                      "description": "health check configuration",
                      "additionalProperties": false
                    },
                    "labels": {
                      "type": "object",
                      "description": "upstream labels",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "scheme": {
                      "enum": [
                        "http",
                        "https",
                        "grpc",
                        "grpcs",
                        "tcp",
                        "tls",
                        "udp",
                        "kafka"
                      ],
                      "type": "string",
                      "default": "http",
                      "description": "upstream scheme"
                    },
                    "hash_on": {
                      "enum": [
                        "vars",
                        "header",
                        "cookie",
                        "consumer",
                        "vars_combinations"
                      ],
                      "type": "string",
                      "description": "hash on type for chash algorithm"
                    },
                    "retries": {
                      "type": "number",
                      "minimum": 0,
                      "description": "retry count"
                    },
                    "timeout": {
                      "type": "object",
                      "properties": {
                        "read": {
                          "type": "number",
                          "description": "read timeout in seconds"
                        },
                        "send": {
                          "type": "number",
                          "description": "send timeout in seconds"
                        },
                        "connect": {
                          "type": "number",
                          "description": "connection timeout in seconds"
                        }
                      },
                      "description": "timeout configuration",
                      "additionalProperties": false
                    },
                    "pass_host": {
                      "enum": [
                        "pass",
                        "node",
                        "rewrite"
                      ],
                      "type": "string",
                      "default": "pass",
                      "description": "host passing mode"
                    },
                    "retry_timeout": {
                      "type": "number",
                      "minimum": 0,
                      "description": "retry timeout"
                    },
                    "upstream_host": {
                      "type": "string",
                      "description": "upstream host for rewrite mode"
                    },
                    "keepalive_pool": {
                      "type": "object",
                      "properties": {
                        "size": {
                          "type": "number",
                          "default": 320,
                          "description": "size"
                        },
                        "requests": {
                          "type": "number",
                          "default": 1000,
                          "description": "requests"
                        },
                        "idle_timeout": {
                          "type": "number",
                          "default": 60,
                          "description": "idle timeout"
                        }
                      },
                      "description": "keepalive pool configuration",
                      "additionalProperties": false
                    }
                  },
                  "description": "upstream service configuration object",
                  "additionalProperties": true
                },
                "upstream_id": {
                  "type": "string",
                  "description": "upstream id"
                },
                "enable_websocket": {
                  "type": "boolean",
                  "description": "enable websocket"
                }
              },
              "description": "service configuration object",
              "additionalProperties": true
            }
          },
          "required": [
            "service"
          ]
        }
      },
      {
        "name": "update_service",
        "description": "Update specific attributes of an existing service",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "service id"
            },
            "service": {
              "type": "object",
              "properties": {
                "desc": {
                  "type": "string",
                  "maxLength": 256,
                  "description": "service description"
                },
                "name": {
                  "type": "string",
                  "maxLength": 100,
                  "minLength": 1,
                  "description": "service name"
                },
                "vars": {
                  "type": "array",
                  "items": {
                    "type": "array"
                  },
                  "description": "service match variables"
                },
                "hosts": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "allowed hosts"
                },
                "labels": {
                  "type": "object",
                  "description": "service labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "script": {
                  "type": "object",
                  "description": "service script configuration",
                  "additionalProperties": {}
                },
                "plugins": {
                  "type": "object",
                  "description": "plugins",
                  "additionalProperties": {}
                },
                "upstream": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string",
                      "description": "hash key for chash algorithm"
                    },
                    "tls": {
                      "type": "object",
                      "properties": {
                        "verify": {
                          "type": "boolean",
                          "description": "TLS verification"
                        },
                        "client_key": {
                          "type": "string",
                          "description": "TLS key"
                        },
                        "client_cert": {
                          "type": "string",
                          "description": "TLS certificate"
                        },
                        "client_cert_id": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          },
                          "description": "TLS certificate id"
                        }
                      },
                      "description": "TLS configuration",
                      "additionalProperties": false
                    },
                    "desc": {
                      "type": "string",
                      "maxLength": 256,
                      "description": "upstream description"
                    },
                    "name": {
                      "type": "string",
                      "description": "upstream name"
                    },
                    "type": {
                      "enum": [
                        "roundrobin",
                        "chash",
                        "ewma",
                        "least_conn"
                      ],
                      "type": "string",
                      "default": "roundrobin",
                      "description": "load balancing algorithm"
                    },
                    "nodes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": [
                          "host",
                          "port"
                        ],
                        "properties": {
                          "host": {
                            "type": "string",
                            "description": "upstream host"
                          },
                          "port": {
                            "type": "number",
                            "description": "upstream port"
                          },
                          "weight": {
                            "type": "number",
                            "minimum": 0,
                            "description": "upstream weight"
                          },
                          "priority": {
                            "type": "number",
                            "minimum": 0,
                            "description": "upstream priority"
                          }
                        },
                        "additionalProperties": false
                      },
                      "description": "upstream nodes with weights"
                    },
                    "checks": {
                      "type": "object",
                      "properties": {
                        "active": {
                          "type": "object",
                          "properties": {
                            "host": {
                              "type": "string",
                              "description": "host for health check"
                            },
                            "port": {
                              "type": "number",
                              "description": "port for health check"
                            },
                            "healthy": {
                              "type": "object",
                              "properties": {
                                "interval": {
                                  "type": "number",
                                  "description": "check interval for healthy status"
                                },
                                "successes": {
                                  "type": "number",
                                  "description": "success count threshold"
                                }
                              },
                              "additionalProperties": false
                            },
                            "timeout": {
                              "type": "number",
                              "description": "timeout for health check"
                            },
                            "http_path": {
                              "type": "string",
                              "description": "HTTP path for health check"
                            },
                            "unhealthy": {
                              "type": "object",
                              "properties": {
                                "interval": {
                                  "type": "number",
                                  "description": "check interval for unhealthy status"
                                },
                                "http_failures": {
                                  "type": "number",
                                  "description": "HTTP failure count threshold"
                                }
                              },
                              "additionalProperties": false
                            },
                            "https_verify_certificate": {
                              "type": "boolean",
                              "description": "verify HTTPS certificate"
                            }
                          },
                          "description": "active health check configuration",
                          "additionalProperties": false
                        },
                        "passive": {
                          "type": "object",
                          "properties": {
                            "healthy": {
                              "type": "object",
                              "properties": {
                                "successes": {
                                  "type": "number",
                                  "description": "success count threshold"
                                },
                                "http_statuses": {
                                  "type": "array",
                                  "items": {
                                    "type": "number"
                                  },
                                  "description": "HTTP status codes for healthy state"
                                }
                              },
                              "additionalProperties": false
                            },
                            "unhealthy": {
                              "type": "object",
                              "properties": {
                                "timeout": {
                                  "type": "number",
                                  "description": "timeout threshold"
                                },
                                "http_failures": {
                                  "type": "number",
                                  "description": "HTTP failure count threshold"
                                },
                                "http_statuses": {
                                  "type": "array",
                                  "items": {
                                    "type": "number"
                                  },
                                  "description": "HTTP status codes for unhealthy state"
                                }
                              },
                              "additionalProperties": false
                            }
                          },
                          "description": "passive health check configuration",
                          "additionalProperties": false
                        }
                      },
                      "description": "health check configuration",
                      "additionalProperties": false
                    },
                    "labels": {
                      "type": "object",
                      "description": "upstream labels",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "scheme": {
                      "enum": [
                        "http",
                        "https",
                        "grpc",
                        "grpcs",
                        "tcp",
                        "tls",
                        "udp",
                        "kafka"
                      ],
                      "type": "string",
                      "default": "http",
                      "description": "upstream scheme"
                    },
                    "hash_on": {
                      "enum": [
                        "vars",
                        "header",
                        "cookie",
                        "consumer",
                        "vars_combinations"
                      ],
                      "type": "string",
                      "description": "hash on type for chash algorithm"
                    },
                    "retries": {
                      "type": "number",
                      "minimum": 0,
                      "description": "retry count"
                    },
                    "timeout": {
                      "type": "object",
                      "properties": {
                        "read": {
                          "type": "number",
                          "description": "read timeout in seconds"
                        },
                        "send": {
                          "type": "number",
                          "description": "send timeout in seconds"
                        },
                        "connect": {
                          "type": "number",
                          "description": "connection timeout in seconds"
                        }
                      },
                      "description": "timeout configuration",
                      "additionalProperties": false
                    },
                    "pass_host": {
                      "enum": [
                        "pass",
                        "node",
                        "rewrite"
                      ],
                      "type": "string",
                      "default": "pass",
                      "description": "host passing mode"
                    },
                    "retry_timeout": {
                      "type": "number",
                      "minimum": 0,
                      "description": "retry timeout"
                    },
                    "upstream_host": {
                      "type": "string",
                      "description": "upstream host for rewrite mode"
                    },
                    "keepalive_pool": {
                      "type": "object",
                      "properties": {
                        "size": {
                          "type": "number",
                          "default": 320,
                          "description": "size"
                        },
                        "requests": {
                          "type": "number",
                          "default": 1000,
                          "description": "requests"
                        },
                        "idle_timeout": {
                          "type": "number",
                          "default": 60,
                          "description": "idle timeout"
                        }
                      },
                      "description": "keepalive pool configuration",
                      "additionalProperties": false
                    }
                  },
                  "description": "upstream service configuration object",
                  "additionalProperties": true
                },
                "upstream_id": {
                  "type": "string",
                  "description": "upstream id"
                },
                "enable_websocket": {
                  "type": "boolean",
                  "description": "enable websocket"
                }
              },
              "description": "service configuration object",
              "additionalProperties": true
            }
          },
          "required": [
            "id",
            "service"
          ]
        }
      },
      {
        "name": "create_upstream",
        "description": "Create an upstream service with load balancing settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "upstream id"
            },
            "upstream": {
              "type": "object",
              "required": [
                "nodes"
              ],
              "properties": {
                "key": {
                  "type": "string",
                  "description": "hash key for chash algorithm"
                },
                "tls": {
                  "type": "object",
                  "properties": {
                    "verify": {
                      "type": "boolean",
                      "description": "TLS verification"
                    },
                    "client_key": {
                      "type": "string",
                      "description": "TLS key"
                    },
                    "client_cert": {
                      "type": "string",
                      "description": "TLS certificate"
                    },
                    "client_cert_id": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "TLS certificate id"
                    }
                  },
                  "description": "TLS configuration",
                  "additionalProperties": false
                },
                "desc": {
                  "type": "string",
                  "maxLength": 256,
                  "description": "upstream description"
                },
                "name": {
                  "type": "string",
                  "description": "upstream name"
                },
                "type": {
                  "enum": [
                    "roundrobin",
                    "chash",
                    "ewma",
                    "least_conn"
                  ],
                  "type": "string",
                  "default": "roundrobin",
                  "description": "load balancing algorithm"
                },
                "nodes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "host",
                      "port"
                    ],
                    "properties": {
                      "host": {
                        "type": "string",
                        "description": "upstream host"
                      },
                      "port": {
                        "type": "number",
                        "description": "upstream port"
                      },
                      "weight": {
                        "type": "number",
                        "minimum": 0,
                        "description": "upstream weight"
                      },
                      "priority": {
                        "type": "number",
                        "minimum": 0,
                        "description": "upstream priority"
                      }
                    },
                    "additionalProperties": false
                  },
                  "description": "upstream nodes with weights"
                },
                "checks": {
                  "type": "object",
                  "properties": {
                    "active": {
                      "type": "object",
                      "properties": {
                        "host": {
                          "type": "string",
                          "description": "host for health check"
                        },
                        "port": {
                          "type": "number",
                          "description": "port for health check"
                        },
                        "healthy": {
                          "type": "object",
                          "properties": {
                            "interval": {
                              "type": "number",
                              "description": "check interval for healthy status"
                            },
                            "successes": {
                              "type": "number",
                              "description": "success count threshold"
                            }
                          },
                          "additionalProperties": false
                        },
                        "timeout": {
                          "type": "number",
                          "description": "timeout for health check"
                        },
                        "http_path": {
                          "type": "string",
                          "description": "HTTP path for health check"
                        },
                        "unhealthy": {
                          "type": "object",
                          "properties": {
                            "interval": {
                              "type": "number",
                              "description": "check interval for unhealthy status"
                            },
                            "http_failures": {
                              "type": "number",
                              "description": "HTTP failure count threshold"
                            }
                          },
                          "additionalProperties": false
                        },
                        "https_verify_certificate": {
                          "type": "boolean",
                          "description": "verify HTTPS certificate"
                        }
                      },
                      "description": "active health check configuration",
                      "additionalProperties": false
                    },
                    "passive": {
                      "type": "object",
                      "properties": {
                        "healthy": {
                          "type": "object",
                          "properties": {
                            "successes": {
                              "type": "number",
                              "description": "success count threshold"
                            },
                            "http_statuses": {
                              "type": "array",
                              "items": {
                                "type": "number"
                              },
                              "description": "HTTP status codes for healthy state"
                            }
                          },
                          "additionalProperties": false
                        },
                        "unhealthy": {
                          "type": "object",
                          "properties": {
                            "timeout": {
                              "type": "number",
                              "description": "timeout threshold"
                            },
                            "http_failures": {
                              "type": "number",
                              "description": "HTTP failure count threshold"
                            },
                            "http_statuses": {
                              "type": "array",
                              "items": {
                                "type": "number"
                              },
                              "description": "HTTP status codes for unhealthy state"
                            }
                          },
                          "additionalProperties": false
                        }
                      },
                      "description": "passive health check configuration",
                      "additionalProperties": false
                    }
                  },
                  "description": "health check configuration",
                  "additionalProperties": false
                },
                "labels": {
                  "type": "object",
                  "description": "upstream labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "scheme": {
                  "enum": [
                    "http",
                    "https",
                    "grpc",
                    "grpcs",
                    "tcp",
                    "tls",
                    "udp",
                    "kafka"
                  ],
                  "type": "string",
                  "default": "http",
                  "description": "upstream scheme"
                },
                "hash_on": {
                  "enum": [
                    "vars",
                    "header",
                    "cookie",
                    "consumer",
                    "vars_combinations"
                  ],
                  "type": "string",
                  "description": "hash on type for chash algorithm"
                },
                "retries": {
                  "type": "number",
                  "minimum": 0,
                  "description": "retry count"
                },
                "timeout": {
                  "type": "object",
                  "properties": {
                    "read": {
                      "type": "number",
                      "description": "read timeout in seconds"
                    },
                    "send": {
                      "type": "number",
                      "description": "send timeout in seconds"
                    },
                    "connect": {
                      "type": "number",
                      "description": "connection timeout in seconds"
                    }
                  },
                  "description": "timeout configuration",
                  "additionalProperties": false
                },
                "pass_host": {
                  "enum": [
                    "pass",
                    "node",
                    "rewrite"
                  ],
                  "type": "string",
                  "default": "pass",
                  "description": "host passing mode"
                },
                "retry_timeout": {
                  "type": "number",
                  "minimum": 0,
                  "description": "retry timeout"
                },
                "upstream_host": {
                  "type": "string",
                  "description": "upstream host for rewrite mode"
                },
                "keepalive_pool": {
                  "type": "object",
                  "properties": {
                    "size": {
                      "type": "number",
                      "default": 320,
                      "description": "size"
                    },
                    "requests": {
                      "type": "number",
                      "default": 1000,
                      "description": "requests"
                    },
                    "idle_timeout": {
                      "type": "number",
                      "default": 60,
                      "description": "idle timeout"
                    }
                  },
                  "description": "keepalive pool configuration",
                  "additionalProperties": false
                }
              },
              "description": "upstream service configuration object",
              "additionalProperties": true
            }
          },
          "required": [
            "upstream"
          ]
        }
      },
      {
        "name": "update_upstream",
        "description": "Update specific attributes of an existing upstream",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "upstream id"
            },
            "upstream": {
              "type": "object",
              "properties": {
                "key": {
                  "type": "string",
                  "description": "hash key for chash algorithm"
                },
                "tls": {
                  "type": "object",
                  "properties": {
                    "verify": {
                      "type": "boolean",
                      "description": "TLS verification"
                    },
                    "client_key": {
                      "type": "string",
                      "description": "TLS key"
                    },
                    "client_cert": {
                      "type": "string",
                      "description": "TLS certificate"
                    },
                    "client_cert_id": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "TLS certificate id"
                    }
                  },
                  "description": "TLS configuration",
                  "additionalProperties": false
                },
                "desc": {
                  "type": "string",
                  "maxLength": 256,
                  "description": "upstream description"
                },
                "name": {
                  "type": "string",
                  "description": "upstream name"
                },
                "type": {
                  "enum": [
                    "roundrobin",
                    "chash",
                    "ewma",
                    "least_conn"
                  ],
                  "type": "string",
                  "default": "roundrobin",
                  "description": "load balancing algorithm"
                },
                "nodes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "host",
                      "port"
                    ],
                    "properties": {
                      "host": {
                        "type": "string",
                        "description": "upstream host"
                      },
                      "port": {
                        "type": "number",
                        "description": "upstream port"
                      },
                      "weight": {
                        "type": "number",
                        "minimum": 0,
                        "description": "upstream weight"
                      },
                      "priority": {
                        "type": "number",
                        "minimum": 0,
                        "description": "upstream priority"
                      }
                    },
                    "additionalProperties": false
                  },
                  "description": "upstream nodes with weights"
                },
                "checks": {
                  "type": "object",
                  "properties": {
                    "active": {
                      "type": "object",
                      "properties": {
                        "host": {
                          "type": "string",
                          "description": "host for health check"
                        },
                        "port": {
                          "type": "number",
                          "description": "port for health check"
                        },
                        "healthy": {
                          "type": "object",
                          "properties": {
                            "interval": {
                              "type": "number",
                              "description": "check interval for healthy status"
                            },
                            "successes": {
                              "type": "number",
                              "description": "success count threshold"
                            }
                          },
                          "additionalProperties": false
                        },
                        "timeout": {
                          "type": "number",
                          "description": "timeout for health check"
                        },
                        "http_path": {
                          "type": "string",
                          "description": "HTTP path for health check"
                        },
                        "unhealthy": {
                          "type": "object",
                          "properties": {
                            "interval": {
                              "type": "number",
                              "description": "check interval for unhealthy status"
                            },
                            "http_failures": {
                              "type": "number",
                              "description": "HTTP failure count threshold"
                            }
                          },
                          "additionalProperties": false
                        },
                        "https_verify_certificate": {
                          "type": "boolean",
                          "description": "verify HTTPS certificate"
                        }
                      },
                      "description": "active health check configuration",
                      "additionalProperties": false
                    },
                    "passive": {
                      "type": "object",
                      "properties": {
                        "healthy": {
                          "type": "object",
                          "properties": {
                            "successes": {
                              "type": "number",
                              "description": "success count threshold"
                            },
                            "http_statuses": {
                              "type": "array",
                              "items": {
                                "type": "number"
                              },
                              "description": "HTTP status codes for healthy state"
                            }
                          },
                          "additionalProperties": false
                        },
                        "unhealthy": {
                          "type": "object",
                          "properties": {
                            "timeout": {
                              "type": "number",
                              "description": "timeout threshold"
                            },
                            "http_failures": {
                              "type": "number",
                              "description": "HTTP failure count threshold"
                            },
                            "http_statuses": {
                              "type": "array",
                              "items": {
                                "type": "number"
                              },
                              "description": "HTTP status codes for unhealthy state"
                            }
                          },
                          "additionalProperties": false
                        }
                      },
                      "description": "passive health check configuration",
                      "additionalProperties": false
                    }
                  },
                  "description": "health check configuration",
                  "additionalProperties": false
                },
                "labels": {
                  "type": "object",
                  "description": "upstream labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "scheme": {
                  "enum": [
                    "http",
                    "https",
                    "grpc",
                    "grpcs",
                    "tcp",
                    "tls",
                    "udp",
                    "kafka"
                  ],
                  "type": "string",
                  "default": "http",
                  "description": "upstream scheme"
                },
                "hash_on": {
                  "enum": [
                    "vars",
                    "header",
                    "cookie",
                    "consumer",
                    "vars_combinations"
                  ],
                  "type": "string",
                  "description": "hash on type for chash algorithm"
                },
                "retries": {
                  "type": "number",
                  "minimum": 0,
                  "description": "retry count"
                },
                "timeout": {
                  "type": "object",
                  "properties": {
                    "read": {
                      "type": "number",
                      "description": "read timeout in seconds"
                    },
                    "send": {
                      "type": "number",
                      "description": "send timeout in seconds"
                    },
                    "connect": {
                      "type": "number",
                      "description": "connection timeout in seconds"
                    }
                  },
                  "description": "timeout configuration",
                  "additionalProperties": false
                },
                "pass_host": {
                  "enum": [
                    "pass",
                    "node",
                    "rewrite"
                  ],
                  "type": "string",
                  "default": "pass",
                  "description": "host passing mode"
                },
                "retry_timeout": {
                  "type": "number",
                  "minimum": 0,
                  "description": "retry timeout"
                },
                "upstream_host": {
                  "type": "string",
                  "description": "upstream host for rewrite mode"
                },
                "keepalive_pool": {
                  "type": "object",
                  "properties": {
                    "size": {
                      "type": "number",
                      "default": 320,
                      "description": "size"
                    },
                    "requests": {
                      "type": "number",
                      "default": 1000,
                      "description": "requests"
                    },
                    "idle_timeout": {
                      "type": "number",
                      "default": 60,
                      "description": "idle timeout"
                    }
                  },
                  "description": "keepalive pool configuration",
                  "additionalProperties": false
                }
              },
              "description": "upstream service configuration object",
              "additionalProperties": true
            }
          },
          "required": [
            "id",
            "upstream"
          ]
        }
      },
      {
        "name": "create_or_update_consumer",
        "description": "Create a consumer, if the consumer already exists, it will be updated",
        "inputSchema": {
          "type": "object",
          "properties": {
            "desc": {
              "type": "string",
              "description": "consumer description"
            },
            "labels": {
              "type": "object",
              "description": "consumer labels",
              "additionalProperties": {
                "type": "string"
              }
            },
            "plugins": {
              "type": "object",
              "description": "consumer plugins",
              "additionalProperties": {}
            },
            "group_id": {
              "type": "string",
              "description": "consumer group id"
            },
            "username": {
              "type": "string",
              "description": "consumer username"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_credential",
        "description": "Get all credentials or a specific credential for a consumer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "credential id"
            },
            "username": {
              "type": "string",
              "description": "consumer username"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "create_or_update_credential",
        "description": "Create or update a credential for a consumer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "credential id"
            },
            "username": {
              "type": "string",
              "description": "consumer username"
            },
            "credential": {
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "desc": {
                  "type": "string",
                  "maxLength": 256,
                  "description": "credential description"
                },
                "name": {
                  "type": "string",
                  "description": "credential name"
                },
                "labels": {
                  "type": "object",
                  "description": "credential labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "plugins": {
                  "type": "object",
                  "description": "credential plugins",
                  "additionalProperties": {}
                }
              },
              "description": "credential configuration object",
              "additionalProperties": true
            }
          },
          "required": [
            "username",
            "id",
            "credential"
          ]
        }
      },
      {
        "name": "delete_credential",
        "description": "Delete a credential for a consumer",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "credential id"
            },
            "username": {
              "type": "string",
              "description": "consumer username"
            }
          },
          "required": [
            "username",
            "id"
          ]
        }
      },
      {
        "name": "create_ssl",
        "description": "Create an SSL certificate",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "SSL certificate ID"
            },
            "ssl": {
              "type": "object",
              "required": [
                "cert",
                "key"
              ],
              "properties": {
                "key": {
                  "type": "string",
                  "description": "SSL private key in PEM format"
                },
                "sni": {
                  "type": "string",
                  "description": "Server Name Indication"
                },
                "cert": {
                  "type": "string",
                  "description": "SSL certificate in PEM format"
                },
                "keys": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "SSL private keys in PEM format"
                },
                "snis": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Server Name Indications"
                },
                "type": {
                  "enum": [
                    "server",
                    "client"
                  ],
                  "type": "string",
                  "default": "server",
                  "description": "SSL type"
                },
                "certs": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "SSL certificates in PEM format"
                },
                "label": {
                  "type": "string",
                  "description": "SSL label"
                },
                "client": {
                  "type": "object",
                  "required": [
                    "ca"
                  ],
                  "properties": {
                    "ca": {
                      "type": "string",
                      "description": "SSL client CA certificate in PEM format"
                    },
                    "depth": {
                      "type": "number",
                      "default": 1,
                      "description": "SSL client verification depth"
                    },
                    "skip_mtls_uri_regex": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "URIs to skip mTLS verification"
                    }
                  },
                  "description": "SSL client configuration",
                  "additionalProperties": false
                },
                "status": {
                  "enum": [
                    0,
                    1
                  ],
                  "type": "number",
                  "description": "SSL certificate status"
                },
                "validity_end": {
                  "type": "number",
                  "description": "SSL certificate validity end timestamp"
                },
                "validity_start": {
                  "type": "number",
                  "description": "SSL certificate validity start timestamp"
                }
              },
              "description": "SSL certificate configuration object",
              "additionalProperties": true
            }
          },
          "required": [
            "ssl"
          ]
        }
      },
      {
        "name": "update_ssl",
        "description": "Update specific attributes of an existing SSL certificate",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "SSL certificate ID"
            },
            "ssl": {
              "type": "object",
              "properties": {
                "key": {
                  "type": "string",
                  "description": "SSL private key in PEM format"
                },
                "sni": {
                  "type": "string",
                  "description": "Server Name Indication"
                },
                "cert": {
                  "type": "string",
                  "description": "SSL certificate in PEM format"
                },
                "keys": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "SSL private keys in PEM format"
                },
                "snis": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Server Name Indications"
                },
                "type": {
                  "enum": [
                    "server",
                    "client"
                  ],
                  "type": "string",
                  "default": "server",
                  "description": "SSL type"
                },
                "certs": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "SSL certificates in PEM format"
                },
                "label": {
                  "type": "string",
                  "description": "SSL label"
                },
                "client": {
                  "type": "object",
                  "required": [
                    "ca"
                  ],
                  "properties": {
                    "ca": {
                      "type": "string",
                      "description": "SSL client CA certificate in PEM format"
                    },
                    "depth": {
                      "type": "number",
                      "default": 1,
                      "description": "SSL client verification depth"
                    },
                    "skip_mtls_uri_regex": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "URIs to skip mTLS verification"
                    }
                  },
                  "description": "SSL client configuration",
                  "additionalProperties": false
                },
                "status": {
                  "enum": [
                    0,
                    1
                  ],
                  "type": "number",
                  "description": "SSL certificate status"
                },
                "validity_end": {
                  "type": "number",
                  "description": "SSL certificate validity end timestamp"
                },
                "validity_start": {
                  "type": "number",
                  "description": "SSL certificate validity start timestamp"
                }
              },
              "description": "SSL certificate configuration object",
              "additionalProperties": true
            }
          },
          "required": [
            "id",
            "ssl"
          ]
        }
      },
      {
        "name": "create_global_rule",
        "description": "Create a global rule",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "global rule ID"
            },
            "plugins": {
              "type": "object",
              "description": "plugins configuration",
              "additionalProperties": {}
            }
          },
          "required": [
            "id",
            "plugins"
          ]
        }
      },
      {
        "name": "update_global_rule",
        "description": "Update specific attributes of an existing global rule",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "global rule ID"
            },
            "plugins": {
              "type": "object",
              "description": "plugins configuration",
              "additionalProperties": {}
            }
          },
          "required": [
            "id",
            "plugins"
          ]
        }
      },
      {
        "name": "create_consumer_group",
        "description": "Create a consumer group",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "consumer group ID"
            },
            "consumerGroup": {
              "type": "object",
              "properties": {
                "desc": {
                  "type": "string",
                  "description": "consumer group description"
                },
                "labels": {
                  "type": "object",
                  "description": "consumer group labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "plugins": {
                  "type": "object",
                  "description": "consumer group plugins",
                  "additionalProperties": {}
                }
              },
              "description": "consumer group configuration object",
              "additionalProperties": true
            }
          },
          "required": [
            "consumerGroup"
          ]
        }
      },
      {
        "name": "update_consumer_group",
        "description": "Update specific attributes of an existing consumer group",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "consumer group ID"
            },
            "consumerGroup": {
              "type": "object",
              "properties": {
                "desc": {
                  "type": "string",
                  "description": "consumer group description"
                },
                "labels": {
                  "type": "object",
                  "description": "consumer group labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "plugins": {
                  "type": "object",
                  "description": "consumer group plugins",
                  "additionalProperties": {}
                }
              },
              "description": "consumer group configuration object",
              "additionalProperties": true
            }
          },
          "required": [
            "id",
            "consumerGroup"
          ]
        }
      },
      {
        "name": "get_all_plugin_names",
        "description": "Get all plugin names",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_plugin_schema",
        "description": "Get all plugins schema or a specific plugin schema by name",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "plugins name"
            },
            "type": {
              "enum": [
                "http",
                "stream"
              ],
              "type": "string",
              "description": "plugins type"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "get_plugin_metadata",
        "description": "Get metadata for a specific plugin",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "plugins name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "create_plugin_config",
        "description": "Create a new plugin config",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "plugin config ID"
            },
            "plugins": {
              "type": "object",
              "required": [
                "desc",
                "labels",
                "plugins"
              ],
              "properties": {
                "desc": {
                  "type": "string",
                  "description": "plugin config description"
                },
                "labels": {
                  "type": "object",
                  "description": "plugin config labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "plugins": {
                  "type": "object",
                  "description": "plugins configuration",
                  "additionalProperties": {}
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "id",
            "plugins"
          ]
        }
      },
      {
        "name": "update_plugin_config",
        "description": "Update a plugin config",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "plugin config ID"
            },
            "plugins": {
              "type": "object",
              "required": [
                "desc",
                "labels",
                "plugins"
              ],
              "properties": {
                "desc": {
                  "type": "string",
                  "description": "plugin config description"
                },
                "labels": {
                  "type": "object",
                  "description": "plugin config labels",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "plugins": {
                  "type": "object",
                  "description": "plugins configuration",
                  "additionalProperties": {}
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "id",
            "plugins"
          ]
        }
      },
      {
        "name": "create_or_update_plugin_metadata",
        "description": "Create or update plugin metadata",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "plugins name"
            },
            "metadata": {
              "type": "object",
              "description": "plugins configuration",
              "additionalProperties": {}
            }
          },
          "required": [
            "name",
            "metadata"
          ]
        }
      },
      {
        "name": "delete_plugin_metadata",
        "description": "Delete plugin metadata",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "plugins name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "create_or_update_stream_route",
        "description": "Create a stream route, if the stream route already exists, it will be updated",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "stream route id"
            },
            "route": {
              "type": "object",
              "required": [
                "server_addr",
                "server_port"
              ],
              "properties": {
                "sni": {
                  "type": "string",
                  "description": "SNI"
                },
                "desc": {
                  "type": "string",
                  "maxLength": 256,
                  "description": "stream route description"
                },
                "plugins": {
                  "type": "object",
                  "description": "plugins",
                  "additionalProperties": {}
                },
                "protocol": {
                  "type": "object",
                  "required": [
                    "name"
                  ],
                  "properties": {
                    "conf": {
                      "type": "object",
                      "description": "protocol-specific configuration",
                      "additionalProperties": {}
                    },
                    "name": {
                      "type": "string"
                    },
                    "logger": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": [
                          "name"
                        ],
                        "properties": {
                          "conf": {
                            "type": "object",
                            "description": "logger plugin configuration",
                            "additionalProperties": {}
                          },
                          "name": {
                            "type": "string"
                          },
                          "filter": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "description": "logger filter rules"
                          }
                        },
                        "additionalProperties": false
                      }
                    },
                    "superior_id": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                },
                "upstream": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string",
                      "description": "hash key for chash algorithm"
                    },
                    "tls": {
                      "type": "object",
                      "properties": {
                        "verify": {
                          "type": "boolean",
                          "description": "TLS verification"
                        },
                        "client_key": {
                          "type": "string",
                          "description": "TLS key"
                        },
                        "client_cert": {
                          "type": "string",
                          "description": "TLS certificate"
                        },
                        "client_cert_id": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          },
                          "description": "TLS certificate id"
                        }
                      },
                      "description": "TLS configuration",
                      "additionalProperties": false
                    },
                    "desc": {
                      "type": "string",
                      "maxLength": 256,
                      "description": "upstream description"
                    },
                    "name": {
                      "type": "string",
                      "description": "upstream name"
                    },
                    "type": {
                      "enum": [
                        "roundrobin",
                        "chash",
                        "ewma",
                        "least_conn"
                      ],
                      "type": "string",
                      "default": "roundrobin",
                      "description": "load balancing algorithm"
                    },
                    "nodes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": [
                          "host",
                          "port"
                        ],
                        "properties": {
                          "host": {
                            "type": "string",
                            "description": "upstream host"
                          },
                          "port": {
                            "type": "number",
                            "description": "upstream port"
                          },
                          "weight": {
                            "type": "number",
                            "minimum": 0,
                            "description": "upstream weight"
                          },
                          "priority": {
                            "type": "number",
                            "minimum": 0,
                            "description": "upstream priority"
                          }
                        },
                        "additionalProperties": false
                      },
                      "description": "upstream nodes with weights"
                    },
                    "checks": {
                      "type": "object",
                      "properties": {
                        "active": {
                          "type": "object",
                          "properties": {
                            "host": {
                              "type": "string",
                              "description": "host for health check"
                            },
                            "port": {
                              "type": "number",
                              "description": "port for health check"
                            },
                            "healthy": {
                              "type": "object",
                              "properties": {
                                "interval": {
                                  "type": "number",
                                  "description": "check interval for healthy status"
                                },
                                "successes": {
                                  "type": "number",
                                  "description": "success count threshold"
                                }
                              },
                              "additionalProperties": false
                            },
                            "timeout": {
                              "type": "number",
                              "description": "timeout for health check"
                            },
                            "http_path": {
                              "type": "string",
                              "description": "HTTP path for health check"
                            },
                            "unhealthy": {
                              "type": "object",
                              "properties": {
                                "interval": {
                                  "type": "number",
                                  "description": "check interval for unhealthy status"
                                },
                                "http_failures": {
                                  "type": "number",
                                  "description": "HTTP failure count threshold"
                                }
                              },
                              "additionalProperties": false
                            },
                            "https_verify_certificate": {
                              "type": "boolean",
                              "description": "verify HTTPS certificate"
                            }
                          },
                          "description": "active health check configuration",
                          "additionalProperties": false
                        },
                        "passive": {
                          "type": "object",
                          "properties": {
                            "healthy": {
                              "type": "object",
                              "properties": {
                                "successes": {
                                  "type": "number",
                                  "description": "success count threshold"
                                },
                                "http_statuses": {
                                  "type": "array",
                                  "items": {
                                    "type": "number"
                                  },
                                  "description": "HTTP status codes for healthy state"
                                }
                              },
                              "additionalProperties": false
                            },
                            "unhealthy": {
                              "type": "object",
                              "properties": {
                                "timeout": {
                                  "type": "number",
                                  "description": "timeout threshold"
                                },
                                "http_failures": {
                                  "type": "number",
                                  "description": "HTTP failure count threshold"
                                },
                                "http_statuses": {
                                  "type": "array",
                                  "items": {
                                    "type": "number"
                                  },
                                  "description": "HTTP status codes for unhealthy state"
                                }
                              },
                              "additionalProperties": false
                            }
                          },
                          "description": "passive health check configuration",
                          "additionalProperties": false
                        }
                      },
                      "description": "health check configuration",
                      "additionalProperties": false
                    },
                    "labels": {
                      "type": "object",
                      "description": "upstream labels",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "scheme": {
                      "enum": [
                        "http",
                        "https",
                        "grpc",
                        "grpcs",
                        "tcp",
                        "tls",
                        "udp",
                        "kafka"
                      ],
                      "type": "string",
                      "default": "http",
                      "description": "upstream scheme"
                    },
                    "hash_on": {
                      "enum": [
                        "vars",
                        "header",
                        "cookie",
                        "consumer",
                        "vars_combinations"
                      ],
                      "type": "string",
                      "description": "hash on type for chash algorithm"
                    },
                    "retries": {
                      "type": "number",
                      "minimum": 0,
                      "description": "retry count"
                    },
                    "timeout": {
                      "type": "object",
                      "properties": {
                        "read": {
                          "type": "number",
                          "description": "read timeout in seconds"
                        },
                        "send": {
                          "type": "number",
                          "description": "send timeout in seconds"
                        },
                        "connect": {
                          "type": "number",
                          "description": "connection timeout in seconds"
                        }
                      },
                      "description": "timeout configuration",
                      "additionalProperties": false
                    },
                    "pass_host": {
                      "enum": [
                        "pass",
                        "node",
                        "rewrite"
                      ],
                      "type": "string",
                      "default": "pass",
                      "description": "host passing mode"
                    },
                    "retry_timeout": {
                      "type": "number",
                      "minimum": 0,
                      "description": "retry timeout"
                    },
                    "upstream_host": {
                      "type": "string",
                      "description": "upstream host for rewrite mode"
                    },
                    "keepalive_pool": {
                      "type": "object",
                      "properties": {
                        "size": {
                          "type": "number",
                          "default": 320,
                          "description": "size"
                        },
                        "requests": {
                          "type": "number",
                          "default": 1000,
                          "description": "requests"
                        },
                        "idle_timeout": {
                          "type": "number",
                          "default": 60,
                          "description": "idle timeout"
                        }
                      },
                      "description": "keepalive pool configuration",
                      "additionalProperties": false
                    }
                  },
                  "description": "upstream service configuration object",
                  "additionalProperties": true
                },
                "service_id": {
                  "type": "string",
                  "description": "service id"
                },
                "remote_addr": {
                  "anyOf": [
                    {
                      "$ref": "#/properties/route/properties/server_addr/anyOf/0"
                    },
                    {
                      "$ref": "#/properties/route/properties/server_addr/anyOf/1"
                    },
                    {
                      "$ref": "#/properties/route/properties/server_addr/anyOf/2"
                    },
                    {
                      "$ref": "#/properties/route/properties/server_addr/anyOf/3"
                    }
                  ],
                  "description": "client IP"
                },
                "server_addr": {
                  "anyOf": [
                    {
                      "type": "string",
                      "format": "ipv4",
                      "description": "IPv4"
                    },
                    {
                      "type": "string",
                      "pattern": "^([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\/([12]?[0-9]|3[0-2])$",
                      "description": "IPv4/CIDR"
                    },
                    {
                      "type": "string",
                      "format": "ipv6",
                      "description": "IPv6"
                    },
                    {
                      "type": "string",
                      "pattern": "^([a-fA-F0-9]{0,4}:){1,8}(:[a-fA-F0-9]{0,4}){0,8}([a-fA-F0-9]{0,4})?\\/[0-9]{1,3}$",
                      "description": "IPv6/CIDR"
                    }
                  ],
                  "description": "server IP"
                },
                "server_port": {
                  "type": "number",
                  "description": "server port"
                },
                "upstream_id": {
                  "type": "string",
                  "description": "upstream id"
                }
              },
              "description": "stream route configuration",
              "additionalProperties": true
            }
          },
          "required": [
            "route"
          ]
        }
      },
      {
        "name": "get_secret_by_id",
        "description": "Get a secret by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "secret id"
            },
            "page": {
              "type": "number",
              "default": 1,
              "description": "page number"
            },
            "manager": {
              "enum": [
                "vault",
                "aws",
                "gcp"
              ],
              "type": "string",
              "description": "secret manager type"
            },
            "page_size": {
              "type": "number",
              "default": 50,
              "maximum": 500,
              "minimum": 10,
              "description": "page size"
            }
          },
          "required": [
            "manager"
          ]
        }
      },
      {
        "name": "create_secret",
        "description": "Create a secret",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "secret id"
            },
            "secret": {
              "anyOf": [
                {
                  "type": "object",
                  "required": [
                    "type",
                    "uri",
                    "prefix",
                    "token"
                  ],
                  "properties": {
                    "uri": {
                      "type": "string",
                      "description": "address of the Vault server"
                    },
                    "type": {
                      "type": "string",
                      "const": "vault"
                    },
                    "token": {
                      "type": "string",
                      "description": "token for Vault authentication"
                    },
                    "prefix": {
                      "type": "string",
                      "description": "path prefix of the secret engine"
                    },
                    "namespace": {
                      "type": "string",
                      "description": "Vault namespace"
                    }
                  },
                  "additionalProperties": false
                },
                {
                  "type": "object",
                  "required": [
                    "type",
                    "region",
                    "access_key_id",
                    "secret_access_key"
                  ],
                  "properties": {
                    "type": {
                      "type": "string",
                      "const": "aws"
                    },
                    "region": {
                      "type": "string",
                      "description": "AWS region"
                    },
                    "endpoint_url": {
                      "type": "string",
                      "description": "AWS secret manager endpoint url"
                    },
                    "access_key_id": {
                      "type": "string",
                      "description": "AWS access key"
                    },
                    "session_token": {
                      "type": "string",
                      "description": "AWS session token"
                    },
                    "secret_access_key": {
                      "type": "string",
                      "description": "AWS secret key"
                    }
                  },
                  "additionalProperties": false
                },
                {
                  "type": "object",
                  "required": [
                    "type",
                    "project_id"
                  ],
                  "properties": {
                    "type": {
                      "type": "string",
                      "const": "gcp"
                    },
                    "auth_file": {
                      "type": "string",
                      "description": "Path to the Google Cloud service account authentication JSON file"
                    },
                    "project_id": {
                      "type": "string",
                      "description": "GCP project ID"
                    },
                    "ssl_verify": {
                      "type": "boolean",
                      "default": true,
                      "description": "Enable SSL verification"
                    },
                    "auth_config": {
                      "type": "object",
                      "required": [
                        "client_email",
                        "private_key",
                        "project_id"
                      ],
                      "properties": {
                        "scope": {
                          "type": "string",
                          "default": "https://www.googleapis.com/auth/cloud-platform",
                          "description": "Access scopes of the Google Cloud service account"
                        },
                        "token_uri": {
                          "type": "string",
                          "default": "https://oauth2.googleapis.com/token",
                          "description": "Token URI of the Google Cloud service account"
                        },
                        "project_id": {
                          "type": "string",
                          "description": "Project ID in the Google Cloud service account"
                        },
                        "entries_uri": {
                          "type": "string",
                          "default": "https://secretmanager.googleapis.com/v1",
                          "description": "The API access endpoint for the Google Secrets Manager"
                        },
                        "private_key": {
                          "type": "string",
                          "description": "Private key of the Google Cloud service account"
                        },
                        "client_email": {
                          "type": "string",
                          "description": "Email address of the Google Cloud service account"
                        }
                      },
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false
                }
              ]
            },
            "manager": {
              "enum": [
                "vault",
                "aws",
                "gcp"
              ],
              "type": "string",
              "description": "secret manager type"
            }
          },
          "required": [
            "manager",
            "secret"
          ]
        }
      },
      {
        "name": "update_secret",
        "description": "Update specific attributes of an existing secret",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "secret id"
            },
            "secret": {
              "anyOf": [
                {
                  "type": "object",
                  "required": [
                    "type",
                    "uri",
                    "prefix",
                    "token"
                  ],
                  "properties": {
                    "uri": {
                      "type": "string",
                      "description": "address of the Vault server"
                    },
                    "type": {
                      "type": "string",
                      "const": "vault"
                    },
                    "token": {
                      "type": "string",
                      "description": "token for Vault authentication"
                    },
                    "prefix": {
                      "type": "string",
                      "description": "path prefix of the secret engine"
                    },
                    "namespace": {
                      "type": "string",
                      "description": "Vault namespace"
                    }
                  },
                  "additionalProperties": false
                },
                {
                  "type": "object",
                  "required": [
                    "type",
                    "region",
                    "access_key_id",
                    "secret_access_key"
                  ],
                  "properties": {
                    "type": {
                      "type": "string",
                      "const": "aws"
                    },
                    "region": {
                      "type": "string",
                      "description": "AWS region"
                    },
                    "endpoint_url": {
                      "type": "string",
                      "description": "AWS secret manager endpoint url"
                    },
                    "access_key_id": {
                      "type": "string",
                      "description": "AWS access key"
                    },
                    "session_token": {
                      "type": "string",
                      "description": "AWS session token"
                    },
                    "secret_access_key": {
                      "type": "string",
                      "description": "AWS secret key"
                    }
                  },
                  "additionalProperties": false
                },
                {
                  "type": "object",
                  "required": [
                    "type",
                    "project_id"
                  ],
                  "properties": {
                    "type": {
                      "type": "string",
                      "const": "gcp"
                    },
                    "auth_file": {
                      "type": "string",
                      "description": "Path to the Google Cloud service account authentication JSON file"
                    },
                    "project_id": {
                      "type": "string",
                      "description": "GCP project ID"
                    },
                    "ssl_verify": {
                      "type": "boolean",
                      "default": true,
                      "description": "Enable SSL verification"
                    },
                    "auth_config": {
                      "type": "object",
                      "required": [
                        "client_email",
                        "private_key",
                        "project_id"
                      ],
                      "properties": {
                        "scope": {
                          "type": "string",
                          "default": "https://www.googleapis.com/auth/cloud-platform",
                          "description": "Access scopes of the Google Cloud service account"
                        },
                        "token_uri": {
                          "type": "string",
                          "default": "https://oauth2.googleapis.com/token",
                          "description": "Token URI of the Google Cloud service account"
                        },
                        "project_id": {
                          "type": "string",
                          "description": "Project ID in the Google Cloud service account"
                        },
                        "entries_uri": {
                          "type": "string",
                          "default": "https://secretmanager.googleapis.com/v1",
                          "description": "The API access endpoint for the Google Secrets Manager"
                        },
                        "private_key": {
                          "type": "string",
                          "description": "Private key of the Google Cloud service account"
                        },
                        "client_email": {
                          "type": "string",
                          "description": "Email address of the Google Cloud service account"
                        }
                      },
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false
                }
              ]
            },
            "manager": {
              "enum": [
                "vault",
                "aws",
                "gcp"
              ],
              "type": "string",
              "description": "secret manager type"
            }
          },
          "required": [
            "id",
            "manager",
            "secret"
          ]
        }
      },
      {
        "name": "delete_secret",
        "description": "Delete a secret by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "secret id"
            },
            "manager": {
              "enum": [
                "vault",
                "aws",
                "gcp"
              ],
              "type": "string",
              "description": "secret manager type"
            }
          },
          "required": [
            "id",
            "manager"
          ]
        }
      },
      {
        "name": "create_or_update_proto",
        "description": "Create a proto, if the proto already exists, it will be updated",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "proto id"
            },
            "proto": {
              "type": "object",
              "required": [
                "content"
              ],
              "properties": {
                "content": {
                  "type": "string",
                  "description": "proto content"
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "proto"
          ]
        }
      }
    ]
  },
  {
    "name": "apw124-logseq-mcp",
    "title": "Logseq MCP Tools",
    "description": "A Model Context Protocol server that enables AI agents to interact with local Logseq knowledge graphs, supporting operations like creating/editing pages and blocks, searching content, and managing journal entries.",
    "icon": "https://avatars.githubusercontent.com/apw124",
    "isOfficial": false,
    "homepage": "https://github.com/apw124/logseq-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "logseq-mcp"
      ],
      "env": {
        "LOGSEQ_TOKEN": "<logseq-token>",
        "LOGSEQ_API_URL": "<logseq-api-url>"
      }
    },
    "parameters": [
      {
        "name": "LOGSEQ_TOKEN",
        "description": "Your Logseq API token from the Advanced settings",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "LOGSEQ_API_URL",
        "description": "The URL of the Logseq API",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_all_pages",
        "description": "\n    Gets all pages from the Logseq graph.\n    \n    Journal pages can be identified by the \"journal?\" attribute set to true and \n    will include a \"journalDay\" attribute in the format YYYYMMDD.\n    \n    Returns:\n        list: A list of all pages in the Logseq graph.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_page",
        "description": "\n    Gets a specific page from the Logseq graph by name.\n    \n    For journal pages, use the format \"mmm dth, yyyy\" (e.g., \"Apr 4th, 2025\").\n    Note that journal pages are automatically created in Logseq with this date format.\n    \n    Journal pages have specific attributes:\n    - \"journal?\": true - Indicates this is a journal page\n    - \"journalDay\": YYYYMMDD - The date in numeric format (e.g., 20250404 for April 4, 2025)\n    \n    Args:\n        name (str): The name of the page to retrieve.\n        \n    Returns:\n        dict: Information about the requested page.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "create_page",
        "description": "\n    Creates a new page in the Logseq graph.\n    \n    For journal pages, use the format \"mmm dth, yyyy\" (e.g., \"Apr 4th, 2025\").\n    Journal pages are specially formatted in Logseq with automatic dating.\n    \n    When you create a journal page, Logseq automatically:\n    - Sets \"journal?\": true\n    - Sets \"journalDay\": YYYYMMDD (e.g., 20250404 for April 4, 2025)\n    - Formats the page as a journal entry\n    \n    Args:\n        name (str): The name of the new page.\n        properties (dict, optional): Properties to set on the new page.\n        \n    Returns:\n        dict: Information about the created page.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "properties": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Properties",
              "default": null
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "delete_page",
        "description": "\n    Deletes a page from the Logseq graph.\n    \n    This operation removes the specified page and all its blocks. This action cannot be undone.\n    \n    For journal pages, use the format \"mmm dth, yyyy\" (e.g., \"Apr 4th, 2025\").\n    \n    Args:\n        name (str): The name of the page to delete.\n        \n    Returns:\n        dict: Result of the deletion operation.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "get_page_linked_references",
        "description": "\n    Gets all linked references to a specific page in the Logseq graph.\n    \n    This returns blocks that contain links to the specified page using\n    the Logseq double bracket notation: [[Page Name]].\n    \n    For journal pages, use the format \"mmm dth, yyyy\" (e.g., \"Apr 4th, 2025\").\n    \n    Args:\n        page_name (str): The name of the page to find references to.\n        \n    Returns:\n        list: A list of blocks that reference the specified page.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_name": {
              "type": "string",
              "title": "Page Name"
            }
          },
          "required": [
            "page_name"
          ]
        }
      },
      {
        "name": "get_page_blocks",
        "description": "\n    Gets all blocks from a specific page in the Logseq graph.\n    \n    For journal pages, use the format \"mmm dth, yyyy\" (e.g., \"Apr 4th, 2025\").\n    Returned blocks contain information about their hierarchical structure:\n      - parent: The parent block's ID\n      - level: The indentation level (1 for top-level, 2+ for indented blocks)\n      - left: The block to the left (typically the parent for indented blocks)\n    \n    Blocks from journal pages will have:\n      - \"journal?\": true\n      - \"journalDay\": YYYYMMDD - The date in numeric format (e.g., 20250404)\n    \n    Args:\n        page_name (str): The name of the page to retrieve blocks from.\n        \n    Returns:\n        list: A list of blocks from the specified page.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_name": {
              "type": "string",
              "title": "Page Name"
            }
          },
          "required": [
            "page_name"
          ]
        }
      },
      {
        "name": "get_block",
        "description": "\n    Gets a specific block from the Logseq graph by its ID.\n    \n    The returned block contains information about its hierarchical structure:\n      - parent: The parent block's ID\n      - level: The indentation level (1 for top-level, 2+ for indented blocks)\n      - left: The block to the left (typically the parent for indented blocks)\n    \n    If the block is from a journal page, it will include:\n      - \"journal?\": true\n      - \"journalDay\": YYYYMMDD - Date in numeric format\n    \n    Args:\n        block_id (str): The ID of the block to retrieve.\n        \n    Returns:\n        dict: Information about the requested block.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "block_id": {
              "type": "string",
              "title": "Block Id"
            }
          },
          "required": [
            "block_id"
          ]
        }
      },
      {
        "name": "create_block",
        "description": "\n    Creates a new block on a page in the Logseq graph.\n    \n    IMPORTANT NOTES:\n    1. All blocks are automatically formatted as bullet points in Logseq UI\n    2. To create links to other pages, use double brackets: [[Page Name]]\n    \n    When creating blocks on journal pages:\n      - The block will inherit the \"journal?\" and \"journalDay\" attributes from the page\n      - \"journalDay\" will be in YYYYMMDD format (e.g., 20250404 for April 4, 2025)\n    \n    Args:\n        page_name (str): The name of the page to create the block on.\n        content (str): The content of the new block.\n        properties (dict, optional): Properties to set on the new block.\n        \n    Returns:\n        dict: Information about the created block.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "title": "Content"
            },
            "page_name": {
              "type": "string",
              "title": "Page Name"
            },
            "properties": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Properties",
              "default": null
            }
          },
          "required": [
            "page_name",
            "content"
          ]
        }
      },
      {
        "name": "insert_block",
        "description": "\n    Inserts a new block as a child of the specified parent block.\n    \n    This allows for creating hierarchical content by adding children to existing blocks.\n    \n    IMPORTANT NOTES:\n    1. All blocks are automatically formatted as bullet points in Logseq UI\n    2. To create links to other pages, use double brackets: [[Page Name]]\n    3. The new block will be inserted at the beginning or end of the parent's children\n       depending on the 'before' parameter\n    \n    When inserting blocks into journal pages:\n      - The block will inherit the \"journal?\" and \"journalDay\" attributes\n      - \"journalDay\" will be in YYYYMMDD format (e.g., 20250404 for April 4, 2025)\n    \n    Args:\n        parent_block_id (str): The ID of the parent block to insert under.\n        content (str): The content of the new block.\n        properties (dict, optional): Properties to set on the new block.\n        before (bool, optional): Whether to insert at the beginning of children. \n                                Default is False (append at the end).\n        \n    Returns:\n        dict: Information about the created block.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "before": {
              "type": "boolean",
              "title": "Before",
              "default": false
            },
            "content": {
              "type": "string",
              "title": "Content"
            },
            "properties": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Properties",
              "default": null
            },
            "parent_block_id": {
              "type": "string",
              "title": "Parent Block Id"
            }
          },
          "required": [
            "parent_block_id",
            "content"
          ]
        }
      },
      {
        "name": "update_block",
        "description": "\n    Updates an existing block in the Logseq graph.\n    \n    IMPORTANT NOTES:\n    1. All blocks are automatically formatted as bullet points in Logseq UI\n    2. To create links to other pages, use double brackets: [[Page Name]]\n    \n    When updating blocks on journal pages:\n      - The \"journal?\" and \"journalDay\" attributes will be preserved\n      - \"journalDay\" will remain in YYYYMMDD format (e.g., 20250404)\n    \n    Args:\n        block_id (str): The ID of the block to update.\n        content (str): The new content for the block.\n        properties (dict, optional): Properties to update on the block.\n        \n    Returns:\n        dict: Information about the updated block.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "title": "Content"
            },
            "block_id": {
              "type": "string",
              "title": "Block Id"
            },
            "properties": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Properties",
              "default": null
            }
          },
          "required": [
            "block_id",
            "content"
          ]
        }
      },
      {
        "name": "move_block",
        "description": "\n    Moves a block to a new location in the graph.\n    \n    This allows for reorganizing the structure of blocks in the graph by moving\n    a block (and all its children) to a different location.\n    \n    IMPORTANT NOTES:\n    1. The block will maintain its children when moved\n    2. The hierarchical position depends on the 'as_child' parameter:\n       - If as_child=True: The block becomes a child of the target block\n       - If as_child=False: The block becomes a sibling after the target block\n    \n    Args:\n        block_id (str): The ID of the block to move.\n        target_block_id (str): The ID of the target block to move to.\n        as_child (bool, optional): Whether to make the block a child of the target.\n                                  Default is False (insert as sibling).\n        \n    Returns:\n        dict: Result of the move operation.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "as_child": {
              "type": "boolean",
              "title": "As Child",
              "default": false
            },
            "block_id": {
              "type": "string",
              "title": "Block Id"
            },
            "target_block_id": {
              "type": "string",
              "title": "Target Block Id"
            }
          },
          "required": [
            "block_id",
            "target_block_id"
          ]
        }
      },
      {
        "name": "remove_block",
        "description": "\n    Removes a block from the Logseq graph.\n    \n    This operation permanently removes the specified block and all its children.\n    This action cannot be undone.\n    \n    To remove a block, you need its block ID, which can be obtained from:\n    - get_page_blocks() function\n    - get_block() function\n    - search_blocks() function\n    \n    Args:\n        block_id (str): The ID of the block to remove.\n        \n    Returns:\n        dict: Result of the removal operation.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "block_id": {
              "type": "string",
              "title": "Block Id"
            }
          },
          "required": [
            "block_id"
          ]
        }
      },
      {
        "name": "search_blocks",
        "description": "\n    Searches for blocks matching a query in the Logseq graph.\n    \n    Examples of useful queries:\n    - page:\"Page Name\" - find all blocks on a specific page\n    - \"search term\" - find blocks containing the term\n    - page:\"Apr 4th, 2025\" - find all blocks in a journal\n    - [[Page Name]] - find references to a specific page\n    \n    Returned blocks from journal pages will include:\n    - \"journal?\": true\n    - \"journalDay\": YYYYMMDD - The date in numeric format\n    \n    Args:\n        query (str): The search query.\n        \n    Returns:\n        list: A list of blocks matching the search query.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "arabold-docs-mcp-server",
    "title": "docs-mcp-server",
    "description": "A Model Context Protocol (MCP) server that scrapes, indexes, and searches documentation for third-party software libraries and packages, supporting versioning and hybrid search.",
    "icon": "https://avatars.githubusercontent.com/arabold",
    "isOfficial": false,
    "homepage": "https://github.com/arabold/docs-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@arabold/docs-mcp-server"
      ],
      "env": {
        "OPENAI_API_KEY": "<openai-api-key>"
      }
    },
    "parameters": [
      {
        "name": "OPENAI_API_KEY",
        "description": "Your OpenAI API key for generating vector embeddings",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "arjunkmrm-mcp-minecraft",
    "title": "mcp-minecraft",
    "description": "Allows AI models to observe and interact with the Minecraft world through a bot.",
    "icon": "https://avatars.githubusercontent.com/arjunkmrm",
    "isOfficial": false,
    "homepage": "https://github.com/arjunkmrm/mcp-minecraft",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-minecraft"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "aashari-mcp-server-atlassian-confluence",
    "title": "Atlassian Confluence MCP Server",
    "description": "A Model Context Protocol server that enables AI assistants like Claude to access and search Atlassian Confluence content, allowing integration with your organization's knowledge base.",
    "icon": "https://avatars.githubusercontent.com/aashari",
    "isOfficial": false,
    "homepage": "https://github.com/aashari/mcp-server-atlassian-confluence",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@aashari/mcp-server-atlassian-confluence"
      ],
      "env": {
        "DEBUG": "<debug>",
        "ATLASSIAN_API_TOKEN": "<atlassian-api-token>",
        "ATLASSIAN_SITE_NAME": "<atlassian-site-name>",
        "ATLASSIAN_USER_EMAIL": "<atlassian-user-email>"
      }
    },
    "parameters": [
      {
        "name": "DEBUG",
        "description": "Enable debug logging",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ATLASSIAN_API_TOKEN",
        "description": "The API token created in your Atlassian account",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "ATLASSIAN_SITE_NAME",
        "description": "Your Atlassian site name (e.g., for example.atlassian.net, enter example)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "ATLASSIAN_USER_EMAIL",
        "description": "Your Atlassian account email address",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "list_spaces",
        "description": "List available Confluence spaces with filtering options and pagination support.\n\n        PURPOSE: Discovers accessible Confluence spaces, providing metadata about each space including ID, key, name, description, and status. This tool is essential for finding spaces before working with their content.\n\n        WHEN TO USE:\n        - When you need to discover what spaces exist in the Confluence instance.\n        - When you need to find a space's ID or key to use with other tools.\n        - When you need to filter spaces by type ('global', 'personal', 'archived').\n        - When you need to locate a space by partial name matching.\n        - When you need to browse available content sources.\n        - As a first step before using 'list_pages' or content search tools.\n\n        WHEN NOT TO USE:\n        - When you already know the specific space ID/key (use 'get_space' instead).\n        - When you need to search for page content (use 'search' instead).\n        - When you need to list pages within a known space (use 'list_pages' instead).\n        - When you need detailed information about a specific space (use 'get_space' instead).\n\n        RETURNS: Formatted list of spaces including:\n        - Numeric ID (used for most API operations)\n        - Space key (short identifier, e.g., 'DEV', 'HR', etc.)\n        - Display name and description\n        - Type (global, personal) and status (current, archived)\n        - Creation information and URL\n        \n        Results can be paginated using the 'limit' and 'cursor' parameters.\n        \n        SORTING: By default, spaces are sorted by name in descending order.\n\n        EXAMPLES:\n        - List all spaces: {}\n        - Filter by type: { type: [\"global\"] }\n        - Filter by status: { status: [\"current\"] }\n        - Search by name: { query: \"Engineering\" }\n        - With pagination: { limit: 20, cursor: \"some-cursor-value\" }\n\n        ERRORS:\n        - Authentication failures: Check Confluence credentials.\n        - Permission issues: Ensure you have access to view spaces.\n        - Invalid filter values: Verify type/status values match allowed options.\n        - No spaces found: May indicate permission issues or overly restrictive filters.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "global",
                "personal",
                "archived"
              ],
              "type": "string",
              "description": "Filter spaces by type. Options include: \"global\" (team spaces), \"personal\" (user spaces), or \"archived\" (archived spaces). If omitted, returns all types."
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1,
              "description": "Maximum number of items to return (1-100). Use this to control the response size. Useful for pagination or when you only need a few results. The Confluence API caps results at 100 items per request."
            },
            "query": {
              "type": "string",
              "description": "Search filter to find spaces matching specific text in their name, key, or description (text search)."
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for retrieving the next set of results. Use this to navigate through large result sets. The cursor value can be obtained from the pagination information in a previous response."
            },
            "status": {
              "enum": [
                "current",
                "archived"
              ],
              "type": "string",
              "description": "Filter spaces by status. Options include: \"current\" (active spaces) or \"archived\" (archived spaces). If omitted, returns spaces with all statuses."
            }
          }
        }
      },
      {
        "name": "get_space",
        "description": "Retrieve comprehensive details about a specific Confluence space by ID.\n\n        PURPOSE: Fetches complete metadata and configuration information for a space, identified by its numeric ID. Provides all available details about a space, including permissions, themes, and homepage.\n\n        WHEN TO USE:\n        - When you need detailed information about a specific space's configuration.\n        - When you need the numeric ID of a space's homepage to use with 'get_page'.\n        - When you need to verify permissions, status, or theme settings.\n        - When you need to analyze space metadata before working with its content.\n        - After finding a space through 'list_spaces' and needing more details.\n        - When you need to determine if a space is active, archived, or has specific restrictions.\n\n        WHEN NOT TO USE:\n        - When you need to discover spaces (use 'list_spaces' instead).\n        - When you need to list pages in a space (use 'list_pages' instead).\n        - When you need to search for content (use 'search' instead).\n        - When you only have a space key and need the ID (use 'list_spaces' first).\n\n        RETURNS: Comprehensive space details formatted in Markdown, including:\n        - Full name, key, and ID information\n        - Description and homepage details\n        - Type, status, and theme configuration\n        - Permissions and restrictions\n        - Creation and modification metadata\n        - URLs for accessing the space directly\n        \n        All available metadata is fetched by default to provide complete information.\n\n        EXAMPLES:\n        - Get space with ID 123456: { spaceId: \"123456\" }\n\n        ERRORS:\n        - Space not found (404): Verify the numeric space ID exists and is accessible.\n        - Permission denied (403): Check if you have access to the space.\n        - Authentication failure: Verify Confluence credentials.\n        - Invalid ID format: Ensure the spaceId is a valid numeric identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceKey": {
              "type": "string",
              "description": "The key of the Confluence space to retrieve (e.g., \"DEV\" or \"MARKETING\"). The space key is a unique identifier for a space, typically a short uppercase code."
            }
          },
          "required": [
            "spaceKey"
          ]
        }
      },
      {
        "name": "list_pages",
        "description": "List Confluence pages, optionally filtering by space ID(s), status, or title/content/label query, with pagination.\n\n        PURPOSE: Discover pages within specific spaces or across the instance based on status or simple text matching. Provides page metadata and IDs needed for the 'get_page' tool.\n\n        WHEN TO USE:\n        - To list pages within one or more specific spaces (using 'spaceId').\n        - To find pages based on their status ('current', 'archived', etc.).\n        - To perform simple text searches on page titles or labels ('query').\n        - To get an overview of recent pages in a space before getting full content.\n        - To obtain 'pageId' values for use with 'get_page'.\n\n        WHEN NOT TO USE:\n        - When you need to search the *full content* of pages with complex logic (use 'search' with CQL).\n        - When you already know the 'pageId' and need details (use 'get_page').\n        - When you need space information (use space tools).\n        - If you only have the space *key* (use 'list-spaces' or 'get-space' to find the numeric 'spaceId' first).\n\n        RETURNS: Formatted list of pages including ID, title, space ID, status, author, creation date, version, and URL. Includes pagination details if applicable (Confluence uses cursor-based pagination).\n        \n        SORTING: By default, pages are sorted by modified date in descending order (most recently modified first). You can change this by specifying a different value in the 'sort' parameter (e.g., \"title\" for alphabetical sorting).\n\n        EXAMPLES:\n        - List pages in space 123456: { spaceId: [\"123456\"] }\n        - List archived pages in space 123456: { spaceId: [\"123456\"], status: [\"archived\"] }\n        - Find pages with \"Project Plan\" in title/label in space 123456: { spaceId: [\"123456\"], query: \"Project Plan\" }\n        - Paginate results: { limit: 10, cursor: \"some-cursor-value\" }\n        - Sort pages by title: { spaceId: [\"123456\"], sort: \"title\" }\n\n        ERRORS:\n        - Space ID not found: Verify the numeric 'spaceId' is correct.\n        - Invalid status: Ensure 'status' is one of the allowed values.\n        - Authentication failures: Check Confluence credentials.\n        - No pages found: Filters might be too restrictive, or the space is empty/inaccessible.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "enum": [
                "id",
                "-id",
                "created-date",
                "-created-date",
                "modified-date",
                "-modified-date",
                "title",
                "-title"
              ],
              "type": "string",
              "description": "Property to sort pages by. Default is \"-modified-date\" which displays the most recently modified pages first. The \"-\" prefix indicates descending order. Valid values: \"id\", \"-id\", \"created-date\", \"-created-date\", \"modified-date\", \"-modified-date\", \"title\", \"-title\"."
            },
            "limit": {
              "type": "number",
              "maximum": 250,
              "minimum": 1,
              "description": "Maximum number of items to return (1-250). Use this to control the response size. Useful for pagination or when you only need a few results. The Confluence API caps results at 250 items per request."
            },
            "query": {
              "type": "string",
              "description": "Filter pages by title, content, or labels (text search). Use this to narrow down results to specific topics or content."
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for retrieving the next set of results. Use this to navigate through large result sets. The cursor value can be obtained from the pagination information in a previous response."
            },
            "status": {
              "type": "array",
              "items": {
                "enum": [
                  "current",
                  "trashed",
                  "deleted",
                  "draft",
                  "archived",
                  "historical"
                ],
                "type": "string"
              },
              "description": "Filter pages by status. Options include: \"current\" (published pages), \"trashed\" (pages in trash), \"deleted\" (permanently deleted), \"draft\" (unpublished drafts), \"archived\" (archived pages), or \"historical\" (previous versions). Defaults to \"current\" if not specified. Provide as an array to include multiple statuses."
            },
            "spaceId": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter pages by space IDs. Provide an array of space IDs (e.g., [\"123456\", \"789012\"]) to only show pages from specific spaces. Useful when you want to focus on content from particular projects or teams."
            }
          }
        }
      },
      {
        "name": "get_page",
        "description": "Retrieve a Confluence page's full content and metadata by its numeric ID.\n\n        PURPOSE: Fetches the complete content (converted to Markdown) and comprehensive metadata for a specific Confluence page, identified by its numeric ID. The page content is properly formatted with headings, tables, lists, and other Markdown elements.\n\n        WHEN TO USE:\n        - When you need to read, analyze, or summarize the full content of a specific page.\n        - When you need detailed page metadata (author, version, status, etc.).\n        - After finding a page ID through 'list_pages' or 'search' and need its complete content.\n        - When you need the actual content of a page rather than just its metadata.\n\n        WHEN NOT TO USE:\n        - When you only have a space ID or space key (use 'list_pages' first).\n        - When you need to find pages based on criteria (use 'list_pages' or 'search').\n        - When you want to discover spaces rather than specific pages (use space tools).\n        - When you need to search across multiple pages (use 'search').\n\n        RETURNS: Comprehensive page details formatted in Markdown, including:\n        - Full title, space information, and creation metadata\n        - Complete page content (converted from Atlassian Document Format to Markdown)\n        - Version information, permissions status, and URL\n        - Metadata including labels, restrictions, and ancestors\n        \n        The page content is fetched using the Confluence Content REST API, with the body transformed from ADF (Atlassian Document Format) to readable Markdown.\n\n        EXAMPLES:\n        - Get page with ID 123456: { pageId: \"123456\" }\n\n        ERRORS:\n        - Page not found (404): Verify the numeric page ID exists and is accessible.\n        - Permission denied (403): Check if the page has view restrictions.\n        - Authentication failure: Verify API credentials.\n        - Content conversion failures: Some complex content elements may not convert perfectly to Markdown.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pageId": {
              "type": "string",
              "description": "The numeric ID of the Confluence page to retrieve (e.g., \"456789\"). This is required and must be a valid page ID from your Confluence instance. The page content will be returned in Markdown format for easy reading."
            }
          },
          "required": [
            "pageId"
          ]
        }
      },
      {
        "name": "search",
        "description": "Search Confluence content using CQL (Confluence Query Language) for precise results.\n\n        PURPOSE: Performs advanced content searches across Confluence using CQL queries, allowing for complex search patterns, content filtering, and targeted results. This is the most powerful search tool for Confluence, supporting complex filtering and sorting.\n\n        WHEN TO USE:\n        - When you need to search for specific text or patterns within page content (not just titles).\n        - When you need to combine multiple search criteria (e.g., text + space + date + type).\n        - When you need to search using complex logical operators (AND, OR, NOT).\n        - When simple title/label searches via 'list_pages' are insufficient.\n        - When you need to search across all content types (pages, blog posts, attachments, etc.).\n        - When you need fine-grained sorting control over search results.\n\n        WHEN NOT TO USE:\n        - When you already know the page ID (use 'get_page' instead).\n        - When you only need to list pages in a space by title (use 'list_pages' with optional query).\n        - When you need to explore or browse spaces (use space-related tools).\n        - When you're not searching for actual content (e.g., for space metadata).\n\n        RETURNS: Formatted search results including:\n        - Result type (page, blog, attachment, etc.)\n        - Title and content excerpt with highlighted match terms\n        - Space information, creation metadata, and URL\n        - Content ID for use with other tools like 'get_page'\n        \n        Results can be paginated using the 'limit' and 'cursor' parameters.\n\n        CQL EXAMPLES:\n        - Basic text search: { cql: \"text ~ 'project plan'\" }\n        - Combined criteria: { cql: \"text ~ 'quarterly report' AND space = DEV AND type = 'page'\" }\n        - Date filtering: { cql: \"created >= '2023-01-01' AND created <= '2023-12-31'\" }\n        - Content by specific user: { cql: \"creator = 'jsmith'\" }\n        - Exact phrase with label: { cql: \"text = 'API Documentation' AND label = 'public'\" }\n        \n        Common CQL fields:\n        - text: Full-text content search\n        - title: Title search\n        - space: Space key\n        - type: Content type (page, blogpost, attachment)\n        - created/modified: Date criteria\n        - label: Content labels\n        - creator/contributor: User references\n\n        ERRORS:\n        - Invalid CQL syntax: Check query format against CQL documentation.\n        - No results: Try broadening search criteria.\n        - Authentication/permission failures: Ensure proper credentials.\n        - Rate limiting: For large result sets, use pagination and caching.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cql": {
              "type": "string",
              "description": "Search query using Confluence Query Language (CQL). Use this to search for content using standard CQL syntax (e.g., \"text ~ 'project plan' AND space = DEV\"). If omitted, returns recent content sorted by last modified date."
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1,
              "description": "Maximum number of items to return (1-100). Use this to control the response size. Useful for pagination or when you only need a few results. The Confluence search API caps results at 100 items per request."
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for retrieving the next set of results. Use this to navigate through large result sets. The cursor value can be obtained from the pagination information in a previous response."
            }
          }
        }
      }
    ]
  },
  {
    "name": "auto-browse-unbundle_openapi_mcp",
    "title": "Unbundle OpenAPI Specs MCP",
    "description": "Unbundle OpenAPI Specs MCP",
    "icon": "https://avatars.githubusercontent.com/auto-browse",
    "isOfficial": false,
    "homepage": "https://github.com/auto-browse/unbundle_openapi_mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@auto-browse/unbundle-openapi-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "split_openapi",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "apiPath": {
              "type": "string",
              "description": "Absolute path to the input OpenAPI definition file."
            },
            "outputDir": {
              "type": "string",
              "description": "Absolute path to the directory for split output files."
            }
          },
          "required": [
            "apiPath",
            "outputDir"
          ]
        }
      },
      {
        "name": "extract_openapi_endpoints",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputApiPath": {
              "type": "string",
              "description": "Absolute path to the large input OpenAPI definition file."
            },
            "outputApiPath": {
              "type": "string",
              "description": "Absolute path where the final, smaller bundled OpenAPI file should be saved."
            },
            "endpointsToKeep": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of exact endpoint paths to keep (e.g., ['/users', '/users/{id}'])."
            }
          },
          "required": [
            "inputApiPath",
            "endpointsToKeep",
            "outputApiPath"
          ]
        }
      }
    ]
  },
  {
    "name": "automation-ai-labs-mcp-wait",
    "title": "MCP-Wait",
    "description": "A simple MCP server that provides waiting functionality to pause until other tasks finish, with progress reporting and support for CLI or HTTP server with SSE.",
    "icon": "https://avatars.githubusercontent.com/automation-ai-labs",
    "isOfficial": false,
    "homepage": "https://github.com/automation-ai-labs/mcp-wait",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@automation-ai-labs/mcp-wait"
      ],
      "env": {
        "PORT": "<port>",
        "TRANSPORT_TYPE": "<transport-type>"
      }
    },
    "parameters": [
      {
        "name": "PORT",
        "description": "The port to use when running as an SSE server",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TRANSPORT_TYPE",
        "description": "The transport type for the MCP server (stdio or sse)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "wait",
        "description": "Wait for a specified number of seconds, useful for waiting for other tasks to finish",
        "inputSchema": {
          "type": "object",
          "properties": {
            "seconds": {
              "type": "number",
              "maximum": 300,
              "minimum": 0,
              "description": "The number of seconds to wait (0-300)"
            }
          },
          "required": [
            "seconds"
          ]
        }
      }
    ]
  },
  {
    "name": "automcp-app-linkd-mcp",
    "title": "Linkd MCP Server",
    "description": "An unofficial Model Context Protocol server that enables programmatic access to LinkedIn data through tools like user search, company search, profile enrichment, and contact retrieval.",
    "icon": "https://avatars.githubusercontent.com/automcp-app",
    "isOfficial": false,
    "homepage": "https://github.com/automcp-app/linkd-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "linkd-mcp"
      ],
      "env": {
        "LINKD_API_KEY": "<linkd-api-key>"
      }
    },
    "parameters": [
      {
        "name": "LINKD_API_KEY",
        "description": "Your Linkd API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "search_for_users",
        "description": "Search for users on Linkd using filters like query, school, and match threshold.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "maximum": 30,
              "minimum": 1,
              "description": "Maximum number of results to return (1–30)"
            },
            "query": {
              "type": "string",
              "description": "The search query, e.g., 'People working on AI at FAANG'"
            },
            "school": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter by school name(s), e.g., ['Stanford', 'MIT']"
            },
            "acceptance_threshold": {
              "type": "number",
              "default": 60,
              "maximum": 100,
              "minimum": 0,
              "description": "Match score threshold between 0 and 100"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "search_for_companies",
        "description": "Search for companies on Linkd using filters like query and match threshold.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "maximum": 30,
              "minimum": 1,
              "description": "Maximum number of results to return (1–30)"
            },
            "query": {
              "type": "string",
              "description": "The search query, e.g., 'Tech companies in California'"
            },
            "acceptance_threshold": {
              "type": "number",
              "default": 60,
              "maximum": 100,
              "minimum": 0,
              "description": "Match score threshold between 0 and 100"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "enrich_linkedin",
        "description": "Retrieves detailed profile information for a specific LinkedIn URL. Each successful lookup costs 1 credit.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The LinkedIn profile URL to look up."
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "retrieve_contacts",
        "description": "Retrieves email addresses and phone numbers for a LinkedIn profile. Each lookup costs 1 credit.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "linkedin_url": {
              "type": "string",
              "description": "The LinkedIn profile URL to look up."
            }
          },
          "required": [
            "linkedin_url"
          ]
        }
      },
      {
        "name": "scrape_linkedin",
        "description": "Retrieves detailed profile data and posts with comments from a LinkedIn profile URL using RapidAPI. Each request costs 2 credits.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "linkedin_url": {
              "type": "string",
              "description": "The LinkedIn profile URL to scrape."
            }
          },
          "required": [
            "linkedin_url"
          ]
        }
      },
      {
        "name": "initiate_deep_research",
        "description": "Initiate a deep research job that combines multiple search variations with optional email enrichment. Each result costs 1 credit.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 30,
              "maximum": 100,
              "description": "Maximum number of results to return (default: 30, max: 100)"
            },
            "query": {
              "type": "string",
              "description": "The search query to research"
            },
            "school": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter results by school names"
            },
            "enrich_emails": {
              "type": "boolean",
              "default": true,
              "description": "Whether to enrich results with contact information (default: true)"
            },
            "acceptance_threshold": {
              "type": "number",
              "default": 60,
              "maximum": 100,
              "minimum": 0,
              "description": "Acceptance score threshold (0-100) for a match (default: 60)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "check_deep_research_status",
        "description": "Check the status of an ongoing deep research job.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "description": "The job ID to check status for"
            }
          },
          "required": [
            "job_id"
          ]
        }
      }
    ]
  },
  {
    "name": "awesimon-elasticsearch-mcp",
    "title": "Elasticsearch MCP Server",
    "description": "Connects agents to Elasticsearch data using the Model Context Protocol, allowing natural language interaction with Elasticsearch indices through MCP Clients like Claude Desktop and Cursor.",
    "icon": "https://avatars.githubusercontent.com/awesimon",
    "isOfficial": false,
    "homepage": "https://github.com/awesimon/elasticsearch-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@awesome-ai/elasticsearch-mcp"
      ],
      "env": {
        "HOST": "<host>",
        "API_KEY": "<api-key>",
        "CA_CERT": "<ca-cert>",
        "PASSWORD": "<password>",
        "USERNAME": "<username>"
      }
    },
    "parameters": [
      {
        "name": "HOST",
        "description": "Your Elasticsearch instance URL",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "API_KEY",
        "description": "Elasticsearch API key for authentication",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CA_CERT",
        "description": "Path to custom CA certificate for Elasticsearch SSL/TLS",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "PASSWORD",
        "description": "Elasticsearch password for basic authentication",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "USERNAME",
        "description": "Elasticsearch username for basic authentication",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "awkoy-replicate-flux-mcp",
    "title": "replicate-flux-mcp",
    "description": "MCP for Replicate Flux Model. Generating images by prompts",
    "icon": "https://avatars.githubusercontent.com/awkoy",
    "isOfficial": false,
    "homepage": "https://github.com/awkoy/replicate-flux-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "replicate-flux-mcp"
      ],
      "env": {
        "REPLICATE_API_TOKEN": "<replicate-api-token>"
      }
    },
    "parameters": [
      {
        "name": "REPLICATE_API_TOKEN",
        "description": "Your Replicate API token for accessing the Flux Schnell model",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "generate_image",
        "description": "Generate an image from a text prompt using Flux Schnell model",
        "inputSchema": {
          "type": "object",
          "properties": {
            "seed": {
              "type": "integer",
              "description": "Random seed. Set for reproducible generation"
            },
            "prompt": {
              "type": "string",
              "minLength": 1,
              "description": "Prompt for generated image"
            },
            "go_fast": {
              "type": "boolean",
              "default": true,
              "description": "Run faster predictions with model optimized for speed (currently fp8 quantized); disable to run in original bf16"
            },
            "megapixels": {
              "enum": [
                "1",
                "0.25"
              ],
              "type": "string",
              "default": "1",
              "description": "Approximate number of megapixels for generated image"
            },
            "num_outputs": {
              "type": "integer",
              "default": 1,
              "maximum": 4,
              "minimum": 1,
              "description": "Number of outputs to generate"
            },
            "aspect_ratio": {
              "enum": [
                "1:1",
                "16:9",
                "21:9",
                "3:2",
                "2:3",
                "4:5",
                "5:4",
                "3:4",
                "4:3",
                "9:16",
                "9:21"
              ],
              "type": "string",
              "default": "1:1",
              "description": "Aspect ratio for the generated image"
            },
            "output_format": {
              "enum": [
                "webp",
                "jpg",
                "png"
              ],
              "type": "string",
              "default": "webp",
              "description": "Format of the output images"
            },
            "output_quality": {
              "type": "integer",
              "default": 80,
              "maximum": 100,
              "minimum": 0,
              "description": "Quality when saving the output images, from 0 to 100. 100 is best quality, 0 is lowest quality. Not relevant for .png outputs"
            },
            "num_inference_steps": {
              "type": "integer",
              "default": 4,
              "maximum": 4,
              "minimum": 1,
              "description": "Number of denoising steps. 4 is recommended, and lower number of steps produce lower quality outputs, faster."
            },
            "disable_safety_checker": {
              "type": "boolean",
              "default": false,
              "description": "Disable safety checker for generated images."
            },
            "support_image_mcp_response_type": {
              "type": "boolean",
              "default": true,
              "description": "Disable if the image type is not supported in the response, if it's Cursor app for example"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "generate_multiple_images",
        "description": "Generate multiple images from an array of prompts using Flux Schnell model",
        "inputSchema": {
          "type": "object",
          "properties": {
            "seed": {
              "type": "integer",
              "description": "Random seed. Set for reproducible generation"
            },
            "go_fast": {
              "type": "boolean",
              "default": true,
              "description": "Run faster predictions with model optimized for speed (currently fp8 quantized); disable to run in original bf16"
            },
            "prompts": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 1
              },
              "maxItems": 10,
              "minItems": 1,
              "description": "Array of text descriptions for the images to generate"
            },
            "megapixels": {
              "enum": [
                "1",
                "0.25"
              ],
              "type": "string",
              "default": "1",
              "description": "Approximate number of megapixels for generated image"
            },
            "aspect_ratio": {
              "enum": [
                "1:1",
                "16:9",
                "21:9",
                "3:2",
                "2:3",
                "4:5",
                "5:4",
                "3:4",
                "4:3",
                "9:16",
                "9:21"
              ],
              "type": "string",
              "default": "1:1",
              "description": "Aspect ratio for the generated image"
            },
            "output_format": {
              "enum": [
                "webp",
                "jpg",
                "png"
              ],
              "type": "string",
              "default": "webp",
              "description": "Format of the output images"
            },
            "output_quality": {
              "type": "integer",
              "default": 80,
              "maximum": 100,
              "minimum": 0,
              "description": "Quality when saving the output images, from 0 to 100. 100 is best quality, 0 is lowest quality. Not relevant for .png outputs"
            },
            "num_inference_steps": {
              "type": "integer",
              "default": 4,
              "maximum": 4,
              "minimum": 1,
              "description": "Number of denoising steps. 4 is recommended, and lower number of steps produce lower quality outputs, faster."
            },
            "disable_safety_checker": {
              "type": "boolean",
              "default": false,
              "description": "Disable safety checker for generated images."
            },
            "support_image_mcp_response_type": {
              "type": "boolean",
              "default": true,
              "description": "Disable if the image type is not supported in the response, if it's Cursor app for example"
            }
          },
          "required": [
            "prompts"
          ]
        }
      },
      {
        "name": "generate_image_variants",
        "description": "Generate multiple variants of the same image from a single prompt",
        "inputSchema": {
          "type": "object",
          "properties": {
            "seed": {
              "type": "integer",
              "description": "Base random seed. Each variant will use seed+variant_index for reproducibility"
            },
            "prompt": {
              "type": "string",
              "minLength": 1,
              "description": "Text description for the image to generate variants of"
            },
            "go_fast": {
              "type": "boolean",
              "default": true,
              "description": "Run faster predictions with model optimized for speed (currently fp8 quantized); disable to run in original bf16"
            },
            "megapixels": {
              "enum": [
                "1",
                "0.25"
              ],
              "type": "string",
              "default": "1",
              "description": "Approximate number of megapixels for generated image"
            },
            "aspect_ratio": {
              "enum": [
                "1:1",
                "16:9",
                "21:9",
                "3:2",
                "2:3",
                "4:5",
                "5:4",
                "3:4",
                "4:3",
                "9:16",
                "9:21"
              ],
              "type": "string",
              "default": "1:1",
              "description": "Aspect ratio for the generated image"
            },
            "num_variants": {
              "type": "integer",
              "default": 4,
              "maximum": 10,
              "minimum": 2,
              "description": "Number of image variants to generate (2-10)"
            },
            "output_format": {
              "enum": [
                "webp",
                "jpg",
                "png"
              ],
              "type": "string",
              "default": "webp",
              "description": "Format of the output images"
            },
            "output_quality": {
              "type": "integer",
              "default": 80,
              "maximum": 100,
              "minimum": 0,
              "description": "Quality when saving the output images, from 0 to 100. 100 is best quality, 0 is lowest quality. Not relevant for .png outputs"
            },
            "variation_mode": {
              "enum": [
                "append",
                "replace"
              ],
              "type": "string",
              "default": "append",
              "description": "How to apply prompt variations: 'append' adds to the base prompt, 'replace' uses variations as standalone prompts"
            },
            "prompt_variations": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional list of prompt modifiers to apply to variants (e.g., ['in watercolor style', 'in oil painting style']). If provided, these will be used instead of random seeds."
            },
            "num_inference_steps": {
              "type": "integer",
              "default": 4,
              "maximum": 4,
              "minimum": 1,
              "description": "Number of denoising steps. 4 is recommended, and lower number of steps produce lower quality outputs, faster."
            },
            "disable_safety_checker": {
              "type": "boolean",
              "default": false,
              "description": "Disable safety checker for generated images."
            },
            "support_image_mcp_response_type": {
              "type": "boolean",
              "default": true,
              "description": "Support image MCP response type on client side"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "generate_svg",
        "description": "Generate an SVG from a text prompt using Recraft model",
        "inputSchema": {
          "type": "object",
          "properties": {
            "size": {
              "enum": [
                "1024x1024",
                "1365x1024",
                "1024x1365",
                "1536x1024",
                "1024x1536",
                "1820x1024",
                "1024x1820",
                "1024x2048",
                "2048x1024",
                "1434x1024",
                "1024x1434",
                "1024x1280",
                "1280x1024",
                "1024x1707",
                "1707x1024"
              ],
              "type": "string",
              "default": "1024x1024",
              "description": "Size of the generated SVG"
            },
            "style": {
              "enum": [
                "any",
                "engraving",
                "line_art",
                "line_circuit",
                "linocut"
              ],
              "type": "string",
              "default": "any",
              "description": "Style of the generated image."
            },
            "prompt": {
              "type": "string",
              "minLength": 1,
              "description": "Prompt for generated SVG"
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "get_prediction",
        "description": "Get details of a specific prediction by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "predictionId": {
              "type": "string",
              "minLength": 1,
              "description": "ID of the prediction to retrieve"
            }
          },
          "required": [
            "predictionId"
          ]
        }
      },
      {
        "name": "create_prediction",
        "description": "Generate an prediction from a text prompt using Flux Schnell model",
        "inputSchema": {
          "type": "object",
          "properties": {
            "seed": {
              "type": "integer",
              "description": "Random seed. Set for reproducible generation"
            },
            "prompt": {
              "type": "string",
              "minLength": 1,
              "description": "Prompt for generated image"
            },
            "go_fast": {
              "type": "boolean",
              "default": true,
              "description": "Run faster predictions with model optimized for speed (currently fp8 quantized); disable to run in original bf16"
            },
            "megapixels": {
              "enum": [
                "1",
                "0.25"
              ],
              "type": "string",
              "default": "1",
              "description": "Approximate number of megapixels for generated image"
            },
            "num_outputs": {
              "type": "integer",
              "default": 1,
              "maximum": 4,
              "minimum": 1,
              "description": "Number of outputs to generate"
            },
            "aspect_ratio": {
              "enum": [
                "1:1",
                "16:9",
                "21:9",
                "3:2",
                "2:3",
                "4:5",
                "5:4",
                "3:4",
                "4:3",
                "9:16",
                "9:21"
              ],
              "type": "string",
              "default": "1:1",
              "description": "Aspect ratio for the generated image"
            },
            "output_format": {
              "enum": [
                "webp",
                "jpg",
                "png"
              ],
              "type": "string",
              "default": "webp",
              "description": "Format of the output images"
            },
            "output_quality": {
              "type": "integer",
              "default": 80,
              "maximum": 100,
              "minimum": 0,
              "description": "Quality when saving the output images, from 0 to 100. 100 is best quality, 0 is lowest quality. Not relevant for .png outputs"
            },
            "num_inference_steps": {
              "type": "integer",
              "default": 4,
              "maximum": 4,
              "minimum": 1,
              "description": "Number of denoising steps. 4 is recommended, and lower number of steps produce lower quality outputs, faster."
            },
            "disable_safety_checker": {
              "type": "boolean",
              "default": false,
              "description": "Disable safety checker for generated images."
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "prediction_list",
        "description": "Get a list of recent predictions from Replicate",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "default": 50,
              "maximum": 100,
              "minimum": 1,
              "description": "Maximum number of predictions to return"
            }
          }
        }
      }
    ]
  },
  {
    "name": "baranwang-mcp-trends-hub",
    "title": "Trends Hub",
    "description": "A MCP server that aggregates hot trends and rankings from various Chinese websites and platforms including Weibo, Zhihu, Bilibili, and more.",
    "icon": "https://avatars.githubusercontent.com/baranwang",
    "isOfficial": false,
    "homepage": "https://github.com/baranwang/mcp-trends-hub",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-trends-hub"
      ],
      "env": {
        "TRENDS_HUB_HIDDEN_FIELDS": "<trends-hub-hidden-fields>",
        "TRENDS_HUB_CUSTOM_RSS_URL": "<trends-hub-custom-rss-url>"
      }
    },
    "parameters": [
      {
        "name": "TRENDS_HUB_HIDDEN_FIELDS",
        "description": "Controls which fields are hidden in the returned data. Format: field-name or tool-name:field-name, multiple values separated by commas (e.g., 'cover,get-nytimes-news:description')",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TRENDS_HUB_CUSTOM_RSS_URL",
        "description": "URL for a custom RSS feed to be added as a 'custom-rss' tool",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get-36kr-trending",
        "description": "获取 36 氪热榜，提供创业、商业、科技领域的热门资讯，包含投融资动态、新兴产业分析和商业模式创新信息",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "hot",
                  "description": "人气榜"
                },
                {
                  "type": "string",
                  "const": "video",
                  "description": "视频榜"
                },
                {
                  "type": "string",
                  "const": "comment",
                  "description": "热议榜"
                },
                {
                  "type": "string",
                  "const": "collect",
                  "description": "收藏榜"
                }
              ],
              "default": "hot",
              "description": "分类"
            }
          }
        }
      },
      {
        "name": "get-9to5mac-news",
        "description": "获取 9to5Mac 苹果相关新闻，包含苹果产品发布、iOS 更新、Mac 硬件、应用推荐及苹果公司动态的英文资讯",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-bbc-news",
        "description": "获取 BBC 新闻，提供全球新闻、英国新闻、商业、政治、健康、教育、科技、娱乐等资讯",
        "inputSchema": {
          "type": "object",
          "properties": {
            "edition": {
              "anyOf": [
                {
                  "type": "string",
                  "const": ""
                },
                {
                  "type": "string",
                  "const": "uk",
                  "description": "UK"
                },
                {
                  "type": "string",
                  "const": "us",
                  "description": "US & Canada"
                },
                {
                  "type": "string",
                  "const": "int",
                  "description": "Rest of the world"
                }
              ],
              "default": "",
              "description": "版本，仅对 `category` 为空有效"
            },
            "category": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "",
                  "description": "热门新闻"
                },
                {
                  "type": "string",
                  "const": "world",
                  "description": "国际"
                },
                {
                  "type": "string",
                  "const": "uk",
                  "description": "英国"
                },
                {
                  "type": "string",
                  "const": "business",
                  "description": "商业"
                },
                {
                  "type": "string",
                  "const": "politics",
                  "description": "政治"
                },
                {
                  "type": "string",
                  "const": "health",
                  "description": "健康"
                },
                {
                  "type": "string",
                  "const": "education",
                  "description": "教育"
                },
                {
                  "type": "string",
                  "const": "science_and_environment",
                  "description": "科学与环境"
                },
                {
                  "type": "string",
                  "const": "technology",
                  "description": "科技"
                },
                {
                  "type": "string",
                  "const": "entertainment_and_arts",
                  "description": "娱乐与艺术"
                }
              ],
              "default": ""
            }
          }
        }
      },
      {
        "name": "get-bilibili-rank",
        "description": "获取哔哩哔哩视频排行榜，包含全站、动画、音乐、游戏等多个分区的热门视频，反映当下年轻人的内容消费趋势",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "anyOf": [
                {
                  "type": "number",
                  "const": 0,
                  "description": "全站"
                },
                {
                  "type": "number",
                  "const": 1,
                  "description": "动画"
                },
                {
                  "type": "number",
                  "const": 3,
                  "description": "音乐"
                },
                {
                  "type": "number",
                  "const": 4,
                  "description": "游戏"
                },
                {
                  "type": "number",
                  "const": 5,
                  "description": "娱乐"
                },
                {
                  "type": "number",
                  "const": 188,
                  "description": "科技"
                },
                {
                  "type": "number",
                  "const": 119,
                  "description": "鬼畜"
                },
                {
                  "type": "number",
                  "const": 129,
                  "description": "舞蹈"
                },
                {
                  "type": "number",
                  "const": 155,
                  "description": "时尚"
                },
                {
                  "type": "number",
                  "const": 160,
                  "description": "生活"
                },
                {
                  "type": "number",
                  "const": 168,
                  "description": "国创相关"
                },
                {
                  "type": "number",
                  "const": 181,
                  "description": "影视"
                }
              ],
              "default": 0,
              "description": "排行榜分区"
            }
          }
        }
      },
      {
        "name": "get-douban-rank",
        "description": "获取豆瓣实时热门榜单，提供当前热门的图书、电影、电视剧、综艺等作品信息，包含评分和热度数据",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "subject",
                  "description": "图书、电影、电视剧、综艺等"
                },
                {
                  "type": "string",
                  "const": "movie",
                  "description": "电影"
                },
                {
                  "type": "string",
                  "const": "tv",
                  "description": "电视剧"
                }
              ],
              "default": "subject"
            },
            "count": {
              "type": "integer",
              "default": 10
            },
            "start": {
              "type": "integer",
              "default": 0
            }
          }
        }
      },
      {
        "name": "get-douyin-trending",
        "description": "获取抖音热搜榜单，展示当下最热门的社会话题、娱乐事件、网络热点和流行趋势",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-gcores-new",
        "description": "获取机核网游戏相关资讯，包含电子游戏评测、玩家文化、游戏开发和游戏周边产品的深度内容",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-ifanr-news",
        "description": "获取爱范儿科技快讯，包含最新的科技产品、数码设备、互联网动态等前沿科技资讯",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "default": 20
            },
            "offset": {
              "type": "integer",
              "default": 0
            }
          }
        }
      },
      {
        "name": "get-infoq-news",
        "description": "获取 InfoQ 技术资讯，包含软件开发、架构设计、云计算、AI等企业级技术内容和前沿开发者动态",
        "inputSchema": {
          "type": "object",
          "properties": {
            "region": {
              "enum": [
                "cn",
                "global"
              ],
              "type": "string",
              "default": "cn"
            }
          }
        }
      },
      {
        "name": "get-juejin-article-rank",
        "description": "获取掘金文章榜，包含前端开发、后端技术、人工智能、移动开发及技术架构等领域的高质量中文技术文章和教程",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category_id": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "6809637769959178254",
                  "description": "后端"
                },
                {
                  "type": "string",
                  "const": "6809637767543259144",
                  "description": "前端"
                },
                {
                  "type": "string",
                  "const": "6809635626879549454",
                  "description": "Android"
                },
                {
                  "type": "string",
                  "const": "6809635626661445640",
                  "description": "iOS"
                },
                {
                  "type": "string",
                  "const": "6809637773935378440",
                  "description": "人工智能"
                },
                {
                  "type": "string",
                  "const": "6809637771511070734",
                  "description": "开发工具"
                },
                {
                  "type": "string",
                  "const": "6809637776263217160",
                  "description": "代码人生"
                },
                {
                  "type": "string",
                  "const": "6809637772874219534",
                  "description": "阅读"
                }
              ],
              "default": "6809637769959178254"
            }
          }
        }
      },
      {
        "name": "get-netease-news-trending",
        "description": "获取网易新闻热点榜，包含时政要闻、社会事件、财经资讯、科技动态及娱乐体育的全方位中文新闻资讯",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-nytimes-news",
        "description": "获取纽约时报新闻，包含国际政治、经济金融、社会文化、科学技术及艺术评论的高质量英文或中文国际新闻资讯",
        "inputSchema": {
          "type": "object",
          "properties": {
            "region": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "cn",
                  "description": "中文"
                },
                {
                  "type": "string",
                  "const": "global",
                  "description": "全球"
                }
              ],
              "default": "cn"
            },
            "section": {
              "type": "string",
              "default": "HomePage",
              "description": "分类，当 `region` 为 `cn` 时无效。可选值: Africa, Americas, ArtandDesign, Arts, AsiaPacific, Automobiles, Baseball, Books/Review, Business, Climate, CollegeBasketball, CollegeFootball, Dance, Dealbook, DiningandWine, Economy, Education, EnergyEnvironment, Europe, FashionandStyle, Golf, Health, Hockey, HomePage, Jobs, Lens, MediaandAdvertising, MiddleEast, MostEmailed, MostShared, MostViewed, Movies, Music, NYRegion, Obituaries, PersonalTech, Politics, ProBasketball, ProFootball, RealEstate, Science, SmallBusiness, Soccer, Space, Sports, SundayBookReview, Sunday-Review, Technology, Television, Tennis, Theater, TMagazine, Travel, Upshot, US, Weddings, Well, World, YourMoney"
            }
          }
        }
      },
      {
        "name": "get-smzdm-rank",
        "description": "获取什么值得买热门，包含商品推荐、优惠信息、购物攻略、产品评测及消费经验分享的实用中文消费类资讯",
        "inputSchema": {
          "type": "object",
          "properties": {
            "unit": {
              "anyOf": [
                {
                  "type": "number",
                  "const": 1,
                  "description": "今日热门"
                },
                {
                  "type": "number",
                  "const": 7,
                  "description": "周热门"
                },
                {
                  "type": "number",
                  "const": 30,
                  "description": "月热门"
                }
              ],
              "default": 1
            }
          }
        }
      },
      {
        "name": "get-sspai-rank",
        "description": "获取少数派热榜，包含数码产品评测、软件应用推荐、生活方式指南及效率工作技巧的优质中文科技生活类内容",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "enum": [
                "热门文章",
                "应用推荐",
                "生活方式",
                "效率技巧",
                "少数派播客"
              ],
              "type": "string",
              "default": "热门文章",
              "description": "分类"
            },
            "limit": {
              "type": "integer",
              "default": 40
            }
          }
        }
      },
      {
        "name": "get-tencent-news-trending",
        "description": "获取腾讯新闻热点榜，包含国内外时事、社会热点、财经资讯、娱乐动态及体育赛事的综合性中文新闻资讯",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_size": {
              "type": "integer",
              "default": 20
            }
          }
        }
      },
      {
        "name": "get-thepaper-trending",
        "description": "获取澎湃新闻热榜，包含时政要闻、财经动态、社会事件、文化教育及深度报道的高质量中文新闻资讯",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-theverge-news",
        "description": "获取 The Verge 新闻，包含科技创新、数码产品评测、互联网趋势及科技公司动态的英文科技资讯",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-toutiao-trending",
        "description": "获取今日头条热榜，包含时政要闻、社会事件、国际新闻、科技发展及娱乐八卦等多领域的热门中文资讯",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-weibo-trending",
        "description": "获取微博热搜榜，包含时事热点、社会现象、娱乐新闻、明星动态及网络热议话题的实时热门中文资讯",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-weread-rank",
        "description": "获取微信读书排行榜，包含热门小说、畅销书籍、新书推荐及各类文学作品的阅读数据和排名信息",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category": {
              "anyOf": [
                {
                  "type": "string",
                  "const": "rising",
                  "description": "飙升榜"
                },
                {
                  "type": "string",
                  "const": "hot_search",
                  "description": "热搜榜"
                },
                {
                  "type": "string",
                  "const": "newbook",
                  "description": "新书榜"
                },
                {
                  "type": "string",
                  "const": "general_novel_rising",
                  "description": "小说榜"
                },
                {
                  "type": "string",
                  "const": "all",
                  "description": "总榜"
                }
              ],
              "default": "rising",
              "description": "排行榜分区"
            }
          }
        }
      },
      {
        "name": "get-zhihu-trending",
        "description": "获取知乎热榜，包含时事热点、社会话题、科技动态、娱乐八卦等多领域的热门问答和讨论的中文资讯",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 50
            }
          }
        }
      }
    ]
  },
  {
    "name": "bigcodegen-mcp-neovim-server",
    "title": "mcp-neovim-server",
    "description": "Leverages Vim's native text editing commands and workflows, which Claude already understands, to create a lightweight code assistance layer.",
    "icon": "https://avatars.githubusercontent.com/bigcodegen",
    "isOfficial": false,
    "homepage": "https://github.com/bigcodegen/mcp-neovim-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-neovim-server"
      ],
      "env": {
        "ALLOW_SHELL_COMMANDS": "<allow-shell-commands>"
      }
    },
    "parameters": [
      {
        "name": "ALLOW_SHELL_COMMANDS",
        "description": "Set to 'true' to enable shell command execution (e.g. `!ls`). Defaults to false for security.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "binalyze-air-mcp",
    "title": "Binalyze AIR MCP Server",
    "description": "A Node.js server implementing Model Context Protocol (MCP) that enables natural language interaction with Binalyze AIR's digital forensics and incident response capabilities.",
    "icon": "https://avatars.githubusercontent.com/binalyze",
    "isOfficial": true,
    "homepage": "https://github.com/binalyze/air-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@binalyze/air-mcp"
      ],
      "env": {
        "AIR_HOST": "<air-host>",
        "AIR_API_TOKEN": "<air-api-token>"
      }
    },
    "parameters": [
      {
        "name": "AIR_HOST",
        "description": "Your Binalyze AIR API host URL",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "AIR_API_TOKEN",
        "description": "API token required for authentication with Binalyze AIR",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "list_assets",
        "description": "List all assets in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter assets by. Leave empty to use default (0)."
            }
          },
          "required": []
        }
      },
      {
        "name": "get_asset_by_id",
        "description": "Get detailed information about a specific asset by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the asset to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_asset_tasks_by_id",
        "description": "Get all tasks associated with a specific asset by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the asset to retrieve tasks for"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_acquisition_profiles",
        "description": "List all acquisition profiles in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter acquisition profiles by. Leave empty to use default (0)."
            },
            "allOrganizations": {
              "type": "boolean",
              "description": "Whether to include profiles from all organizations. Defaults to true."
            }
          },
          "required": []
        }
      },
      {
        "name": "assign_acquisition_task",
        "description": "Assign an evidence acquisition task to specific endpoints",
        "inputSchema": {
          "type": "object",
          "properties": {
            "caseId": {
              "type": "string",
              "description": "The case ID to associate the acquisition with"
            },
            "cpuLimit": {
              "type": "number",
              "description": "CPU usage limit percentage (1-100). Defaults to 80"
            },
            "keywords": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of keywords to search for"
            },
            "analyzers": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of analyzer IDs to use (e.g. [\"bha\", \"wsa\"])"
            },
            "endpointIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of endpoint IDs to collect evidence from"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Array of organization IDs to filter by. Defaults to [0]"
            },
            "enableEncryption": {
              "type": "boolean",
              "description": "Whether to enable encryption. Defaults to false"
            },
            "enableCompression": {
              "type": "boolean",
              "description": "Whether to enable compression. Defaults to true"
            },
            "encryptionPassword": {
              "type": "string",
              "description": "Password for encryption if enabled"
            },
            "acquisitionProfileId": {
              "type": "string",
              "description": "The acquisition profile ID to use for the task"
            }
          },
          "required": [
            "caseId",
            "acquisitionProfileId",
            "endpointIds"
          ]
        }
      },
      {
        "name": "get_acquisition_profile_by_id",
        "description": "Get details of a specific acquisition profile by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "profileId": {
              "type": "string",
              "description": "The ID of the acquisition profile to retrieve (e.g., \"full\")"
            }
          },
          "required": [
            "profileId"
          ]
        }
      },
      {
        "name": "assign_image_acquisition_task",
        "description": "Assign a disk image acquisition task to specific endpoints and volumes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "caseId": {
              "type": [
                "string",
                "null"
              ],
              "description": "The case ID to associate the acquisition with (optional)"
            },
            "chunkSize": {
              "type": "number",
              "description": "Chunk size in bytes. Defaults to 1048576"
            },
            "endpoints": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "endpointId",
                  "volumes"
                ],
                "properties": {
                  "volumes": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "endpointId": {
                    "type": "string"
                  }
                }
              },
              "description": "Array of endpoints and volumes to image (e.g., [{\"endpointId\": \"uuid\", \"volumes\": [\"/dev/sda1\"]}]). At least one endpoint and one volume per endpoint required."
            },
            "chunkCount": {
              "type": "number",
              "description": "Number of chunks to acquire. Defaults to 0 (acquire until end)."
            },
            "startOffset": {
              "type": "number",
              "description": "Offset in bytes to start acquisition from. Defaults to 0."
            },
            "repositoryId": {
              "type": "string",
              "description": "The repository ID where the image will be saved"
            },
            "bandwidthLimit": {
              "type": "number",
              "description": "Bandwidth limit in KB/s. Defaults to 100000"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Array of organization IDs. Defaults to [0]"
            },
            "enableEncryption": {
              "type": "boolean",
              "description": "Whether to enable encryption. Defaults to false"
            },
            "enableCompression": {
              "type": "boolean",
              "description": "Whether to enable compression. Defaults to true"
            },
            "encryptionPassword": {
              "type": "string",
              "description": "Password for encryption if enabled"
            }
          },
          "required": [
            "repositoryId",
            "endpoints"
          ]
        }
      },
      {
        "name": "create_acquisition_profile",
        "description": "Create a new acquisition profile",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aix": {
              "type": "object",
              "description": "AIX specific configuration. Must include keys like `evidenceList` (array of strings), `artifactList` (array of strings, optional), and `customContentProfiles` (array). Example: { \"evidenceList\": [\"logs\"], ... }"
            },
            "name": {
              "type": "string",
              "description": "Name for the new acquisition profile"
            },
            "linux": {
              "type": "object",
              "description": "Linux specific configuration. Must include keys like `evidenceList` (array of strings), `artifactList` (array of strings, optional), `customContentProfiles` (array), and `networkCapture` (object). Example: { \"evidenceList\": [\"logs\"], ... }"
            },
            "macos": {
              "type": "object",
              "description": "macOS specific configuration. Must include keys like `evidenceList` (array of strings), `artifactList` (array of strings, optional), `customContentProfiles` (array), and `networkCapture` (object). Example: { \"evidenceList\": [\"logs\"], ... }"
            },
            "windows": {
              "type": "object",
              "description": "Windows specific configuration. Must include keys like `evidenceList` (array of strings), `artifactList` (array of strings, optional), `customContentProfiles` (array), and `networkCapture` (object). Example: { \"evidenceList\": [\"evt\"], \"artifactList\": [], \"customContentProfiles\": [], \"networkCapture\": { \"enabled\": false, \"duration\": 600, \"pcap\": { \"enabled\": false }, \"networkFlow\": { \"enabled\": false } } }"
            },
            "eDiscovery": {
              "type": "object",
              "description": "eDiscovery configuration. Must include the key `patterns` (array of objects with `pattern` and `category` strings). Example: { \"patterns\": [] }"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Organization IDs to associate the profile with. Defaults to empty array."
            }
          },
          "required": [
            "name",
            "windows",
            "linux",
            "macos",
            "aix",
            "eDiscovery"
          ]
        }
      },
      {
        "name": "assign_reboot_task",
        "description": "Assign a reboot task to specific endpoints",
        "inputSchema": {
          "type": "object",
          "properties": {
            "endpointIds": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Endpoint ID(s) to reboot. Can be a single ID or an array of IDs."
            },
            "managedStatus": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter endpoints by managed status. Default is [\"managed\"]."
            },
            "organizationIds": {
              "oneOf": [
                {
                  "type": "number"
                },
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  }
                }
              ],
              "description": "Organization ID(s) to filter endpoints by. Defaults to 0."
            }
          },
          "required": [
            "endpointIds"
          ]
        }
      },
      {
        "name": "assign_shutdown_task",
        "description": "Assign a shutdown task to specific endpoints",
        "inputSchema": {
          "type": "object",
          "properties": {
            "endpointIds": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Endpoint ID(s) to shutdown. Can be a single ID or an array of IDs."
            },
            "managedStatus": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter endpoints by managed status. Default is [\"managed\"]."
            },
            "organizationIds": {
              "oneOf": [
                {
                  "type": "number"
                },
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  }
                }
              ],
              "description": "Organization ID(s) to filter endpoints by. Defaults to 0."
            }
          },
          "required": [
            "endpointIds"
          ]
        }
      },
      {
        "name": "assign_isolation_task",
        "description": "Assign an isolation task to specific endpoints",
        "inputSchema": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Whether to enable (isolate) or disable (unisolate) isolation. Defaults to true."
            },
            "endpointIds": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Endpoint ID(s) to isolate or unisolate. Can be a single ID or an array of IDs."
            },
            "managedStatus": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter endpoints by managed status. Default is [\"managed\"]."
            },
            "organizationIds": {
              "oneOf": [
                {
                  "type": "number"
                },
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  }
                }
              ],
              "description": "Organization ID(s) to filter endpoints by. Defaults to 0."
            }
          },
          "required": [
            "endpointIds"
          ]
        }
      },
      {
        "name": "assign_log_retrieval_task",
        "description": "Assign a log retrieval task to specific endpoints",
        "inputSchema": {
          "type": "object",
          "properties": {
            "endpointIds": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Endpoint ID(s) to retrieve logs from. Can be a single ID or an array of IDs."
            },
            "managedStatus": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter endpoints by managed status. Default is [\"managed\"]."
            },
            "organizationIds": {
              "oneOf": [
                {
                  "type": "number"
                },
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  }
                }
              ],
              "description": "Organization ID(s) to filter endpoints by. This is REQUIRED to identify the correct endpoints. Examples: 0, \"123\", [0], [\"123\", \"456\"]"
            }
          },
          "required": [
            "endpointIds",
            "organizationIds"
          ]
        }
      },
      {
        "name": "assign_version_update_task",
        "description": "Assign a version update task to specific endpoints",
        "inputSchema": {
          "type": "object",
          "properties": {
            "endpointIds": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Endpoint ID(s) to update version. Can be a single ID or an array of IDs."
            },
            "managedStatus": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter endpoints by managed status. Default is [\"managed\"]."
            },
            "organizationIds": {
              "oneOf": [
                {
                  "type": "number"
                },
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  }
                }
              ],
              "description": "Organization ID(s) to filter endpoints by. Defaults to 0."
            }
          },
          "required": [
            "endpointIds"
          ]
        }
      },
      {
        "name": "list_organizations",
        "description": "List all organizations in the system",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "list_cases",
        "description": "List all cases in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter cases by. Leave empty to use default (0)."
            }
          },
          "required": []
        }
      },
      {
        "name": "list_policies",
        "description": "List all policies in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter policies by. Leave empty to use default (0)."
            }
          },
          "required": []
        }
      },
      {
        "name": "list_tasks",
        "description": "List all tasks in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter tasks by. Leave empty to use default (0)."
            }
          },
          "required": []
        }
      },
      {
        "name": "list_triage_rules",
        "description": "List all triage rules in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter triage rules by. Leave empty to use default (0)."
            }
          },
          "required": []
        }
      },
      {
        "name": "list_users",
        "description": "List all users in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter users by. Leave empty to use default (0)."
            }
          },
          "required": []
        }
      },
      {
        "name": "list_drone_analyzers",
        "description": "List all drone analyzers in the system",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "export_audit_logs",
        "description": "Initiate an export of audit logs from the AIR system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter audit logs by. Defaults to \"0\" or specific IDs like \"123\" or \"123,456\"."
            }
          },
          "required": []
        }
      },
      {
        "name": "list_audit_logs",
        "description": "List audit logs from the AIR system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter audit logs by. Defaults to \"0\" or specific IDs like \"123\" or \"123,456\"."
            }
          },
          "required": []
        }
      },
      {
        "name": "uninstall_assets",
        "description": "Uninstall specific assets based on filters without purging data. Requires specifying `filter.includedEndpointIds`.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filter": {
              "type": "object",
              "required": [],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Filter by asset name."
                },
                "issue": {
                  "type": "string",
                  "description": "Filter by issue."
                },
                "tagId": {
                  "type": "string",
                  "description": "Filter by tag ID."
                },
                "policy": {
                  "type": "string",
                  "description": "Filter by policy."
                },
                "groupId": {
                  "type": "string",
                  "description": "Filter by group ID."
                },
                "version": {
                  "type": "string",
                  "description": "Filter by agent version."
                },
                "platform": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by platform (e.g., [\"windows\"])."
                },
                "ipAddress": {
                  "type": "string",
                  "description": "Filter by IP address."
                },
                "searchTerm": {
                  "type": "string",
                  "description": "Optional search term."
                },
                "onlineStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by online status (e.g., [\"online\"])."
                },
                "groupFullPath": {
                  "type": "string",
                  "description": "Filter by full group path."
                },
                "managedStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by managed status (e.g., [\"managed\"])."
                },
                "isolationStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by isolation status (e.g., [\"isolated\"])."
                },
                "organizationIds": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "description": "Organization IDs filter. Defaults to [0]."
                },
                "excludedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to exclude."
                },
                "includedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "REQUIRED: Array of endpoint IDs to uninstall."
                }
              },
              "description": "Filter object to specify which assets to uninstall."
            }
          },
          "required": [
            "filter"
          ]
        }
      },
      {
        "name": "purge_and_uninstall_assets",
        "description": "Purge data and uninstall specific assets based on filters. Requires specifying `filter.includedEndpointIds`.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filter": {
              "type": "object",
              "required": [
                "includedEndpointIds"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Filter by asset name."
                },
                "issue": {
                  "type": "string",
                  "description": "Filter by issue."
                },
                "tagId": {
                  "type": "string",
                  "description": "Filter by tag ID."
                },
                "policy": {
                  "type": "string",
                  "description": "Filter by policy."
                },
                "groupId": {
                  "type": "string",
                  "description": "Filter by group ID."
                },
                "version": {
                  "type": "string",
                  "description": "Filter by agent version."
                },
                "platform": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by platform (e.g., [\"windows\"])."
                },
                "ipAddress": {
                  "type": "string",
                  "description": "Filter by IP address."
                },
                "searchTerm": {
                  "type": "string",
                  "description": "Optional search term."
                },
                "onlineStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by online status (e.g., [\"online\"])."
                },
                "groupFullPath": {
                  "type": "string",
                  "description": "Filter by full group path."
                },
                "managedStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by managed status (e.g., [\"managed\"])."
                },
                "isolationStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by isolation status (e.g., [\"isolated\"])."
                },
                "organizationIds": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "description": "Organization IDs filter. Defaults to [0]."
                },
                "excludedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to exclude."
                },
                "includedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "REQUIRED: Array of endpoint IDs to purge and uninstall."
                }
              },
              "description": "Filter object to specify which assets to purge and uninstall."
            }
          },
          "required": [
            "filter"
          ]
        }
      },
      {
        "name": "add_tags_to_assets",
        "description": "Add tags to specific assets based on filters. Requires specifying `filter.includedEndpointIds` and `tags`.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "REQUIRED: Array of tags to add to the selected assets."
            },
            "filter": {
              "type": "object",
              "required": [
                "includedEndpointIds"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Filter by asset name."
                },
                "issue": {
                  "type": "string",
                  "description": "Filter by issue."
                },
                "tagId": {
                  "type": "string",
                  "description": "Filter by existing tag ID."
                },
                "policy": {
                  "type": "string",
                  "description": "Filter by policy."
                },
                "groupId": {
                  "type": "string",
                  "description": "Filter by group ID."
                },
                "version": {
                  "type": "string",
                  "description": "Filter by agent version."
                },
                "platform": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by platform (e.g., [\"windows\"])."
                },
                "ipAddress": {
                  "type": "string",
                  "description": "Filter by IP address."
                },
                "searchTerm": {
                  "type": "string",
                  "description": "Optional search term."
                },
                "onlineStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by online status (e.g., [\"online\"])."
                },
                "groupFullPath": {
                  "type": "string",
                  "description": "Filter by full group path."
                },
                "managedStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by managed status (e.g., [\"managed\"])."
                },
                "isolationStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by isolation status (e.g., [\"isolated\"])."
                },
                "organizationIds": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "description": "Organization IDs filter. Defaults to [0]."
                },
                "excludedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to exclude."
                },
                "includedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "REQUIRED: Array of endpoint IDs to add tags to."
                }
              },
              "description": "Filter object to specify which assets to add tags to."
            }
          },
          "required": [
            "filter",
            "tags"
          ]
        }
      },
      {
        "name": "remove_tags_from_assets",
        "description": "Remove tags from specific assets based on filters. Requires specifying `filter.includedEndpointIds` and `tags`.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "REQUIRED: Array of tags to remove from the selected assets."
            },
            "filter": {
              "type": "object",
              "required": [
                "includedEndpointIds"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Filter by asset name."
                },
                "issue": {
                  "type": "string",
                  "description": "Filter by issue."
                },
                "tagId": {
                  "type": "string",
                  "description": "Filter by existing tag ID."
                },
                "policy": {
                  "type": "string",
                  "description": "Filter by policy."
                },
                "groupId": {
                  "type": "string",
                  "description": "Filter by group ID."
                },
                "version": {
                  "type": "string",
                  "description": "Filter by agent version."
                },
                "platform": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by platform (e.g., [\"windows\"])."
                },
                "ipAddress": {
                  "type": "string",
                  "description": "Filter by IP address."
                },
                "searchTerm": {
                  "type": "string",
                  "description": "Optional search term."
                },
                "onlineStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by online status (e.g., [\"online\"])."
                },
                "groupFullPath": {
                  "type": "string",
                  "description": "Filter by full group path."
                },
                "managedStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by managed status (e.g., [\"managed\"])."
                },
                "isolationStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by isolation status (e.g., [\"isolated\"])."
                },
                "organizationIds": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "description": "Organization IDs filter. Defaults to [0]."
                },
                "excludedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to exclude."
                },
                "includedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "REQUIRED: Array of endpoint IDs to remove tags from."
                }
              },
              "description": "Filter object to specify which assets to remove tags from."
            }
          },
          "required": [
            "filter",
            "tags"
          ]
        }
      },
      {
        "name": "create_auto_asset_tag",
        "description": "Create a new rule to automatically tag assets based on specified conditions for Linux, Windows, and macOS.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "The tag name to be applied automatically."
            },
            "linuxConditions": {
              "$ref": "#/definitions/ConditionGroup",
              "description": "Conditions for Linux assets."
            },
            "macosConditions": {
              "$ref": "#/definitions/ConditionGroup",
              "description": "Conditions for macOS assets."
            },
            "windowsConditions": {
              "$ref": "#/definitions/ConditionGroup",
              "description": "Conditions for Windows assets."
            }
          },
          "required": [
            "tag",
            "linuxConditions",
            "windowsConditions",
            "macosConditions"
          ]
        }
      },
      {
        "name": "update_auto_asset_tag",
        "description": "Update an existing auto asset tag rule.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the auto asset tag to update."
            },
            "tag": {
              "type": "string",
              "description": "The tag name to be applied automatically."
            },
            "linuxConditions": {
              "$ref": "#/definitions/ConditionGroup",
              "description": "Conditions for Linux assets."
            },
            "macosConditions": {
              "$ref": "#/definitions/ConditionGroup",
              "description": "Conditions for macOS assets."
            },
            "windowsConditions": {
              "$ref": "#/definitions/ConditionGroup",
              "description": "Conditions for Windows assets."
            }
          },
          "required": [
            "id",
            "tag"
          ]
        }
      },
      {
        "name": "get_auto_asset_tag_by_id",
        "description": "Get details of a specific auto asset tag rule by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the auto asset tag to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "delete_auto_asset_tag_by_id",
        "description": "Delete a specific auto asset tag rule by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the auto asset tag to delete"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_auto_asset_tags",
        "description": "List all auto asset tag rules in the system.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "start_tagging",
        "description": "Start the auto asset tagging process for assets matching filter criteria.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filter": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Filter by asset name."
                },
                "tags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by tags."
                },
                "issue": {
                  "type": "string",
                  "description": "Filter by issue."
                },
                "policy": {
                  "type": "string",
                  "description": "Filter by policy."
                },
                "groupId": {
                  "type": "string",
                  "description": "Filter by group ID."
                },
                "version": {
                  "type": "string",
                  "description": "Filter by agent version."
                },
                "platform": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by platform (e.g., [\"windows\"])."
                },
                "ipAddress": {
                  "type": "string",
                  "description": "Filter by IP address."
                },
                "searchTerm": {
                  "type": "string",
                  "description": "Optional search term."
                },
                "onlineStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by online status (e.g., [\"online\"])."
                },
                "groupFullPath": {
                  "type": "string",
                  "description": "Filter by full group path."
                },
                "managedStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by managed status (e.g., [\"managed\"])."
                },
                "isolationStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by isolation status (e.g., [\"isolated\"])."
                },
                "organizationIds": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  },
                  "description": "Organization IDs filter. Defaults to [0]."
                },
                "excludedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to exclude."
                },
                "includedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to include."
                }
              },
              "description": "Filter object to specify which assets to apply auto tagging to."
            }
          },
          "required": [
            "filter"
          ]
        }
      },
      {
        "name": "acquire_baseline",
        "description": "Assign a baseline acquisition task to specific endpoints",
        "inputSchema": {
          "type": "object",
          "properties": {
            "caseId": {
              "type": "string",
              "description": "The case ID to associate the baseline acquisition with"
            },
            "filter": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Filter by asset name"
                },
                "tags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by tags"
                },
                "issue": {
                  "type": "string",
                  "description": "Filter by issue"
                },
                "policy": {
                  "type": "string",
                  "description": "Filter by policy"
                },
                "groupId": {
                  "type": "string",
                  "description": "Filter by group ID"
                },
                "version": {
                  "type": "string",
                  "description": "Filter by agent version"
                },
                "platform": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by platform (e.g., [\"windows\"])"
                },
                "ipAddress": {
                  "type": "string",
                  "description": "Filter by IP address"
                },
                "searchTerm": {
                  "type": "string",
                  "description": "Optional search term"
                },
                "onlineStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by online status (e.g., [\"online\"])"
                },
                "groupFullPath": {
                  "type": "string",
                  "description": "Filter by full group path"
                },
                "managedStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by managed status (e.g., [\"managed\"])"
                },
                "isolationStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by isolation status (e.g., [\"isolated\"])"
                },
                "organizationIds": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  },
                  "description": "Organization IDs filter. Defaults to [0]"
                },
                "excludedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to exclude"
                },
                "includedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to include for baseline acquisition"
                }
              },
              "description": "Filter object to specify which assets to acquire baseline from"
            }
          },
          "required": [
            "caseId",
            "filter"
          ]
        }
      },
      {
        "name": "compare_baseline",
        "description": "Compare baseline acquisition tasks for a specific endpoint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of baseline task IDs to compare (minimum 2)"
            },
            "endpointId": {
              "type": "string",
              "description": "The endpoint ID to compare baselines for"
            }
          },
          "required": [
            "endpointId",
            "taskIds"
          ]
        }
      },
      {
        "name": "get_comparison_report",
        "description": "Get comparison result report for a specific endpoint and task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the comparison task to get the report for"
            },
            "endpointId": {
              "type": "string",
              "description": "The endpoint ID associated with the comparison task"
            }
          },
          "required": [
            "endpointId",
            "taskId"
          ]
        }
      },
      {
        "name": "list_acquisition_artifacts",
        "description": "List all acquisition artifacts available for evidence collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "random_string": {
              "type": "string",
              "description": "Dummy parameter for no-parameter tools"
            }
          },
          "required": [
            "random_string"
          ]
        }
      },
      {
        "name": "list_e_discovery_patterns",
        "description": "List all e-discovery patterns for file type detection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "random_string": {
              "type": "string",
              "description": "Dummy parameter for no-parameter tools"
            }
          },
          "required": [
            "random_string"
          ]
        }
      },
      {
        "name": "create_policy",
        "description": "Create a new policy with specific storage and compression settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cpu": {
              "type": "object",
              "properties": {
                "limit": {
                  "type": "number",
                  "description": "CPU usage limit percentage (1-100)"
                }
              },
              "description": "CPU usage limits"
            },
            "name": {
              "type": "string",
              "description": "Name for the new policy"
            },
            "saveTo": {
              "type": "object",
              "required": [
                "windows",
                "linux",
                "macos"
              ],
              "properties": {
                "linux": {
                  "type": "object",
                  "required": [
                    "location",
                    "path",
                    "useMostFreeVolume",
                    "volume"
                  ],
                  "properties": {
                    "tmp": {
                      "type": "string",
                      "description": "Temporary folder path for Linux"
                    },
                    "path": {
                      "type": "string",
                      "description": "Path for evidence storage on Linux"
                    },
                    "volume": {
                      "type": "string",
                      "description": "Volume to use for Linux (e.g., \"/\")"
                    },
                    "location": {
                      "type": "string",
                      "description": "Storage location for Linux (e.g., \"local\")"
                    },
                    "useMostFreeVolume": {
                      "type": "boolean",
                      "description": "Whether to use volume with most free space"
                    }
                  }
                },
                "macos": {
                  "type": "object",
                  "required": [
                    "location",
                    "path",
                    "useMostFreeVolume",
                    "volume"
                  ],
                  "properties": {
                    "tmp": {
                      "type": "string",
                      "description": "Temporary folder path for macOS"
                    },
                    "path": {
                      "type": "string",
                      "description": "Path for evidence storage on macOS"
                    },
                    "volume": {
                      "type": "string",
                      "description": "Volume to use for macOS (e.g., \"/\")"
                    },
                    "location": {
                      "type": "string",
                      "description": "Storage location for macOS (e.g., \"local\")"
                    },
                    "useMostFreeVolume": {
                      "type": "boolean",
                      "description": "Whether to use volume with most free space"
                    }
                  }
                },
                "windows": {
                  "type": "object",
                  "required": [
                    "location",
                    "path",
                    "useMostFreeVolume",
                    "volume"
                  ],
                  "properties": {
                    "tmp": {
                      "type": "string",
                      "description": "Temporary folder path for Windows"
                    },
                    "path": {
                      "type": "string",
                      "description": "Path for evidence storage on Windows"
                    },
                    "volume": {
                      "type": "string",
                      "description": "Volume to use for Windows (e.g., \"C:\")"
                    },
                    "location": {
                      "type": "string",
                      "description": "Storage location for Windows (e.g., \"local\")"
                    },
                    "useMostFreeVolume": {
                      "type": "boolean",
                      "description": "Whether to use volume with most free space"
                    }
                  }
                }
              },
              "description": "Configuration for where to save evidence"
            },
            "sendTo": {
              "type": "object",
              "required": [
                "location"
              ],
              "properties": {
                "location": {
                  "type": "string",
                  "description": "Location to send evidence to (e.g., \"user-local\")"
                }
              },
              "description": "Configuration for where to send evidence"
            },
            "compression": {
              "type": "object",
              "required": [
                "enabled",
                "encryption"
              ],
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Whether compression is enabled"
                },
                "encryption": {
                  "type": "object",
                  "required": [
                    "enabled"
                  ],
                  "properties": {
                    "enabled": {
                      "type": "boolean",
                      "description": "Whether encryption is enabled"
                    },
                    "password": {
                      "type": "string",
                      "description": "Password for encryption when enabled"
                    }
                  }
                }
              },
              "description": "Compression and encryption settings"
            },
            "organizationIds": {
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "number"
                },
                {
                  "type": "string"
                }
              ],
              "description": "Organization IDs to associate with policy. Defaults to [0]."
            }
          },
          "required": [
            "name",
            "saveTo",
            "compression",
            "sendTo"
          ]
        }
      },
      {
        "name": "update_policy",
        "description": "Update an existing policy with specific storage and filter settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the policy to update"
            },
            "cpu": {
              "type": "object",
              "properties": {
                "limit": {
                  "type": "number",
                  "description": "CPU usage limit percentage (1-100)"
                }
              },
              "description": "CPU usage limits"
            },
            "name": {
              "type": "string",
              "description": "Name for the policy"
            },
            "filter": {
              "type": "object",
              "properties": {
                "operator": {
                  "type": "string",
                  "description": "Logical operator for combining conditions (e.g., \"and\", \"or\")"
                },
                "conditions": {
                  "type": "array",
                  "description": "Array of conditions for policy filtering"
                }
              },
              "description": "Filter conditions to determine which endpoints the policy applies to"
            },
            "saveTo": {
              "type": "object",
              "required": [
                "windows",
                "linux",
                "macos"
              ],
              "properties": {
                "linux": {
                  "type": "object",
                  "required": [
                    "location",
                    "path",
                    "useMostFreeVolume",
                    "volume"
                  ],
                  "properties": {
                    "tmp": {
                      "type": "string",
                      "description": "Temporary folder path for Linux"
                    },
                    "path": {
                      "type": "string",
                      "description": "Path for evidence storage on Linux"
                    },
                    "volume": {
                      "type": "string",
                      "description": "Volume to use for Linux (e.g., \"/\")"
                    },
                    "location": {
                      "type": "string",
                      "description": "Storage location for Linux (e.g., \"local\")"
                    },
                    "useMostFreeVolume": {
                      "type": "boolean",
                      "description": "Whether to use volume with most free space"
                    }
                  }
                },
                "macos": {
                  "type": "object",
                  "required": [
                    "location",
                    "path",
                    "useMostFreeVolume",
                    "volume"
                  ],
                  "properties": {
                    "tmp": {
                      "type": "string",
                      "description": "Temporary folder path for macOS"
                    },
                    "path": {
                      "type": "string",
                      "description": "Path for evidence storage on macOS"
                    },
                    "volume": {
                      "type": "string",
                      "description": "Volume to use for macOS (e.g., \"/\")"
                    },
                    "location": {
                      "type": "string",
                      "description": "Storage location for macOS (e.g., \"local\")"
                    },
                    "useMostFreeVolume": {
                      "type": "boolean",
                      "description": "Whether to use volume with most free space"
                    }
                  }
                },
                "windows": {
                  "type": "object",
                  "required": [
                    "location",
                    "path",
                    "useMostFreeVolume",
                    "volume"
                  ],
                  "properties": {
                    "tmp": {
                      "type": "string",
                      "description": "Temporary folder path for Windows"
                    },
                    "path": {
                      "type": "string",
                      "description": "Path for evidence storage on Windows"
                    },
                    "volume": {
                      "type": "string",
                      "description": "Volume to use for Windows (e.g., \"C:\")"
                    },
                    "location": {
                      "type": "string",
                      "description": "Storage location for Windows (e.g., \"local\")"
                    },
                    "useMostFreeVolume": {
                      "type": "boolean",
                      "description": "Whether to use volume with most free space"
                    }
                  }
                }
              },
              "description": "Configuration for where to save evidence"
            },
            "sendTo": {
              "type": "object",
              "required": [
                "location"
              ],
              "properties": {
                "location": {
                  "type": "string",
                  "description": "Location to send evidence to (e.g., \"user-local\")"
                }
              },
              "description": "Configuration for where to send evidence"
            },
            "compression": {
              "type": "object",
              "required": [
                "enabled",
                "encryption"
              ],
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Whether compression is enabled"
                },
                "encryption": {
                  "type": "object",
                  "required": [
                    "enabled"
                  ],
                  "properties": {
                    "enabled": {
                      "type": "boolean",
                      "description": "Whether encryption is enabled"
                    },
                    "password": {
                      "type": "string",
                      "description": "Password for encryption when enabled"
                    }
                  }
                }
              },
              "description": "Compression and encryption settings"
            },
            "organizationIds": {
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "number"
                },
                {
                  "type": "string"
                }
              ],
              "description": "Organization IDs to associate with policy. Defaults to [0]."
            }
          },
          "required": [
            "id",
            "name",
            "saveTo",
            "compression",
            "sendTo"
          ]
        }
      },
      {
        "name": "get_policy_by_id",
        "description": "Get detailed information about a specific policy by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the policy to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "update_policy_priorities",
        "description": "Update the priority order of policies",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Ordered list of policy IDs that defines their priority (first has highest priority)"
            },
            "organizationIds": {
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "number"
                },
                {
                  "type": "string"
                }
              ],
              "description": "Organization IDs to associate with priority update. Defaults to [0]."
            }
          },
          "required": [
            "ids"
          ]
        }
      },
      {
        "name": "get_policy_match_stats",
        "description": "Get statistics on how many endpoints match each policy based on filter criteria",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Filter assets by name"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter assets by tags"
            },
            "issue": {
              "type": "string",
              "description": "Filter assets by issue"
            },
            "policy": {
              "type": "string",
              "description": "Filter assets by policy name"
            },
            "groupId": {
              "type": "string",
              "description": "Filter assets by group ID"
            },
            "version": {
              "type": "string",
              "description": "Filter assets by agent version"
            },
            "platform": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter assets by platform (e.g., [\"windows\"])"
            },
            "ipAddress": {
              "type": "string",
              "description": "Filter assets by IP address"
            },
            "searchTerm": {
              "type": "string",
              "description": "General search term for filtering assets"
            },
            "onlineStatus": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter assets by online status (e.g., [\"online\"])"
            },
            "groupFullPath": {
              "type": "string",
              "description": "Filter assets by full group path"
            },
            "managedStatus": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter assets by managed status (e.g., [\"managed\"])"
            },
            "isolationStatus": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter assets by isolation status (e.g., [\"isolated\"])"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "type": "string"
                  }
                ]
              },
              "description": "Organization IDs to filter by. Defaults to [0]."
            },
            "excludedEndpointIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exclude these endpoint IDs"
            },
            "includedEndpointIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Include only these endpoint IDs"
            }
          },
          "required": []
        }
      },
      {
        "name": "delete_policy_by_id",
        "description": "Delete a specific policy by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the policy to delete"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_task_assignments_by_id",
        "description": "Get all assignments associated with a specific task by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to retrieve assignments for"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "cancel_task_assignment",
        "description": "Cancel a task assignment by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assignmentId": {
              "type": "string",
              "description": "The ID of the task assignment to cancel"
            }
          },
          "required": [
            "assignmentId"
          ]
        }
      },
      {
        "name": "delete_task_assignment",
        "description": "Delete a specific task assignment by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assignmentId": {
              "type": "string",
              "description": "The ID of the task assignment to delete"
            }
          },
          "required": [
            "assignmentId"
          ]
        }
      },
      {
        "name": "get_task_by_id",
        "description": "Get detailed information about a specific task by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the task to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "cancel_task_by_id",
        "description": "Cancel a specific task by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the task to cancel"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "delete_task_by_id",
        "description": "Delete a specific task by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the task to delete"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_triage_tags",
        "description": "List all triage rule tags in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "withCount": {
              "type": "boolean",
              "description": "Whether to include count of rules for each tag. Defaults to true."
            },
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter triage tags by. Leave empty to use default (0)."
            }
          },
          "required": []
        }
      },
      {
        "name": "create_triage_tag",
        "description": "Create a new triage rule tag",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the tag to create"
            },
            "organizationId": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "number"
                }
              ],
              "description": "Organization ID to associate the tag with. Defaults to 0."
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "create_triage_rule",
        "description": "Create a new triage rule",
        "inputSchema": {
          "type": "object",
          "properties": {
            "rule": {
              "type": "string",
              "description": "The YARA rule content"
            },
            "engine": {
              "type": "string",
              "description": "Rule engine to use, e.g., \"yara\""
            },
            "searchIn": {
              "type": "string",
              "description": "Where to search, e.g., \"filesystem\""
            },
            "description": {
              "type": "string",
              "description": "A descriptive name for the triage rule"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "number"
                  }
                ]
              },
              "description": "Organization IDs to associate with this rule. Defaults to [0]"
            }
          },
          "required": [
            "description",
            "rule",
            "searchIn",
            "engine"
          ]
        }
      },
      {
        "name": "update_triage_rule",
        "description": "Update an existing triage rule by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the triage rule to update"
            },
            "rule": {
              "type": "string",
              "description": "The YARA rule content"
            },
            "searchIn": {
              "type": "string",
              "description": "Where to search, e.g., \"filesystem\""
            },
            "description": {
              "type": "string",
              "description": "A descriptive name for the triage rule"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "type": "string"
                  }
                ]
              },
              "description": "Organization IDs to associate with this rule. Defaults to [0]"
            }
          },
          "required": [
            "id",
            "description",
            "rule",
            "searchIn"
          ]
        }
      },
      {
        "name": "delete_triage_rule",
        "description": "Delete an existing triage rule by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the triage rule to delete"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_triage_rule_by_id",
        "description": "Get a specific triage rule by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the triage rule to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "validate_triage_rule",
        "description": "Validate a triage rule syntax without creating it",
        "inputSchema": {
          "type": "object",
          "properties": {
            "rule": {
              "type": "string",
              "description": "The YARA rule content to validate"
            }
          },
          "required": [
            "rule"
          ]
        }
      },
      {
        "name": "assign_triage_task",
        "description": "Assign a triage task to endpoints based on filter criteria",
        "inputSchema": {
          "type": "object",
          "properties": {
            "caseId": {
              "type": "string",
              "description": "Case ID for the triage task"
            },
            "filter": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Filter by asset name"
                },
                "tags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by tags"
                },
                "issue": {
                  "type": "string",
                  "description": "Filter by issue"
                },
                "policy": {
                  "type": "string",
                  "description": "Filter by policy"
                },
                "groupId": {
                  "type": "string",
                  "description": "Filter by group ID"
                },
                "version": {
                  "type": "string",
                  "description": "Filter by agent version"
                },
                "platform": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by platform (e.g., [\"windows\"])"
                },
                "ipAddress": {
                  "type": "string",
                  "description": "Filter by IP address"
                },
                "searchTerm": {
                  "type": "string",
                  "description": "Optional search term"
                },
                "onlineStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by online status"
                },
                "groupFullPath": {
                  "type": "string",
                  "description": "Filter by full group path"
                },
                "managedStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by managed status (e.g., [\"managed\"])"
                },
                "isolationStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by isolation status"
                },
                "organizationIds": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "description": "Organization IDs filter"
                },
                "excludedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to exclude"
                },
                "includedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to include"
                }
              },
              "description": "Filter criteria for selecting endpoints"
            },
            "taskConfig": {
              "type": "object",
              "required": [
                "choice"
              ],
              "properties": {
                "choice": {
                  "type": "string",
                  "description": "Configuration choice, e.g., \"use-custom-options\""
                }
              },
              "description": "Task configuration options"
            },
            "mitreAttack": {
              "type": "object",
              "required": [
                "enabled"
              ],
              "properties": {
                "enabled": {
                  "type": "boolean",
                  "description": "Whether to enable MITRE ATT&CK framework"
                }
              },
              "description": "MITRE ATT&CK configuration"
            },
            "triageRuleIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of triage rule IDs to apply"
            }
          },
          "required": [
            "caseId",
            "triageRuleIds",
            "taskConfig",
            "mitreAttack",
            "filter"
          ]
        }
      },
      {
        "name": "add_note_to_case",
        "description": "Add a note to a specific case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "note": {
              "type": "string",
              "description": "The content of the note to add to the case"
            },
            "caseId": {
              "type": "string",
              "description": "The ID of the case to add a note to (e.g., \"C-2022-0002\")"
            }
          },
          "required": [
            "caseId",
            "note"
          ]
        }
      },
      {
        "name": "update_note_in_case",
        "description": "Update an existing note in a specific case",
        "inputSchema": {
          "type": "object",
          "properties": {
            "note": {
              "type": "string",
              "description": "The new content for the note"
            },
            "caseId": {
              "type": "string",
              "description": "The ID of the case containing the note (e.g., \"C-2022-0002\")"
            },
            "noteId": {
              "type": "string",
              "description": "The ID of the note to update (e.g., \"8d9baa16-9aa3-4e4f-a08e-a74341ce2f90\")"
            }
          },
          "required": [
            "caseId",
            "noteId",
            "note"
          ]
        }
      },
      {
        "name": "delete_note_from_case",
        "description": "Delete a note from a case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "caseId": {
              "type": "string",
              "description": "The ID of the case containing the note (e.g., \"C-2022-0002\")"
            },
            "noteId": {
              "type": "string",
              "description": "The ID of the note to delete (e.g., \"8d9baa16-9aa3-4e4f-a08e-a74341ce2f90\")"
            }
          },
          "required": [
            "caseId",
            "noteId"
          ]
        }
      },
      {
        "name": "export_cases",
        "description": "Export cases data from the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter cases by. Leave empty to use default (0)."
            }
          },
          "required": []
        }
      },
      {
        "name": "export_case_notes",
        "description": "Export notes for a specific case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "caseId": {
              "type": "string",
              "description": "The ID of the case to export notes for"
            }
          },
          "required": [
            "caseId"
          ]
        }
      },
      {
        "name": "export_case_endpoints",
        "description": "Export endpoints for a specific case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "caseId": {
              "type": "string",
              "description": "The ID of the case to export endpoints for"
            },
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter by. Defaults to \"0\"."
            }
          },
          "required": [
            "caseId"
          ]
        }
      },
      {
        "name": "export_case_activities",
        "description": "Export activities for a specific case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "caseId": {
              "type": "string",
              "description": "The ID of the case to export activities for"
            }
          },
          "required": [
            "caseId"
          ]
        }
      },
      {
        "name": "create_case",
        "description": "Create a new case in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the case"
            },
            "visibility": {
              "type": "string",
              "description": "Visibility of the case. Defaults to \"public-to-organization\""
            },
            "ownerUserId": {
              "type": "string",
              "description": "User ID of the case owner"
            },
            "organizationId": {
              "type": "number",
              "description": "Organization ID to create the case in. Defaults to 0."
            },
            "assignedUserIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of user IDs to assign to the case. Defaults to empty array."
            }
          },
          "required": [
            "name",
            "ownerUserId"
          ]
        }
      },
      {
        "name": "update_case",
        "description": "Update an existing case by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the case to update"
            },
            "name": {
              "type": "string",
              "description": "New name for the case"
            },
            "notes": {
              "type": "array",
              "description": "New notes for the case"
            },
            "status": {
              "enum": [
                "open",
                "closed",
                "archived"
              ],
              "type": "string",
              "description": "New status for the case"
            },
            "visibility": {
              "type": "string",
              "description": "New visibility setting for the case"
            },
            "ownerUserId": {
              "type": "string",
              "description": "New owner user ID for the case"
            },
            "assignedUserIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "New array of user IDs to assign to the case"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_case_by_id",
        "description": "Get detailed information about a specific case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the case to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "close_case_by_id",
        "description": "Close a case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the case to close"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "open_case_by_id",
        "description": "Open a previously closed case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the case to open"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "archive_case_by_id",
        "description": "Archive a case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the case to archive"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "change_case_owner",
        "description": "Change the owner of a case",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the case to change owner for"
            },
            "newOwnerId": {
              "type": "string",
              "description": "User ID of the new owner"
            }
          },
          "required": [
            "id",
            "newOwnerId"
          ]
        }
      },
      {
        "name": "check_case_name",
        "description": "Check if a case name is already in use",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The case name to check for availability"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "get_case_activities",
        "description": "Get activity history for a specific case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the case to retrieve activities for"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_case_endpoints",
        "description": "Get all endpoints associated with a specific case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the case to retrieve endpoints for"
            },
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter endpoints by. Defaults to 0."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_case_tasks_by_id",
        "description": "Get all tasks associated with a specific case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the case to retrieve tasks for"
            },
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter tasks by. Leave empty to use default (0)."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_case_users",
        "description": "Get all users associated with a specific case by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the case to retrieve users for (e.g., C-2022-0001)"
            },
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter users by. Leave empty to use default (0)."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "remove_endpoints_from_case",
        "description": "Remove endpoints from a case based on specified filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the case to remove endpoints from"
            },
            "filter": {
              "type": "object",
              "required": [],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Filter by asset name"
                },
                "tags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by tags"
                },
                "issue": {
                  "type": "string",
                  "description": "Filter by issue"
                },
                "policy": {
                  "type": "string",
                  "description": "Filter by policy"
                },
                "groupId": {
                  "type": "string",
                  "description": "Filter by group ID"
                },
                "version": {
                  "type": "string",
                  "description": "Filter by agent version"
                },
                "platform": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by platform (e.g., [\"windows\"])"
                },
                "ipAddress": {
                  "type": "string",
                  "description": "Filter by IP address"
                },
                "searchTerm": {
                  "type": "string",
                  "description": "Optional search term"
                },
                "onlineStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by online status (e.g., [\"online\"])"
                },
                "groupFullPath": {
                  "type": "string",
                  "description": "Filter by full group path"
                },
                "managedStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by managed status (e.g., [\"managed\"])"
                },
                "isolationStatus": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by isolation status (e.g., [\"isolated\"])"
                },
                "organizationIds": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "number"
                      },
                      {
                        "type": "string"
                      }
                    ]
                  },
                  "description": "Organization IDs filter. Defaults to [0]"
                },
                "excludedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to exclude"
                },
                "includedEndpointIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of endpoint IDs to remove"
                }
              },
              "description": "Filter object to specify which endpoints to remove"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "remove_task_assignment_from_case",
        "description": "Remove a specific task assignment from a case",
        "inputSchema": {
          "type": "object",
          "properties": {
            "caseId": {
              "type": "string",
              "description": "The ID of the case to remove the task assignment from"
            },
            "taskAssignmentId": {
              "type": "string",
              "description": "The ID of the task assignment to remove"
            }
          },
          "required": [
            "caseId",
            "taskAssignmentId"
          ]
        }
      },
      {
        "name": "import_task_assignments_to_case",
        "description": "Import task assignments to a specific case",
        "inputSchema": {
          "type": "object",
          "properties": {
            "caseId": {
              "type": "string",
              "description": "ID of the case to import task assignments to"
            },
            "taskAssignmentIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of task assignment IDs to import to the case"
            }
          },
          "required": [
            "caseId",
            "taskAssignmentIds"
          ]
        }
      },
      {
        "name": "list_repositories",
        "description": "List all evidence repositories in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "organizationIds": {
              "type": "string",
              "description": "Organization IDs to filter repositories by. Leave empty to use default (0)."
            }
          },
          "required": []
        }
      },
      {
        "name": "get_repository_by_id",
        "description": "Get detailed information about a specific evidence repository by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the repository to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "create_smb_repository",
        "description": "Create a new SMB evidence repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for the SMB repository"
            },
            "path": {
              "type": "string",
              "description": "Network share path (e.g. \\\\Network\\Share)"
            },
            "password": {
              "type": "string",
              "description": "Password for SMB authentication"
            },
            "username": {
              "type": "string",
              "description": "Username for SMB authentication"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Organization IDs to associate the repository with. Defaults to empty array."
            }
          },
          "required": [
            "name",
            "path",
            "username",
            "password"
          ]
        }
      },
      {
        "name": "update_smb_repository",
        "description": "Update an existing SMB repository by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the SMB repository to update"
            },
            "name": {
              "type": "string",
              "description": "Updated name for the SMB repository"
            },
            "path": {
              "type": "string",
              "description": "Updated network share path (e.g. \\\\Network\\Share)"
            },
            "password": {
              "type": "string",
              "description": "Updated password for SMB authentication"
            },
            "username": {
              "type": "string",
              "description": "Updated username for SMB authentication"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Updated organization IDs to associate the repository with"
            }
          },
          "required": [
            "id",
            "name",
            "path",
            "username",
            "password"
          ]
        }
      },
      {
        "name": "create_sftp_repository",
        "description": "Create a new SFTP evidence repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "host": {
              "type": "string",
              "description": "SFTP server hostname or IP address"
            },
            "name": {
              "type": "string",
              "description": "Name for the SFTP repository"
            },
            "path": {
              "type": "string",
              "description": "Path on the SFTP server (e.g. /)"
            },
            "port": {
              "type": "number",
              "description": "SFTP server port (default: 22)"
            },
            "password": {
              "type": "string",
              "description": "Password for SFTP authentication"
            },
            "username": {
              "type": "string",
              "description": "Username for SFTP authentication"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Organization IDs to associate the repository with"
            }
          },
          "required": [
            "name",
            "host",
            "path",
            "username",
            "password"
          ]
        }
      },
      {
        "name": "update_sftp_repository",
        "description": "Update an existing SFTP repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the SFTP repository to update"
            },
            "host": {
              "type": "string",
              "description": "Updated SFTP server hostname or IP address"
            },
            "name": {
              "type": "string",
              "description": "Updated name for the SFTP repository"
            },
            "path": {
              "type": "string",
              "description": "Updated path on the SFTP server (e.g. /)"
            },
            "port": {
              "type": "number",
              "description": "Updated SFTP server port (default: 22)"
            },
            "password": {
              "type": "string",
              "description": "Updated password for SFTP authentication"
            },
            "username": {
              "type": "string",
              "description": "Updated username for SFTP authentication"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Updated organization IDs to associate the repository with"
            }
          },
          "required": [
            "id",
            "name",
            "host",
            "path",
            "username",
            "password"
          ]
        }
      },
      {
        "name": "create_ftps_repository",
        "description": "Create a new FTPS evidence repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "host": {
              "type": "string",
              "description": "FTPS server hostname or IP address"
            },
            "name": {
              "type": "string",
              "description": "Name for the FTPS repository"
            },
            "path": {
              "type": "string",
              "description": "Path on the FTPS server (e.g. /)"
            },
            "port": {
              "type": "number",
              "description": "FTPS server port (default: 22)"
            },
            "password": {
              "type": "string",
              "description": "Password for FTPS authentication"
            },
            "username": {
              "type": "string",
              "description": "Username for FTPS authentication"
            },
            "publicKey": {
              "type": "string",
              "description": "Public key for FTPS authentication (optional)"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Organization IDs to associate the repository with"
            },
            "allowSelfSignedSSL": {
              "type": "boolean",
              "description": "Whether to allow self-signed SSL certificates"
            }
          },
          "required": [
            "name",
            "host",
            "path",
            "username",
            "password"
          ]
        }
      },
      {
        "name": "update_ftps_repository",
        "description": "Update an existing FTPS evidence repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the FTPS repository to update"
            },
            "host": {
              "type": "string",
              "description": "Updated FTPS server hostname or IP address"
            },
            "name": {
              "type": "string",
              "description": "Updated name for the FTPS repository"
            },
            "path": {
              "type": "string",
              "description": "Updated path on the FTPS server (e.g. /)"
            },
            "port": {
              "type": "number",
              "description": "Updated FTPS server port (default: 22)"
            },
            "password": {
              "type": "string",
              "description": "Updated password for FTPS authentication"
            },
            "username": {
              "type": "string",
              "description": "Updated username for FTPS authentication"
            },
            "publicKey": {
              "type": "string",
              "description": "Public key for FTPS authentication (optional)"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Updated organization IDs to associate the repository with"
            },
            "allowSelfSignedSSL": {
              "type": "boolean",
              "description": "Whether to allow self-signed SSL certificates"
            }
          },
          "required": [
            "id",
            "name",
            "host",
            "path",
            "username",
            "password"
          ]
        }
      },
      {
        "name": "validate_ftps_repository",
        "description": "Validate FTPS repository configuration without creating it",
        "inputSchema": {
          "type": "object",
          "properties": {
            "host": {
              "type": "string",
              "description": "FTPS server hostname or IP address"
            },
            "name": {
              "type": "string",
              "description": "Name for the FTPS repository"
            },
            "path": {
              "type": "string",
              "description": "Path on the FTPS server (e.g. /)"
            },
            "port": {
              "type": "number",
              "description": "FTPS server port (default: 22)"
            },
            "password": {
              "type": "string",
              "description": "Password for FTPS authentication"
            },
            "username": {
              "type": "string",
              "description": "Username for FTPS authentication"
            },
            "publicKey": {
              "type": "string",
              "description": "Public key for FTPS authentication (optional)"
            },
            "allowSelfSignedSSL": {
              "type": "boolean",
              "description": "Whether to allow self-signed SSL certificates"
            }
          },
          "required": [
            "name",
            "host",
            "path",
            "username",
            "password"
          ]
        }
      },
      {
        "name": "create_azure_storage_repository",
        "description": "Create a new Azure Storage repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for the Azure Storage repository"
            },
            "SASUrl": {
              "type": "string",
              "description": "SAS URL for Azure Storage access"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Organization IDs to associate the repository with. Defaults to empty array."
            }
          },
          "required": [
            "name",
            "SASUrl"
          ]
        }
      },
      {
        "name": "update_azure_storage_repository",
        "description": "Update an existing Azure Storage repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the Azure Storage repository to update"
            },
            "name": {
              "type": "string",
              "description": "Updated name for the Azure Storage repository"
            },
            "SASUrl": {
              "type": "string",
              "description": "Updated SAS URL for Azure Storage access"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Updated organization IDs to associate the repository with. Defaults to empty array."
            }
          },
          "required": [
            "id",
            "name",
            "SASUrl"
          ]
        }
      },
      {
        "name": "validate_azure_storage_repository",
        "description": "Validate an Azure Storage repository configuration",
        "inputSchema": {
          "type": "object",
          "properties": {
            "SASUrl": {
              "type": "string",
              "description": "SAS URL for Azure Storage access"
            }
          },
          "required": [
            "SASUrl"
          ]
        }
      },
      {
        "name": "create_amazon_s3_repository",
        "description": "Create a new Amazon S3 repository for evidence storage",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for the Amazon S3 repository"
            },
            "bucket": {
              "type": "string",
              "description": "S3 bucket name"
            },
            "region": {
              "type": "string",
              "description": "AWS region (e.g. eu-west-1)"
            },
            "accessKeyId": {
              "type": "string",
              "description": "AWS access key ID"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Organization IDs to associate the repository with. Defaults to empty array."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "AWS secret access key"
            }
          },
          "required": [
            "name",
            "region",
            "bucket",
            "accessKeyId",
            "secretAccessKey"
          ]
        }
      },
      {
        "name": "update_amazon_s3_repository",
        "description": "Update an existing Amazon S3 repository",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the Amazon S3 repository to update"
            },
            "name": {
              "type": "string",
              "description": "Updated name for the Amazon S3 repository"
            },
            "bucket": {
              "type": "string",
              "description": "Updated S3 bucket name"
            },
            "region": {
              "type": "string",
              "description": "Updated AWS region (e.g. eu-west-1)"
            },
            "accessKeyId": {
              "type": "string",
              "description": "Updated AWS access key ID"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Updated organization IDs to associate the repository with. Defaults to empty array."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "Updated AWS secret access key"
            }
          },
          "required": [
            "id",
            "name",
            "region",
            "bucket",
            "accessKeyId",
            "secretAccessKey"
          ]
        }
      },
      {
        "name": "validate_amazon_s3_repository",
        "description": "Validate Amazon S3 repository configuration",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for the Amazon S3 repository"
            },
            "bucket": {
              "type": "string",
              "description": "S3 bucket name"
            },
            "region": {
              "type": "string",
              "description": "AWS region (e.g. eu-west-1)"
            },
            "accessKeyId": {
              "type": "string",
              "description": "AWS access key ID"
            },
            "organizationIds": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Organization IDs to associate the repository with. Defaults to empty array."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "AWS secret access key"
            }
          },
          "required": [
            "name",
            "region",
            "bucket",
            "accessKeyId",
            "secretAccessKey"
          ]
        }
      },
      {
        "name": "get_repository_by_id",
        "description": "Get detailed information about a specific evidence repository by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the repository to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "delete_repository",
        "description": "Delete an evidence repository by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the repository to delete"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "download_case_ppc",
        "description": "Download a PPC file for a specific endpoint and task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to download the PPC file for"
            },
            "endpointId": {
              "type": "string",
              "description": "The ID of the endpoint to download the PPC file for"
            }
          },
          "required": [
            "endpointId",
            "taskId"
          ]
        }
      },
      {
        "name": "download_task_report",
        "description": "Download a task report for a specific endpoint and task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to download the task report for"
            },
            "endpointId": {
              "type": "string",
              "description": "The ID of the endpoint to download the task report for"
            }
          },
          "required": [
            "endpointId",
            "taskId"
          ]
        }
      },
      {
        "name": "get_report_file_info",
        "description": "Get information about a PPC file for a specific endpoint and task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to get report file information for"
            },
            "endpointId": {
              "type": "string",
              "description": "The ID of the endpoint to get report file information for"
            }
          },
          "required": [
            "endpointId",
            "taskId"
          ]
        }
      },
      {
        "name": "get_organization_users",
        "description": "Get users for a specific organization by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the organization to retrieve users for"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "assign_users_to_organization",
        "description": "Assign users to a specific organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the organization to assign users to"
            },
            "userIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of user IDs to assign to the organization"
            }
          },
          "required": [
            "id",
            "userIds"
          ]
        }
      },
      {
        "name": "remove_user_from_organization",
        "description": "Remove a user from an organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "userId": {
              "type": "string",
              "description": "The ID of the user to remove from the organization"
            },
            "organizationId": {
              "type": "string",
              "description": "The ID of the organization to remove the user from"
            }
          },
          "required": [
            "organizationId",
            "userId"
          ]
        }
      },
      {
        "name": "create_organization",
        "description": "Create a new organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the organization"
            },
            "note": {
              "type": "string",
              "description": "Additional notes about the organization (optional)"
            },
            "contact": {
              "type": "object",
              "required": [
                "name",
                "email"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Contact name"
                },
                "email": {
                  "type": "string",
                  "description": "Contact email address"
                },
                "phone": {
                  "type": "string",
                  "description": "Contact phone number (optional)"
                },
                "title": {
                  "type": "string",
                  "description": "Contact title (optional)"
                },
                "mobile": {
                  "type": "string",
                  "description": "Contact mobile number (optional)"
                }
              },
              "description": "Contact information for the organization"
            },
            "shareableDeploymentEnabled": {
              "type": "boolean",
              "description": "Whether shareable deployment is enabled. Defaults to false."
            }
          },
          "required": [
            "name",
            "contact"
          ]
        }
      },
      {
        "name": "update_organization_by_id",
        "description": "Update an existing organization by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "The ID of the organization to update"
            },
            "name": {
              "type": "string",
              "description": "Updated name of the organization"
            },
            "note": {
              "type": "string",
              "description": "Additional notes about the organization"
            },
            "contact": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Contact name"
                },
                "email": {
                  "type": "string",
                  "description": "Contact email address"
                },
                "phone": {
                  "type": "string",
                  "description": "Contact phone number"
                },
                "title": {
                  "type": "string",
                  "description": "Contact title"
                },
                "mobile": {
                  "type": "string",
                  "description": "Contact mobile number"
                }
              },
              "description": "Updated contact information for the organization"
            },
            "shareableDeploymentEnabled": {
              "type": "boolean",
              "description": "Whether shareable deployment is enabled"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_organization_by_id",
        "description": "Get detailed information about a specific organization by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "The ID of the organization to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "check_organization_name_exists",
        "description": "Check if an organization name already exists in the system",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the organization to check"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "get_shareable_deployment_info",
        "description": "Get shareable deployment information using a deployment token",
        "inputSchema": {
          "type": "object",
          "properties": {
            "deploymentToken": {
              "type": "string",
              "description": "The deployment token to retrieve information for"
            }
          },
          "required": [
            "deploymentToken"
          ]
        }
      },
      {
        "name": "update_organization_shareable_deployment",
        "description": "Update an organization's shareable deployment settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "The ID of the organization to update"
            },
            "status": {
              "type": "boolean",
              "description": "Whether shareable deployment should be enabled (true) or disabled (false)"
            }
          },
          "required": [
            "id",
            "status"
          ]
        }
      },
      {
        "name": "update_organization_deployment_token",
        "description": "Update the deployment token for a specific organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "The ID of the organization to update"
            },
            "deploymentToken": {
              "type": "string",
              "description": "New deployment token for the organization"
            }
          },
          "required": [
            "id",
            "deploymentToken"
          ]
        }
      },
      {
        "name": "delete_organization",
        "description": "Delete an organization by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "The ID of the organization to delete"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "add_tags_to_organization",
        "description": "Add tags to an organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "ID of the organization to add tags to"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of tags to add to the organization"
            }
          },
          "required": [
            "id",
            "tags"
          ]
        }
      },
      {
        "name": "delete_tags_from_organization",
        "description": "Delete specific tags from an organization",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "ID of the organization to delete tags from"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of tags to delete from the organization"
            }
          },
          "required": [
            "id",
            "tags"
          ]
        }
      },
      {
        "name": "get_user_by_id",
        "description": "Get detailed information about a specific user by their ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the user to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "call_webhook",
        "description": "Call a webhook with the specified parameters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "string",
              "description": "The data parameter for the webhook (e.g., IP address like \"192.168.1.100\")"
            },
            "slug": {
              "type": "string",
              "description": "The webhook slug (e.g., \"air-generic-url-webhook\")"
            },
            "token": {
              "type": "string",
              "description": "The webhook token for authentication"
            }
          },
          "required": [
            "slug",
            "data",
            "token"
          ]
        }
      },
      {
        "name": "post_webhook",
        "description": "Post data to a webhook",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "description": "The data to be sent in the request body"
            },
            "slug": {
              "type": "string",
              "description": "The webhook slug (e.g., \"air-generic-url-webhook\")"
            },
            "token": {
              "type": "string",
              "description": "The webhook token for authentication"
            }
          },
          "required": [
            "slug",
            "data",
            "token"
          ]
        }
      },
      {
        "name": "get_task_assignments",
        "description": "Get all assignments for a specific task by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "slug": {
              "type": "string",
              "description": "The webhook slug (e.g., \"air-generic-url-webhook\")"
            },
            "token": {
              "type": "string",
              "description": "The webhook token for authentication"
            },
            "taskId": {
              "type": "string",
              "description": "The ID of the task to retrieve assignments for"
            }
          },
          "required": [
            "slug",
            "taskId",
            "token"
          ]
        }
      },
      {
        "name": "update_banner_message",
        "description": "Update the system banner message settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Whether the banner message is enabled or disabled"
            }
          },
          "required": [
            "enabled"
          ]
        }
      }
    ]
  },
  {
    "name": "bitrefill-bitrefill-mcp-server",
    "title": "Bitrefill Search and Shop",
    "description": "This MCP wraps Bitrefill public API to allow agents to search for products and shop using cryptocurrencies like Bitcoin, Ethereum, Solana, and many more.",
    "icon": "https://avatars.githubusercontent.com/bitrefill",
    "isOfficial": true,
    "homepage": "https://github.com/bitrefill/bitrefill-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "bitrefill-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "search",
        "description": "Search for gift cards, esims, mobile topups and more. It's suggested to use the `categories` tool before searching for products, to have a better understanding of what's available.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "col": {
              "type": "number",
              "description": "Column layout parameter"
            },
            "rec": {
              "type": "number",
              "description": "Recommendation parameter"
            },
            "sec": {
              "type": "number",
              "description": "Security parameter"
            },
            "src": {
              "type": "string",
              "description": "Source of the request"
            },
            "cart": {
              "type": "string",
              "description": "Cart identifier"
            },
            "skip": {
              "type": "number",
              "description": "Number of results to skip (for pagination)"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "query": {
              "type": "string",
              "description": "Search query (e.g., 'Amazon', 'Netflix', 'AT&T' or '*' for all)"
            },
            "prefcc": {
              "type": "number",
              "description": "Preferred country code parameter"
            },
            "country": {
              "type": "string",
              "description": "Country code (e.g., 'US', 'IT', 'GB')"
            },
            "category": {
              "type": "string",
              "description": "Filter by category (e.g., 'gaming', 'entertainment')"
            },
            "language": {
              "type": "string",
              "description": "Language code for results (e.g., 'en')"
            },
            "beta_flags": {
              "type": "string",
              "description": "Beta feature flags"
            },
            "do_recommend": {
              "type": "number",
              "description": "Enable recommendations"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "detail",
        "description": "Get detailed information about a product",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Unique identifier of the product"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "categories",
        "description": "Get the full product type/categories map. It's suggested to use this tool to get the categories and then use the `search` tool to search for products in a specific category.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "blazickjp-arxiv-mcp-server",
    "title": "ArXiv MCP Server",
    "description": "The ArXiv MCP Server bridges the gap between AI models and academic research by providing a sophisticated interface to arXiv's extensive research repository. This server enables AI assistants to perform precise paper searches and access full paper content, enhancing their ability to engage with scientific literature.",
    "icon": "https://avatars.githubusercontent.com/blazickjp",
    "isOfficial": false,
    "homepage": "https://github.com/blazickjp/arxiv-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "arxiv-mcp-server"
      ],
      "env": {
        "ARXIV_STORAGE_PATH": "<arxiv-storage-path>"
      }
    },
    "parameters": [
      {
        "name": "ARXIV_STORAGE_PATH",
        "description": "Paper storage location",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "blazickjp-web-browser-mcp-server",
    "title": "web-browser-mcp-server",
    "description": "Enables web browsing capabilities using BeautifulSoup4",
    "icon": "https://avatars.githubusercontent.com/blazickjp",
    "isOfficial": false,
    "homepage": "https://github.com/blazickjp/web-browser-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "web-browser-mcp-server"
      ],
      "env": {
        "REQUEST_TIMEOUT": "<request-timeout>"
      }
    },
    "parameters": [
      {
        "name": "REQUEST_TIMEOUT",
        "description": "The request timeout period in seconds for the web-browser-mcp-server.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "b-open-io-bsv-mcp",
    "title": "Bitcoin SV MCP Server",
    "description": "A collection of Bitcoin SV tools for the Model Context Protocol that enables AI assistants to interact with the BSV blockchain through wallet operations, ordinals (NFTs), and various blockchain utilities.",
    "icon": "https://avatars.githubusercontent.com/b-open-io",
    "isOfficial": false,
    "homepage": "https://github.com/b-open-io/bsv-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "bsv-mcp"
      ],
      "env": {
        "DISABLE_TOOLS": "<disable-tools>",
        "DISABLE_PROMPTS": "<disable-prompts>",
        "PRIVATE_KEY_WIF": "<private-key-wif>",
        "IDENTITY_KEY_WIF": "<identity-key-wif>",
        "DISABLE_BSV_TOOLS": "<disable-bsv-tools>",
        "DISABLE_RESOURCES": "<disable-resources>",
        "DISABLE_MNEE_TOOLS": "<disable-mnee-tools>",
        "DISABLE_UTILS_TOOLS": "<disable-utils-tools>",
        "DISABLE_BROADCASTING": "<disable-broadcasting>",
        "DISABLE_WALLET_TOOLS": "<disable-wallet-tools>",
        "DISABLE_ORDINALS_TOOLS": "<disable-ordinals-tools>"
      }
    },
    "parameters": [
      {
        "name": "DISABLE_TOOLS",
        "description": "Set to true to disable all tools",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DISABLE_PROMPTS",
        "description": "Set to true to disable all educational prompts",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "PRIVATE_KEY_WIF",
        "description": "Your private key in WIF format for Bitcoin wallet operations",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "IDENTITY_KEY_WIF",
        "description": "Optional WIF for identity key; if set, ordinals inscriptions will be signed with sigma-protocol for authentication, curation, and web-of-trust",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DISABLE_BSV_TOOLS",
        "description": "Set to true to disable BSV blockchain tools",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DISABLE_RESOURCES",
        "description": "Set to true to disable all resources (BRCs, changelog)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DISABLE_MNEE_TOOLS",
        "description": "Set to true to disable MNEE token tools",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DISABLE_UTILS_TOOLS",
        "description": "Set to true to disable utility tools",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DISABLE_BROADCASTING",
        "description": "Set to true to disable transaction broadcasting; returns raw transaction hex instead - useful for testing and transaction review before broadcasting",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DISABLE_WALLET_TOOLS",
        "description": "Set to true to disable Bitcoin wallet tools",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DISABLE_ORDINALS_TOOLS",
        "description": "Set to true to disable Ordinals/NFT tools",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "brightdata-brightdata-mcp",
    "title": "Bright Data MCP",
    "description": "Official Bright Data server for the Model Context Protocol that enables AI assistants like Claude Desktop to reference and make decisions based on real-time public web data.",
    "icon": "https://avatars.githubusercontent.com/brightdata",
    "isOfficial": true,
    "homepage": "https://github.com/brightdata/brightdata-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@brightdata/mcp"
      ],
      "env": {
        "API_TOKEN": "<api-token>",
        "BROWSER_AUTH": "<browser-auth>",
        "WEB_UNLOCKER_ZONE": "<web-unlocker-zone>"
      }
    },
    "parameters": [
      {
        "name": "API_TOKEN",
        "description": "Your Bright Data API token from the user settings page",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "BROWSER_AUTH",
        "description": "Optional authentication string for enabling remote browser control tools, formatted like: brd-customer-[your-customer-ID]-zone-[your-zone-ID]:[your-password]",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "WEB_UNLOCKER_ZONE",
        "description": "Optional override for the default mcp_unlocker zone name",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "search_engine",
        "description": "Scrape search results from Google, Bing or Yandex. Returns SERP results in markdown (URL, title, description)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string"
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for next page"
            },
            "engine": {
              "enum": [
                "google",
                "bing",
                "yandex"
              ],
              "type": "string",
              "default": "google"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "scrape_as_markdown",
        "description": "Scrape a single webpage URL with advanced options for content extraction and get back the results in MarkDown language. This tool can unlock any webpage even if it uses bot detection or CAPTCHA.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "scrape_as_html",
        "description": "Scrape a single webpage URL with advanced options for content extraction and get back the results in HTML. This tool can unlock any webpage even if it uses bot detection or CAPTCHA.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "extract",
        "description": "Scrape a webpage and extract structured data as JSON. First scrapes the page as markdown, then uses AI sampling to convert it to structured JSON format. This tool can unlock any webpage even if it uses bot detection or CAPTCHA.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            },
            "extraction_prompt": {
              "type": "string",
              "description": "Custom prompt to guide the extraction process. If not provided, will extract general structured data from the page."
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "session_stats",
        "description": "Tell the user about the tool usage during this session",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "web_data_amazon_product",
        "description": "Quickly read structured amazon product data.\nRequires a valid product URL with /dp/ in it.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_amazon_product_reviews",
        "description": "Quickly read structured amazon product review data.\nRequires a valid product URL with /dp/ in it.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_amazon_product_search",
        "description": "Quickly read structured amazon product search data.\nRequires a valid search keyword and amazon domain URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            },
            "keyword": {
              "type": "string"
            },
            "pages_to_search": {
              "type": "string",
              "default": "1"
            }
          },
          "required": [
            "keyword",
            "url"
          ]
        }
      },
      {
        "name": "web_data_walmart_product",
        "description": "Quickly read structured walmart product data.\nRequires a valid product URL with /ip/ in it.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_walmart_seller",
        "description": "Quickly read structured walmart seller data.\nRequires a valid walmart seller URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_ebay_product",
        "description": "Quickly read structured ebay product data.\nRequires a valid ebay product URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_homedepot_products",
        "description": "Quickly read structured homedepot product data.\nRequires a valid homedepot product URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_zara_products",
        "description": "Quickly read structured zara product data.\nRequires a valid zara product URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_etsy_products",
        "description": "Quickly read structured etsy product data.\nRequires a valid etsy product URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_bestbuy_products",
        "description": "Quickly read structured bestbuy product data.\nRequires a valid bestbuy product URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_linkedin_person_profile",
        "description": "Quickly read structured linkedin people profile data.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_linkedin_company_profile",
        "description": "Quickly read structured linkedin company profile data\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_linkedin_job_listings",
        "description": "Quickly read structured linkedin job listings data\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_linkedin_posts",
        "description": "Quickly read structured linkedin posts data\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_linkedin_people_search",
        "description": "Quickly read structured linkedin people search data\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            },
            "last_name": {
              "type": "string"
            },
            "first_name": {
              "type": "string"
            }
          },
          "required": [
            "url",
            "first_name",
            "last_name"
          ]
        }
      },
      {
        "name": "web_data_crunchbase_company",
        "description": "Quickly read structured crunchbase company data\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_zoominfo_company_profile",
        "description": "Quickly read structured ZoomInfo company profile data.\nRequires a valid ZoomInfo company URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_instagram_profiles",
        "description": "Quickly read structured Instagram profile data.\nRequires a valid Instagram URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_instagram_posts",
        "description": "Quickly read structured Instagram post data.\nRequires a valid Instagram URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_instagram_reels",
        "description": "Quickly read structured Instagram reel data.\nRequires a valid Instagram URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_instagram_comments",
        "description": "Quickly read structured Instagram comments data.\nRequires a valid Instagram URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_facebook_posts",
        "description": "Quickly read structured Facebook post data.\nRequires a valid Facebook post URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_facebook_marketplace_listings",
        "description": "Quickly read structured Facebook marketplace listing data.\nRequires a valid Facebook marketplace listing URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_facebook_company_reviews",
        "description": "Quickly read structured Facebook company reviews data.\nRequires a valid Facebook company URL and number of reviews.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            },
            "num_of_reviews": {
              "type": "string"
            }
          },
          "required": [
            "url",
            "num_of_reviews"
          ]
        }
      },
      {
        "name": "web_data_facebook_events",
        "description": "Quickly read structured Facebook events data.\nRequires a valid Facebook event URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_tiktok_profiles",
        "description": "Quickly read structured Tiktok profiles data.\nRequires a valid Tiktok profile URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_tiktok_posts",
        "description": "Quickly read structured Tiktok post data.\nRequires a valid Tiktok post URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_tiktok_shop",
        "description": "Quickly read structured Tiktok shop data.\nRequires a valid Tiktok shop product URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_tiktok_comments",
        "description": "Quickly read structured Tiktok comments data.\nRequires a valid Tiktok video URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_google_maps_reviews",
        "description": "Quickly read structured Google maps reviews data.\nRequires a valid Google maps URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            },
            "days_limit": {
              "type": "string",
              "default": "3"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_google_shopping",
        "description": "Quickly read structured Google shopping data.\nRequires a valid Google shopping product URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_google_play_store",
        "description": "Quickly read structured Google play store data.\nRequires a valid Google play store app URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_apple_app_store",
        "description": "Quickly read structured apple app store data.\nRequires a valid apple app store app URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_reuter_news",
        "description": "Quickly read structured reuter news data.\nRequires a valid reuter news report URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_github_repository_file",
        "description": "Quickly read structured github repository data.\nRequires a valid github repository file URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_yahoo_finance_business",
        "description": "Quickly read structured yahoo finance business data.\nRequires a valid yahoo finance business URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_x_posts",
        "description": "Quickly read structured X post data.\nRequires a valid X post URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_zillow_properties_listing",
        "description": "Quickly read structured zillow properties listing data.\nRequires a valid zillow properties listing URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_booking_hotel_listings",
        "description": "Quickly read structured booking hotel listings data.\nRequires a valid booking hotel listing URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_youtube_profiles",
        "description": "Quickly read structured youtube profiles data.\nRequires a valid youtube profile URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_youtube_comments",
        "description": "Quickly read structured youtube comments data.\nRequires a valid youtube video URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            },
            "num_of_comments": {
              "type": "string",
              "default": "10"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_reddit_posts",
        "description": "Quickly read structured reddit posts data.\nRequires a valid reddit post URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "web_data_youtube_videos",
        "description": "Quickly read structured YouTube videos data.\nRequires a valid YouTube video URL.\nThis can be a cache lookup, so it can be more reliable than scraping",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "scraping_browser_navigate",
        "description": "Navigate a scraping browser session to a new URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to navigate to"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "scraping_browser_go_back",
        "description": "Go back to the previous page",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "scraping_browser_go_forward",
        "description": "Go forward to the next page",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "scraping_browser_links",
        "description": "Get all links on the current page, text and selectors\nIt's strongly recommended that you call the links tool to check that your click target is valid",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "scraping_browser_click",
        "description": "Click on an element.\nAvoid calling this unless you know the element selector (you can use other tools to find those)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for the element to click"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "scraping_browser_type",
        "description": "Type text into an element",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Text to type"
            },
            "submit": {
              "type": "boolean",
              "description": "Whether to submit the form after typing (press Enter)"
            },
            "selector": {
              "type": "string",
              "description": "CSS selector for the element to type into"
            }
          },
          "required": [
            "selector",
            "text"
          ]
        }
      },
      {
        "name": "scraping_browser_wait_for",
        "description": "Wait for an element to be visible on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "timeout": {
              "type": "number",
              "description": "Maximum time to wait in milliseconds (default: 30000)"
            },
            "selector": {
              "type": "string",
              "description": "CSS selector to wait for"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "scraping_browser_screenshot",
        "description": "Take a screenshot of the current page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "full_page": {
              "type": "boolean",
              "description": "Whether to screenshot the full page (default: false)\nYou should avoid fullscreen if it's not important, since the images can be quite large"
            }
          }
        }
      },
      {
        "name": "scraping_browser_get_text",
        "description": "Get the text content of the current page",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "scraping_browser_get_html",
        "description": "Get the HTML content of the current page. Avoid using the full_page option unless it is important to see things like script tags since this can be large",
        "inputSchema": {
          "type": "object",
          "properties": {
            "full_page": {
              "type": "boolean",
              "description": "Whether to get the full page HTML including head and script tags\nAvoid this if you only need the extra HTML, since it can be quite large"
            }
          }
        }
      },
      {
        "name": "scraping_browser_scroll",
        "description": "Scroll to the bottom of the current page",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "scraping_browser_scroll_to",
        "description": "Scroll to a specific element on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "selector": {
              "type": "string",
              "description": "CSS selector for the element to scroll to"
            }
          },
          "required": [
            "selector"
          ]
        }
      }
    ]
  },
  {
    "name": "djyde-browser-mcp",
    "title": "browser-mcp",
    "description": "A MCP server that allows AI assistants to interact with the browser, including getting page content as markdown, modifying page styles, and searching browser history.",
    "icon": "https://avatars.githubusercontent.com/djyde",
    "isOfficial": false,
    "homepage": "https://github.com/djyde/browser-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@djyde/browser-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_current_page_url",
        "description": "Get the URL from current browser browsing tab",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_current_page_markdown",
        "description": "Get the markdown from current browser browsing page",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "append_style",
        "description": "Append a css style to the current browser browsing page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "css_string": {
              "type": "string",
              "description": "The css style to append to the current browser browsing page"
            }
          }
        }
      },
      {
        "name": "history_search",
        "description": "Search the browser history",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "A free-text query to the history service. Leave this empty to retrieve all pages."
            }
          }
        }
      }
    ]
  },
  {
    "name": "browserstack-mcp-server",
    "title": "BrowserStack MCP server",
    "description": "BrowserStack MCP server",
    "icon": "https://avatars.githubusercontent.com/browserstack",
    "isOfficial": true,
    "homepage": "https://github.com/browserstack/mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@browserstack/mcp-server"
      ],
      "env": {
        "BROWSERSTACK_USERNAME": "<browserstack-username>",
        "BROWSERSTACK_ACCESS_KEY": "<browserstack-access-key>"
      }
    },
    "parameters": [
      {
        "name": "BROWSERSTACK_USERNAME",
        "description": "Your BrowserStack username from Account Settings",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "BROWSERSTACK_ACCESS_KEY",
        "description": "Your BrowserStack access key from Account Settings",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "runTestsOnBrowserStack",
        "description": "Use this tool to get instructions for running tests on BrowserStack.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "desiredPlatforms": {
              "type": "array",
              "items": {
                "enum": [
                  "windows",
                  "macos",
                  "android",
                  "ios"
                ],
                "type": "string"
              },
              "description": "The platforms the user wants to test on. Always ask this to the user, do not try to infer this."
            },
            "detectedLanguage": {
              "type": "string",
              "description": "The programming language used in the project. Example: 'nodejs', 'python'"
            },
            "detectedTestingFramework": {
              "type": "string",
              "description": "The testing framework used in the project. Example: 'jest', 'pytest'"
            },
            "detectedBrowserAutomationFramework": {
              "type": "string",
              "description": "The automation framework configured in the project. Example: 'playwright', 'selenium'"
            }
          },
          "required": [
            "detectedBrowserAutomationFramework",
            "detectedTestingFramework",
            "detectedLanguage",
            "desiredPlatforms"
          ]
        }
      },
      {
        "name": "runAppLiveSession",
        "description": "Use this tool when user wants to manually check their app on a particular mobile device using BrowserStack's cloud infrastructure. Can be used to debug crashes, slow performance, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "appPath": {
              "type": "string",
              "description": "The path to the .ipa or .apk file to install on the device. Always ask the user for the app path, do not assume it."
            },
            "desiredPhone": {
              "type": "string",
              "description": "The full name of the device to run the app on. Example: 'iPhone 12 Pro' or 'Samsung Galaxy S20' or 'Google Pixel 6'. Always ask the user for the device they want to use, do not assume it. "
            },
            "desiredPlatform": {
              "enum": [
                "android",
                "ios"
              ],
              "type": "string",
              "description": "Which platform to run on, examples: 'android', 'ios'. Set this based on the app path provided."
            },
            "desiredPlatformVersion": {
              "type": "string",
              "description": "Specifies the platform version to run the app on. For example, use '12.0' for Android or '16.0' for iOS. If the user says 'latest', 'newest', or similar, normalize it to 'latest'. Likewise, convert terms like 'earliest' or 'oldest' to 'oldest'."
            }
          },
          "required": [
            "desiredPhone",
            "desiredPlatformVersion",
            "desiredPlatform",
            "appPath"
          ]
        }
      },
      {
        "name": "runBrowserLiveSession",
        "description": "Use this tool when user wants to manually check their website on a particular browser and OS combination using BrowserStack's cloud infrastructure. Can be used to debug layout issues, compatibility problems, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "desiredOS": {
              "enum": [
                "Windows",
                "OS X"
              ],
              "type": "string",
              "description": "The operating system to run the browser on. Example: 'Windows', 'OS X'"
            },
            "desiredURL": {
              "type": "string",
              "description": "The URL of the website to test. This can be a local URL (e.g., http://localhost:3000) or a public URL. Always ask the user for the URL, do not assume it."
            },
            "desiredBrowser": {
              "enum": [
                "Chrome",
                "IE",
                "Firefox",
                "Safari",
                "Edge"
              ],
              "type": "string",
              "description": "The browser to run the test on. Example: 'Chrome', 'IE', 'Safari', 'Edge'. Always ask the user for the browser they want to use, do not assume it."
            },
            "desiredOSVersion": {
              "type": "string",
              "description": "The OS version to run the browser on. Example: '10' for Windows, '12' for macOS, '14' for iOS"
            },
            "desiredBrowserVersion": {
              "type": "string",
              "description": "The version of the browser to use. Example: 133.0, 134.0, 87.0"
            }
          },
          "required": [
            "desiredBrowser",
            "desiredOSVersion",
            "desiredOS",
            "desiredURL",
            "desiredBrowserVersion"
          ]
        }
      },
      {
        "name": "getFailuresInLastRun",
        "description": "Use this tool to debug failures in the last run of the test suite on BrowserStack. Use only when browserstack.yml file is present in the project root.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "buildName": {
              "type": "string",
              "description": "Name of the build to get failures for. This is the 'build' key in the browserstack.yml file. If not sure, ask the user for the build name."
            },
            "projectName": {
              "type": "string",
              "description": "Name of the project to get failures for. This is the 'projectName' key in the browserstack.yml file. If not sure, ask the user for the project name."
            }
          },
          "required": [
            "buildName",
            "projectName"
          ]
        }
      },
      {
        "name": "startAccessibilityScan",
        "description": "Use this tool to start an accessibility scan for a list of URLs on BrowserStack.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the accessibility scan"
            },
            "pageURL": {
              "type": "string",
              "description": "The URL to scan for accessibility issues"
            }
          },
          "required": [
            "name",
            "pageURL"
          ]
        }
      },
      {
        "name": "getNetworkFailures",
        "description": "Use this tool to fetch failed network requests from a BrowserStack Automate session.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sessionId": {
              "type": "string",
              "description": "The Automate session ID."
            }
          },
          "required": [
            "sessionId"
          ]
        }
      },
      {
        "name": "createProjectOrFolder",
        "description": "Create a project and/or folder in BrowserStack Test Management.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "parent_id": {
              "type": "number",
              "description": "Parent folder ID; if omitted, folder is created at root."
            },
            "folder_name": {
              "type": "string",
              "description": "Name of the folder to create."
            },
            "project_name": {
              "type": "string",
              "description": "Name of the project to create."
            },
            "folder_description": {
              "type": "string",
              "description": "Description for the new folder."
            },
            "project_identifier": {
              "type": "string",
              "description": "Existing project identifier to use for folder creation."
            },
            "project_description": {
              "type": "string",
              "description": "Description for the new project."
            }
          }
        }
      },
      {
        "name": "createTestCase",
        "description": "Use this tool to create a test case in BrowserStack Test Management.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the test case."
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tags to attach to the test case. This should be strictly in array format not the string of json"
            },
            "owner": {
              "type": "string",
              "format": "email",
              "description": "Email of the test case owner."
            },
            "issues": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of the linked Jira, Asana or Azure issues ID's. This should be strictly in array format not the string of json."
            },
            "folder_id": {
              "type": "string",
              "description": "The ID of the folder within the project where the test case should be created. If not provided, ask the user if they would like to create a new folder using the createProjectOrFolder tool."
            },
            "description": {
              "type": "string",
              "description": "Brief description of the test case."
            },
            "custom_fields": {
              "type": "object",
              "description": "Map of custom field names to values.",
              "additionalProperties": {
                "type": "string"
              }
            },
            "issue_tracker": {
              "type": "object",
              "required": [
                "name",
                "host"
              ],
              "properties": {
                "host": {
                  "type": "string",
                  "format": "uri",
                  "description": "Base URL of the issue tracker."
                },
                "name": {
                  "type": "string",
                  "description": "Issue tracker name,  For example, use jira for Jira, azure for Azure DevOps, or asana for Asana."
                }
              },
              "additionalProperties": false
            },
            "preconditions": {
              "type": "string",
              "description": "Any preconditions (HTML allowed)."
            },
            "test_case_steps": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "step",
                  "result"
                ],
                "properties": {
                  "step": {
                    "type": "string",
                    "description": "Action to perform in this step."
                  },
                  "result": {
                    "type": "string",
                    "description": "Expected result of this step."
                  }
                },
                "additionalProperties": false
              },
              "description": "List of steps and expected results."
            },
            "project_identifier": {
              "type": "string",
              "description": "The ID of the BrowserStack project where the test case should be created. If no project identifier is provided, ask the user if they would like to create a new project using the createProjectOrFolder tool."
            }
          },
          "required": [
            "project_identifier",
            "folder_id",
            "name",
            "test_case_steps"
          ]
        }
      }
    ]
  },
  {
    "name": "bsmi021-mcp-chain-of-draft-server",
    "title": "Chain of Draft Thinking",
    "description": "Chain of Draft Server is a powerful AI-driven tool that helps developers make better decisions through systematic, iterative refinement of thoughts and designs. It integrates seamlessly with popular AI agents and provides a structured approach to reasoning, API design, architecture decisions, code r",
    "icon": "https://avatars.githubusercontent.com/bsmi021",
    "isOfficial": false,
    "homepage": "https://github.com/bsmi021/mcp-chain-of-draft-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-chain-of-draft-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "chain-of-draft",
        "description": "\n    # Chain of Draft (CoD): Systematic Reasoning Tool\n\n    \n⚠️ REQUIRED PARAMETERS - ALL MUST BE PROVIDED:\n1. reasoning_chain: string[] - At least one reasoning step\n2. next_step_needed: boolean - Whether another iteration is needed\n3. draft_number: number - Current draft number (≥ 1)\n4. total_drafts: number - Total planned drafts (≥ draft_number)\n\nOptional parameters only required based on context:\n- is_critique?: boolean - If true, critique_focus is required\n- critique_focus?: string - Required when is_critique=true\n- revision_instructions?: string - Recommended for revision steps\n- step_to_review?: number - Specific step index to review\n- is_final_draft?: boolean - Marks final iteration\n\n\n    ## Purpose:\n    Enhances problem-solving through structured, iterative critique and revision.\n\n    Chain of Draft is an advanced reasoning tool that enhances problem-solving through structured, iterative critique and revision. Unlike traditional reasoning approaches, CoD mimics the human drafting process to improve clarity, accuracy, and robustness of conclusions.\n\n    ## When to Use This Tool:\n    - **Complex Problem-Solving:** Tasks requiring detailed, multi-step analysis with high accuracy demands\n    - **Critical Reasoning:** Problems where logical flow and consistency are essential\n    - **Error-Prone Scenarios:** Questions where initial reasoning might contain mistakes or oversight\n    - **Multi-Perspective Analysis:** Cases benefiting from examining a problem from different angles\n    - **Self-Correction Needs:** When validation and refinement of initial thoughts are crucial\n    - **Detailed Solutions:** Tasks requiring comprehensive explanations with supporting evidence\n    - **Mathematical or Logical Puzzles:** Problems with potential for calculation errors or logical gaps\n    - **Nuanced Analysis:** Situations with subtle distinctions that might be missed in a single pass\n\n    ## Key Capabilities:\n    - **Iterative Improvement:** Systematically refines reasoning through multiple drafts\n    - **Self-Critique:** Critically examines previous reasoning to identify flaws and opportunities\n    - **Focused Revision:** Targets specific aspects of reasoning in each iteration\n    - **Perspective Flexibility:** Can adopt different analytical viewpoints during critique\n    - **Progressive Refinement:** Builds toward optimal solutions through controlled iterations\n    - **Context Preservation:** Maintains understanding across multiple drafts and revisions\n    - **Adaptable Depth:** Adjusts the number of iterations based on problem complexity\n    - **Targeted Improvements:** Addresses specific weaknesses in each revision cycle\n\n    ## Parameters Explained:\n    - **reasoning_chain:** Array of strings representing your current reasoning steps. Each element should contain a clear, complete thought that contributes to the overall analysis.\n    \n    - **next_step_needed:** Boolean flag indicating whether additional critique or revision is required. Set to true until the final, refined reasoning chain is complete.\n    \n    - **draft_number:** Integer tracking the current iteration (starting from 1). Increments with each critique or revision.\n    \n    - **total_drafts:** Estimated number of drafts needed for completion. This can be adjusted as the solution evolves.\n    \n    - **is_critique:** Boolean indicating the current mode:\n      * true = Evaluating previous reasoning\n      * false = Implementing revisions\n    \n    - **critique_focus:** (Required when is_critique=true) Specific aspect being evaluated, such as:\n      * \"logical_consistency\": Checking for contradictions or flaws in reasoning\n      * \"factual_accuracy\": Verifying correctness of facts and calculations\n      * \"completeness\": Ensuring all relevant aspects are considered\n      * \"clarity\": Evaluating how understandable the reasoning is\n      * \"relevance\": Assessing if reasoning directly addresses the problem\n    \n    - **revision_instructions:** (Required when is_critique=false) Detailed guidance for improving the reasoning based on the preceding critique.\n    \n    - **step_to_review:** (Optional) Zero-based index of the specific reasoning step being critiqued or revised. When omitted, applies to the entire chain.\n    \n    - **is_final_draft:** (Optional) Boolean indicating whether this is the final iteration of reasoning.\n\n    ## Best Practice Workflow:\n    1. **Start with Initial Draft:** Begin with your first-pass reasoning and set a reasonable total_drafts (typically 3-5).\n    \n    2. **Alternate Critique and Revision:** Use is_critique=true to evaluate reasoning, then is_critique=false to implement improvements.\n    \n    3. **Focus Each Critique:** Choose a specific critique_focus for each evaluation cycle rather than attempting to address everything at once.\n    \n    4. **Provide Detailed Revision Guidance:** Include specific, actionable revision_instructions based on each critique.\n    \n    5. **Target Specific Steps When Needed:** Use step_to_review to focus on particular reasoning steps that need improvement.\n    \n    6. **Adjust Total Drafts As Needed:** Modify total_drafts based on problem complexity and progress.\n    \n    7. **Mark Completion Appropriately:** Set next_step_needed=false only when the reasoning chain is complete and satisfactory.\n    \n    8. **Aim for Progressive Improvement:** Each iteration should measurably improve the reasoning quality.\n\n    ## Example Application:\n    - **Initial Draft:** First-pass reasoning about a complex problem\n    - **Critique #1:** Focus on logical consistency and identify contradictions\n    - **Revision #1:** Address logical flaws found in the critique\n    - **Critique #2:** Focus on completeness and identify missing considerations\n    - **Revision #2:** Incorporate overlooked aspects and strengthen reasoning\n    - **Final Critique:** Holistic review of clarity and relevance\n    - **Final Revision:** Refine presentation and ensure direct addressing of the problem\n\n    Chain of Draft is particularly effective when complex reasoning must be broken down into clear steps, analyzed from multiple perspectives, and refined through systematic critique. By mimicking the human drafting process, it produces more robust and accurate reasoning than single-pass approaches.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "is_critique": {
              "type": "boolean",
              "description": "Boolean flag indicating whether the current step is a critique phase (true) evaluating previous reasoning, or a revision phase (false) implementing improvements."
            },
            "draft_number": {
              "type": "number",
              "minimum": 1,
              "description": "Current draft number in the iteration sequence (must be >= 1). Increments with each new critique or revision."
            },
            "total_drafts": {
              "type": "number",
              "minimum": 1,
              "description": "Estimated total number of drafts needed to reach a complete solution (must be >= draft_number). Can be adjusted as the solution evolves."
            },
            "critique_focus": {
              "type": "string",
              "minLength": 1,
              "description": "The specific aspect or dimension being critiqued in the current evaluation (e.g., 'logical_consistency', 'factual_accuracy', 'completeness', 'clarity', 'relevance'). Required when is_critique is true."
            },
            "is_final_draft": {
              "type": "boolean",
              "description": "Boolean flag indicating whether this is the final draft in the reasoning process. Helps signal the completion of the iterative refinement."
            },
            "step_to_review": {
              "type": "number",
              "minimum": 0,
              "description": "Zero-based index of the specific reasoning step being targeted for critique or revision. When omitted, the critique or revision applies to the entire reasoning chain."
            },
            "reasoning_chain": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 1
              },
              "minItems": 1,
              "description": "Array of strings representing the current chain of reasoning steps. Each step should be a clear, complete thought that contributes to the overall analysis or solution."
            },
            "next_step_needed": {
              "type": "boolean",
              "description": "Boolean flag indicating whether another critique or revision cycle is needed in the reasoning chain. Set to false only when the final, satisfactory conclusion has been reached."
            },
            "new_reasoning_steps": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 1
              },
              "minItems": 1,
              "description": "New reasoning steps to add to the chain"
            },
            "revision_instructions": {
              "type": "string",
              "minLength": 1,
              "description": "Detailed, actionable guidance for how to revise the reasoning based on the preceding critique. Should directly address issues identified in the critique. Required when is_critique is false."
            }
          },
          "required": [
            "reasoning_chain",
            "next_step_needed",
            "draft_number",
            "total_drafts",
            "new_reasoning_steps"
          ]
        }
      }
    ]
  },
  {
    "name": "btwiuse-npm-search-mcp-server",
    "title": "npm-search-mcp-server",
    "description": "MCP server for searching npm packages",
    "icon": "https://avatars.githubusercontent.com/btwiuse",
    "isOfficial": false,
    "homepage": "https://github.com/btwiuse/npm-search-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "npm-search-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "buoooou-mcp-ui-gen",
    "title": "SupaUI MCP Server",
    "description": "A Model Context Protocol server that enables AI agents to generate, fetch, and manage UI components through natural language interactions.",
    "icon": "https://avatars.githubusercontent.com/buoooou",
    "isOfficial": false,
    "homepage": "https://github.com/buoooou/mcp-ui-gen",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@buouui/supaui-mcp"
      ],
      "env": {
        "BUOU_API_KEY": "<buou-api-key>"
      }
    },
    "parameters": [
      {
        "name": "BUOU_API_KEY",
        "description": "Your API key from buouui.com",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "fetch-ui",
        "description": "\n\"Use this tool when the user wants to see component, get inspiration, or /buou or /ui fetch data and previews from buouui.com. \nThis tool ONLY returns the text snippet for that UI component. \nAfter calling this tool, you must edit or add files to integrate the snippet into the codebase.\"\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "Full users message"
            },
            "searchQuery": {
              "type": "string",
              "description": "Search query for buouui.com(library for searching UI components) to find a UI component that matches the user's message. Must be a two-four words max or phrase"
            }
          },
          "required": [
            "message",
            "searchQuery"
          ]
        }
      },
      {
        "name": "list-ui",
        "description": "\n\"Use this tool when the user wants to see buouui.com component, or /buou fetch data and previews from buouui.com. \nThis tool returns the JSON data of matching components without generating new code. This tool ONLY returns the text snippet for that UI component. \nAfter calling this tool, you need to display the data in the UI, and finally you need to show the website page of the buouui.com.\"\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "Full users message"
            },
            "searchQuery": {
              "type": "string",
              "description": "Search query for buouui.com(library for searching UI components) to find a UI component that matches the user's message. Must be a two-four words max or phrase"
            }
          },
          "required": [
            "message",
            "searchQuery"
          ]
        }
      },
      {
        "name": "create-image",
        "description": "\n\"Use this tool when the user requests a new image, mentions /buou /image or asks for a image.\nIf the customer provides the picture editing operation of the attachment, please send it to the corresponding tool.\nThis tool ONLY returns the url of the image. \nAfter calling this tool, Please show the image returned by this tool and provide it for download.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "image": {
              "type": "string",
              "description": "If the customer provides the picture editing operation of the attachment,please send it to the corresponding tool,otherwise, pass an empty string"
            },
            "message": {
              "type": "string",
              "description": "Translate into English and explain the content of the customer's image."
            }
          },
          "required": [
            "message",
            "image"
          ]
        }
      }
    ]
  },
  {
    "name": "burakdirin-clickhouse-mcp-server",
    "title": "clickhouse-mcp-server",
    "description": "An MCP server implementation that enables Claude AI to interact with Clickhouse databases. Features include secure database connections, query execution, read-only mode support, and multi-query capabilities.",
    "icon": "https://avatars.githubusercontent.com/burakdirin",
    "isOfficial": false,
    "homepage": "https://github.com/burakdirin/clickhouse-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "clickhouse-mcp-server"
      ],
      "env": {
        "CLICKHOUSE_HOST": "<clickhouse-host>",
        "CLICKHOUSE_USER": "<clickhouse-user>",
        "CLICKHOUSE_DATABASE": "<clickhouse-database>",
        "CLICKHOUSE_PASSWORD": "<clickhouse-password>",
        "CLICKHOUSE_READONLY": "<clickhouse-readonly>"
      }
    },
    "parameters": [
      {
        "name": "CLICKHOUSE_HOST",
        "description": "Clickhouse server address",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CLICKHOUSE_USER",
        "description": "Clickhouse username",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CLICKHOUSE_DATABASE",
        "description": "Initial database (optional)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CLICKHOUSE_PASSWORD",
        "description": "Clickhouse password",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CLICKHOUSE_READONLY",
        "description": "Read-only mode (set to 1/true to enable)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "connect_database",
        "description": "Connect to a specific ClickHouse database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database": {
              "type": "string",
              "title": "Database"
            }
          },
          "required": [
            "database"
          ]
        }
      },
      {
        "name": "execute_query",
        "description": "Execute ClickHouse queries",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "burakdirin-mysqldb-mcp-server",
    "title": "mysqldb-mcp-server",
    "description": "An MCP server that enables MySQL database integration with Claude. You can execute SQL queries and manage database connections.",
    "icon": "https://avatars.githubusercontent.com/burakdirin",
    "isOfficial": false,
    "homepage": "https://github.com/burakdirin/mysqldb-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mysqldb-mcp-server"
      ],
      "env": {
        "MYSQL_HOST": "<mysql-host>",
        "MYSQL_USER": "<mysql-user>",
        "MYSQL_DATABASE": "<mysql-database>",
        "MYSQL_PASSWORD": "<mysql-password>",
        "MYSQL_READONLY": "<mysql-readonly>",
        "UV_PUBLISH_TOKEN": "<uv-publish-token>",
        "UV_PUBLISH_PASSWORD": "<uv-publish-password>",
        "UV_PUBLISH_USERNAME": "<uv-publish-username>"
      }
    },
    "parameters": [
      {
        "name": "MYSQL_HOST",
        "description": "MySQL server address",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_USER",
        "description": "MySQL username",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_DATABASE",
        "description": "Initial database (optional)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MYSQL_PASSWORD",
        "description": "MySQL password",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_READONLY",
        "description": "Read-only mode (set to 1/true to enable)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "UV_PUBLISH_TOKEN",
        "description": "Token for publishing to PyPI",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "UV_PUBLISH_PASSWORD",
        "description": "Password for publishing to PyPI",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "UV_PUBLISH_USERNAME",
        "description": "Username for publishing to PyPI",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "connect_database",
        "description": "Connect to a specific MySQL database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database": {
              "type": "string",
              "title": "Database"
            }
          },
          "required": [
            "database"
          ]
        }
      },
      {
        "name": "execute_query",
        "description": "Execute MySQL queries",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "burningion-video-editing-mcp",
    "title": "video-editing-mcp",
    "description": "Upload, edit, and generate videos from everyone's favorite LLM and Video Jungle.",
    "icon": "https://avatars.githubusercontent.com/burningion",
    "isOfficial": false,
    "homepage": "https://github.com/burningion/video-editing-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "video-editor-mcp"
      ],
      "env": {
        "YOURAPIKEY": "<yourapikey>",
        "UV_PUBLISH_TOKEN": "<uv-publish-token>",
        "UV_PUBLISH_PASSWORD": "<uv-publish-password>",
        "UV_PUBLISH_USERNAME": "<uv-publish-username>"
      }
    },
    "parameters": [
      {
        "name": "YOURAPIKEY",
        "description": "Your Video Jungle API key",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "UV_PUBLISH_TOKEN",
        "description": "Token for publishing to PyPI",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "UV_PUBLISH_PASSWORD",
        "description": "Password for publishing to PyPI",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "UV_PUBLISH_USERNAME",
        "description": "Username for publishing to PyPI",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "smithery-ai-mcp-obsidian",
    "title": "Obsidian",
    "description": "This is a connector to allow Claude Desktop (or any MCP client) to read and search any directory containing Markdown notes (such as an Obsidian vault).",
    "icon": "https://avatars.githubusercontent.com/smithery-ai",
    "isOfficial": false,
    "homepage": "https://github.com/smithery-ai/mcp-obsidian",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-obsidian"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "cdugo-package-documentation-mcp",
    "title": "DocsFetcher MCP Server",
    "description": "Fetches and extracts comprehensive package documentation from multiple programming language ecosystems (JavaScript, Python, Java, etc.) for LLMs like Claude without requiring API keys.",
    "icon": "https://avatars.githubusercontent.com/cdugo",
    "isOfficial": false,
    "homepage": "https://github.com/cdugo/package-documentation-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@cdugo/docs-fetcher-mcp"
      ],
      "env": {
        "PORT": "<port>"
      }
    },
    "parameters": [
      {
        "name": "PORT",
        "description": "The port on which the server will run",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "fetch-url-docs",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri",
              "description": "URL of the library documentation to fetch"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "fetch-package-docs",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "language": {
              "type": "string",
              "description": "Programming language or repository type (e.g., javascript, python, java, dotnet)"
            },
            "packageName": {
              "type": "string",
              "description": "Name of the package to fetch documentation for"
            }
          },
          "required": [
            "packageName"
          ]
        }
      },
      {
        "name": "fetch-library-docs",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "library": {
              "type": "string",
              "description": "Name of the package or URL of the library documentation to fetch"
            },
            "language": {
              "type": "string",
              "description": "Programming language or repository type if providing a package name (e.g., javascript, python, java, dotnet)"
            }
          },
          "required": [
            "library"
          ]
        }
      },
      {
        "name": "fetch-multilingual-docs",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "languages": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of programming languages or repository types to check (e.g., javascript, python, java)"
            },
            "packageName": {
              "type": "string",
              "description": "Name of the package to fetch documentation for"
            }
          },
          "required": [
            "packageName",
            "languages"
          ]
        }
      }
    ]
  },
  {
    "name": "characat0-databricks-mcp-server",
    "title": "databricks-mcp-server",
    "description": "databricks-mcp-server",
    "icon": "https://avatars.githubusercontent.com/characat0",
    "isOfficial": false,
    "homepage": "https://github.com/characat0/databricks-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "databricks-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "chatmcp-heybeauty-mcp",
    "title": "HeyBeauty MCP Server",
    "description": "A TypeScript-based MCP server that implements virtual try-on capabilities using the HeyBeauty API, allowing users to visualize how clothes would look on them through Claude.",
    "icon": "https://avatars.githubusercontent.com/chatmcp",
    "isOfficial": false,
    "homepage": "https://github.com/chatmcp/heybeauty-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "heybeauty-mcp"
      ],
      "env": {
        "HEYBEAUTY_API_KEY": "<heybeauty-api-key>"
      }
    },
    "parameters": [
      {
        "name": "HEYBEAUTY_API_KEY",
        "description": "Your HeyBeauty API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "submit_tryon_task",
        "description": "Submit a tryon task with user image url and cloth image url",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cloth_id": {
              "type": "string",
              "description": "Cloth id, get from the selected cloth resource"
            },
            "user_img_url": {
              "type": "string",
              "description": "User image url, should be a url of a picture"
            },
            "cloth_img_url": {
              "type": "string",
              "description": "Cloth image url, should be a url of a picture, user input or get from the selected cloth resource"
            },
            "cloth_description": {
              "type": "string",
              "description": "Cloth description, user input or get from the selected cloth resource"
            }
          },
          "required": [
            "user_img_url",
            "cloth_img_url"
          ]
        }
      },
      {
        "name": "query_tryon_task",
        "description": "Query a tryon task with task id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "Task id, get from the submit_tryon_task tool"
            }
          },
          "required": [
            "task_id"
          ]
        }
      }
    ]
  },
  {
    "name": "chriscarrollsmith-taskqueue-mcp",
    "title": "taskqueue-mcp",
    "description": "MCP server for \"taming the Claude\" with structured task queues.",
    "icon": "https://avatars.githubusercontent.com/chriscarrollsmith",
    "isOfficial": false,
    "homepage": "https://github.com/chriscarrollsmith/taskqueue-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "taskqueue-mcp"
      ],
      "env": {
        "TASK_MANAGER_FILE_PATH": "<task-manager-file-path>"
      }
    },
    "parameters": [
      {
        "name": "TASK_MANAGER_FILE_PATH",
        "description": "Custom path to the tasks.json file. If not provided, defaults to platform-specific locations (Linux: ~/.local/share/taskqueue-mcp/tasks.json, macOS: ~/Library/Application Support/taskqueue-mcp/tasks.json, Windows: %APPDATA%\\taskqueue-mcp\\tasks.json)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "list_projects",
        "description": "List all projects in the system and their basic information (ID, initial prompt, task counts), optionally filtered by state (open, pending_approval, completed, all).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "state": {
              "enum": [
                "open",
                "pending_approval",
                "completed",
                "all"
              ],
              "type": "string",
              "description": "Filter projects by state. 'open' (any incomplete task), 'pending_approval' (any tasks awaiting approval), 'completed' (all tasks done and approved), or 'all' to skip filtering."
            }
          },
          "required": []
        }
      },
      {
        "name": "read_project",
        "description": "Read all information for a given project, by its ID, including its tasks' statuses.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string",
              "description": "The ID of the project to read (e.g., proj-1)."
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "create_project",
        "description": "Create a new project with an initial prompt and a list of tasks. This is typically the first step in any workflow.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tasks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "title",
                  "description"
                ],
                "properties": {
                  "title": {
                    "type": "string",
                    "description": "The title of the task."
                  },
                  "description": {
                    "type": "string",
                    "description": "A detailed description of the task."
                  },
                  "ruleRecommendations": {
                    "type": "string",
                    "description": "Recommendations for relevant rules to review when completing the task."
                  },
                  "toolRecommendations": {
                    "type": "string",
                    "description": "Recommendations for tools to use to complete the task."
                  }
                }
              },
              "description": "An array of task objects."
            },
            "autoApprove": {
              "type": "boolean",
              "description": "If true, tasks will be automatically approved when marked as done. If false or not provided, tasks require manual approval."
            },
            "projectPlan": {
              "type": "string",
              "description": "A more detailed plan for the project. If not provided, the initial prompt will be used."
            },
            "initialPrompt": {
              "type": "string",
              "description": "The initial prompt or goal for the project."
            }
          },
          "required": [
            "initialPrompt",
            "tasks"
          ]
        }
      },
      {
        "name": "delete_project",
        "description": "Delete a project and all its associated tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string",
              "description": "The ID of the project to delete (e.g., proj-1)."
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "add_tasks_to_project",
        "description": "Add new tasks to an existing project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tasks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "title",
                  "description"
                ],
                "properties": {
                  "title": {
                    "type": "string",
                    "description": "The title of the task."
                  },
                  "description": {
                    "type": "string",
                    "description": "A detailed description of the task."
                  },
                  "ruleRecommendations": {
                    "type": "string",
                    "description": "Recommendations for relevant rules to review when completing the task."
                  },
                  "toolRecommendations": {
                    "type": "string",
                    "description": "Recommendations for tools to use to complete the task."
                  }
                }
              },
              "description": "An array of task objects to add."
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project to add tasks to (e.g., proj-1)."
            }
          },
          "required": [
            "projectId",
            "tasks"
          ]
        }
      },
      {
        "name": "finalize_project",
        "description": "Mark a project as complete. Can only be called when all tasks are both done and approved. This is typically the last step in a project workflow.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string",
              "description": "The ID of the project to finalize (e.g., proj-1)."
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "generate_project_plan",
        "description": "Use an LLM to generate a project plan and tasks from a prompt. The LLM will analyze the prompt and any attached files to create a structured project plan.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string",
              "description": "The specific model to use (e.g., 'gpt-4-turbo' for OpenAI)."
            },
            "prompt": {
              "type": "string",
              "description": "The prompt text or file path to use for generating the project plan."
            },
            "provider": {
              "enum": [
                "openai",
                "google",
                "deepseek"
              ],
              "type": "string",
              "description": "The LLM provider to use (requires corresponding API key to be set)."
            },
            "attachments": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional array of paths to files to attach as context. There is no need to read the files before calling this tool!"
            }
          },
          "required": [
            "prompt",
            "provider",
            "model"
          ]
        }
      },
      {
        "name": "list_tasks",
        "description": "List all tasks, optionally filtered by project ID and/or state (open, pending_approval, completed, all). Tasks may include tool and rule recommendations to guide their completion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "state": {
              "enum": [
                "open",
                "pending_approval",
                "completed",
                "all"
              ],
              "type": "string",
              "description": "Filter tasks by state. 'open' (not started/in progress), 'pending_approval', 'completed', or 'all' to skip filtering."
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project to list tasks from. If omitted, list all tasks."
            }
          },
          "required": []
        }
      },
      {
        "name": "read_task",
        "description": "Get details of a specific task by its ID. The task may include toolRecommendations and ruleRecommendations fields that should be used to guide task completion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to read (e.g., task-1)."
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project containing the task (e.g., proj-1)."
            }
          },
          "required": [
            "projectId",
            "taskId"
          ]
        }
      },
      {
        "name": "create_task",
        "description": "Create a new task within an existing project. You can optionally include tool and rule recommendations to guide task completion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "The title of the task."
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project to add the task to (e.g., proj-1)."
            },
            "description": {
              "type": "string",
              "description": "A detailed description of the task."
            },
            "ruleRecommendations": {
              "type": "string",
              "description": "Recommendations for relevant rules to review when completing the task."
            },
            "toolRecommendations": {
              "type": "string",
              "description": "Recommendations for tools to use to complete the task."
            }
          },
          "required": [
            "projectId",
            "title",
            "description"
          ]
        }
      },
      {
        "name": "update_task",
        "description": "Modify a task's properties. Note: (1) completedDetails are required when setting status to 'done', (2) approved tasks cannot be modified, (3) status must follow valid transitions: not started → in progress → done. You can also update tool and rule recommendations to guide task completion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "The new title for the task (optional)."
            },
            "status": {
              "enum": [
                "not started",
                "in progress",
                "done"
              ],
              "type": "string",
              "description": "The new status for the task (optional)."
            },
            "taskId": {
              "type": "string",
              "description": "The ID of the task to update (e.g., task-1)."
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project containing the task (e.g., proj-1)."
            },
            "description": {
              "type": "string",
              "description": "The new description for the task (optional)."
            },
            "completedDetails": {
              "type": "string",
              "description": "Details about the task completion (required if status is set to 'done')."
            },
            "ruleRecommendations": {
              "type": "string",
              "description": "Recommendations for relevant rules to review when completing the task."
            },
            "toolRecommendations": {
              "type": "string",
              "description": "Recommendations for tools to use to complete the task."
            }
          },
          "required": [
            "projectId",
            "taskId"
          ]
        }
      },
      {
        "name": "delete_task",
        "description": "Remove a task from a project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to delete (e.g., task-1)."
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project containing the task (e.g., proj-1)."
            }
          },
          "required": [
            "projectId",
            "taskId"
          ]
        }
      },
      {
        "name": "approve_task",
        "description": "Approve a completed task. Tasks must be marked as 'done' with completedDetails before approval. Note: This is a CLI-only operation that requires human intervention.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to approve (e.g., task-1)."
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project containing the task (e.g., proj-1)."
            }
          },
          "required": [
            "projectId",
            "taskId"
          ]
        }
      },
      {
        "name": "get_next_task",
        "description": "Get the next task to be done in a project. Returns the first non-approved task in sequence, regardless of status. The task may include toolRecommendations and ruleRecommendations fields that should be used to guide task completion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string",
              "description": "The ID of the project to get the next task from (e.g., proj-1)."
            }
          },
          "required": [
            "projectId"
          ]
        }
      }
    ]
  },
  {
    "name": "clay-inc-clay-mcp",
    "title": "Clay",
    "description": "A Model Context Protocol (MCP) server for Clay (https://clay.earth). Search your email, calendar, Twitter / X, Linkedin, iMessage, Facebook, and WhatsApp contacts. Take notes, set reminders, and more.",
    "icon": "https://avatars.githubusercontent.com/clay-inc",
    "isOfficial": true,
    "homepage": "https://github.com/clay-inc/clay-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@clayhq/clay-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "searchContacts",
        "description": "Search for contacts and return matching people. Use for questions about specific contacts or \"who\" questions (e.g. \"Who did I meet most?\" or \"who works as an engineer?\"). Returns actual contact records for queries needing specific people.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "description": "The number of contacts to return if the user asks for an amount."
            },
            "query": {
              "type": "string",
              "description": "The raw search query from the user. Must preserve exact intent and details to enable accurate searching, including: relationship qualifiers, interaction metrics, relationship strength, names, companies, locations, dates (specific dates, date ranges, or relative dates like \"last week\" are required if mentioned by user), job titles, skills, and logical conditions (OR/AND)."
            },
            "keywords": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Extract and list specific keywords related to professional expertise, skills, interests, or hobbies that the user is searching for. For example, if someone asks for 'people who know about machine learning or play tennis', the keywords would be ['machine learning', 'tennis']. Do not include job titles or company names here as those have dedicated fields. Focus on capturing domain expertise, technical skills, personal interests, and hobby-related terms that help identify relevant contacts."
            },
            "location": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "If the query refers to a location (city, state, country, region) where people are located or based, list the locations as they would appear on a LinkedIn profile. For example, if someone asks about \"people in New York\", return \"New York City Metropolitan Area\" or if they ask about \"contacts in California\", return \"San Francisco Bay Area\", \"Greater Los Angeles Area\", etc."
            },
            "job_title": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "If the query refers to a job title, position, or industry, list relevant job titles as they would be on a LinkedIn profile. Examples: Developer should return positions such as 'Software Engineer', 'Full Stack Developer', 'Data Scientist', etc. Banker should return positions such as 'Financial Analyst', 'Investment Banker', 'Credit Analyst', etc. Healthcare industry should return positions such as 'Registered Nurse', 'Physician', 'Medical Director', etc. Legal industry should return positions such as 'Attorney', 'Legal Counsel', 'Paralegal', etc."
            },
            "company_name": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "If the query refers to a company or acronym of companies, list company names as they would on a LinkedIn profile."
            },
            "sort_instructions": {
              "type": "string",
              "description": "How would you like the results sorted? For example: \"most recent contacts\" will sort by last interaction date, \"closest connections\" will sort by interaction count, and \"alphabetical\" will sort by name. If no sort preference is given, this can be left empty."
            },
            "exclude_contact_ids": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Used to exclude previously returned contact IDs when the user asks for more results (e.g. \"who else\" or \"show me more\"). You should pass all contact IDs from previous searchContacts responses to ensure new results are shown."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "searchInteractions",
        "description": "Search for interactions and return matching interactions. Use for questions about specific interactions, \"who\" questions (e.g. \"Who did I meet most?\"), finding best friends based on relevance score, or finding recently added/created contacts. Returns actual contact records for queries needing specific interactions.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "description": "The number of contacts to return if the user asks for an amount."
            },
            "query": {
              "type": "string",
              "description": "The raw search query from the user. Must preserve exact intent and details to enable accurate searching, including: relationship qualifiers, interaction metrics, relationship strength, names, companies, locations, dates (specific dates, date ranges, or relative dates like \"last week\" are required if mentioned by user), job titles, skills, and logical conditions (OR/AND)."
            },
            "keywords": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Extract and list specific keywords related to professional expertise, skills, interests, or hobbies that the user is searching for. For example, if someone asks for 'people who know about machine learning or play tennis', the keywords would be ['machine learning', 'tennis']. Do not include job titles or company names here as those have dedicated fields. Focus on capturing domain expertise, technical skills, personal interests, and hobby-related terms that help identify relevant contacts."
            },
            "location": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "If the query refers to a location (city, state, country, region) where people are located or based, list the locations as they would appear on a LinkedIn profile. For example, if someone asks about \"people in New York\", return \"New York City Metropolitan Area\" or if they ask about \"contacts in California\", return \"San Francisco Bay Area\", \"Greater Los Angeles Area\", etc."
            },
            "job_title": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "If the query refers to a job title, position, or industry, list relevant job titles as they would be on a LinkedIn profile. Examples: Developer should return positions such as 'Software Engineer', 'Full Stack Developer', 'Data Scientist', etc. Banker should return positions such as 'Financial Analyst', 'Investment Banker', 'Credit Analyst', etc. Healthcare industry should return positions such as 'Registered Nurse', 'Physician', 'Medical Director', etc. Legal industry should return positions such as 'Attorney', 'Legal Counsel', 'Paralegal', etc."
            },
            "company_name": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "If the query refers to a company or acronym of companies, list company names as they would on a LinkedIn profile."
            },
            "sort_instructions": {
              "type": "string",
              "description": "How would you like the results sorted? For example: \"most recent contacts\" will sort by last interaction date, \"closest connections\" will sort by interaction count, and \"alphabetical\" will sort by name. If no sort preference is given, this can be left empty."
            },
            "exclude_contact_ids": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Used to exclude previously returned contact IDs when the user asks for more results (e.g. \"who else\" or \"show me more\"). You should pass all contact IDs from previous searchContacts responses to ensure new results are shown."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "aggregateContacts",
        "description": "Get numerical statistics and counts ONLY. Returns numbers and percentages, never specific contacts. For counting questions like \"how many work at Google?\" or \"what % are engineers?\". Use search endpoint instead for any \"who\" questions or to get actual contact details.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The raw search query from the user. This field is required and should contain all the key details extracted from the user's prompt to enable effective database searching and aggregation. For example, if the user asks 'how many people work at Google', preserve both the company filter 'Google' and the fact that they want a count. If they ask 'what are the most common job titles in my network', preserve that they want job titles aggregated and ranked by frequency. The query should maintain any conditions (OR, AND) and aggregation needs to properly build the elasticsearch query."
            },
            "location": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "If the query refers to a location (city, state, country, region) where people are located or based, list the locations as they would appear on a LinkedIn profile. For example, if someone asks about \"people in New York\", return \"New York City Metropolitan Area\" or if they ask about \"contacts in California\", return \"San Francisco Bay Area\", \"Greater Los Angeles Area\", etc."
            },
            "job_title": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "If the query refers to a job title, position, or industry, list relevant job titles as they would be on a LinkedIn profile. Examples: Developer should return positions such as 'Software Engineer', 'Full Stack Developer', 'Data Scientist', etc. Banker should return positions such as 'Financial Analyst', 'Investment Banker', 'Credit Analyst', etc. Healthcare industry should return positions such as 'Registered Nurse', 'Physician', 'Medical Director', etc. Legal industry should return positions such as 'Attorney', 'Legal Counsel', 'Paralegal', etc."
            },
            "company_name": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "If the query refers to a company or acronym of companies, list company names as they would on a LinkedIn profile."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "getContact",
        "description": "Get details for a contact by id, including emails, social links, phone numbers, and notes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contact_id": {
              "type": "number",
              "description": "The ID of the contact to get details for."
            }
          },
          "required": [
            "contact_id"
          ]
        }
      },
      {
        "name": "createContact",
        "description": "Create a new contact record in Clay. This endpoint should only be used when you need to create a completely new contact, not for adding contacts to groups.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "The email of the contact."
            },
            "phone": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The phone number of the contact."
            },
            "title": {
              "type": "string",
              "description": "The job title of the contact."
            },
            "website": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "The website of the contact."
            },
            "birthday": {
              "type": "string",
              "description": "The birthday of the contact. Use the format YYYY-MM-DD, if no year is specified use 0, month and day are required."
            },
            "linkedin": {
              "type": "string",
              "description": "The LinkedIn handle of the contact."
            },
            "last_name": {
              "type": "string",
              "description": "The last name of the contact."
            },
            "first_name": {
              "type": "string",
              "description": "The first name of the contact."
            },
            "organization": {
              "type": "string",
              "description": "The organization of the contact."
            }
          }
        }
      },
      {
        "name": "createNote",
        "description": "Create a note for a contact. Only use this when the user explicitly asks to create, add, or save a note.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The content of the note."
            },
            "contact_id": {
              "type": "number",
              "description": "The ID of the contact to add the note to."
            }
          },
          "required": [
            "contact_id",
            "content"
          ]
        }
      },
      {
        "name": "getGroups",
        "description": "Get all groups or lists for the user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "The maximum number of groups to return."
            }
          }
        }
      },
      {
        "name": "createGroup",
        "description": "Create a group or list for the user. If a group with the same name already exists, it will not create a duplicate unless explicitly requested to ignore the check.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "The name of the group to create."
            }
          },
          "required": [
            "title"
          ]
        }
      },
      {
        "name": "updateGroup",
        "description": "Update a group or list. Use this to update the group title and/or modify its members. When adding or removing contacts, provide ALL contact IDs to add/remove in a single call - do not make multiple calls for individual contacts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "The new name of the group if the user wants to rename it."
            },
            "group_id": {
              "type": "number",
              "description": "The ID of the group or list to update."
            },
            "add_contact_ids": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "default": [],
              "description": "A list of contact IDs that should be added to this group. Each ID should be a number representing an existing contact in your network. You can provide multiple IDs to add several contacts at once."
            },
            "remove_contact_ids": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "default": [],
              "description": "A list of contact IDs that should be removed from this group. Each ID should be a number representing an existing contact in your network. You can provide multiple IDs to remove several contacts at once."
            }
          },
          "required": [
            "group_id"
          ]
        }
      },
      {
        "name": "getNotes",
        "description": "Use ONLY when the user explicitly mentions \"note\" or \"notes\" to retrieve notes between two dates (e.g. \"what notes from last week?\"). Returns notes by creation date only - does NOT search note content or filter by other criteria. NEVER use this tool for finding contacts or any other purpose besides retrieving notes. This tool is strictly prohibited from being used unless \"note\" or \"notes\" are explicitly mentioned in the query.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end": {
              "type": "string",
              "description": "Use Date Math with now +/- time intervals. Supported units: d (days), w (weeks), M (months), y (years), h (hours), m (minutes), s (seconds). Examples: now-1d (yesterday), now+2w (2 weeks ahead), now/M (start of month), now+1M/M (start of next month)."
            },
            "start": {
              "type": "string",
              "description": "Use Date Math with now +/- time intervals. Supported units: d (days), w (weeks), M (months), y (years), h (hours), m (minutes), s (seconds). Examples: now-1d (yesterday), now+2w (2 weeks ahead), now/M (start of month), now+1M/M (start of next month)."
            }
          },
          "required": [
            "start",
            "end"
          ]
        }
      },
      {
        "name": "getEvents",
        "description": "Use this tool ONLY to fetch meetings/events in a date range (e.g. \"what meetings next week?\", \"show calendar for tomorrow\"). DO NOT use for counting meetings, analyzing patterns, or finding frequent participants.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end": {
              "type": "string",
              "description": "Use Date Math with now +/- time intervals. Supported units: d (days), w (weeks), M (months), y (years), h (hours), m (minutes), s (seconds). Examples: now-1d (yesterday), now+2w (2 weeks ahead), now/M (start of month), now+1M/M (start of next month)."
            },
            "start": {
              "type": "string",
              "description": "Use Date Math with now +/- time intervals. Supported units: d (days), w (weeks), M (months), y (years), h (hours), m (minutes), s (seconds). Examples: now-1d (yesterday), now+2w (2 weeks ahead), now/M (start of month), now+1M/M (start of next month)."
            }
          },
          "required": [
            "start",
            "end"
          ]
        }
      }
    ]
  },
  {
    "name": "codefriar-sf-mcp",
    "title": "Salesforce CLI MCP Server",
    "description": "Exposes Salesforce CLI functionality to LLM tools like Claude Desktop, allowing AI agents to execute Salesforce commands, manage orgs, deploy code, and query data through natural language.",
    "icon": "https://avatars.githubusercontent.com/codefriar",
    "isOfficial": false,
    "homepage": "https://github.com/codefriar/sf-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "sf-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "sf_cache_clear",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "sf_cache_refresh",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "sf_detect_project_directory",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "sf_set_project_directory",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Optional name for this project root"
            },
            "directory": {
              "type": "string",
              "description": "The absolute path to a directory containing an sfdx-project.json file"
            },
            "isDefault": {
              "type": "boolean",
              "description": "Set this root as the default for command execution"
            },
            "description": {
              "type": "string",
              "description": "Optional description for this project root"
            }
          },
          "required": [
            "directory"
          ]
        }
      },
      {
        "name": "sf_list_roots",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "coinpaprika-dexpaprika-mcp",
    "title": "DexPaprika (CoinPaprika)",
    "description": "DexPaprika MCP server allows LLMs to access real-time and historical data on tokens, DEX trading activity, and liquidity across multiple blockchains. It enables natural language queries for exploring market trends, token performance, and DeFi analytics through a standardized interface.",
    "icon": "https://avatars.githubusercontent.com/coinpaprika",
    "isOfficial": true,
    "homepage": "https://github.com/coinpaprika/dexpaprika-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "dexpaprika-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "getNetworks",
        "description": "Retrieve a list of all supported blockchain networks and their metadata",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getNetworkDexes",
        "description": "Get a list of available decentralized exchanges on a specific network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 0,
              "description": "Page number for pagination"
            },
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Number of items per page"
            },
            "network": {
              "type": "string",
              "description": "Network ID (e.g., ethereum, solana)"
            }
          },
          "required": [
            "network"
          ]
        }
      },
      {
        "name": "getTopPools",
        "description": "Get a paginated list of top liquidity pools from all networks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 0,
              "description": "Page number for pagination"
            },
            "sort": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "default": "desc",
              "description": "Sort order"
            },
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Number of items per page"
            },
            "orderBy": {
              "enum": [
                "volume_usd",
                "price_usd",
                "transactions",
                "last_price_change_usd_24h",
                "created_at"
              ],
              "type": "string",
              "default": "volume_usd",
              "description": "Field to order by"
            }
          }
        }
      },
      {
        "name": "getNetworkPools",
        "description": "Get a list of top liquidity pools on a specific network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 0,
              "description": "Page number for pagination"
            },
            "sort": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "default": "desc",
              "description": "Sort order"
            },
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Number of items per page"
            },
            "network": {
              "type": "string",
              "description": "Network ID (e.g., ethereum, solana)"
            },
            "orderBy": {
              "enum": [
                "volume_usd",
                "price_usd",
                "transactions",
                "last_price_change_usd_24h",
                "created_at"
              ],
              "type": "string",
              "default": "volume_usd",
              "description": "Field to order by"
            }
          },
          "required": [
            "network"
          ]
        }
      },
      {
        "name": "getDexPools",
        "description": "Get top pools on a specific DEX within a network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dex": {
              "type": "string",
              "description": "DEX identifier"
            },
            "page": {
              "type": "number",
              "default": 0,
              "description": "Page number for pagination"
            },
            "sort": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "default": "desc",
              "description": "Sort order"
            },
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Number of items per page"
            },
            "network": {
              "type": "string",
              "description": "Network ID (e.g., ethereum, solana)"
            },
            "orderBy": {
              "enum": [
                "volume_usd",
                "price_usd",
                "transactions",
                "last_price_change_usd_24h",
                "created_at"
              ],
              "type": "string",
              "default": "volume_usd",
              "description": "Field to order by"
            }
          },
          "required": [
            "network",
            "dex"
          ]
        }
      },
      {
        "name": "getPoolDetails",
        "description": "Get detailed information about a specific pool on a network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network ID (e.g., ethereum, solana)"
            },
            "inversed": {
              "type": "boolean",
              "default": false,
              "description": "Whether to invert the price ratio"
            },
            "poolAddress": {
              "type": "string",
              "description": "Pool address or identifier"
            }
          },
          "required": [
            "network",
            "poolAddress"
          ]
        }
      },
      {
        "name": "getTokenDetails",
        "description": "Get detailed information about a specific token on a network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network ID (e.g., ethereum, solana)"
            },
            "tokenAddress": {
              "type": "string",
              "description": "Token address or identifier"
            }
          },
          "required": [
            "network",
            "tokenAddress"
          ]
        }
      },
      {
        "name": "getTokenPools",
        "description": "Get a list of top liquidity pools for a specific token on a network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 0,
              "description": "Page number for pagination"
            },
            "sort": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "default": "desc",
              "description": "Sort order"
            },
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Number of items per page"
            },
            "address": {
              "type": "string",
              "description": "Filter pools that contain this additional token address"
            },
            "network": {
              "type": "string",
              "description": "Network ID (e.g., ethereum, solana)"
            },
            "orderBy": {
              "enum": [
                "volume_usd",
                "price_usd",
                "transactions",
                "last_price_change_usd_24h",
                "created_at"
              ],
              "type": "string",
              "default": "volume_usd",
              "description": "Field to order by"
            },
            "tokenAddress": {
              "type": "string",
              "description": "Token address or identifier"
            }
          },
          "required": [
            "network",
            "tokenAddress"
          ]
        }
      },
      {
        "name": "getPoolOHLCV",
        "description": "Get OHLCV (Open-High-Low-Close-Volume) data for a specific pool",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end": {
              "type": "string",
              "description": "End time for historical data (max 1 year from start)"
            },
            "limit": {
              "type": "number",
              "default": 1,
              "description": "Number of data points to retrieve (max 366)"
            },
            "start": {
              "type": "string",
              "description": "Start time for historical data (ISO-8601, yyyy-mm-dd, or Unix timestamp)"
            },
            "network": {
              "type": "string",
              "description": "Network ID (e.g., ethereum, solana)"
            },
            "interval": {
              "type": "string",
              "default": "24h",
              "description": "Interval granularity for OHLCV data (1m, 5m, 10m, 15m, 30m, 1h, 6h, 12h, 24h)"
            },
            "inversed": {
              "type": "boolean",
              "default": false,
              "description": "Whether to invert the price ratio in OHLCV calculations"
            },
            "poolAddress": {
              "type": "string",
              "description": "Pool address or identifier"
            }
          },
          "required": [
            "network",
            "poolAddress",
            "start"
          ]
        }
      },
      {
        "name": "getPoolTransactions",
        "description": "Get transactions of a pool on a network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 0,
              "description": "Page number for pagination"
            },
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Number of items per page"
            },
            "cursor": {
              "type": "string",
              "description": "Transaction ID used for cursor-based pagination"
            },
            "network": {
              "type": "string",
              "description": "Network ID (e.g., ethereum, solana)"
            },
            "poolAddress": {
              "type": "string",
              "description": "Pool address or identifier"
            }
          },
          "required": [
            "network",
            "poolAddress"
          ]
        }
      },
      {
        "name": "search",
        "description": "Search for tokens, pools, and DEXes by name or identifier",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search term (e.g., \"uniswap\", \"bitcoin\", or a token address)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "getStats",
        "description": "Get high-level statistics about the DexPaprika ecosystem",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "cristip73-mcp-server-asana",
    "title": "MCP Server for Asana",
    "description": "This server implementation allows AI assistants to interact with Asana's API, enabling users to manage tasks, projects, workspaces, and comments through natural language requests.",
    "icon": "https://avatars.githubusercontent.com/cristip73",
    "isOfficial": false,
    "homepage": "https://github.com/cristip73/mcp-server-asana",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@cristip73/mcp-server-asana"
      ],
      "env": {
        "ASANA_ACCESS_TOKEN": "<asana-access-token>",
        "DEFAULT_WORKSPACE_ID": "<default-workspace-id>"
      }
    },
    "parameters": [
      {
        "name": "ASANA_ACCESS_TOKEN",
        "description": "Your personal access token from the Asana developer console",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "DEFAULT_WORKSPACE_ID",
        "description": "Optional default workspace ID to use for API calls that require a workspace",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "asana_list_workspaces",
        "description": "List all available workspaces in Asana",
        "inputSchema": {
          "type": "object",
          "properties": {
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            }
          }
        }
      },
      {
        "name": "asana_search_projects",
        "description": "Search for projects in Asana using name pattern matching",
        "inputSchema": {
          "type": "object",
          "properties": {
            "archived": {
              "type": "boolean",
              "default": false,
              "description": "Only return archived projects"
            },
            "workspace": {
              "type": "string",
              "description": "The workspace to search in"
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "name_pattern": {
              "type": "string",
              "description": "Regular expression pattern to match project names"
            }
          },
          "required": [
            "workspace",
            "name_pattern"
          ]
        }
      },
      {
        "name": "asana_search_tasks",
        "description": "Search tasks in a workspace with advanced filtering options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Text to search for in task names and descriptions"
            },
            "due_on": {
              "type": "string",
              "description": "ISO 8601 date string or null"
            },
            "sort_by": {
              "type": "string",
              "default": "modified_at",
              "description": "Sort by: due_date, created_at, completed_at, likes, modified_at"
            },
            "start_on": {
              "type": "string",
              "description": "ISO 8601 date string or null"
            },
            "tags_all": {
              "type": "string",
              "description": "Comma-separated list of tag IDs that must all match"
            },
            "tags_any": {
              "type": "string",
              "description": "Comma-separated list of tag IDs"
            },
            "tags_not": {
              "type": "string",
              "description": "Comma-separated list of tag IDs to exclude"
            },
            "completed": {
              "type": "boolean",
              "description": "Filter for completed tasks"
            },
            "teams_any": {
              "type": "string",
              "description": "Comma-separated list of team IDs"
            },
            "workspace": {
              "type": "string",
              "description": "The workspace to search in"
            },
            "created_on": {
              "type": "string",
              "description": "ISO 8601 date string or null"
            },
            "is_blocked": {
              "type": "boolean",
              "description": "Filter for tasks with incomplete dependencies"
            },
            "is_subtask": {
              "type": "boolean",
              "description": "Filter for subtasks"
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "is_blocking": {
              "type": "boolean",
              "description": "Filter for incomplete tasks with dependents"
            },
            "modified_on": {
              "type": "string",
              "description": "ISO 8601 date string or null"
            },
            "assignee_any": {
              "type": "string",
              "description": "Comma-separated list of user IDs"
            },
            "assignee_not": {
              "type": "string",
              "description": "Comma-separated list of user IDs to exclude"
            },
            "completed_on": {
              "type": "string",
              "description": "ISO 8601 date string or null"
            },
            "due_at_after": {
              "type": "string",
              "description": "ISO 8601 datetime string"
            },
            "due_on_after": {
              "type": "string",
              "description": "ISO 8601 date string"
            },
            "liked_by_not": {
              "type": "string",
              "description": "Comma-separated list of user IDs to exclude"
            },
            "projects_all": {
              "type": "string",
              "description": "Comma-separated list of project IDs that must all match"
            },
            "projects_any": {
              "type": "string",
              "description": "Comma-separated list of project IDs"
            },
            "projects_not": {
              "type": "string",
              "description": "Comma-separated list of project IDs to exclude"
            },
            "sections_all": {
              "type": "string",
              "description": "Comma-separated list of section IDs that must all match"
            },
            "sections_any": {
              "type": "string",
              "description": "Comma-separated list of section IDs"
            },
            "sections_not": {
              "type": "string",
              "description": "Comma-separated list of section IDs to exclude"
            },
            "custom_fields": {
              "type": "object",
              "description": "Object containing custom field filters. Keys should be in the format \"{gid}.{operation}\" where operation can be:\n- {gid}.is_set: Boolean - For all custom field types, check if value is set\n- {gid}.value: String|Number|String(enum_option_gid) - Direct value match for Text, Number or Enum fields\n- {gid}.starts_with: String - For Text fields only, check if value starts with string\n- {gid}.ends_with: String - For Text fields only, check if value ends with string\n- {gid}.contains: String - For Text fields only, check if value contains string\n- {gid}.less_than: Number - For Number fields only, check if value is less than number\n- {gid}.greater_than: Number - For Number fields only, check if value is greater than number\n\nExample: { \"12345.value\": \"high\", \"67890.contains\": \"urgent\" }"
            },
            "due_at_before": {
              "type": "string",
              "description": "ISO 8601 datetime string"
            },
            "due_on_before": {
              "type": "string",
              "description": "ISO 8601 date string"
            },
            "followers_not": {
              "type": "string",
              "description": "Comma-separated list of user IDs to exclude"
            },
            "created_by_any": {
              "type": "string",
              "description": "Comma-separated list of user IDs"
            },
            "created_by_not": {
              "type": "string",
              "description": "Comma-separated list of user IDs to exclude"
            },
            "has_attachment": {
              "type": "boolean",
              "description": "Filter for tasks with attachments"
            },
            "portfolios_any": {
              "type": "string",
              "description": "Comma-separated list of portfolio IDs"
            },
            "sort_ascending": {
              "type": "boolean",
              "default": false,
              "description": "Sort in ascending order"
            },
            "start_on_after": {
              "type": "string",
              "description": "ISO 8601 date string"
            },
            "assigned_by_any": {
              "type": "string",
              "description": "Comma-separated list of user IDs"
            },
            "assigned_by_not": {
              "type": "string",
              "description": "Comma-separated list of user IDs to exclude"
            },
            "start_on_before": {
              "type": "string",
              "description": "ISO 8601 date string"
            },
            "created_at_after": {
              "type": "string",
              "description": "ISO 8601 datetime string"
            },
            "created_on_after": {
              "type": "string",
              "description": "ISO 8601 date string"
            },
            "resource_subtype": {
              "type": "string",
              "description": "Filter by task subtype (e.g. milestone)"
            },
            "created_at_before": {
              "type": "string",
              "description": "ISO 8601 datetime string"
            },
            "created_on_before": {
              "type": "string",
              "description": "ISO 8601 date string"
            },
            "modified_at_after": {
              "type": "string",
              "description": "ISO 8601 datetime string"
            },
            "modified_on_after": {
              "type": "string",
              "description": "ISO 8601 date string"
            },
            "completed_at_after": {
              "type": "string",
              "description": "ISO 8601 datetime string"
            },
            "completed_on_after": {
              "type": "string",
              "description": "ISO 8601 date string"
            },
            "modified_at_before": {
              "type": "string",
              "description": "ISO 8601 datetime string"
            },
            "modified_on_before": {
              "type": "string",
              "description": "ISO 8601 date string"
            },
            "commented_on_by_not": {
              "type": "string",
              "description": "Comma-separated list of user IDs to exclude"
            },
            "completed_at_before": {
              "type": "string",
              "description": "ISO 8601 datetime string"
            },
            "completed_on_before": {
              "type": "string",
              "description": "ISO 8601 date string"
            }
          },
          "required": [
            "workspace"
          ]
        }
      },
      {
        "name": "asana_get_task",
        "description": "Get detailed information about a specific task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "The task ID to retrieve"
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            }
          },
          "required": [
            "task_id"
          ]
        }
      },
      {
        "name": "asana_create_task",
        "description": "Create a new task in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the task"
            },
            "notes": {
              "type": "string",
              "description": "Description of the task"
            },
            "due_on": {
              "type": "string",
              "description": "Due date in YYYY-MM-DD format"
            },
            "parent": {
              "type": "string",
              "description": "The parent task ID to set this task under"
            },
            "assignee": {
              "type": "string",
              "description": "Assignee (can be 'me' or a user ID)"
            },
            "projects": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of project IDs to add this task to"
            },
            "followers": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of user IDs to add as followers"
            },
            "html_notes": {
              "type": "string",
              "description": "HTML-like formatted description of the task. Does not support ALL HTML tags. Only a subset. The only allowed TAG in the HTML are: <body> <h1> <h2> <ol> <ul> <li> <strong> <em> <u> <s> <code> <pre> <blockquote> <a data-asana-type=\"\" data-asana-gid=\"\"> <hr> <img> <table> <tr> <td>. No other tags are allowed. Use the \\n to create a newline. Do not use \\n after <body>. Example: <body><h1>Motivation</h1>\nA customer called in to complain\n<h1>Goal</h1>\nFix the problem</body>"
            },
            "project_id": {
              "type": "string",
              "description": "The project to create the task in"
            },
            "custom_fields": {
              "type": "object",
              "description": "Object mapping custom field GID strings to their values. For enum fields use the enum option GID as the value."
            },
            "resource_subtype": {
              "type": "string",
              "description": "The type of the task. Can be one of 'default_task' or 'milestone'"
            }
          },
          "required": [
            "project_id",
            "name"
          ]
        }
      },
      {
        "name": "asana_get_task_stories",
        "description": "Get comments and stories for a specific task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "The task ID to get stories for"
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            }
          },
          "required": [
            "task_id"
          ]
        }
      },
      {
        "name": "asana_update_task",
        "description": "Update an existing task's details",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "New name for the task"
            },
            "notes": {
              "type": "string",
              "description": "New description for the task"
            },
            "due_on": {
              "type": "string",
              "description": "New due date in YYYY-MM-DD format"
            },
            "task_id": {
              "type": "string",
              "description": "The task ID to update"
            },
            "assignee": {
              "type": "string",
              "description": "New assignee (can be 'me' or a user ID)"
            },
            "completed": {
              "type": "boolean",
              "description": "Mark task as completed or not"
            },
            "custom_fields": {
              "type": "object",
              "description": "Object mapping custom field GID strings to their values. For enum fields use the enum option GID as the value."
            },
            "resource_subtype": {
              "type": "string",
              "description": "The type of the task. Can be one of 'default_task' or 'milestone'"
            }
          },
          "required": [
            "task_id"
          ]
        }
      },
      {
        "name": "asana_get_project",
        "description": "Get detailed information about a specific project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "project_id": {
              "type": "string",
              "description": "The project ID to retrieve"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "asana_get_project_task_counts",
        "description": "Get the number of tasks in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "project_id": {
              "type": "string",
              "description": "The project ID to get task counts for"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "asana_get_project_sections",
        "description": "Get sections in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "project_id": {
              "type": "string",
              "description": "The project ID to get sections for"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "asana_create_task_story",
        "description": "Create a comment or story on a task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "The text content of the story/comment"
            },
            "task_id": {
              "type": "string",
              "description": "The task ID to add the story to"
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            }
          },
          "required": [
            "task_id",
            "text"
          ]
        }
      },
      {
        "name": "asana_add_task_dependencies",
        "description": "Set dependencies for a task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "The task ID to add dependencies to"
            },
            "dependencies": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of task IDs that this task depends on"
            }
          },
          "required": [
            "task_id",
            "dependencies"
          ]
        }
      },
      {
        "name": "asana_add_task_dependents",
        "description": "Set dependents for a task (tasks that depend on this task)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "The task ID to add dependents to"
            },
            "dependents": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of task IDs that depend on this task"
            }
          },
          "required": [
            "task_id",
            "dependents"
          ]
        }
      },
      {
        "name": "asana_create_subtask",
        "description": "Create a new subtask for an existing task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the subtask"
            },
            "notes": {
              "type": "string",
              "description": "Description of the subtask"
            },
            "due_on": {
              "type": "string",
              "description": "Due date in YYYY-MM-DD format"
            },
            "assignee": {
              "type": "string",
              "description": "Assignee (can be 'me' or a user ID)"
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "parent_task_id": {
              "type": "string",
              "description": "The parent task ID to create the subtask under"
            }
          },
          "required": [
            "parent_task_id",
            "name"
          ]
        }
      },
      {
        "name": "asana_get_multiple_tasks_by_gid",
        "description": "Get detailed information about multiple tasks by their GIDs (maximum 25 tasks)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_ids": {
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "maxItems": 25
                },
                {
                  "type": "string",
                  "description": "Comma-separated list of task GIDs (max 25)"
                }
              ],
              "description": "Array or comma-separated string of task GIDs to retrieve (max 25)"
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            }
          },
          "required": [
            "task_ids"
          ]
        }
      },
      {
        "name": "asana_get_project_status",
        "description": "Get a project status update",
        "inputSchema": {
          "type": "object",
          "properties": {
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "project_status_gid": {
              "type": "string",
              "description": "The project status GID to retrieve"
            }
          },
          "required": [
            "project_status_gid"
          ]
        }
      },
      {
        "name": "asana_get_project_statuses",
        "description": "Get all status updates for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1,
              "description": "Results per page (1-100)"
            },
            "offset": {
              "type": "string",
              "description": "Pagination offset token"
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "project_gid": {
              "type": "string",
              "description": "The project GID to get statuses for"
            }
          },
          "required": [
            "project_gid"
          ]
        }
      },
      {
        "name": "asana_create_project_status",
        "description": "Create a new status update for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "The text content of the status update"
            },
            "color": {
              "enum": [
                "green",
                "yellow",
                "red"
              ],
              "type": "string",
              "description": "The color of the status (green, yellow, red)"
            },
            "title": {
              "type": "string",
              "description": "The title of the status update"
            },
            "html_text": {
              "type": "string",
              "description": "HTML formatted text for the status update"
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "project_gid": {
              "type": "string",
              "description": "The project GID to create the status for"
            }
          },
          "required": [
            "project_gid",
            "text"
          ]
        }
      },
      {
        "name": "asana_delete_project_status",
        "description": "Delete a project status update",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_status_gid": {
              "type": "string",
              "description": "The project status GID to delete"
            }
          },
          "required": [
            "project_status_gid"
          ]
        }
      },
      {
        "name": "asana_set_parent_for_task",
        "description": "Set the parent of a task and position the subtask within the other subtasks of that parent",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "parent": {
                "type": "string",
                "required": true,
                "description": "The GID of the new parent of the task, or null for no parent"
              },
              "insert_after": {
                "type": "string",
                "description": "A subtask of the parent to insert the task after, or null to insert at the beginning of the list. Cannot be used with insert_before. The task must already be set as a subtask of that parent."
              },
              "insert_before": {
                "type": "string",
                "description": "A subtask of the parent to insert the task before, or null to insert at the end of the list. Cannot be used with insert_after. The task must already be set as a subtask of that parent."
              }
            },
            "opts": {
              "opt_fields": {
                "type": "string",
                "description": "Comma-separated list of optional fields to include"
              }
            },
            "task_id": {
              "type": "string",
              "description": "The task ID to operate on"
            }
          },
          "required": [
            "task_id",
            "data"
          ]
        }
      },
      {
        "name": "asana_get_tasks_for_tag",
        "description": "Get tasks for a specific tag",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "The number of objects to return per page. The value must be between 1 and 100."
            },
            "offset": {
              "type": "string",
              "description": "An offset to the next page returned by the API."
            },
            "tag_gid": {
              "type": "string",
              "description": "The tag GID to retrieve tasks for"
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "opt_pretty": {
              "type": "boolean",
              "description": "Provides the response in a 'pretty' format"
            }
          },
          "required": [
            "tag_gid"
          ]
        }
      },
      {
        "name": "asana_get_tags_for_workspace",
        "description": "Get tags in a workspace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Results per page. The number of objects to return per page. The value must be between 1 and 100."
            },
            "offset": {
              "type": "string",
              "description": "Offset token. An offset to the next page returned by the API."
            },
            "opt_fields": {
              "type": "string",
              "description": "Comma-separated list of optional fields to include"
            },
            "workspace_gid": {
              "type": "string",
              "description": "Globally unique identifier for the workspace or organization"
            }
          },
          "required": [
            "workspace_gid"
          ]
        }
      }
    ]
  },
  {
    "name": "crystaldba-postgres-mcp",
    "title": "Postgres MCP",
    "description": "Postgres Pro is an open source Model Context Protocol (MCP) server built to support you and your AI agents throughout the entire development process—from initial coding, through testing and deployment, and to production tuning and maintenance.",
    "icon": "https://avatars.githubusercontent.com/crystaldba",
    "isOfficial": false,
    "homepage": "https://github.com/crystaldba/postgres-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "postgres-mcp"
      ],
      "env": {
        "DATABASE_URI": "<database-uri>"
      }
    },
    "parameters": [
      {
        "name": "DATABASE_URI",
        "description": "The PostgreSQL database connection URI",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "cswkim-discogs-mcp-server",
    "title": "Discogs MCP Server",
    "description": "Enables interactions with the Discogs API for music catalog operations and search functionality, allowing users to manage their Discogs collections through natural language.",
    "icon": "https://avatars.githubusercontent.com/cswkim",
    "isOfficial": false,
    "homepage": "https://github.com/cswkim/discogs-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "discogs-mcp-server"
      ],
      "env": {
        "DISCOGS_PERSONAL_ACCESS_TOKEN": "<discogs-personal-access-token>"
      }
    },
    "parameters": [
      {
        "name": "DISCOGS_PERSONAL_ACCESS_TOKEN",
        "description": "Your Discogs personal access token from your Discogs Settings > Developers page",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_release",
        "description": "Get a release",
        "inputSchema": {
          "type": "object",
          "properties": {
            "curr_abbr": {
              "enum": [
                "USD",
                "GBP",
                "EUR",
                "CAD",
                "AUD",
                "JPY",
                "CHF",
                "MXN",
                "BRL",
                "NZD",
                "SEK",
                "ZAR"
              ],
              "type": "string"
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            }
          },
          "required": [
            "release_id"
          ]
        }
      },
      {
        "name": "get_release_rating_by_user",
        "description": "Retrieves the release's rating for a given user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            }
          },
          "required": [
            "username",
            "release_id"
          ]
        }
      },
      {
        "name": "edit_release_rating",
        "description": "Updates the release's rating for a given user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "rating": {
              "type": "integer",
              "maximum": 5,
              "minimum": 1
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            }
          },
          "required": [
            "username",
            "release_id",
            "rating"
          ]
        }
      },
      {
        "name": "delete_release_rating",
        "description": "Deletes the release's rating for a given user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            }
          },
          "required": [
            "username",
            "release_id"
          ]
        }
      },
      {
        "name": "get_release_community_rating",
        "description": "Retrieves the release community rating average and count",
        "inputSchema": {
          "type": "object",
          "properties": {
            "release_id": {
              "type": "number",
              "minimum": 1
            }
          },
          "required": [
            "release_id"
          ]
        }
      },
      {
        "name": "get_master_release",
        "description": "Get a master release",
        "inputSchema": {
          "type": "object",
          "properties": {
            "master_id": {
              "type": "integer"
            }
          },
          "required": [
            "master_id"
          ]
        }
      },
      {
        "name": "get_master_release_versions",
        "description": "Retrieves a list of all Releases that are versions of this master",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [
                "released",
                "title",
                "format",
                "label",
                "catno",
                "country"
              ],
              "type": "string"
            },
            "label": {
              "type": "string"
            },
            "format": {
              "type": "string"
            },
            "country": {
              "type": "string"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "released": {
              "type": "string"
            },
            "master_id": {
              "type": "integer"
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          "required": [
            "master_id"
          ]
        }
      },
      {
        "name": "get_artist",
        "description": "Get an artist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "artist_id": {
              "type": "number"
            }
          },
          "required": [
            "artist_id"
          ]
        }
      },
      {
        "name": "get_artist_releases",
        "description": "Get an artist's releases",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [
                "year",
                "title",
                "format"
              ],
              "type": "string"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "artist_id": {
              "type": "number"
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          "required": [
            "artist_id"
          ]
        }
      },
      {
        "name": "get_label",
        "description": "Get a label",
        "inputSchema": {
          "type": "object",
          "properties": {
            "label_id": {
              "type": "number"
            }
          },
          "required": [
            "label_id"
          ]
        }
      },
      {
        "name": "get_label_releases",
        "description": "Returns a list of Releases associated with the label",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [],
              "type": "string"
            },
            "label_id": {
              "type": "number"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          "required": [
            "label_id"
          ]
        }
      },
      {
        "name": "search",
        "description": "Issue a search query to the Discogs database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string"
            },
            "anv": {
              "type": "string"
            },
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [
                "title",
                "artist",
                "year"
              ],
              "type": "string"
            },
            "type": {
              "enum": [
                "artist",
                "label",
                "master",
                "release"
              ],
              "type": "string"
            },
            "year": {
              "type": "string"
            },
            "catno": {
              "type": "string"
            },
            "genre": {
              "type": "string"
            },
            "label": {
              "type": "string"
            },
            "style": {
              "type": "string"
            },
            "title": {
              "type": "string"
            },
            "track": {
              "type": "string"
            },
            "artist": {
              "type": "string"
            },
            "credit": {
              "type": "string"
            },
            "format": {
              "type": "string"
            },
            "barcode": {
              "type": "string"
            },
            "country": {
              "type": "string"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "submitter": {
              "type": "string"
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            },
            "contributor": {
              "type": "string"
            },
            "release_title": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "get_user_inventory",
        "description": "Returns the list of listings in a user's inventory",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [
                "listed",
                "price",
                "item",
                "artist",
                "label",
                "catno",
                "audio",
                "status",
                "location"
              ],
              "type": "string"
            },
            "status": {
              "enum": [
                "For Sale",
                "Expired",
                "Draft",
                "Pending"
              ],
              "type": "string"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_marketplace_listing",
        "description": "Get a listing from the marketplace",
        "inputSchema": {
          "type": "object",
          "properties": {
            "curr_abbr": {
              "enum": [
                "USD",
                "GBP",
                "EUR",
                "CAD",
                "AUD",
                "JPY",
                "CHF",
                "MXN",
                "BRL",
                "NZD",
                "SEK",
                "ZAR"
              ],
              "type": "string"
            },
            "listing_id": {
              "type": "integer"
            }
          },
          "required": [
            "listing_id"
          ]
        }
      },
      {
        "name": "create_marketplace_listing",
        "description": "Create a new marketplace listing",
        "inputSchema": {
          "type": "object",
          "properties": {
            "price": {
              "type": "number"
            },
            "status": {
              "enum": [
                "For Sale",
                "Expired",
                "Draft",
                "Pending"
              ],
              "type": "string"
            },
            "weight": {
              "type": "number"
            },
            "comments": {
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "condition": {
              "enum": [
                "Mint (M)",
                "Near Mint (NM or M-)",
                "Very Good Plus (VG+)",
                "Very Good (VG)",
                "Good Plus (G+)",
                "Good (G)",
                "Fair (F)",
                "Poor (P)"
              ],
              "type": "string"
            },
            "release_id": {
              "type": "integer"
            },
            "external_id": {
              "type": "string"
            },
            "allow_offers": {
              "type": "boolean"
            },
            "format_quantity": {
              "type": "number"
            },
            "sleeve_condition": {
              "enum": [
                "Mint (M)",
                "Near Mint (NM or M-)",
                "Very Good Plus (VG+)",
                "Very Good (VG)",
                "Good Plus (G+)",
                "Good (G)",
                "Fair (F)",
                "Poor (P)",
                "Generic",
                "Not Graded",
                "No Cover"
              ],
              "type": "string"
            }
          },
          "required": [
            "release_id",
            "condition",
            "price",
            "status"
          ]
        }
      },
      {
        "name": "update_marketplace_listing",
        "description": "Update a marketplace listing",
        "inputSchema": {
          "type": "object",
          "properties": {
            "price": {
              "type": "number"
            },
            "status": {
              "enum": [
                "For Sale",
                "Expired",
                "Draft",
                "Pending"
              ],
              "type": "string"
            },
            "weight": {
              "type": "number"
            },
            "comments": {
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "condition": {
              "enum": [
                "Mint (M)",
                "Near Mint (NM or M-)",
                "Very Good Plus (VG+)",
                "Very Good (VG)",
                "Good Plus (G+)",
                "Good (G)",
                "Fair (F)",
                "Poor (P)"
              ],
              "type": "string"
            },
            "listing_id": {
              "type": "integer"
            },
            "release_id": {
              "type": "integer"
            },
            "external_id": {
              "type": "string"
            },
            "allow_offers": {
              "type": "boolean"
            },
            "format_quantity": {
              "type": "number"
            },
            "sleeve_condition": {
              "enum": [
                "Mint (M)",
                "Near Mint (NM or M-)",
                "Very Good Plus (VG+)",
                "Very Good (VG)",
                "Good Plus (G+)",
                "Good (G)",
                "Fair (F)",
                "Poor (P)",
                "Generic",
                "Not Graded",
                "No Cover"
              ],
              "type": "string"
            }
          },
          "required": [
            "listing_id",
            "release_id",
            "condition",
            "price",
            "status"
          ]
        }
      },
      {
        "name": "delete_marketplace_listing",
        "description": "Delete a marketplace listing",
        "inputSchema": {
          "type": "object",
          "properties": {
            "listing_id": {
              "type": "integer"
            }
          },
          "required": [
            "listing_id"
          ]
        }
      },
      {
        "name": "get_marketplace_order",
        "description": "Get a marketplace order",
        "inputSchema": {
          "type": "object",
          "properties": {
            "order_id": {
              "type": "number"
            }
          },
          "required": [
            "order_id"
          ]
        }
      },
      {
        "name": "edit_marketplace_order",
        "description": "Edit a marketplace order",
        "inputSchema": {
          "type": "object",
          "properties": {
            "status": {
              "enum": [
                "New Order",
                "Buyer Contacted",
                "Invoice Sent",
                "Payment Pending",
                "Payment Received",
                "Shipped",
                "Refund Sent",
                "Cancelled (Non-Paying Buyer)",
                "Cancelled (Item Unavailable)",
                "Cancelled (Per Buyer's Request)"
              ],
              "type": "string"
            },
            "order_id": {
              "type": "number"
            },
            "shipping": {
              "type": "number"
            }
          },
          "required": [
            "order_id"
          ]
        }
      },
      {
        "name": "get_marketplace_orders",
        "description": "Get a list of marketplace orders",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [
                "id",
                "buyer",
                "created",
                "status",
                "last_activity"
              ],
              "type": "string"
            },
            "status": {
              "enum": [
                "New Order",
                "Buyer Contacted",
                "Invoice Sent",
                "Payment Pending",
                "Payment Received",
                "Shipped",
                "Refund Sent",
                "Cancelled (Non-Paying Buyer)",
                "Cancelled (Item Unavailable)",
                "Cancelled (Per Buyer's Request)"
              ],
              "type": "string"
            },
            "archived": {
              "type": "boolean"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            },
            "created_after": {
              "type": "string"
            },
            "created_before": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "get_marketplace_order_messages",
        "description": "Get a list of an order's messages",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [],
              "type": "string"
            },
            "order_id": {
              "type": "number"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          "required": [
            "order_id"
          ]
        }
      },
      {
        "name": "create_marketplace_order_message",
        "description": "Adds a new message to the order's message log",
        "inputSchema": {
          "type": "object",
          "properties": {
            "status": {
              "enum": [
                "New Order",
                "Buyer Contacted",
                "Invoice Sent",
                "Payment Pending",
                "Payment Received",
                "Shipped",
                "Refund Sent",
                "Cancelled (Non-Paying Buyer)",
                "Cancelled (Item Unavailable)",
                "Cancelled (Per Buyer's Request)"
              ],
              "type": "string"
            },
            "message": {
              "type": "string"
            },
            "order_id": {
              "type": "number"
            }
          },
          "required": [
            "order_id"
          ]
        }
      },
      {
        "name": "get_marketplace_release_stats",
        "description": "Retrieve marketplace statistics for the provided Release ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "curr_abbr": {
              "enum": [
                "USD",
                "GBP",
                "EUR",
                "CAD",
                "AUD",
                "JPY",
                "CHF",
                "MXN",
                "BRL",
                "NZD",
                "SEK",
                "ZAR"
              ],
              "type": "string"
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            }
          },
          "required": [
            "release_id"
          ]
        }
      },
      {
        "name": "inventory_export",
        "description": "Request an export of your inventory as a CSV",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_inventory_exports",
        "description": "Get a list of all recent exports of your inventory",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_inventory_export",
        "description": "Get details about an inventory export",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "download_inventory_export",
        "description": "Download an inventory export as a CSV",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_user_identity",
        "description": "Retrieve basic information about the authenticated user",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_user_profile",
        "description": "Retrieve a user by username",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "edit_user_profile",
        "description": "Edit a user's profile data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "profile": {
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "curr_abbr": {
              "enum": [
                "USD",
                "GBP",
                "EUR",
                "CAD",
                "AUD",
                "JPY",
                "CHF",
                "MXN",
                "BRL",
                "NZD",
                "SEK",
                "ZAR"
              ],
              "type": "string"
            },
            "home_page": {
              "type": "string"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_user_submissions",
        "description": "Retrieve a user's submissions by username",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_user_contributions",
        "description": "Retrieve a user's contributions by username",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [
                "label",
                "artist",
                "title",
                "catno",
                "format",
                "rating",
                "year",
                "added"
              ],
              "type": "string"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_user_collection_folders",
        "description": "Retrieve a list of folders in a user's collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "create_user_collection_folder",
        "description": "Create a new folder in a user's collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "username": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_user_collection_folder",
        "description": "Retrieve metadata about a folder in a user's collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            },
            "folder_id": {
              "type": "integer",
              "minimum": 0
            }
          },
          "required": [
            "username",
            "folder_id"
          ]
        }
      },
      {
        "name": "edit_user_collection_folder",
        "description": "Edit a folder's metadata. Folders 0 and 1 cannot be renamed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "folder_id": {
              "type": "integer",
              "minimum": 0
            }
          },
          "required": [
            "username",
            "folder_id"
          ]
        }
      },
      {
        "name": "delete_user_collection_folder",
        "description": "Delete a folder from a user's collection. A folder must be empty before it can be deleted.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            },
            "folder_id": {
              "type": "integer",
              "minimum": 0
            }
          },
          "required": [
            "username",
            "folder_id"
          ]
        }
      },
      {
        "name": "find_release_in_user_collection",
        "description": "Find a release in a user's collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [],
              "type": "string"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          "required": [
            "username",
            "release_id"
          ]
        }
      },
      {
        "name": "get_user_collection_items",
        "description": "Retrieve a list of items in a user's collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [
                "added",
                "artist",
                "catno",
                "format",
                "label",
                "rating",
                "title",
                "year"
              ],
              "type": "string"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "folder_id": {
              "type": "integer",
              "minimum": 0
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          "required": [
            "username",
            "folder_id"
          ]
        }
      },
      {
        "name": "add_release_to_user_collection_folder",
        "description": "Add a release to a folder in a user's collection. The folder_id must be non-zero.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            },
            "folder_id": {
              "type": "integer",
              "minimum": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            }
          },
          "required": [
            "username",
            "folder_id",
            "release_id"
          ]
        }
      },
      {
        "name": "rate_release_in_user_collection",
        "description": "Rate a release in a user's collection. The folder_id must be non-zero.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "rating": {
              "type": "integer",
              "maximum": 5,
              "minimum": 1
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "folder_id": {
              "type": "integer",
              "minimum": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            },
            "instance_id": {
              "type": "integer"
            }
          },
          "required": [
            "username",
            "folder_id",
            "release_id",
            "instance_id"
          ]
        }
      },
      {
        "name": "move_release_in_user_collection",
        "description": "Move a release in a user's collection to another folder",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            },
            "folder_id": {
              "type": "integer",
              "minimum": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            },
            "instance_id": {
              "type": "integer"
            },
            "destination_folder_id": {
              "type": "number"
            }
          },
          "required": [
            "username",
            "folder_id",
            "release_id",
            "instance_id",
            "destination_folder_id"
          ]
        }
      },
      {
        "name": "delete_release_from_user_collection_folder",
        "description": "Remove an instance of a release from a user's collection folder. The folder_id must be non-zero.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            },
            "folder_id": {
              "type": "integer",
              "minimum": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            },
            "instance_id": {
              "type": "integer"
            }
          },
          "required": [
            "username",
            "folder_id",
            "release_id",
            "instance_id"
          ]
        }
      },
      {
        "name": "get_user_collection_custom_fields",
        "description": "Retrieve a list of user-defined collection notes fields. These fields are available on every release in the collection.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "edit_user_collection_custom_field_value",
        "description": "Edit a custom field value for a release in a user's collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "value": {
              "type": "string"
            },
            "field_id": {
              "type": "number"
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "folder_id": {
              "type": "integer",
              "minimum": 0
            },
            "release_id": {
              "type": [
                "number",
                "string"
              ]
            },
            "instance_id": {
              "type": [
                "number",
                "string"
              ]
            }
          },
          "required": [
            "username",
            "folder_id",
            "value",
            "release_id",
            "instance_id",
            "field_id"
          ]
        }
      },
      {
        "name": "get_user_collection_value",
        "description": "Returns the minimum, median, and maximum value of a user's collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_user_wantlist",
        "description": "Returns the list of releases in a user's wantlist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [
                "added",
                "artist",
                "label",
                "rating",
                "title",
                "year"
              ],
              "type": "string"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "add_to_wantlist",
        "description": "Add a release to a user's wantlist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notes": {
              "type": "string"
            },
            "rating": {
              "type": "integer",
              "maximum": 5,
              "minimum": 0
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            }
          },
          "required": [
            "username",
            "release_id"
          ]
        }
      },
      {
        "name": "edit_item_in_wantlist",
        "description": "Edit a release in a user's wantlist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notes": {
              "type": "string"
            },
            "rating": {
              "type": "integer",
              "maximum": 5,
              "minimum": 0
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            }
          },
          "required": [
            "username",
            "release_id"
          ]
        }
      },
      {
        "name": "delete_item_in_wantlist",
        "description": "Delete a release from a user's wantlist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notes": {
              "type": "string"
            },
            "rating": {
              "type": "integer",
              "maximum": 5,
              "minimum": 0
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "release_id": {
              "type": "number",
              "minimum": 1
            }
          },
          "required": [
            "username",
            "release_id"
          ]
        }
      },
      {
        "name": "get_user_lists",
        "description": "Get a user's lists",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "minimum": 1
            },
            "sort": {
              "enum": [],
              "type": "string"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1
            },
            "username": {
              "type": "string",
              "minLength": 1
            },
            "sort_order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_list",
        "description": "Get a list by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "list_id": {
              "type": "number"
            }
          },
          "required": [
            "list_id"
          ]
        }
      },
      {
        "name": "fetch_image",
        "description": "Fetch an image by URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "cyanheads-filesystem-mcp-server",
    "title": "Filesystem MCP Server",
    "description": "A Model Context Protocol server that provides AI agents with secure access to local filesystem operations, enabling reading, writing, and managing files through a standardized interface.",
    "icon": "https://avatars.githubusercontent.com/cyanheads",
    "isOfficial": false,
    "homepage": "https://github.com/cyanheads/filesystem-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@cyanheads/filesystem-mcp-server"
      ],
      "env": {
        "LOG_DIR": "<log-dir>",
        "LOG_LEVEL": "<log-level>",
        "FS_BASE_DIRECTORY": "<fs-base-directory>"
      }
    },
    "parameters": [
      {
        "name": "LOG_DIR",
        "description": "Specifies the directory where log files (combined.log, error.log) will be stored.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "LOG_LEVEL",
        "description": "Controls the verbosity of logs. Options: error, warn, info, http, verbose, debug, silly.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "FS_BASE_DIRECTORY",
        "description": "If set to an absolute path, all file operations performed by the server will be strictly confined within this directory and its subdirectories. This prevents the AI agent from accessing files outside the intended scope.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "read_file",
        "description": "Reads the entire content of a specified file as UTF-8 text. Accepts relative or absolute paths. Relative paths are resolved against the session default set by `set_filesystem_default`.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "The path to the file to read. Can be relative or absolute. If relative, it resolves against the path set by `set_filesystem_default`. If absolute, it is used directly. If relative and no default is set, an error occurs."
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "set_filesystem_default",
        "description": "Sets a default absolute path for the current session. Relative paths used in other filesystem tools (like readFile) will be resolved against this default. The default is cleared on server restart.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "The absolute path to set as the default for resolving relative paths during this session."
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "write_file",
        "description": "Writes content to a specified file. Creates the file (and necessary directories) if it doesn't exist, or overwrites it if it does. Accepts relative or absolute paths (resolved like readFile).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "The path to the file to write. Can be relative or absolute. If relative, it resolves against the path set by `set_filesystem_default`. If absolute, it is used directly. Missing directories will be created."
            },
            "content": {
              "type": "string",
              "description": "The content to write to the file. If the file exists, it will be overwritten."
            }
          },
          "required": [
            "path",
            "content"
          ]
        }
      },
      {
        "name": "update_file",
        "description": "Performs targeted search-and-replace operations within an existing file using an array of {search, replace} blocks. Preferred for smaller, localized changes. For large-scale updates or overwrites, consider using `write_file`. Accepts relative or absolute paths. File must exist. Supports optional `useRegex` (boolean, default false) and `replaceAll` (boolean, default false).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "The path to the file to update. Can be relative or absolute (resolved like readFile). The file must exist."
            },
            "blocks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "search",
                  "replace"
                ],
                "properties": {
                  "search": {
                    "type": "string",
                    "minLength": 1
                  },
                  "replace": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "minItems": 1,
              "description": "An array of objects, each with a `search` (string) and `replace` (string) property."
            },
            "useRegex": {
              "type": "boolean",
              "default": false,
              "description": "If true, treat the `search` field of each block as a JavaScript regular expression pattern. Defaults to false (exact string matching)."
            },
            "replaceAll": {
              "type": "boolean",
              "default": false,
              "description": "If true, replace all occurrences matching the SEARCH criteria within the file. If false, only replace the first occurrence. Defaults to false."
            }
          },
          "required": [
            "path",
            "blocks"
          ]
        }
      },
      {
        "name": "list_files",
        "description": "Lists files and directories within the specified directory. Optionally lists recursively and returns a tree-like structure. Includes an optional `maxEntries` parameter (default 50) to limit the number of items returned.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "The path to the directory to list. Can be relative or absolute (resolved like readFile)."
            },
            "maxEntries": {
              "type": "integer",
              "default": 50,
              "description": "Maximum number of directory entries (files + folders) to return. Defaults to 50. Helps prevent excessive output for large directories.",
              "exclusiveMinimum": 0
            },
            "includeNested": {
              "type": "boolean",
              "default": false,
              "description": "If true, list files and directories recursively. Defaults to false (top-level only)."
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "delete_file",
        "description": "Removes a specific file. Accepts relative or absolute paths.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "The path to the file to delete. Can be relative or absolute (resolved like readFile)."
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "delete_directory",
        "description": "Removes a directory. Optionally removes recursively. Accepts relative or absolute paths.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "The path to the directory to delete. Can be relative or absolute."
            },
            "recursive": {
              "type": "boolean",
              "default": false,
              "description": "If true, delete the directory and all its contents. If false, only delete if the directory is empty."
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "create_directory",
        "description": "Creates a directory. Optionally creates parent directories. Accepts relative or absolute paths.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "minLength": 1,
              "description": "The path to the directory to create. Can be relative or absolute."
            },
            "create_parents": {
              "type": "boolean",
              "default": true,
              "description": "If true, create any necessary parent directories that don't exist. If false, fail if a parent directory is missing."
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "move_path",
        "description": "Moves or renames a file or directory. Accepts relative or absolute paths for source and destination.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "source_path": {
              "type": "string",
              "minLength": 1,
              "description": "The current path of the file or directory to move. Can be relative or absolute."
            },
            "destination_path": {
              "type": "string",
              "minLength": 1,
              "description": "The new path for the file or directory. Can be relative or absolute."
            }
          },
          "required": [
            "source_path",
            "destination_path"
          ]
        }
      },
      {
        "name": "copy_path",
        "description": "Copies a file or directory to a new location. Accepts relative or absolute paths. Defaults to recursive copy for directories.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "recursive": {
              "type": "boolean",
              "default": true,
              "description": "If copying a directory, whether to copy its contents recursively. Defaults to true."
            },
            "source_path": {
              "type": "string",
              "minLength": 1,
              "description": "The path of the file or directory to copy. Can be relative or absolute."
            },
            "destination_path": {
              "type": "string",
              "minLength": 1,
              "description": "The path where the copy should be created. Can be relative or absolute."
            }
          },
          "required": [
            "source_path",
            "destination_path"
          ]
        }
      }
    ]
  },
  {
    "name": "daisys-ai-daisys-mcp",
    "title": "Daisys MCP Server",
    "description": "A beta server that enables integration with Daisys.ai services via the Message Control Protocol (MCP), allowing AI clients like Claude Desktop and Cursor to use Daisys features through a standardized interface.",
    "icon": "https://avatars.githubusercontent.com/daisys-ai",
    "isOfficial": false,
    "homepage": "https://github.com/daisys-ai/daisys-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "daisys-mcp"
      ],
      "env": {
        "DAISYS_EMAIL": "<daisys-email>",
        "DAISYS_PASSWORD": "<daisys-password>",
        "DAISYS_BASE_STORAGE_PATH": "<daisys-base-storage-path>"
      }
    },
    "parameters": [
      {
        "name": "DAISYS_EMAIL",
        "description": "Your Daisys account email",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "DAISYS_PASSWORD",
        "description": "Your Daisys account password",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "DAISYS_BASE_STORAGE_PATH",
        "description": "Path where you want to store your audio files",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "text_to_speech",
        "description": "\n        Convert text to speech with a given voice and play the audio buffer.\n        Voice_id can be provided. If not provided, the latest voice will be used.\n\n        ⚠️ TOKEN WARNING: This tool makes an API call to Daisys API which may incur costs. \n\n        Args:\n            text (str): The text to convert to speech.\n            voice_id (str, optional): The voice_id of the voice to use. If no voice specified use latest created voice.\n            audio_format (str, optional): Can be either \"wav\" or \"mp3\". Defaults to \"wav\" always use \"wav\" unless mp3 specified.\n            output_dir (str, optional): Directory where files should be saved. Defaults to $HOME/Desktop if not provided.\n            streaming (bool, optional): Whether to use streaming or not. Set to True unless specifically asked to not stream. (streaming makes use of the websocket protocol which send and play audio in chunks)\n            Defaults don't store if not provided.\n\n        Returns:\n            Text content with the path to the output file and name of the voice used.\n        ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "title": "Text"
            },
            "voice_id": {
              "type": "string",
              "title": "Voice Id",
              "default": null
            },
            "streaming": {
              "type": "boolean",
              "title": "Streaming",
              "default": true
            },
            "output_dir": {
              "type": "string",
              "title": "Output Dir",
              "default": null
            },
            "audio_format": {
              "type": "string",
              "title": "Audio Format",
              "default": "wav"
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "get_voices",
        "description": "Get available voices can be filtered by model and gender, and sorted by name or timestamp in ascending or descending order.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string",
              "title": "Model",
              "default": null
            },
            "gender": {
              "type": "string",
              "title": "Gender",
              "default": null
            },
            "sort_by": {
              "enum": [
                "description",
                "name"
              ],
              "type": "string",
              "title": "Sort By",
              "default": "name"
            },
            "sort_direction": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "title": "Sort Direction",
              "default": "asc"
            }
          }
        }
      },
      {
        "name": "get_models",
        "description": "\n        Get all available models from Daisys API.\n\n        Args:\n            language (str, optional): needs to be \"de\" for german, \"en\" for english and \"nl\" for dutch. Defaults to None.\n            sort_by (str, optional): can be \"name\" or \"displayname\". Defaults to \"displayname\".\n            sort_direction (str, optional): can be \"asc\" or \"desc\". Defaults to \"asc\".\n\n        Returns:\n            model_list: An object containing details of all models\n\n        ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort_by": {
              "enum": [
                "name",
                "displayname"
              ],
              "type": "string",
              "title": "Sort By",
              "default": "displayname"
            },
            "language": {
              "type": "string",
              "title": "Language",
              "default": null
            },
            "sort_direction": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "title": "Sort Direction",
              "default": "asc"
            }
          }
        }
      },
      {
        "name": "create_voice",
        "description": "\n        Convert text to speech with a given voice and play the audio buffer.\n        Voice_id can be provided. If not provided, the latest voice will be used.\n\n        before calling also call get models so it always inputs a valid model\n\n        ⚠️ TOKEN WARNING: This tool makes an API call to Daisys API which may incur costs. \n\n        Args:\n            name (str, optional): The name of the voice to create. Defaults to \"Daisy\".\n            gender (str, optional): The gender of the voice can be \"male\" or \"female\". Defaults to \"female\".\n            model (str, optional): The model of the voice. Defaults to \"english-v3.0\".\n            pitch (int, optional): Adjusts the pitch level; -10 for very low pitch, 10 for very high pitch.\n            pace (int, optional): Controls the speech rate; -10 for very slow, 10 for very fast.\n            expression (int, optional): Modulates expressiveness; -10 for monotone, 10 for highly expressive.\n\n        Returns:\n            McpVoice: An object containing details of the created voice, including voice_id, name, gender, model, and description.\n\n        ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name",
              "default": "Daisy"
            },
            "pace": {
              "type": "integer",
              "title": "Pace",
              "default": 0
            },
            "model": {
              "type": "string",
              "title": "Model",
              "default": "english-v3.0"
            },
            "pitch": {
              "type": "integer",
              "title": "Pitch",
              "default": 0
            },
            "gender": {
              "type": "string",
              "title": "Gender",
              "default": "female"
            },
            "expression": {
              "type": "integer",
              "title": "Expression",
              "default": 0
            }
          }
        }
      },
      {
        "name": "remove_voice",
        "description": "Delete a voice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "voice_id": {
              "type": "string",
              "title": "Voice Id"
            }
          },
          "required": [
            "voice_id"
          ]
        }
      }
    ]
  },
  {
    "name": "isdaniel-mcp_weather_server",
    "title": "Weather MCP Server",
    "description": "A Model Context Protocol server that retrieves current weather information for specified cities using the Open-Meteo API, requiring no API key.",
    "icon": "https://avatars.githubusercontent.com/isdaniel",
    "isOfficial": false,
    "homepage": "https://github.com/isdaniel/mcp_weather_server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp_weather_server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_current_weather",
        "description": "Get current weather information for a specified city.\nIt extracts the current hour's temperature and weather code, maps\nthe weather code to a human-readable description, and returns a formatted summary.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "city": {
              "type": "string",
              "title": "City",
              "description": "The name of the city to fetch weather information for, PLEASE NOTE English name only, if the parameter city isn't English please translate to English before invoking this function."
            }
          },
          "required": [
            "city"
          ]
        }
      },
      {
        "name": "get_weather_by_datetime_range",
        "description": "\nGet weather information for a specified city between start and end dates.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "city": {
              "type": "string",
              "title": "City",
              "description": "The name of the city to fetch weather information for, PLEASE NOTE English name only, if the parameter city isn't English please translate to English before invoking this function."
            },
            "end_date": {
              "type": "string",
              "title": "End Date",
              "description": "End date in format YYYY-MM-DD , please follow ISO 8601 format"
            },
            "start_date": {
              "type": "string",
              "title": "Start Date",
              "description": "Start date in format YYYY-MM-DD, please follow ISO 8601 format"
            }
          },
          "required": [
            "city",
            "start_date",
            "end_date"
          ]
        }
      },
      {
        "name": "get_current_datetime",
        "description": "Get current time in specified timezone",
        "inputSchema": {
          "type": "object",
          "properties": {
            "timezone_name": {
              "type": "string",
              "title": "Timezone Name",
              "description": "IANA timezone name (e.g., 'America/New_York', 'Europe/London'). Use UTC timezone if no timezone provided by the user."
            }
          },
          "required": [
            "timezone_name"
          ]
        }
      }
    ]
  },
  {
    "name": "da-okazaki-mcp-neo4j-server",
    "title": "MCP Neo4j Server",
    "description": "This server enables interaction between Neo4j databases and Claude Desktop, allowing users to execute Cypher queries, create nodes, and establish relationships in the database.",
    "icon": "https://avatars.githubusercontent.com/da-okazaki",
    "isOfficial": false,
    "homepage": "https://github.com/da-okazaki/mcp-neo4j-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@alanse/mcp-neo4j-server"
      ],
      "env": {
        "NEO4J_URI": "<neo4j-uri>",
        "NEO4J_PASSWORD": "<neo4j-password>",
        "NEO4J_USERNAME": "<neo4j-username>"
      }
    },
    "parameters": [
      {
        "name": "NEO4J_URI",
        "description": "Neo4j database URI",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NEO4J_PASSWORD",
        "description": "Neo4j password",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "NEO4J_USERNAME",
        "description": "Neo4j username",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "its-dart-dart-mcp-server",
    "title": "Dart MCP Server",
    "description": "An official AI Model Context Protocol server that enables AI assistants to interact with Dart project management by creating/managing tasks and documents through prompts and tools.",
    "icon": "https://avatars.githubusercontent.com/its-dart",
    "isOfficial": false,
    "homepage": "https://github.com/its-dart/dart-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "dart-mcp-server"
      ],
      "env": {
        "DART_TOKEN": "<dart-token>"
      }
    },
    "parameters": [
      {
        "name": "DART_TOKEN",
        "description": "Your Dart authentication token from your Dart profile",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_config",
        "description": "Get information about the user's space, including all of the possible values that can be provided to other endpoints. This includes available assignees, dartboards, folders, statuses, tags, priorities, and sizes.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "list_tasks",
        "description": "List tasks from Dart with optional filtering parameters. You can filter by assignee, status, dartboard, priority, due date, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "Filter by tag"
            },
            "kind": {
              "type": "string",
              "description": "Filter by task kind"
            },
            "size": {
              "type": "number",
              "description": "Filter by task size"
            },
            "duids": {
              "type": "string",
              "description": "Filter by IDs"
            },
            "limit": {
              "type": "number",
              "description": "Number of results per page"
            },
            "title": {
              "type": "string",
              "description": "Filter by title"
            },
            "offset": {
              "type": "number",
              "description": "Initial index for pagination"
            },
            "status": {
              "type": "string",
              "description": "Filter by status"
            },
            "assignee": {
              "type": "string",
              "description": "Filter by assignee name or email"
            },
            "in_trash": {
              "type": "boolean",
              "description": "Filter by trash status"
            },
            "is_draft": {
              "type": "boolean",
              "description": "Filter by draft status"
            },
            "priority": {
              "type": "string",
              "description": "Filter by priority"
            },
            "dartboard": {
              "type": "string",
              "description": "Filter by dartboard title"
            },
            "description": {
              "type": "string",
              "description": "Filter by description content"
            },
            "status_duid": {
              "type": "string",
              "description": "Filter by status ID"
            },
            "due_at_after": {
              "type": "string",
              "description": "Filter by due date after (ISO format)"
            },
            "assignee_duid": {
              "type": "string",
              "description": "Filter by assignee ID"
            },
            "due_at_before": {
              "type": "string",
              "description": "Filter by due date before (ISO format)"
            },
            "dartboard_duid": {
              "type": "string",
              "description": "Filter by dartboard ID"
            },
            "start_at_after": {
              "type": "string",
              "description": "Filter by start date after (ISO format)"
            },
            "start_at_before": {
              "type": "string",
              "description": "Filter by start date before (ISO format)"
            },
            "subscriber_duid": {
              "type": "string",
              "description": "Filter by subscriber ID"
            }
          },
          "required": []
        }
      },
      {
        "name": "create_task",
        "description": "Create a new task in Dart. You can specify title, description, status, priority, size, dates, dartboard, assignees, tags, and parent task.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "size": {
              "type": "number",
              "description": "A number that represents the amount of work needed"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of tags to apply to the task"
            },
            "dueAt": {
              "type": "string",
              "description": "The due date in ISO format (should be at 9:00am in user's timezone)"
            },
            "title": {
              "type": "string",
              "description": "The title of the task (required)"
            },
            "status": {
              "type": "string",
              "description": "The status from the list of available statuses"
            },
            "startAt": {
              "type": "string",
              "description": "The start date in ISO format (should be at 9:00am in user's timezone)"
            },
            "assignee": {
              "type": "string",
              "description": "Single assignee name or email (if workspace doesn't allow multiple assignees)"
            },
            "parentId": {
              "type": "string",
              "description": "The ID of the parent task"
            },
            "priority": {
              "type": "string",
              "description": "The priority (Critical, High, Medium, or Low)"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of assignee names or emails (if workspace allows multiple assignees)"
            },
            "dartboard": {
              "type": "string",
              "description": "The title of the dartboard (project or list of tasks)"
            },
            "description": {
              "type": "string",
              "description": "A longer description of the task, which can include markdown formatting"
            }
          },
          "required": [
            "title"
          ]
        }
      },
      {
        "name": "get_task",
        "description": "Retrieve an existing task by its ID. Returns the task's information including title, description, status, priority, dates, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{12}$",
              "description": "The 12-character alphanumeric ID of the task"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "update_task",
        "description": "Update an existing task. You can modify any of its properties including title, description, status, priority, dates, assignees, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{12}$",
              "description": "The 12-character alphanumeric ID of the task"
            },
            "size": {
              "type": "number",
              "description": "A number that represents the amount of work needed"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of tags to apply to the task"
            },
            "dueAt": {
              "type": "string",
              "description": "The due date in ISO format (should be at 9:00am in user's timezone)"
            },
            "title": {
              "type": "string",
              "description": "The title of the task"
            },
            "status": {
              "type": "string",
              "description": "The status from the list of available statuses"
            },
            "startAt": {
              "type": "string",
              "description": "The start date in ISO format (should be at 9:00am in user's timezone)"
            },
            "assignee": {
              "type": "string",
              "description": "Single assignee name or email (if workspace doesn't allow multiple assignees)"
            },
            "parentId": {
              "type": "string",
              "description": "The ID of the parent task"
            },
            "priority": {
              "type": "string",
              "description": "The priority (Critical, High, Medium, or Low)"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of assignee names or emails (if workspace allows multiple assignees)"
            },
            "dartboard": {
              "type": "string",
              "description": "The title of the dartboard (project or list of tasks)"
            },
            "description": {
              "type": "string",
              "description": "A longer description of the task, which can include markdown formatting"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "delete_task",
        "description": "Move an existing task to the trash, where it can be recovered if needed. Nothing else about the task will be changed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{12}$",
              "description": "The 12-character alphanumeric ID of the task"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_docs",
        "description": "List docs from Dart with optional filtering parameters. You can filter by folder, title, text content, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "s": {
              "type": "string",
              "description": "Search by title, text, or folder title"
            },
            "text": {
              "type": "string",
              "description": "Filter by text content"
            },
            "duids": {
              "type": "string",
              "description": "Filter by IDs"
            },
            "limit": {
              "type": "number",
              "description": "Number of results per page"
            },
            "title": {
              "type": "string",
              "description": "Filter by title"
            },
            "folder": {
              "type": "string",
              "description": "Filter by folder title"
            },
            "offset": {
              "type": "number",
              "description": "Initial index for pagination"
            },
            "in_trash": {
              "type": "boolean",
              "description": "Filter by trash status"
            },
            "is_draft": {
              "type": "boolean",
              "description": "Filter by draft status"
            },
            "folder_duid": {
              "type": "string",
              "description": "Filter by folder ID"
            }
          },
          "required": []
        }
      },
      {
        "name": "create_doc",
        "description": "Create a new doc in Dart. You can specify title, text content, and folder.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "The text content of the doc, which can include markdown formatting"
            },
            "title": {
              "type": "string",
              "description": "The title of the doc (required)"
            },
            "folder": {
              "type": "string",
              "description": "The title of the folder to place the doc in"
            }
          },
          "required": [
            "title"
          ]
        }
      },
      {
        "name": "get_doc",
        "description": "Retrieve an existing doc by its ID. Returns the doc's information including title, text content, folder, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{12}$",
              "description": "The 12-character alphanumeric ID of the doc"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "update_doc",
        "description": "Update an existing doc. You can modify its title, text content, and folder.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{12}$",
              "description": "The 12-character alphanumeric ID of the doc"
            },
            "text": {
              "type": "string",
              "description": "The text content of the doc, which can include markdown formatting"
            },
            "title": {
              "type": "string",
              "description": "The title of the doc"
            },
            "folder": {
              "type": "string",
              "description": "The title of the folder to place the doc in"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "delete_doc",
        "description": "Move an existing doc to the trash, where it can be recovered if needed. Nothing else about the doc will be changed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9]{12}$",
              "description": "The 12-character alphanumeric ID of the doc"
            }
          },
          "required": [
            "id"
          ]
        }
      }
    ]
  },
  {
    "name": "databutton-databutton-mcp",
    "title": "Databutton MCP Server",
    "description": "An MCP server for doing doing initial app planning and creating a good starting point in Databutton – it starts a new app and generates the initial MVP tasks",
    "icon": "https://avatars.githubusercontent.com/databutton",
    "isOfficial": true,
    "homepage": "https://github.com/databutton/databutton-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "databutton"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "submit_app_requirements",
        "description": "Submit app requirements",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the app"
            },
            "spec": {
              "type": "object",
              "required": [
                "description",
                "targetAudience",
                "design",
                "typography"
              ],
              "properties": {
                "design": {
                  "type": "string",
                  "description": "The app's design"
                },
                "typography": {
                  "type": "string",
                  "description": "The app's typography"
                },
                "description": {
                  "type": "string",
                  "description": "The app's specifications given in no more than 4-5 paragraphs"
                },
                "targetAudience": {
                  "type": "string",
                  "description": "The app's target audience"
                }
              },
              "additionalProperties": false
            },
            "pitch": {
              "type": "string",
              "description": "The pitch for the app"
            }
          },
          "required": [
            "name",
            "pitch",
            "spec"
          ]
        }
      }
    ]
  },
  {
    "name": "ai-1st-deepview-mcp",
    "title": "DeepView MCP",
    "description": "A Model Context Protocol server that enables IDEs like Cursor and Windsurf to analyze large codebases using Gemini's extensive context window.",
    "icon": "https://avatars.githubusercontent.com/ai-1st",
    "isOfficial": false,
    "homepage": "https://github.com/ai-1st/deepview-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "deepview-mcp"
      ],
      "env": {
        "GEMINI_API_KEY": "<gemini-api-key>"
      }
    },
    "parameters": [
      {
        "name": "GEMINI_API_KEY",
        "description": "Your API key from Google AI Studio",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "deepview",
        "description": "\nAsk a question about the codebase using Gemini.\n\nArgs:\n    question: The question to ask about the codebase\n    codebase_file: Optional path to the codebase file. If provided, will load this file\n                  instead of using the globally loaded codebase.\n\nReturns:\n    Dictionary with the query result or error\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "question": {
              "type": "string",
              "title": "Question"
            },
            "codebase_file": {
              "type": "string",
              "title": "Codebase File",
              "default": null
            }
          },
          "required": [
            "question"
          ]
        }
      }
    ]
  },
  {
    "name": "delorenj-mcp-server-ticketmaster",
    "title": "MCP Server for Ticketmaster Events",
    "description": "Provides tools for discovering events at Madison Square Garden via the Ticketmaster API, returning structured data with event details like name, date, price, and ticket purchase links.",
    "icon": "https://avatars.githubusercontent.com/delorenj",
    "isOfficial": false,
    "homepage": "https://github.com/delorenj/mcp-server-ticketmaster",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@delorenj/mcp-server-ticketmaster"
      ],
      "env": {
        "TICKETMASTER_API_KEY": "<ticketmaster-api-key>"
      }
    },
    "parameters": [
      {
        "name": "TICKETMASTER_API_KEY",
        "description": "Your Ticketmaster API key obtained from the Ticketmaster Developer portal",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "designcomputer-mysql_mcp_server",
    "title": "MySQL MCP Server",
    "description": "Allows AI assistants to list tables, read data, and execute SQL queries through a controlled interface, making database exploration and analysis safer and more structured.",
    "icon": "https://avatars.githubusercontent.com/designcomputer",
    "isOfficial": false,
    "homepage": "https://github.com/designcomputer/mysql_mcp_server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mysql-mcp-server"
      ],
      "env": {
        "MYSQL_HOST": "<mysql-host>",
        "MYSQL_PORT": "<mysql-port>",
        "MYSQL_USER": "<mysql-user>",
        "MYSQL_DATABASE": "<mysql-database>",
        "MYSQL_PASSWORD": "<mysql-password>"
      }
    },
    "parameters": [
      {
        "name": "MYSQL_HOST",
        "description": "Database host",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_PORT",
        "description": "Database port (defaults to 3306 if not specified)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MYSQL_USER",
        "description": "MySQL username",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_DATABASE",
        "description": "MySQL database name",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_PASSWORD",
        "description": "MySQL password",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "execute_sql",
        "description": "Execute an SQL query on the MySQL server",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "docfork-docfork-mcp",
    "title": "Docfork",
    "description": "Provides up-to-date documentation for 9000+ libraries directly in your AI code editor, enabling accurate code suggestions and eliminating outdated information.",
    "icon": "https://avatars.githubusercontent.com/docfork",
    "isOfficial": false,
    "homepage": "https://github.com/docfork/docfork-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "docfork"
      ],
      "env": {
        "DEFAULT_MINIMUM_TOKENS": "<default-minimum-tokens>"
      }
    },
    "parameters": [
      {
        "name": "DEFAULT_MINIMUM_TOKENS",
        "description": "Set the minimum token count for documentation retrieval",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get-library-docs",
        "description": "Retrieves up-to-date documentation and code examples for any library. This tool automatically searches for the library by name and fetches its documentation.\n\nUsage:\n1. Provide the author and library name pair (e.g., \"vercel/next.js\", \"shadcn-ui/ui\", \"vuejs/docs\")\n2. Specify a topic to focus the documentation on (e.g., \"dynamic\", \"routing\", \"authentication\")\n\nThe tool will:\n1. Automatically find and select the most relevant library based on the provided name\n2. Fetch comprehensive documentation for the selected library\n3. Return relevant sections focused on the specified topic\n\nResponse includes:\n- Library selection explanation\n- Comprehensive documentation with code examples\n- Focused content if a topic was specified",
        "inputSchema": {
          "type": "object",
          "properties": {
            "topic": {
              "type": "string",
              "description": "Topic to focus documentation on (e.g., 'hooks', 'routing', 'authentication')"
            },
            "tokens": {
              "type": "number",
              "description": "Maximum number of tokens of documentation to retrieve (default: 10000). Higher values provide more context but consume more tokens."
            },
            "libraryName": {
              "type": "string",
              "description": "Author and library name pair to search for and retrieve documentation (e.g., 'vercel/next.js', 'reactjs/react.dev', 'vuejs/docs')"
            }
          },
          "required": [
            "libraryName",
            "topic"
          ]
        }
      }
    ]
  },
  {
    "name": "doggybee-mcp-server-ccxt",
    "title": "CCXT MCP Server",
    "description": "High-performance CCXT MCP server for cryptocurrency exchange integration",
    "icon": "https://avatars.githubusercontent.com/doggybee",
    "isOfficial": false,
    "homepage": "https://github.com/doggybee/mcp-server-ccxt",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@mcpfun/mcp-server-ccxt"
      ],
      "env": {
        "BINANCE_SECRET": "<binance-secret>",
        "BINANCE_API_KEY": "<binance-api-key>",
        "DEFAULT_EXCHANGE": "<default-exchange>"
      }
    },
    "parameters": [
      {
        "name": "BINANCE_SECRET",
        "description": "Your Binance exchange API secret",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "BINANCE_API_KEY",
        "description": "Your Binance exchange API key",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DEFAULT_EXCHANGE",
        "description": "The default exchange to use (optional)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "cache-stats",
        "description": "Get CCXT cache statistics",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "clear-cache",
        "description": "Clear CCXT cache",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "set-log-level",
        "description": "Set logging level",
        "inputSchema": {
          "type": "object",
          "properties": {
            "level": {
              "enum": [
                "debug",
                "info",
                "warning",
                "error"
              ],
              "type": "string",
              "description": "Logging level to set"
            }
          },
          "required": [
            "level"
          ]
        }
      },
      {
        "name": "list-exchanges",
        "description": "List all available cryptocurrency exchanges",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-ticker",
        "description": "Get current ticker information for a trading pair",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol (e.g., BTC/USDT)"
            },
            "exchange": {
              "type": "string",
              "description": "Exchange ID (e.g., binance, coinbase)"
            }
          },
          "required": [
            "exchange",
            "symbol"
          ]
        }
      },
      {
        "name": "batch-get-tickers",
        "description": "Get ticker information for multiple trading pairs at once",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbols": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of trading pair symbols (e.g., ['BTC/USDT', 'ETH/USDT'])"
            },
            "exchange": {
              "type": "string",
              "description": "Exchange ID (e.g., binance, coinbase)"
            }
          },
          "required": [
            "exchange",
            "symbols"
          ]
        }
      },
      {
        "name": "get-orderbook",
        "description": "Get market order book for a trading pair",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 20,
              "description": "Depth of the orderbook"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol (e.g., BTC/USDT)"
            },
            "exchange": {
              "type": "string",
              "description": "Exchange ID (e.g., binance, coinbase)"
            }
          },
          "required": [
            "exchange",
            "symbol"
          ]
        }
      },
      {
        "name": "get-ohlcv",
        "description": "Get OHLCV candlestick data for a trading pair",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Number of candles to fetch (max 1000)"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol (e.g., BTC/USDT)"
            },
            "exchange": {
              "type": "string",
              "description": "Exchange ID (e.g., binance, coinbase)"
            },
            "timeframe": {
              "type": "string",
              "default": "1d",
              "description": "Timeframe (e.g., 1m, 5m, 1h, 1d)"
            }
          },
          "required": [
            "exchange",
            "symbol"
          ]
        }
      },
      {
        "name": "get-trades",
        "description": "Get recent trades for a trading pair",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 50,
              "description": "Number of trades to fetch"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol (e.g., BTC/USDT)"
            },
            "exchange": {
              "type": "string",
              "description": "Exchange ID (e.g., binance, coinbase)"
            }
          },
          "required": [
            "exchange",
            "symbol"
          ]
        }
      },
      {
        "name": "get-markets",
        "description": "Get all available markets for an exchange",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1,
              "description": "Page number"
            },
            "exchange": {
              "type": "string",
              "description": "Exchange ID (e.g., binance, coinbase)"
            },
            "pageSize": {
              "type": "number",
              "default": 100,
              "description": "Items per page"
            }
          },
          "required": [
            "exchange"
          ]
        }
      },
      {
        "name": "get-exchange-info",
        "description": "Get exchange information and status",
        "inputSchema": {
          "type": "object",
          "properties": {
            "exchange": {
              "type": "string",
              "description": "Exchange ID (e.g., binance, coinbase)"
            }
          },
          "required": [
            "exchange"
          ]
        }
      },
      {
        "name": "account-balance",
        "description": "Get your account balance from a crypto exchange",
        "inputSchema": {
          "type": "object",
          "properties": {
            "apiKey": {
              "type": "string",
              "description": "API key for authentication"
            },
            "secret": {
              "type": "string",
              "description": "API secret for authentication"
            },
            "exchange": {
              "type": "string",
              "description": "Exchange ID (e.g., binance, coinbase)"
            }
          },
          "required": [
            "exchange",
            "apiKey",
            "secret"
          ]
        }
      },
      {
        "name": "place-market-order",
        "description": "Place a market order on an exchange",
        "inputSchema": {
          "type": "object",
          "properties": {
            "side": {
              "enum": [
                "buy",
                "sell"
              ],
              "type": "string",
              "description": "Order side: buy or sell"
            },
            "amount": {
              "type": "number",
              "description": "Amount to buy/sell",
              "exclusiveMinimum": 0
            },
            "apiKey": {
              "type": "string",
              "description": "API key for authentication"
            },
            "secret": {
              "type": "string",
              "description": "API secret for authentication"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol (e.g., BTC/USDT)"
            },
            "exchange": {
              "type": "string",
              "description": "Exchange ID (e.g., binance, coinbase)"
            }
          },
          "required": [
            "exchange",
            "symbol",
            "side",
            "amount",
            "apiKey",
            "secret"
          ]
        }
      }
    ]
  },
  {
    "name": "domdomegg-airtable-mcp-server",
    "title": "airtable-mcp-server",
    "description": "A Model Context Protocol server that provides read and write access to Airtable databases. This server enables LLMs to inspect database schemas, then read and write records.",
    "icon": "https://avatars.githubusercontent.com/domdomegg",
    "isOfficial": false,
    "homepage": "https://github.com/domdomegg/airtable-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "airtable-mcp-server"
      ],
      "env": {
        "AIRTABLE_API_KEY": "<airtable-api-key>"
      }
    },
    "parameters": [
      {
        "name": "AIRTABLE_API_KEY",
        "description": "",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "dpflucas-mysql-mcp-server",
    "title": "MySQL Database Access",
    "description": "An MCP server that provides read-only access to MySQL databases.",
    "icon": "https://avatars.githubusercontent.com/dpflucas",
    "isOfficial": false,
    "homepage": "https://github.com/dpflucas/mysql-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mysql-mcp-server"
      ],
      "env": {
        "MYSQL_HOST": "<mysql-host>",
        "MYSQL_PORT": "<mysql-port>",
        "MYSQL_USER": "<mysql-user>",
        "MYSQL_DATABASE": "<mysql-database>",
        "MYSQL_PASSWORD": "<mysql-password>"
      }
    },
    "parameters": [
      {
        "name": "MYSQL_HOST",
        "description": "Database server hostname",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_PORT",
        "description": "Database server port",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MYSQL_USER",
        "description": "Database username",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_DATABASE",
        "description": "Default database name (optional)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MYSQL_PASSWORD",
        "description": "Database password (optional, but recommended for secure connections)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "list_databases",
        "description": "List all accessible databases on the MySQL server",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "list_tables",
        "description": "List all tables in a specified database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database": {
              "type": "string",
              "description": "Database name (optional, uses default if not specified)"
            }
          },
          "required": []
        }
      },
      {
        "name": "describe_table",
        "description": "Show the schema for a specific table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table": {
              "type": "string",
              "description": "Table name"
            },
            "database": {
              "type": "string",
              "description": "Database name (optional, uses default if not specified)"
            }
          },
          "required": [
            "table"
          ]
        }
      },
      {
        "name": "execute_query",
        "description": "Execute a read-only SQL query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SQL query (only SELECT, SHOW, DESCRIBE, and EXPLAIN statements are allowed)"
            },
            "database": {
              "type": "string",
              "description": "Database name (optional, uses default if not specified)"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "dryeab-mcp-telegram",
    "title": "MCP Telegram",
    "description": "MCP Server for Telegram",
    "icon": "https://avatars.githubusercontent.com/dryeab",
    "isOfficial": false,
    "homepage": "https://github.com/dryeab/mcp-telegram",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-telegram"
      ],
      "env": {
        "API_ID": "<api-id>",
        "API_HASH": "<api-hash>"
      }
    },
    "parameters": [
      {
        "name": "API_ID",
        "description": "Your Telegram API ID obtained from my.telegram.org/apps",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "API_HASH",
        "description": "Your Telegram API Hash obtained from my.telegram.org/apps",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "effytech-freshdesk_mcp",
    "title": "Freshdesk MCP server",
    "description": "Integrate AI models with Freshdesk to automate support operations. Create, update, and manage support tickets seamlessly through the Freshdesk API. Enhance your customer support experience with automated ticket management and AI-driven interactions.",
    "icon": "https://avatars.githubusercontent.com/effytech",
    "isOfficial": false,
    "homepage": "https://github.com/effytech/freshdesk_mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "freshdesk-mcp"
      ],
      "env": {
        "FRESHDESK_DOMAIN": "<freshdesk-domain>",
        "FRESHDESK_API_KEY": "<freshdesk-api-key>"
      }
    },
    "parameters": [
      {
        "name": "FRESHDESK_DOMAIN",
        "description": "Your Freshdesk domain (e.g., yourcompany.freshdesk.com)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "FRESHDESK_API_KEY",
        "description": "Your Freshdesk API key from the Freshdesk admin panel",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_ticket_fields",
        "description": "Get ticket fields from Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_tickets",
        "description": "Get tickets from Freshdesk with pagination support.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "create_ticket",
        "description": "Create a ticket in Freshdesk",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Email",
              "default": null
            },
            "source": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                }
              ],
              "title": "Source"
            },
            "status": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                }
              ],
              "title": "Status"
            },
            "subject": {
              "type": "string",
              "title": "Subject"
            },
            "priority": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                }
              ],
              "title": "Priority"
            },
            "description": {
              "type": "string",
              "title": "Description"
            },
            "requester_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Requester Id",
              "default": null
            },
            "custom_fields": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Custom Fields",
              "default": null
            },
            "additional_fields": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Additional Fields",
              "default": null
            }
          },
          "required": [
            "subject",
            "description",
            "source",
            "priority",
            "status"
          ]
        }
      },
      {
        "name": "update_ticket",
        "description": "Update a ticket in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            },
            "ticket_fields": {
              "type": "object",
              "title": "Ticket Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "ticket_id",
            "ticket_fields"
          ]
        }
      },
      {
        "name": "delete_ticket",
        "description": "Delete a ticket in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            }
          },
          "required": [
            "ticket_id"
          ]
        }
      },
      {
        "name": "get_ticket",
        "description": "Get a ticket in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            }
          },
          "required": [
            "ticket_id"
          ]
        }
      },
      {
        "name": "search_tickets",
        "description": "Search for tickets in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_ticket_conversation",
        "description": "Get a ticket conversation in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            }
          },
          "required": [
            "ticket_id"
          ]
        }
      },
      {
        "name": "create_ticket_reply",
        "description": "Create a reply to a ticket in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "title": "Body"
            },
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            }
          },
          "required": [
            "ticket_id",
            "body"
          ]
        }
      },
      {
        "name": "create_ticket_note",
        "description": "Create a note for a ticket in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "title": "Body"
            },
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            }
          },
          "required": [
            "ticket_id",
            "body"
          ]
        }
      },
      {
        "name": "update_ticket_conversation",
        "description": "Update a conversation for a ticket in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "title": "Body"
            },
            "conversation_id": {
              "type": "integer",
              "title": "Conversation Id"
            }
          },
          "required": [
            "conversation_id",
            "body"
          ]
        }
      },
      {
        "name": "get_agents",
        "description": "Get all agents in Freshdesk with pagination support.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "list_contacts",
        "description": "List all contacts in Freshdesk with pagination support.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "get_contact",
        "description": "Get a contact in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contact_id": {
              "type": "integer",
              "title": "Contact Id"
            }
          },
          "required": [
            "contact_id"
          ]
        }
      },
      {
        "name": "search_contacts",
        "description": "Search for contacts in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "update_contact",
        "description": "Update a contact in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contact_id": {
              "type": "integer",
              "title": "Contact Id"
            },
            "contact_fields": {
              "type": "object",
              "title": "Contact Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "contact_id",
            "contact_fields"
          ]
        }
      },
      {
        "name": "list_canned_responses",
        "description": "List all canned responses in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "folder_id": {
              "type": "integer",
              "title": "Folder Id"
            }
          },
          "required": [
            "folder_id"
          ]
        }
      },
      {
        "name": "list_canned_response_folders",
        "description": "List all canned response folders in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "view_canned_response",
        "description": "View a canned response in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "canned_response_id": {
              "type": "integer",
              "title": "Canned Response Id"
            }
          },
          "required": [
            "canned_response_id"
          ]
        }
      },
      {
        "name": "create_canned_response",
        "description": "Create a canned response in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "canned_response_fields": {
              "type": "object",
              "title": "Canned Response Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "canned_response_fields"
          ]
        }
      },
      {
        "name": "update_canned_response",
        "description": "Update a canned response in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "canned_response_id": {
              "type": "integer",
              "title": "Canned Response Id"
            },
            "canned_response_fields": {
              "type": "object",
              "title": "Canned Response Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "canned_response_id",
            "canned_response_fields"
          ]
        }
      },
      {
        "name": "create_canned_response_folder",
        "description": "Create a canned response folder in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "update_canned_response_folder",
        "description": "Update a canned response folder in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "folder_id": {
              "type": "integer",
              "title": "Folder Id"
            }
          },
          "required": [
            "folder_id",
            "name"
          ]
        }
      },
      {
        "name": "list_solution_articles",
        "description": "List all solution articles in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "folder_id": {
              "type": "integer",
              "title": "Folder Id"
            }
          },
          "required": [
            "folder_id"
          ]
        }
      },
      {
        "name": "list_solution_folders",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category_id": {
              "type": "integer",
              "title": "Category Id"
            }
          },
          "required": [
            "category_id"
          ]
        }
      },
      {
        "name": "list_solution_categories",
        "description": "List all solution categories in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "view_solution_category",
        "description": "View a solution category in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category_id": {
              "type": "integer",
              "title": "Category Id"
            }
          },
          "required": [
            "category_id"
          ]
        }
      },
      {
        "name": "create_solution_category",
        "description": "Create a solution category in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category_fields": {
              "type": "object",
              "title": "Category Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "category_fields"
          ]
        }
      },
      {
        "name": "update_solution_category",
        "description": "Update a solution category in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category_id": {
              "type": "integer",
              "title": "Category Id"
            },
            "category_fields": {
              "type": "object",
              "title": "Category Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "category_id",
            "category_fields"
          ]
        }
      },
      {
        "name": "create_solution_category_folder",
        "description": "Create a solution category folder in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "category_id": {
              "type": "integer",
              "title": "Category Id"
            },
            "folder_fields": {
              "type": "object",
              "title": "Folder Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "category_id",
            "folder_fields"
          ]
        }
      },
      {
        "name": "view_solution_category_folder",
        "description": "View a solution category folder in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "folder_id": {
              "type": "integer",
              "title": "Folder Id"
            }
          },
          "required": [
            "folder_id"
          ]
        }
      },
      {
        "name": "update_solution_category_folder",
        "description": "Update a solution category folder in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "folder_id": {
              "type": "integer",
              "title": "Folder Id"
            },
            "folder_fields": {
              "type": "object",
              "title": "Folder Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "folder_id",
            "folder_fields"
          ]
        }
      },
      {
        "name": "create_solution_article",
        "description": "Create a solution article in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "folder_id": {
              "type": "integer",
              "title": "Folder Id"
            },
            "article_fields": {
              "type": "object",
              "title": "Article Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "folder_id",
            "article_fields"
          ]
        }
      },
      {
        "name": "view_solution_article",
        "description": "View a solution article in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "article_id": {
              "type": "integer",
              "title": "Article Id"
            }
          },
          "required": [
            "article_id"
          ]
        }
      },
      {
        "name": "update_solution_article",
        "description": "Update a solution article in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "article_id": {
              "type": "integer",
              "title": "Article Id"
            },
            "article_fields": {
              "type": "object",
              "title": "Article Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "article_id",
            "article_fields"
          ]
        }
      },
      {
        "name": "view_agent",
        "description": "View an agent in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "agent_id": {
              "type": "integer",
              "title": "Agent Id"
            }
          },
          "required": [
            "agent_id"
          ]
        }
      },
      {
        "name": "create_agent",
        "description": "Create an agent in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "agent_fields": {
              "type": "object",
              "title": "Agent Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "agent_fields"
          ]
        }
      },
      {
        "name": "update_agent",
        "description": "Update an agent in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "agent_id": {
              "type": "integer",
              "title": "Agent Id"
            },
            "agent_fields": {
              "type": "object",
              "title": "Agent Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "agent_id",
            "agent_fields"
          ]
        }
      },
      {
        "name": "search_agents",
        "description": "Search for agents in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "list_groups",
        "description": "List all groups in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "create_group",
        "description": "Create a group in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "group_fields": {
              "type": "object",
              "title": "Group Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "group_fields"
          ]
        }
      },
      {
        "name": "view_group",
        "description": "View a group in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "group_id": {
              "type": "integer",
              "title": "Group Id"
            }
          },
          "required": [
            "group_id"
          ]
        }
      },
      {
        "name": "create_ticket_field",
        "description": "Create a ticket field in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_field_fields": {
              "type": "object",
              "title": "Ticket Field Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "ticket_field_fields"
          ]
        }
      },
      {
        "name": "view_ticket_field",
        "description": "View a ticket field in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_field_id": {
              "type": "integer",
              "title": "Ticket Field Id"
            }
          },
          "required": [
            "ticket_field_id"
          ]
        }
      },
      {
        "name": "update_ticket_field",
        "description": "Update a ticket field in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_field_id": {
              "type": "integer",
              "title": "Ticket Field Id"
            },
            "ticket_field_fields": {
              "type": "object",
              "title": "Ticket Field Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "ticket_field_id",
            "ticket_field_fields"
          ]
        }
      },
      {
        "name": "update_group",
        "description": "Update a group in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "group_id": {
              "type": "integer",
              "title": "Group Id"
            },
            "group_fields": {
              "type": "object",
              "title": "Group Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "group_id",
            "group_fields"
          ]
        }
      },
      {
        "name": "list_contact_fields",
        "description": "List all contact fields in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "view_contact_field",
        "description": "View a contact field in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contact_field_id": {
              "type": "integer",
              "title": "Contact Field Id"
            }
          },
          "required": [
            "contact_field_id"
          ]
        }
      },
      {
        "name": "create_contact_field",
        "description": "Create a contact field in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contact_field_fields": {
              "type": "object",
              "title": "Contact Field Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "contact_field_fields"
          ]
        }
      },
      {
        "name": "update_contact_field",
        "description": "Update a contact field in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contact_field_id": {
              "type": "integer",
              "title": "Contact Field Id"
            },
            "contact_field_fields": {
              "type": "object",
              "title": "Contact Field Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "contact_field_id",
            "contact_field_fields"
          ]
        }
      },
      {
        "name": "get_field_properties",
        "description": "Get properties of a specific field by name.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "field_name": {
              "type": "string",
              "title": "Field Name"
            }
          },
          "required": [
            "field_name"
          ]
        }
      },
      {
        "name": "list_companies",
        "description": "List all companies in Freshdesk with pagination support.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "view_company",
        "description": "Get a company in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "company_id": {
              "type": "integer",
              "title": "Company Id"
            }
          },
          "required": [
            "company_id"
          ]
        }
      },
      {
        "name": "search_companies",
        "description": "Search for companies in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "find_company_by_name",
        "description": "Find a company by name in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "list_company_fields",
        "description": "List all company fields in Freshdesk.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "effytech-freshservice_mcp",
    "title": "Freshservice MCP server",
    "description": "Freshservice MCP server",
    "icon": "https://avatars.githubusercontent.com/effytech",
    "isOfficial": false,
    "homepage": "https://github.com/effytech/freshservice_mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "freshservice-mcp"
      ],
      "env": {
        "FRESHSERVICE_APIKEY": "<freshservice-apikey>",
        "FRESHSERVICE_DOMAIN": "<freshservice-domain>"
      }
    },
    "parameters": [
      {
        "name": "FRESHSERVICE_APIKEY",
        "description": "Your Freshservice API key generated from the admin panel (Profile Settings → API Settings)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "FRESHSERVICE_DOMAIN",
        "description": "Your Freshservice domain (e.g., yourcompany.freshservice.com)",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_ticket_fields",
        "description": "Get ticket fields from Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_tickets",
        "description": "Get tickets from Freshservice with pagination support.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "create_ticket",
        "description": "Create a ticket in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Email",
              "default": null
            },
            "source": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                }
              ],
              "title": "Source"
            },
            "status": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                }
              ],
              "title": "Status"
            },
            "subject": {
              "type": "string",
              "title": "Subject"
            },
            "priority": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                }
              ],
              "title": "Priority"
            },
            "description": {
              "type": "string",
              "title": "Description"
            },
            "requester_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Requester Id",
              "default": null
            },
            "custom_fields": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Custom Fields",
              "default": null
            }
          },
          "required": [
            "subject",
            "description",
            "source",
            "priority",
            "status"
          ]
        }
      },
      {
        "name": "update_ticket",
        "description": "Update a ticket in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            },
            "ticket_fields": {
              "type": "object",
              "title": "Ticket Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "ticket_id",
            "ticket_fields"
          ]
        }
      },
      {
        "name": "filter_tickets",
        "description": "Filter the tickets in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "title": "Page",
              "default": 1
            },
            "query": {
              "type": "string",
              "title": "Query"
            },
            "workspace_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Workspace Id",
              "default": null
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "delete_ticket",
        "description": "Delete a ticket in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            }
          },
          "required": [
            "ticket_id"
          ]
        }
      },
      {
        "name": "get_ticket_by_id",
        "description": "Get a ticket in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            }
          },
          "required": [
            "ticket_id"
          ]
        }
      },
      {
        "name": "list_service_items",
        "description": "Get list of service items from Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "get_requested_items",
        "description": "Fetch requested items for a specific ticket if the ticket is a service request.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            }
          },
          "required": [
            "ticket_id"
          ]
        }
      },
      {
        "name": "create_service_request",
        "description": "Create a service request in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "title": "Email"
            },
            "quantity": {
              "type": "integer",
              "title": "Quantity",
              "default": 1
            },
            "display_id": {
              "type": "integer",
              "title": "Display Id"
            },
            "requested_for": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Requested For",
              "default": null
            }
          },
          "required": [
            "display_id",
            "email"
          ]
        }
      },
      {
        "name": "send_ticket_reply",
        "description": "\nSend reply to a ticket in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "title": "Body"
            },
            "user_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "User Id",
              "default": null
            },
            "cc_emails": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cc Emails",
              "default": null
            },
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            },
            "bcc_emails": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Bcc Emails",
              "default": null
            },
            "from_email": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "From Email",
              "default": null
            }
          },
          "required": [
            "ticket_id",
            "body"
          ]
        }
      },
      {
        "name": "create_ticket_note",
        "description": "Create a note for a ticket in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "title": "Body"
            },
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            }
          },
          "required": [
            "ticket_id",
            "body"
          ]
        }
      },
      {
        "name": "update_ticket_conversation",
        "description": "Update a conversation for a ticket in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "title": "Body"
            },
            "conversation_id": {
              "type": "integer",
              "title": "Conversation Id"
            }
          },
          "required": [
            "conversation_id",
            "body"
          ]
        }
      },
      {
        "name": "list_all_ticket_conversation",
        "description": "List all conversation of a ticket in freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ticket_id": {
              "type": "integer",
              "title": "Ticket Id"
            }
          },
          "required": [
            "ticket_id"
          ]
        }
      },
      {
        "name": "get_all_products",
        "description": "List all the products from Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "get_products_by_id",
        "description": "Get product by product ID in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "product_id": {
              "type": "integer",
              "title": "Product Id"
            }
          },
          "required": [
            "product_id"
          ]
        }
      },
      {
        "name": "create_product",
        "description": "Create a product in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "status": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Status",
              "default": null
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Description",
              "default": null
            },
            "manufacturer": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Manufacturer",
              "default": null
            },
            "asset_type_id": {
              "type": "integer",
              "title": "Asset Type Id"
            },
            "description_text": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Description Text",
              "default": null
            },
            "mode_of_procurement": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Mode Of Procurement",
              "default": null
            },
            "depreciation_type_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Depreciation Type Id",
              "default": null
            }
          },
          "required": [
            "name",
            "asset_type_id"
          ]
        }
      },
      {
        "name": "update_product",
        "description": "Update a product in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            },
            "name": {
              "type": "string",
              "title": "Name"
            },
            "status": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Status",
              "default": null
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Description",
              "default": null
            },
            "manufacturer": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Manufacturer",
              "default": null
            },
            "asset_type_id": {
              "type": "integer",
              "title": "Asset Type Id"
            },
            "description_text": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Description Text",
              "default": null
            },
            "mode_of_procurement": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Mode Of Procurement",
              "default": null
            },
            "depreciation_type_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Depreciation Type Id",
              "default": null
            }
          },
          "required": [
            "id",
            "name",
            "asset_type_id"
          ]
        }
      },
      {
        "name": "create_requester",
        "description": "Creates a requester in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Address",
              "default": null
            },
            "language": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Language",
              "default": null
            },
            "job_title": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Job Title",
              "default": null
            },
            "last_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Last Name",
              "default": null
            },
            "time_zone": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Time Zone",
              "default": null
            },
            "first_name": {
              "type": "string",
              "title": "First Name"
            },
            "location_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Location Id",
              "default": null
            },
            "time_format": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Time Format",
              "default": null
            },
            "custom_fields": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Custom Fields",
              "default": null
            },
            "primary_email": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Primary Email",
              "default": null
            },
            "department_ids": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "integer"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Department Ids",
              "default": null
            },
            "secondary_emails": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Secondary Emails",
              "default": null
            },
            "work_phone_number": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Work Phone Number",
              "default": null
            },
            "mobile_phone_number": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Mobile Phone Number",
              "default": null
            },
            "reporting_manager_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Reporting Manager Id",
              "default": null
            },
            "background_information": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Background Information",
              "default": null
            },
            "can_see_all_tickets_from_associated_departments": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Can See All Tickets From Associated Departments",
              "default": null
            }
          },
          "required": [
            "first_name"
          ]
        }
      },
      {
        "name": "get_all_requesters",
        "description": "Fetch all requesters from Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "type": "integer",
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "get_requester_id",
        "description": "Get requester by ID in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "requester_id": {
              "type": "integer",
              "title": "Requester Id"
            }
          },
          "required": [
            "requester_id"
          ]
        }
      },
      {
        "name": "list_all_requester_fields",
        "description": "List all requester fields in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "update_requester",
        "description": "Update a requester in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Address",
              "default": null
            },
            "language": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Language",
              "default": null
            },
            "job_title": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Job Title",
              "default": null
            },
            "last_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Last Name",
              "default": null
            },
            "time_zone": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Time Zone",
              "default": null
            },
            "first_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "First Name",
              "default": null
            },
            "location_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Location Id",
              "default": null
            },
            "time_format": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Time Format",
              "default": null
            },
            "requester_id": {
              "type": "integer",
              "title": "Requester Id"
            },
            "custom_fields": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Custom Fields",
              "default": null
            },
            "primary_email": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Primary Email",
              "default": null
            },
            "department_ids": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "integer"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Department Ids",
              "default": null
            },
            "secondary_emails": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Secondary Emails",
              "default": null
            },
            "work_phone_number": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Work Phone Number",
              "default": null
            },
            "mobile_phone_number": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Mobile Phone Number",
              "default": null
            },
            "reporting_manager_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Reporting Manager Id",
              "default": null
            },
            "background_information": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Background Information",
              "default": null
            },
            "can_see_all_tickets_from_associated_departments": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Can See All Tickets From Associated Departments",
              "default": false
            }
          },
          "required": [
            "requester_id"
          ]
        }
      },
      {
        "name": "filter_requesters",
        "description": "Filter requesters in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            },
            "include_agents": {
              "type": "boolean",
              "title": "Include Agents",
              "default": false
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "create_agent",
        "description": "Create a new agent in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "title": "Email",
              "default": null
            },
            "job_title": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Job Title",
              "default": null
            },
            "last_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Last Name",
              "default": null
            },
            "first_name": {
              "type": "string",
              "title": "First Name"
            },
            "occasional": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Occasional",
              "default": false
            },
            "work_phone_number": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Work Phone Number",
              "default": null
            },
            "mobile_phone_number": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Mobile Phone Number",
              "default": null
            }
          },
          "required": [
            "first_name"
          ]
        }
      },
      {
        "name": "get_agent",
        "description": "Get agent by id in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "agent_id": {
              "type": "integer",
              "title": "Agent Id"
            }
          },
          "required": [
            "agent_id"
          ]
        }
      },
      {
        "name": "get_all_agents",
        "description": "Fetch agents from Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "type": "integer",
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "filter_agents",
        "description": "Filter Freshservice agents based on a query.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "update_agent",
        "description": "Update the agent details in the Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "title": "email",
              "default": null
            },
            "address": {
              "type": "string",
              "title": "address",
              "default": null
            },
            "agent_id": {
              "type": "string",
              "title": "agent_id"
            },
            "language": {
              "type": "string",
              "title": "language",
              "default": null
            },
            "time_zone": {
              "type": "string",
              "title": "time_zone",
              "default": null
            },
            "occasional": {
              "type": "string",
              "title": "occasional",
              "default": null
            },
            "location_id": {
              "type": "string",
              "title": "location_id",
              "default": null
            },
            "time_format": {
              "type": "string",
              "title": "time_format",
              "default": null
            },
            "department_ids": {
              "type": "string",
              "title": "department_ids",
              "default": null
            },
            "scoreboard_level_id": {
              "type": "string",
              "title": "scoreboard_level_id",
              "default": null
            },
            "reporting_manager_id": {
              "type": "string",
              "title": "reporting_manager_id",
              "default": null
            },
            "background_information": {
              "type": "string",
              "title": "background_information",
              "default": null
            },
            "can_see_all_tickets_from_associated_departments": {
              "type": "string",
              "title": "can_see_all_tickets_from_associated_departments",
              "default": null
            }
          },
          "required": [
            "agent_id"
          ]
        }
      },
      {
        "name": "get_agent_fields",
        "description": "Get all agent fields in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_all_agent_groups",
        "description": "Get all agent groups in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getAgentGroupById",
        "description": "Get agent groups by its group id in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "group_id": {
              "type": "integer",
              "title": "Group Id"
            }
          },
          "required": [
            "group_id"
          ]
        }
      },
      {
        "name": "add_requester_to_group",
        "description": "Add a requester to a manual requester group in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "group_id": {
              "type": "integer",
              "title": "Group Id"
            },
            "requester_id": {
              "type": "integer",
              "title": "Requester Id"
            }
          },
          "required": [
            "group_id",
            "requester_id"
          ]
        }
      },
      {
        "name": "create_group",
        "description": "Create a group in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "group_data": {
              "type": "object",
              "title": "Group Data",
              "additionalProperties": true
            }
          },
          "required": [
            "group_data"
          ]
        }
      },
      {
        "name": "update_group",
        "description": "Update a group in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "group_id": {
              "type": "integer",
              "title": "Group Id"
            },
            "group_fields": {
              "type": "object",
              "title": "Group Fields",
              "additionalProperties": true
            }
          },
          "required": [
            "group_id",
            "group_fields"
          ]
        }
      },
      {
        "name": "get_all_requester_groups",
        "description": "Get all requester groups in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page",
              "default": 1
            },
            "per_page": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Per Page",
              "default": 30
            }
          }
        }
      },
      {
        "name": "get_requester_groups_by_id",
        "description": "Get requester groups in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "requester_group_id": {
              "type": "integer",
              "title": "Requester Group Id"
            }
          },
          "required": [
            "requester_group_id"
          ]
        }
      },
      {
        "name": "create_requester_group",
        "description": "Create a requester group in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Description",
              "default": null
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "update_requester_group",
        "description": "Update an requester group in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            },
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Name",
              "default": null
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Description",
              "default": null
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_requester_group_members",
        "description": "List all members of a requester group in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "group_id": {
              "type": "integer",
              "title": "Group Id"
            }
          },
          "required": [
            "group_id"
          ]
        }
      },
      {
        "name": "get_all_canned_response",
        "description": "List all canned response in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_canned_response",
        "description": "Get a canned response in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_all_canned_response_folder",
        "description": "List all canned response of a folder in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_canned_response_folder",
        "description": "List canned response folder in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_all_workspaces",
        "description": "List all workspaces in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_workspace",
        "description": "Get a workspace by its ID in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_all_solution_category",
        "description": "Get all solution category in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_solution_category",
        "description": "Get solution category by its ID in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "create_solution_category",
        "description": "Create a new solution category in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "description": {
              "type": "string",
              "title": "Description",
              "default": null
            },
            "workspace_id": {
              "type": "integer",
              "title": "Workspace Id",
              "default": null
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "update_solution_category",
        "description": "Update a solution category in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "category_id": {
              "type": "integer",
              "title": "Category Id"
            },
            "description": {
              "type": "string",
              "title": "Description",
              "default": null
            },
            "workspace_id": {
              "type": "integer",
              "title": "Workspace Id",
              "default": null
            },
            "default_category": {
              "type": "boolean",
              "title": "Default Category",
              "default": null
            }
          },
          "required": [
            "category_id",
            "name"
          ]
        }
      },
      {
        "name": "get_list_of_solution_folder",
        "description": "Get list of solution folder by its ID in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_solution_folder",
        "description": "Get solution folder by its ID in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_list_of_solution_article",
        "description": "Get list of solution article in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_solution_article",
        "description": "Get solution article by id in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "create_solution_article",
        "description": "Create a new solution article in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags",
              "default": null
            },
            "title": {
              "type": "string",
              "title": "Title"
            },
            "status": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Status",
              "default": 1
            },
            "keywords": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Keywords",
              "default": null
            },
            "folder_id": {
              "type": "integer",
              "title": "Folder Id"
            },
            "description": {
              "type": "string",
              "title": "Description"
            },
            "review_date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Review Date",
              "default": null
            },
            "article_type": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Article Type",
              "default": 1
            }
          },
          "required": [
            "title",
            "description",
            "folder_id"
          ]
        }
      },
      {
        "name": "update_solution_article",
        "description": "Update a solution article in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags",
              "default": null
            },
            "title": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Title",
              "default": null
            },
            "status": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Status",
              "default": null
            },
            "keywords": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Keywords",
              "default": null
            },
            "folder_id": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Folder Id",
              "default": null
            },
            "article_id": {
              "type": "integer",
              "title": "Article Id"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Description",
              "default": null
            },
            "review_date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Review Date",
              "default": null
            },
            "article_type": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Article Type",
              "default": null
            }
          },
          "required": [
            "article_id"
          ]
        }
      },
      {
        "name": "create_solution_folder",
        "description": "Create a new folder under a solution category in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "visibility": {
              "type": "integer",
              "title": "Visibility",
              "default": 4
            },
            "category_id": {
              "type": "integer",
              "title": "Category Id"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Description",
              "default": null
            },
            "department_ids": {
              "type": "array",
              "items": {
                "type": "integer"
              },
              "title": "Department Ids"
            }
          },
          "required": [
            "name",
            "category_id",
            "department_ids"
          ]
        }
      },
      {
        "name": "update_solution_folder",
        "description": "Update an existing solution folder's details in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "integer",
              "title": "Id"
            },
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Name",
              "default": null
            },
            "visibility": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Visibility",
              "default": null
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Description",
              "default": null
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "publish_solution_article",
        "description": "Publish a solution article in Freshservice.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "article_id": {
              "type": "integer",
              "title": "Article Id"
            }
          },
          "required": [
            "article_id"
          ]
        }
      }
    ]
  },
  {
    "name": "elevenlabs-elevenlabs-mcp",
    "title": "ElevenLabs MCP Server",
    "description": "An official Model Context Protocol (MCP) server that enables AI clients to interact with ElevenLabs' Text to Speech and audio processing APIs, allowing for speech generation, voice cloning, audio transcription, and other audio-related tasks.",
    "icon": "https://cdn.simpleicons.org/elevenlabs",
    "isOfficial": true,
    "homepage": "https://github.com/elevenlabs/elevenlabs-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "elevenlabs-mcp"
      ],
      "env": {
        "ELEVENLABS_API_KEY": "<elevenlabs-api-key>",
        "ELEVENLABS_MCP_BASE_PATH": "<elevenlabs-mcp-base-path>"
      }
    },
    "parameters": [
      {
        "name": "ELEVENLABS_API_KEY",
        "description": "Your ElevenLabs API key from elevenlabs.io/app/settings/api-keys",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "ELEVENLABS_MCP_BASE_PATH",
        "description": "The base path MCP server should look for and output files specified with relative paths",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "text_to_speech",
        "description": "Convert text to speech with a given voice and save the output audio file to a given directory.\n    Directory is optional, if not provided, the output file will be saved to $HOME/Desktop.\n    Only one of voice_id or voice_name can be provided. If none are provided, the default voice will be used.\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n\n     Args:\n        text (str): The text to convert to speech.\n        voice_name (str, optional): The name of the voice to use.\n        stability (float, optional): Stability of the generated audio. Determines how stable the voice is and the randomness between each generation. Lower values introduce broader emotional range for the voice. Higher values can result in a monotonous voice with limited emotion. Range is 0 to 1.\n        similarity_boost (float, optional): Similarity boost of the generated audio. Determines how closely the AI should adhere to the original voice when attempting to replicate it. Range is 0 to 1.\n        style (float, optional): Style of the generated audio. Determines the style exaggeration of the voice. This setting attempts to amplify the style of the original speaker. It does consume additional computational resources and might increase latency if set to anything other than 0. Range is 0 to 1.\n        use_speaker_boost (bool, optional): Use speaker boost of the generated audio. This setting boosts the similarity to the original speaker. Using this setting requires a slightly higher computational load, which in turn increases latency.\n        speed (float, optional): Speed of the generated audio. Controls the speed of the generated speech. Values range from 0.7 to 1.2, with 1.0 being the default speed. Lower values create slower, more deliberate speech while higher values produce faster-paced speech. Extreme values can impact the quality of the generated speech. Range is 0.7 to 1.2.\n        output_directory (str, optional): Directory where files should be saved.\n            Defaults to $HOME/Desktop if not provided.\n\n    Returns:\n        Text content with the path to the output file and name of the voice used.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "title": "Text"
            },
            "speed": {
              "type": "number",
              "title": "Speed",
              "default": 1
            },
            "style": {
              "type": "number",
              "title": "Style",
              "default": 0
            },
            "voice_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Voice Id",
              "default": null
            },
            "stability": {
              "type": "number",
              "title": "Stability",
              "default": 0.5
            },
            "voice_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Voice Name",
              "default": null
            },
            "output_directory": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Output Directory",
              "default": null
            },
            "similarity_boost": {
              "type": "number",
              "title": "Similarity Boost",
              "default": 0.75
            },
            "use_speaker_boost": {
              "type": "boolean",
              "title": "Use Speaker Boost",
              "default": true
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "speech_to_text",
        "description": "Transcribe speech from an audio file and either save the output text file to a given directory or return the text to the client directly.\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n\n    Args:\n        file_path: Path to the audio file to transcribe\n        language_code: ISO 639-3 language code for transcription (default: \"eng\" for English)\n        diarize: Whether to diarize the audio file. If True, which speaker is currently speaking will be annotated in the transcription.\n        save_transcript_to_file: Whether to save the transcript to a file.\n        return_transcript_to_client_directly: Whether to return the transcript to the client directly.\n        output_directory: Directory where files should be saved.\n            Defaults to $HOME/Desktop if not provided.\n\n    Returns:\n        TextContent containing the transcription. If save_transcript_to_file is True, the transcription will be saved to a file in the output directory.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "diarize": {
              "type": "boolean",
              "title": "Diarize",
              "default": false
            },
            "language_code": {
              "type": "string",
              "title": "Language Code",
              "default": "eng"
            },
            "input_file_path": {
              "type": "string",
              "title": "Input File Path"
            },
            "output_directory": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Output Directory",
              "default": null
            },
            "save_transcript_to_file": {
              "type": "boolean",
              "title": "Save Transcript To File",
              "default": true
            },
            "return_transcript_to_client_directly": {
              "type": "boolean",
              "title": "Return Transcript To Client Directly",
              "default": false
            }
          },
          "required": [
            "input_file_path"
          ]
        }
      },
      {
        "name": "text_to_sound_effects",
        "description": "Convert text description of a sound effect to sound effect with a given duration and save the output audio file to a given directory.\n    Directory is optional, if not provided, the output file will be saved to $HOME/Desktop.\n    Duration must be between 0.5 and 5 seconds.\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n\n    Args:\n        text: Text description of the sound effect\n        duration_seconds: Duration of the sound effect in seconds\n        output_directory: Directory where files should be saved.\n            Defaults to $HOME/Desktop if not provided.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "title": "Text"
            },
            "duration_seconds": {
              "type": "number",
              "title": "Duration Seconds",
              "default": 2
            },
            "output_directory": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Output Directory",
              "default": null
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "search_voices",
        "description": "\n    Search for existing voices, a voice that has already been added to the user's ElevenLabs voice library. \n    Searches in name, description, labels and category.\n\n    Args:\n        search: Search term to filter voices by. Searches in name, description, labels and category.\n        sort: Which field to sort by. `created_at_unix` might not be available for older voices.\n        sort_direction: Sort order, either ascending or descending.\n\n    Returns:\n        List of voices that match the search criteria.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "enum": [
                "created_at_unix",
                "name"
              ],
              "type": "string",
              "title": "Sort",
              "default": "name"
            },
            "search": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Search",
              "default": null
            },
            "sort_direction": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "title": "Sort Direction",
              "default": "desc"
            }
          }
        }
      },
      {
        "name": "get_voice",
        "description": "Get details of a specific voice",
        "inputSchema": {
          "type": "object",
          "properties": {
            "voice_id": {
              "type": "string",
              "title": "Voice Id"
            }
          },
          "required": [
            "voice_id"
          ]
        }
      },
      {
        "name": "voice_clone",
        "description": "Clone a voice using provided audio files.\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "files": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "Files"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Description",
              "default": null
            }
          },
          "required": [
            "name",
            "files"
          ]
        }
      },
      {
        "name": "isolate_audio",
        "description": "Isolate audio from a file and save the output audio file to a given directory.\n    Directory is optional, if not provided, the output file will be saved to $HOME/Desktop.\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "input_file_path": {
              "type": "string",
              "title": "Input File Path"
            },
            "output_directory": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Output Directory",
              "default": null
            }
          },
          "required": [
            "input_file_path"
          ]
        }
      },
      {
        "name": "check_subscription",
        "description": "Check the current subscription status. Could be used to measure the usage of the API.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_agent",
        "description": "Create a conversational AI agent with custom configuration.\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n\n    Args:\n        name: Name of the agent\n        first_message: First message the agent will say i.e. \"Hi, how can I help you today?\"\n        system_prompt: System prompt for the agent\n        voice_id: ID of the voice to use for the agent\n        language: ISO 639-1 language code for the agent\n        llm: LLM to use for the agent\n        temperature: Temperature for the agent. The lower the temperature, the more deterministic the agent's responses will be. Range is 0 to 1.\n        max_tokens: Maximum number of tokens to generate.\n        asr_quality: Quality of the ASR. `high` or `low`.\n        model_id: ID of the ElevenLabsmodel to use for the agent.\n        optimize_streaming_latency: Optimize streaming latency. Range is 0 to 4.\n        stability: Stability for the agent. Range is 0 to 1.\n        similarity_boost: Similarity boost for the agent. Range is 0 to 1.\n        turn_timeout: Timeout for the agent to respond in seconds. Defaults to 7 seconds.\n        max_duration_seconds: Maximum duration of a conversation in seconds. Defaults to 600 seconds (10 minutes).\n        record_voice: Whether to record the agent's voice.\n        retention_days: Number of days to retain the agent's data.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "llm": {
              "type": "string",
              "title": "Llm",
              "default": "gemini-2.0-flash-001"
            },
            "name": {
              "type": "string",
              "title": "Name"
            },
            "language": {
              "type": "string",
              "title": "Language",
              "default": "en"
            },
            "model_id": {
              "type": "string",
              "title": "Model Id",
              "default": "eleven_turbo_v2"
            },
            "voice_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Voice Id",
              "default": "cgSgspJ2msm6clMCkdW9"
            },
            "stability": {
              "type": "number",
              "title": "Stability",
              "default": 0.5
            },
            "max_tokens": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Max Tokens",
              "default": null
            },
            "asr_quality": {
              "type": "string",
              "title": "Asr Quality",
              "default": "high"
            },
            "temperature": {
              "type": "number",
              "title": "Temperature",
              "default": 0.5
            },
            "record_voice": {
              "type": "boolean",
              "title": "Record Voice",
              "default": true
            },
            "turn_timeout": {
              "type": "integer",
              "title": "Turn Timeout",
              "default": 7
            },
            "first_message": {
              "type": "string",
              "title": "First Message"
            },
            "system_prompt": {
              "type": "string",
              "title": "System Prompt"
            },
            "retention_days": {
              "type": "integer",
              "title": "Retention Days",
              "default": 730
            },
            "similarity_boost": {
              "type": "number",
              "title": "Similarity Boost",
              "default": 0.8
            },
            "max_duration_seconds": {
              "type": "integer",
              "title": "Max Duration Seconds",
              "default": 300
            },
            "optimize_streaming_latency": {
              "type": "integer",
              "title": "Optimize Streaming Latency",
              "default": 3
            }
          },
          "required": [
            "name",
            "first_message",
            "system_prompt"
          ]
        }
      },
      {
        "name": "add_knowledge_base_to_agent",
        "description": "Add a knowledge base to ElevenLabs workspace. Allowed types are epub, pdf, docx, txt, html.\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n\n    Args:\n        agent_id: ID of the agent to add the knowledge base to.\n        knowledge_base_name: Name of the knowledge base.\n        url: URL of the knowledge base.\n        input_file_path: Path to the file to add to the knowledge base.\n        text: Text to add to the knowledge base.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Url",
              "default": null
            },
            "text": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Text",
              "default": null
            },
            "agent_id": {
              "type": "string",
              "title": "Agent Id"
            },
            "input_file_path": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Input File Path",
              "default": null
            },
            "knowledge_base_name": {
              "type": "string",
              "title": "Knowledge Base Name"
            }
          },
          "required": [
            "agent_id",
            "knowledge_base_name"
          ]
        }
      },
      {
        "name": "list_agents",
        "description": "List all available conversational AI agents",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_agent",
        "description": "Get details about a specific conversational AI agent",
        "inputSchema": {
          "type": "object",
          "properties": {
            "agent_id": {
              "type": "string",
              "title": "Agent Id"
            }
          },
          "required": [
            "agent_id"
          ]
        }
      },
      {
        "name": "speech_to_speech",
        "description": "Transform audio from one voice to another using provided audio files.\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "voice_name": {
              "type": "string",
              "title": "Voice Name",
              "default": "Adam"
            },
            "input_file_path": {
              "type": "string",
              "title": "Input File Path"
            },
            "output_directory": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Output Directory",
              "default": null
            }
          },
          "required": [
            "input_file_path"
          ]
        }
      },
      {
        "name": "text_to_voice",
        "description": "Create voice previews from a text prompt. Creates three previews with slight variations. Saves the previews to a given directory. If no text is provided, the tool will auto-generate text.\n\n    Voice preview files are saved as: voice_design_(generated_voice_id)_(timestamp).mp3\n\n    Example file name: voice_design_Ya2J5uIa5Pq14DNPsbC1_20250403_164949.mp3\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Text",
              "default": null
            },
            "output_directory": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Output Directory",
              "default": null
            },
            "voice_description": {
              "type": "string",
              "title": "Voice Description"
            }
          },
          "required": [
            "voice_description"
          ]
        }
      },
      {
        "name": "create_voice_from_preview",
        "description": "Add a generated voice to the voice library. Uses the voice ID from the `text_to_voice` tool.\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "voice_name": {
              "type": "string",
              "title": "Voice Name"
            },
            "voice_description": {
              "type": "string",
              "title": "Voice Description"
            },
            "generated_voice_id": {
              "type": "string",
              "title": "Generated Voice Id"
            }
          },
          "required": [
            "generated_voice_id",
            "voice_name",
            "voice_description"
          ]
        }
      },
      {
        "name": "make_outbound_call",
        "description": "Make an outbound call via Twilio using an ElevenLabs agent.\n\n    ⚠️ COST WARNING: This tool makes an API call to ElevenLabs which may incur costs. Only use when explicitly requested by the user.\n\n    Args:\n        agent_id: The ID of the agent that will handle the call\n        agent_phone_number_id: The ID of the phone number to use for the call\n        to_number: The phone number to call (E.164 format: +1xxxxxxxxxx)\n\n    Returns:\n        TextContent containing information about the call\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "agent_id": {
              "type": "string",
              "title": "Agent Id"
            },
            "to_number": {
              "type": "string",
              "title": "To Number"
            },
            "agent_phone_number_id": {
              "type": "string",
              "title": "Agent Phone Number Id"
            }
          },
          "required": [
            "agent_id",
            "agent_phone_number_id",
            "to_number"
          ]
        }
      },
      {
        "name": "search_voice_library",
        "description": "Search for a voice across the entire ElevenLabs voice library.\n\n    Args:\n        page: Page number to return (0-indexed)\n        page_size: Number of voices to return per page (1-100)\n        search: Search term to filter voices by\n        \n    Returns:\n        TextContent containing information about the shared voices\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "title": "Page",
              "default": 0
            },
            "search": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Search",
              "default": null
            },
            "page_size": {
              "type": "integer",
              "title": "Page Size",
              "default": 10
            }
          }
        }
      },
      {
        "name": "list_phone_numbers",
        "description": "List all phone numbers associated with the ElevenLabs account",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "play_audio",
        "description": "Play an audio file. Supports WAV and MP3 formats.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "input_file_path": {
              "type": "string",
              "title": "Input File Path"
            }
          },
          "required": [
            "input_file_path"
          ]
        }
      }
    ]
  },
  {
    "name": "emzimmer-server-wp-mcp",
    "title": "WordPress MCP Server",
    "description": "Enables AI assistants to interact with WordPress sites through the WordPress REST API. Supports multiple WordPress sites with secure authentication, enabling content management, post operations, and site configuration through natural language.",
    "icon": "https://avatars.githubusercontent.com/emzimmer",
    "isOfficial": false,
    "homepage": "https://github.com/emzimmer/server-wp-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "server-wp-mcp"
      ],
      "env": {
        "WP_SITES_PATH": "<wp-sites-path>"
      }
    },
    "parameters": [
      {
        "name": "WP_SITES_PATH",
        "description": "The absolute path to the JSON configuration file containing your WordPress site details.",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "unctad-ai-eregulations-mcp-server",
    "title": "eRegulations MCP Server",
    "description": "A Model Context Protocol server implementation that provides structured, AI-friendly access to eRegulations data, making it easier for AI models to answer user questions about administrative procedures.",
    "icon": "https://avatars.githubusercontent.com/unctad-ai",
    "isOfficial": false,
    "homepage": "https://github.com/unctad-ai/eregulations-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@unctad-ai/eregulations-mcp-server"
      ],
      "env": {
        "EREGULATIONS_API_URL": "<eregulations-api-url>"
      }
    },
    "parameters": [
      {
        "name": "EREGULATIONS_API_URL",
        "description": "URL of the eRegulations API to connect to (e.g., https://api-tanzania.tradeportal.org)",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "listProcedures",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "max_items": {
              "type": "integer",
              "description": "Optional maximum number of procedures to include in the formatted text output.",
              "exclusiveMinimum": 0
            },
            "max_length": {
              "type": "integer",
              "description": "Optional maximum length for procedure descriptions in the formatted text output.",
              "exclusiveMinimum": 0
            }
          }
        }
      },
      {
        "name": "getProcedureDetails",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "max_length": {
              "type": "integer",
              "description": "Optional maximum length for the main procedure description in the formatted text output.",
              "exclusiveMinimum": 0
            },
            "procedureId": {
              "type": "number",
              "description": "ID of the procedure to retrieve"
            }
          },
          "required": [
            "procedureId"
          ]
        }
      },
      {
        "name": "getProcedureStep",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "stepId": {
              "type": "number",
              "description": "ID of the step within the procedure"
            },
            "procedureId": {
              "type": "number",
              "description": "ID of the procedure"
            }
          },
          "required": [
            "procedureId",
            "stepId"
          ]
        }
      },
      {
        "name": "searchProcedures",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keyword": {
              "type": "string",
              "description": "The keyword or phrase to search for procedures"
            },
            "max_items": {
              "type": "integer",
              "description": "Optional maximum number of procedures to include in the formatted text output.",
              "exclusiveMinimum": 0
            },
            "max_length": {
              "type": "integer",
              "description": "Optional maximum length for procedure descriptions in the formatted text output.",
              "exclusiveMinimum": 0
            }
          },
          "required": [
            "keyword"
          ]
        }
      }
    ]
  },
  {
    "name": "ergut-mcp-bigquery-server",
    "title": "BigQuery MCP Server",
    "description": "This is a server that lets your LLMs (like Claude) talk directly to your BigQuery data! Think of it as a friendly translator that sits between your AI assistant and your database, making sure they can chat securely and efficiently.",
    "icon": "https://avatars.githubusercontent.com/ergut",
    "isOfficial": false,
    "homepage": "https://github.com/ergut/mcp-bigquery-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@ergut/mcp-bigquery-server"
      ],
      "env": {
        "key-file": "<key-file>",
        "location": "<location>",
        "project-id": "<project-id>"
      }
    },
    "parameters": [
      {
        "name": "key-file",
        "description": "Path to service account key JSON file",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "location",
        "description": "BigQuery location",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "project-id",
        "description": "Your Google Cloud project ID",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "erniebrodeur-mcp-grep",
    "title": "MCP-Grep",
    "description": "A server implementation that exposes grep functionality through the Model Context Protocol, allowing MCP-compatible clients to search for patterns in files using regular expressions.",
    "icon": "https://avatars.githubusercontent.com/erniebrodeur",
    "isOfficial": false,
    "homepage": "https://github.com/erniebrodeur/mcp-grep",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-grep"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "grep",
        "description": "Search for pattern in files using system grep.\n    \n    Args:\n        pattern: Pattern to search for\n        paths: File or directory paths to search in (string or list of strings)\n        ignore_case: Case-insensitive matching (-i)\n        before_context: Number of lines before match (-B)\n        after_context: Number of lines after match (-A)\n        context: Number of context lines around match (equal before/after)\n        max_count: Stop after N matches (-m)\n        fixed_strings: Treat pattern as literal text, not regex (-F)\n        recursive: Search directories recursively (-r)\n        regexp: Use regular expressions for pattern matching\n        invert_match: Select non-matching lines (-v)\n        line_number: Show line numbers (-n)\n        file_pattern: Pattern to filter files (e.g., \"*.txt\")\n        \n    Returns:\n        JSON string with search results\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "title": "Paths"
            },
            "regexp": {
              "type": "boolean",
              "title": "Regexp",
              "default": true
            },
            "context": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Context",
              "default": null
            },
            "pattern": {
              "type": "string",
              "title": "Pattern"
            },
            "max_count": {
              "type": "integer",
              "title": "Max Count",
              "default": 0
            },
            "recursive": {
              "type": "boolean",
              "title": "Recursive",
              "default": false
            },
            "ignore_case": {
              "type": "boolean",
              "title": "Ignore Case",
              "default": false
            },
            "line_number": {
              "type": "boolean",
              "title": "Line Number",
              "default": true
            },
            "file_pattern": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "File Pattern",
              "default": null
            },
            "invert_match": {
              "type": "boolean",
              "title": "Invert Match",
              "default": false
            },
            "after_context": {
              "type": "integer",
              "title": "After Context",
              "default": 0
            },
            "fixed_strings": {
              "type": "boolean",
              "title": "Fixed Strings",
              "default": false
            },
            "before_context": {
              "type": "integer",
              "title": "Before Context",
              "default": 0
            }
          },
          "required": [
            "pattern",
            "paths"
          ]
        }
      }
    ]
  },
  {
    "name": "qianniuspace-mcp-security-audit",
    "title": "MCP Security Audit Server",
    "description": "Audits npm package dependencies for security vulnerabilities, providing detailed reports and fix recommendations with MCP integration.",
    "icon": "https://avatars.githubusercontent.com/qianniuspace",
    "isOfficial": false,
    "homepage": "https://github.com/qianniuspace/mcp-security-audit",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-security-audit"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "audit_nodejs_dependencies",
        "description": "Audit specific dependencies for vulnerabilities",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dependencies": {
              "type": "object",
              "description": "Dependencies object from package.json",
              "additionalProperties": {
                "type": "string"
              }
            }
          },
          "required": [
            "dependencies"
          ]
        }
      }
    ]
  },
  {
    "name": "evalstate-mcp-hfspace",
    "title": "mcp-hfspace",
    "description": "Use HuggingFace Spaces directly from Claude. Use Open Source Image Generation, Chat, Vision tasks and more. Supports Image, Audio and text uploads/downloads.",
    "icon": "https://avatars.githubusercontent.com/evalstate",
    "isOfficial": false,
    "homepage": "https://github.com/evalstate/mcp-hfspace",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@llmindset/mcp-hfspace"
      ],
      "env": {
        "HF_TOKEN": "<hf-token>",
        "MCP_HF_WORK_DIR": "<mcp-hf-work-dir>",
        "CLAUDE_DESKTOP_MODE": "<claude-desktop-mode>"
      }
    },
    "parameters": [
      {
        "name": "HF_TOKEN",
        "description": "Your Hugging Face Token for accessing private spaces.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_HF_WORK_DIR",
        "description": "Specifies the working directory for handling the upload and download of images and other file-based content.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CLAUDE_DESKTOP_MODE",
        "description": "Disables Claude Desktop Mode, in which content is returned as an embedded Base64 encoded Resource.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "executeautomation-mcp-playwright",
    "title": "mcp-playwright",
    "description": "A Model Context Protocol server that provides browser automation capabilities using Playwright. This server enables LLMs to interact with web pages, take screenshots, and execute JavaScript in a real browser environment.",
    "icon": "https://avatars.githubusercontent.com/executeautomation",
    "isOfficial": false,
    "homepage": "https://github.com/executeautomation/mcp-playwright",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@executeautomation/playwright-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "eyaltoledano-claude-task-master",
    "title": "Task Master",
    "description": "A task management system for AI-driven development with Claude, designed to work seamlessly with Cursor AI and other code editors via MCP.",
    "icon": "https://avatars.githubusercontent.com/eyaltoledano",
    "isOfficial": false,
    "homepage": "https://github.com/eyaltoledano/claude-task-master",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "task-master-ai"
      ],
      "env": {
        "XAI_API_KEY": "<xai-api-key>",
        "GOOGLE_API_KEY": "<google-api-key>",
        "OLLAMA_API_KEY": "<ollama-api-key>",
        "OPENAI_API_KEY": "<openai-api-key>",
        "MISTRAL_API_KEY": "<mistral-api-key>",
        "ANTHROPIC_API_KEY": "<anthropic-api-key>",
        "OPENROUTER_API_KEY": "<openrouter-api-key>",
        "PERPLEXITY_API_KEY": "<perplexity-api-key>",
        "AZURE_OPENAI_API_KEY": "<azure-openai-api-key>"
      }
    },
    "parameters": [
      {
        "name": "XAI_API_KEY",
        "description": "API key for xAI (for research or main model)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GOOGLE_API_KEY",
        "description": "API key for Google Gemini models",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OLLAMA_API_KEY",
        "description": "API key for Ollama models",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OPENAI_API_KEY",
        "description": "API key for OpenAI models",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MISTRAL_API_KEY",
        "description": "API key for Mistral models",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ANTHROPIC_API_KEY",
        "description": "API key for Anthropic Claude models",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OPENROUTER_API_KEY",
        "description": "API key for OpenRouter (for research or main model)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "PERPLEXITY_API_KEY",
        "description": "API key for Perplexity (for research model)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "AZURE_OPENAI_API_KEY",
        "description": "API key for Azure OpenAI models",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "listTasks",
        "description": "List all tasks from Task Master",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "Path to the tasks file"
            },
            "status": {
              "type": "string",
              "description": "Filter tasks by status"
            },
            "projectRoot": {
              "type": "string",
              "description": "Root directory of the project (default: current working directory)"
            },
            "withSubtasks": {
              "type": "boolean",
              "description": "Include subtasks in the response"
            }
          },
          "required": [
            "projectRoot"
          ]
        }
      },
      {
        "name": "showTask",
        "description": "Show detailed information about a specific task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Task ID to show"
            },
            "file": {
              "type": "string",
              "description": "Path to the tasks file"
            },
            "projectRoot": {
              "type": "string",
              "description": "Root directory of the project (default: current working directory)"
            }
          },
          "required": [
            "id",
            "projectRoot"
          ]
        }
      },
      {
        "name": "setTaskStatus",
        "description": "Set the status of a task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Task ID (can be comma-separated for multiple tasks)"
            },
            "file": {
              "type": "string",
              "description": "Path to the tasks file"
            },
            "status": {
              "type": "string",
              "description": "New status (todo, in-progress, review, done)"
            },
            "projectRoot": {
              "type": "string",
              "description": "Root directory of the project (default: current working directory)"
            }
          },
          "required": [
            "id",
            "status",
            "projectRoot"
          ]
        }
      },
      {
        "name": "expandTask",
        "description": "Break down a task into detailed subtasks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Task ID to expand"
            },
            "num": {
              "type": "number",
              "description": "Number of subtasks to generate"
            },
            "file": {
              "type": "string",
              "description": "Path to the tasks file"
            },
            "force": {
              "type": "boolean",
              "description": "Force regeneration of subtasks for tasks that already have them"
            },
            "prompt": {
              "type": "string",
              "description": "Additional context to guide subtask generation"
            },
            "research": {
              "type": "boolean",
              "description": "Enable Perplexity AI for research-backed subtask generation"
            },
            "projectRoot": {
              "type": "string",
              "description": "Root directory of the project (default: current working directory)"
            }
          },
          "required": [
            "id",
            "projectRoot"
          ]
        }
      },
      {
        "name": "nextTask",
        "description": "Show the next task to work on based on dependencies and status",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "Path to the tasks file"
            },
            "projectRoot": {
              "type": "string",
              "description": "Root directory of the project (default: current working directory)"
            }
          },
          "required": [
            "projectRoot"
          ]
        }
      },
      {
        "name": "addTask",
        "description": "Add a new task using AI",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "string",
              "description": "Path to the tasks file"
            },
            "prompt": {
              "type": "string",
              "description": "Description of the task to add"
            },
            "priority": {
              "type": "string",
              "description": "Task priority (high, medium, low)"
            },
            "projectRoot": {
              "type": "string",
              "description": "Root directory of the project (default: current working directory)"
            },
            "dependencies": {
              "type": "string",
              "description": "Comma-separated list of task IDs this task depends on"
            }
          },
          "required": [
            "prompt",
            "projectRoot"
          ]
        }
      }
    ]
  },
  {
    "name": "f2c-ai-f2c-mcp",
    "title": "f2c-mcp-server",
    "description": "f2c-mcp-server",
    "icon": "https://avatars.githubusercontent.com/f2c-ai",
    "isOfficial": false,
    "homepage": "https://github.com/f2c-ai/f2c-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@f2c/mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_code",
        "description": "Generate UI code for a given node or the currently selected node in the Figma desktop app. Use the nodeId parameter to specify a node id. If no node id is provided, the currently selected node will be used. If a URL is provided, extract the node id from the URL, for example, if given the URL https://figma.com/design/:fileKey/:fileName?node-id=1-2, the extracted nodeId would be 1:2. IMPORTANT: After you call this tool, you should call get_image to get an image of the node for context.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "string",
              "description": "Comma-separated list of Figma node IDs for conversion. To obtain node IDs, select elements in Figma, right-click and select \"Copy/Paste as\" → \"Copy ID\"."
            },
            "fileKey": {
              "type": "string",
              "description": "The Figma file identifier found in the file URL (e.g., https://www.figma.com/file/XXXXXXXXXXXX/). Extract the XXXXXXXXXXXX portion as the fileKey."
            },
            "imgFormat": {
              "enum": [
                "png",
                "jpg",
                "svg"
              ],
              "type": "string",
              "default": "png",
              "description": "Export format for image assets: \"png\" for lossless quality, \"jpg\" for compressed files, or \"svg\" for vector graphics."
            },
            "localPath": {
              "type": "string",
              "description": "Absolute path for asset(e.g., images) and code storage. Directory will be created if non-existent. Path must follow OS-specific format without special character escaping. When this path is set, all code-related static resources are stored in this directory, while other assets (e.g., images) will be saved into the subdirectory named assets under this path."
            },
            "scaleSize": {
              "type": "number",
              "default": 2,
              "maximum": 4,
              "minimum": 1,
              "description": "Image export scale factor (1-4). Higher values yield better quality at the cost of larger file sizes."
            },
            "personalToken": {
              "type": "string",
              "description": "Figma personal access token for API authentication.The parameters are not required when the tool is called."
            }
          },
          "required": [
            "fileKey",
            "ids"
          ]
        }
      },
      {
        "name": "get_image",
        "description": "Generate an image for a given node or the currently selected node in the Figma desktop app. Use the nodeId parameter to specify a node id. If no node id is provided, the currently selected node will be used. If a URL is provided, extract the node id from the URL, for example, if given the URL https://figma.com/design/:fileKey/:fileName?node-id=1-2, the extracted nodeId would be 1:2. Also export Figma design images for visual verification and design fidelity validation. Essential for comparing generated code output against original designs, ensuring pixel-perfect implementation and catching visual discrepancies during the design-to-code process.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "string",
              "description": "Comma-separated node IDs to export. Use \"Copy ID\" from Figma context menu to get precise element references for comparison"
            },
            "scale": {
              "type": "number",
              "description": "Scale factor (1-4x) for high-resolution comparison. Use 2x+ for detailed fidelity checks on retina displays"
            },
            "format": {
              "enum": [
                "jpg",
                "png",
                "svg",
                "pdf"
              ],
              "type": "string",
              "description": "Export format for verification: \"png\" for pixel-perfect comparison with transparency, \"jpg\" for quick previews, \"svg\" for scalable reference, \"pdf\" for print validation"
            },
            "fileKey": {
              "type": "string",
              "description": "Figma file identifier from the URL for accessing the design source"
            },
            "version": {
              "type": "string",
              "description": "Specific design version for consistent comparison baseline"
            },
            "personalToken": {
              "type": "string",
              "description": "Figma personal access token for authenticated access to design files"
            },
            "svg_include_id": {
              "type": "boolean",
              "description": "Include element IDs in SVG for precise element mapping during code validation"
            },
            "svg_simplify_stroke": {
              "type": "boolean",
              "description": "Simplify stroke paths for cleaner reference images during visual comparison"
            },
            "use_absolute_bounds": {
              "type": "boolean",
              "description": "Use absolute positioning for accurate layout verification against implemented code"
            }
          },
          "required": [
            "fileKey",
            "ids"
          ]
        }
      }
    ]
  },
  {
    "name": "f4ww4z-mcp-mysql-server",
    "title": "mcp-mysql-server",
    "description": "This server enables AI models to interact with MySQL databases through a standardized interface.",
    "icon": "https://avatars.githubusercontent.com/f4ww4z",
    "isOfficial": false,
    "homepage": "https://github.com/f4ww4z/mcp-mysql-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@f4ww4z/mcp-mysql-server"
      ],
      "env": {
        "MYSQL_HOST": "<mysql-host>",
        "MYSQL_USER": "<mysql-user>",
        "MYSQL_DATABASE": "<mysql-database>",
        "MYSQL_PASSWORD": "<mysql-password>"
      }
    },
    "parameters": [
      {
        "name": "MYSQL_HOST",
        "description": "MySQL database host",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_USER",
        "description": "MySQL database user",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_DATABASE",
        "description": "MySQL database name",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MYSQL_PASSWORD",
        "description": "MySQL database password",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "fakepixels-base-mcp-server",
    "title": "Base Network MCP Server",
    "description": "An MCP server that enables LLMs to perform blockchain operations on the Base network through natural language commands, including wallet management, balance checking, and transaction execution.",
    "icon": "https://avatars.githubusercontent.com/fakepixels",
    "isOfficial": false,
    "homepage": "https://github.com/fakepixels/base-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "base-network-mcp-server"
      ],
      "env": {
        "BASE_PROVIDER_URL": "<base-provider-url>",
        "DEFAULT_GAS_PRICE": "<default-gas-price>",
        "WALLET_PRIVATE_KEY": "<wallet-private-key>"
      }
    },
    "parameters": [
      {
        "name": "BASE_PROVIDER_URL",
        "description": "The URL of the Base network provider (Mainnet or Sepolia)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "DEFAULT_GAS_PRICE",
        "description": "Default gas price in Gwei",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "WALLET_PRIVATE_KEY",
        "description": "Your wallet private key for authentication and transaction signing",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "process_command",
        "description": "Process a natural language command for Base network operations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "Natural language command (e.g., \"Send 0.1 ETH to 0x123...\")"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "create_wallet",
        "description": "Create a new wallet",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Optional name for the wallet"
            }
          }
        }
      },
      {
        "name": "check_balance",
        "description": "Check wallet balance",
        "inputSchema": {
          "type": "object",
          "properties": {
            "wallet": {
              "type": "string",
              "description": "Wallet name or address (defaults to primary wallet)"
            }
          }
        }
      },
      {
        "name": "list_wallets",
        "description": "List all available wallets",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "fatwang2-search1api-mcp",
    "title": "Search1API MCP Server",
    "description": "A Model Context Protocol (MCP) server that provides search and crawl functionality using Search1API.",
    "icon": "https://avatars.githubusercontent.com/fatwang2",
    "isOfficial": false,
    "homepage": "https://github.com/fatwang2/search1api-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "search1api-mcp"
      ],
      "env": {
        "SEARCH1API_KEY": "<search1api-key>"
      }
    },
    "parameters": [
      {
        "name": "SEARCH1API_KEY",
        "description": "Your API key from Search1API (https://www.search1api.com)",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "search",
        "description": "Web search tool",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query, be simple and concise"
            },
            "time_range": {
              "enum": [
                "day",
                "month",
                "year"
              ],
              "type": "string",
              "description": "Time range for search results, only use when specific time constraints are required"
            },
            "max_results": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of results to return"
            },
            "crawl_results": {
              "type": "number",
              "default": 0,
              "description": "Number of results to crawl for full webpage content, useful when search result summaries are insufficient for complex queries"
            },
            "exclude_sites": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "List of sites to exclude from search. Only use when you need to explicitly filter out specific domains from results"
            },
            "include_sites": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "List of sites to include in search. Only use when you need special results from sites not available in search_service"
            },
            "search_service": {
              "enum": [
                "google",
                "bing",
                "duckduckgo",
                "yahoo",
                "x",
                "reddit",
                "github",
                "youtube",
                "arxiv",
                "wechat",
                "bilibili",
                "imdb",
                "wikipedia"
              ],
              "type": "string",
              "default": "google",
              "description": "Specify the search engine to use. Choose based on your specific needs"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "news",
        "description": "News search tool",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query, be simple and concise"
            },
            "time_range": {
              "enum": [
                "day",
                "month",
                "year"
              ],
              "type": "string",
              "description": "Time range for search results, only use when specific time constraints are required"
            },
            "max_results": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of results to return"
            },
            "crawl_results": {
              "type": "number",
              "default": 0,
              "description": "Number of results to crawl for full webpage content, useful when search result summaries are insufficient for complex queries"
            },
            "exclude_sites": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "List of sites to exclude from search. Only use when you need to explicitly filter out specific domains from results"
            },
            "include_sites": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "List of sites to include in search. Only use when you need special results from sites not available in search_service"
            },
            "search_service": {
              "enum": [
                "google",
                "bing",
                "duckduckgo",
                "yahoo",
                "hackernews"
              ],
              "type": "string",
              "default": "bing",
              "description": "Specify the news engine to use. Choose based on your specific needs"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "crawl",
        "description": "Extract content from URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to crawl"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "sitemap",
        "description": "Get all related links from a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to get sitemap"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "reasoning",
        "description": "Deep thinking and complex problem solving",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The question or problem that needs deep thinking"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "trending",
        "description": "Get trending topics from popular platforms",
        "inputSchema": {
          "type": "object",
          "properties": {
            "max_results": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of trending items to return"
            },
            "search_service": {
              "enum": [
                "github",
                "hackernews"
              ],
              "type": "string",
              "default": "github",
              "description": "Specify the platform to get trending topics from"
            }
          },
          "required": [
            "search_service"
          ]
        }
      }
    ]
  },
  {
    "name": "felores-placid-mcp-server",
    "title": "Placid MCP Server",
    "description": "A server for integrating with Placid.app's API, enabling listing templates and generating creatives using the Model Context Protocol with secure API token management.",
    "icon": "https://avatars.githubusercontent.com/felores",
    "isOfficial": false,
    "homepage": "https://github.com/felores/placid-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@felores/placid-mcp-server"
      ],
      "env": {
        "PLACID_API_TOKEN": "<placid-api-token>"
      }
    },
    "parameters": [
      {
        "name": "PLACID_API_TOKEN",
        "description": "Your Placid.app API token obtained from your Placid.app account under Settings > API",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "fenxer-steam-review-mcp",
    "title": "Steam Review MCP",
    "description": "Enables LLMs to retrieve and analyze Steam game reviews, providing access to review statistics, game information, and helping summarize pros and cons of games.",
    "icon": "https://avatars.githubusercontent.com/fenxer",
    "isOfficial": false,
    "homepage": "https://github.com/fenxer/steam-review-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "steam-review-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_steam_review",
        "description": "Retrieves reviews and game information for a specific Steam application. Returns formatted review data including review scores, positive/negative counts, review texts, and basic game information.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "appid": {
              "type": "string",
              "description": "Steam application ID"
            },
            "cursor": {
              "type": "string",
              "default": "*",
              "description": "reviews are returned in batches of 20, so pass * for the first set, then the value of cursor that was returned in the response for the next set, etc. Note that cursor values may contain characters that need to be URLEncoded for use in the querystring."
            },
            "filter": {
              "type": "string",
              "default": "all",
              "description": "recent: sorted by creation time, updated: sorted by last updated time,all: (default) sorted by helpfulness, with sliding windows based on day_range parameter, will always find results to return."
            },
            "language": {
              "enum": [
                "all",
                "arabic",
                "bulgarian",
                "schinese",
                "tchinese",
                "czech",
                "danish",
                "dutch",
                "english",
                "finnish",
                "french",
                "german",
                "greek",
                "hungarian",
                "indonesian",
                "italian",
                "japanese",
                "koreana",
                "norwegian",
                "polish",
                "portuguese",
                "brazilian",
                "romanian",
                "russian",
                "spanish",
                "latam",
                "swedish",
                "thai",
                "turkish",
                "ukrainian",
                "vietnamese"
              ],
              "type": "string",
              "default": "all",
              "description": "Language filter (e.g. english, french, schinese). Default is all languages."
            },
            "day_range": {
              "type": "number",
              "default": 365,
              "description": "range from now to n days ago to look for helpful reviews. Only applicable for the all filter."
            },
            "review_type": {
              "type": "string",
              "default": "all",
              "description": "all:all reviews (default), positive: only positive reviews, negative: only negative reviews"
            },
            "num_per_page": {
              "type": "number",
              "default": 50,
              "description": "number of reviews to get, max 100, default 50"
            },
            "purchase_type": {
              "type": "string",
              "default": "steam",
              "description": "all: all reviews, non_steam_purchase: reviews written by users who did not pay for the product on Steam,steam: reviews written by users who paid for the product on Steam (default)"
            }
          },
          "required": [
            "appid"
          ]
        }
      }
    ]
  },
  {
    "name": "ferrislucas-iterm-mcp",
    "title": "iTerm MCP Server",
    "description": "This MCP server enables users to execute shell commands in the current iTerm2 session through integration with Claude Desktop, facilitating seamless command execution via the Model Context Protocol.",
    "icon": "https://avatars.githubusercontent.com/ferrislucas",
    "isOfficial": false,
    "homepage": "https://github.com/ferrislucas/iterm-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "iterm-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "feuerdev-keep-mcp",
    "title": "Keep MCP",
    "description": "Enables interaction with Google Keep notes through an MCP server, allowing users to search, create, update, and delete notes via natural language commands.",
    "icon": "https://avatars.githubusercontent.com/feuerdev",
    "isOfficial": false,
    "homepage": "https://github.com/feuerdev/keep-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "keep-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "find",
        "description": "\n    Find notes based on a search query.\n    \n    Args:\n        query (str, optional): A string to match against the title and text\n        \n    Returns:\n        str: JSON string containing the matching notes with their id, title, text, pinned status, color and labels\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "query",
              "default": ""
            }
          }
        }
      },
      {
        "name": "create_note",
        "description": "\n    Create a new note with title and text.\n    \n    Args:\n        title (str, optional): The title of the note\n        text (str, optional): The content of the note\n        \n    Returns:\n        str: JSON string containing the created note's data\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "title": "Text",
              "default": null
            },
            "title": {
              "type": "string",
              "title": "Title",
              "default": null
            }
          }
        }
      },
      {
        "name": "update_note",
        "description": "\n    Update a note's properties.\n    \n    Args:\n        note_id (str): The ID of the note to update\n        title (str, optional): New title for the note\n        text (str, optional): New text content for the note\n        \n    Returns:\n        str: JSON string containing the updated note's data\n        \n    Raises:\n        ValueError: If the note doesn't exist or cannot be modified\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "title": "Text",
              "default": null
            },
            "title": {
              "type": "string",
              "title": "Title",
              "default": null
            },
            "note_id": {
              "type": "string",
              "title": "Note Id"
            }
          },
          "required": [
            "note_id"
          ]
        }
      },
      {
        "name": "delete_note",
        "description": "\n    Delete a note (mark for deletion).\n    \n    Args:\n        note_id (str): The ID of the note to delete\n        \n    Returns:\n        str: Success message\n        \n    Raises:\n        ValueError: If the note doesn't exist or cannot be modified\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "note_id": {
              "type": "string",
              "title": "Note Id"
            }
          },
          "required": [
            "note_id"
          ]
        }
      }
    ]
  },
  {
    "name": "firstorderai-authenticator_mcp",
    "title": "Authenticator App MCP Server",
    "description": "A secure server that enables AI agents to access 2FA codes and passwords from the Authenticator App, allowing them to assist with automated login processes while maintaining security.",
    "icon": "https://avatars.githubusercontent.com/firstorderai",
    "isOfficial": false,
    "homepage": "https://github.com/firstorderai/authenticator_mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "authenticator-mcp"
      ],
      "env": {
        "AUTHENTICATOR_ACCESS_TOKEN": "<authenticator-access-token>"
      }
    },
    "parameters": [
      {
        "name": "AUTHENTICATOR_ACCESS_TOKEN",
        "description": "Your Authenticator App access token generated from the desktop app",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_2fa_code",
        "description": "Retrieve the current 2FA code for a username when logging into a website.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "website": {
              "type": "string",
              "description": "The domain name of the website you need to login, e.g. \"github.com\""
            },
            "username": {
              "type": "string",
              "description": "The username or email of the account you need to login, e.g. \"john.doe@example.com\""
            }
          },
          "required": [
            "website",
            "username"
          ]
        }
      },
      {
        "name": "get_password",
        "description": "Retrieve the password for a username when logging into a website.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "website": {
              "type": "string",
              "description": "The domain name of the website you need to login, e.g. \"github.com\""
            },
            "username": {
              "type": "string",
              "description": "The username or email of the account you need to login, e.g. \"john.doe@example.com\""
            }
          },
          "required": [
            "website",
            "username"
          ]
        }
      },
      {
        "name": "get_account_list",
        "description": "Retrieve the accounts can be used when logging into a website.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "website": {
              "type": "string",
              "description": "The domain name of the website you need to login, e.g. \"github.com\""
            }
          },
          "required": [
            "website"
          ]
        }
      }
    ]
  },
  {
    "name": "f-is-h-mcp-easy-copy",
    "title": "MCP Easy Copy",
    "description": "A Model Context Protocol server that automatically reads the Claude Desktop configuration file and presents all available MCP services in an easy-to-copy format at the top of the tools list.",
    "icon": "https://avatars.githubusercontent.com/f-is-h",
    "isOfficial": false,
    "homepage": "https://github.com/f-is-h/mcp-easy-copy",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@fishes/mcp-easy-copy"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "_________available_mcp_services_for_easy_copy_________",
        "description": "List all MCP services available in this Claude instance",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "fleagne-backlog-mcp-server",
    "title": "Backlog MCP Server",
    "description": "An MCP server implementation that integrates with Backlog API, enabling project management operations including issues, projects, and wikis through natural language interactions.",
    "icon": "https://avatars.githubusercontent.com/fleagne",
    "isOfficial": false,
    "homepage": "https://github.com/fleagne/backlog-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "backlog-mcp-server"
      ],
      "env": {
        "BACKLOG_API_KEY": "<backlog-api-key>",
        "BACKLOG_BASE_URL": "<backlog-base-url>",
        "BACKLOG_SPACE_ID": "<backlog-space-id>"
      }
    },
    "parameters": [
      {
        "name": "BACKLOG_API_KEY",
        "description": "Your Backlog API key",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "BACKLOG_BASE_URL",
        "description": "Your Backlog base URL (default: https://{your-space-id}.backlog.com/api/v2)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "BACKLOG_SPACE_ID",
        "description": "Your Backlog space ID",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "backlog_get_projects",
        "description": "Performs list project get using the Backlog Projects get API. Supports pagination, content filtering. Maximum 20 results per request, with offset for pagination.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "all": {
              "type": "boolean",
              "default": false,
              "description": "Only applies to administrators. If true, it returns all projects. If false, it returns only projects they have joined (set to false by default)."
            },
            "archived": {
              "type": "boolean",
              "description": "For unspecified parameters, this form returns all projects. For false parameters, it returns unarchived projects. For true parameters, it returns archived projects."
            }
          }
        }
      },
      {
        "name": "backlog_get_project",
        "description": "Performs an project get using the Backlog Project get API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectIdOrKey": {
              "type": "string",
              "description": "Project ID or Project Key"
            }
          },
          "required": [
            "projectIdOrKey"
          ]
        }
      },
      {
        "name": "backlog_get_issues",
        "description": "Performs list issue get using the Backlog Issues API. Supports pagination, content filtering. Maximum 20 results per request, with offset for pagination.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "enum": [
                "issueType",
                "category",
                "version",
                "milestone",
                "summary",
                "status",
                "priority",
                "attachment",
                "sharedFile",
                "created",
                "createdUser",
                "updated",
                "updatedUser",
                "assignee",
                "startDate",
                "dueDate",
                "estimatedHours",
                "actualHours",
                "childIssue"
              ],
              "type": "string",
              "description": "Attribute name for sorting"
            },
            "count": {
              "type": "number",
              "default": 20,
              "maximum": 100,
              "minimum": 1,
              "description": "Number of results (1-100, default 20)"
            },
            "order": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "default": "desc",
              "description": "Sort order"
            },
            "offset": {
              "type": "number",
              "default": 0,
              "description": "Offset for pagination"
            },
            "keyword": {
              "type": "string",
              "description": "Keyword for searching"
            },
            "statusId": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Status ids"
            },
            "projectId": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Project ids"
            },
            "assigneeId": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Assignee ids"
            },
            "priorityId": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Priority ids"
            },
            "createdSince": {
              "type": "string",
              "description": "Start date of created date (YYYY-MM-DD format)"
            },
            "createdUntil": {
              "type": "string",
              "description": "End date of created date (YYYY-MM-DD format)"
            }
          }
        }
      },
      {
        "name": "backlog_get_issue",
        "description": "Performs an issue get using the Backlog Issue API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueIdOrKey": {
              "type": "string",
              "description": "Issue ID or Issue Key"
            }
          },
          "required": [
            "issueIdOrKey"
          ]
        }
      },
      {
        "name": "backlog_add_issue",
        "description": "Add an issue using the Backlog Issue API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dueDate": {
              "type": "string",
              "description": "Due date of the issue (YYYY-MM-DD format)"
            },
            "summary": {
              "type": "string",
              "description": "Summary of the issue"
            },
            "projectId": {
              "type": "number",
              "description": "Project id"
            },
            "startDate": {
              "type": "string",
              "description": "Start date of the issue (YYYY-MM-DD format)"
            },
            "versionId": {
              "type": "number",
              "description": "Version id"
            },
            "assigneeId": {
              "type": "number",
              "description": "Assignee id"
            },
            "categoryId": {
              "type": "number",
              "description": "Category id"
            },
            "priorityId": {
              "type": "number",
              "description": "Priority id"
            },
            "actualHours": {
              "type": "number",
              "description": "Actual hours for the issue"
            },
            "description": {
              "type": "string",
              "description": "Description of the issue"
            },
            "issueTypeId": {
              "type": "number",
              "description": "Issue type id"
            },
            "milestoneId": {
              "type": "number",
              "description": "Milestone id"
            },
            "estimatedHours": {
              "type": "number",
              "description": "Estimated hours for the issue"
            }
          },
          "required": [
            "projectId",
            "summary",
            "issueTypeId",
            "priorityId"
          ]
        }
      },
      {
        "name": "backlog_update_issue",
        "description": "Update an issue using the Backlog Issue API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "comment": {
              "type": "string",
              "description": "Comment"
            },
            "dueDate": {
              "type": "string",
              "description": "Due date"
            },
            "summary": {
              "type": "string",
              "description": "Summary"
            },
            "statusId": {
              "type": "number",
              "description": "Status id"
            },
            "startDate": {
              "type": "string",
              "description": "Start date"
            },
            "versionId": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Version ids"
            },
            "assigneeId": {
              "type": "number",
              "description": "Assignee id"
            },
            "categoryId": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Category ids"
            },
            "priorityId": {
              "type": "number",
              "description": "Priority id"
            },
            "actualHours": {
              "type": "number",
              "description": "Actual hours"
            },
            "description": {
              "type": "string",
              "description": "Description"
            },
            "issueTypeId": {
              "type": "number",
              "description": "Issue type id"
            },
            "milestoneId": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Milestone ids"
            },
            "attachmentId": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Attachment ids"
            },
            "issueIdOrKey": {
              "type": "string",
              "description": "Issue ID or Issue Key"
            },
            "parentIssueId": {
              "type": "number",
              "description": "Parent issue id"
            },
            "estimatedHours": {
              "type": "number",
              "description": "Estimated hours"
            },
            "notifiedUserId": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Notified user ids"
            }
          },
          "required": [
            "issueIdOrKey"
          ]
        }
      },
      {
        "name": "backlog_delete_issue",
        "description": "Delete an issue using the Backlog Issue API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueIdOrKey": {
              "type": "string",
              "description": "Issue ID or Issue Key"
            }
          },
          "required": [
            "issueIdOrKey"
          ]
        }
      },
      {
        "name": "backlog_get_wikis",
        "description": "Performs list wikis get using the Backlog Wiki API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "type": "string",
              "description": "Keyword for searching"
            },
            "projectIdOrKey": {
              "type": "string",
              "description": "Project ID or Project Key"
            }
          },
          "required": [
            "projectIdOrKey"
          ]
        }
      },
      {
        "name": "backlog_get_wiki",
        "description": "Performs an wiki get using the Backlog Wiki API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "wikiId": {
              "type": "number",
              "description": "Wiki page ID"
            }
          },
          "required": [
            "wikiId"
          ]
        }
      },
      {
        "name": "backlog_add_wiki",
        "description": "Add an wiki using the Backlog Wiki API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Page Name"
            },
            "content": {
              "type": "string",
              "description": "Content"
            },
            "projectId": {
              "type": "number",
              "description": "Project ID"
            },
            "mailNotify": {
              "type": "boolean",
              "description": "True make to notify by Email"
            }
          },
          "required": [
            "projectId",
            "name",
            "content"
          ]
        }
      },
      {
        "name": "backlog_update_wiki",
        "description": "Update an wiki using the Backlog Wiki API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Page Name"
            },
            "wikiId": {
              "type": "number",
              "description": "Wiki page ID"
            },
            "content": {
              "type": "string",
              "description": "Content"
            },
            "mailNotify": {
              "type": "boolean",
              "description": "True make to notify by Email"
            }
          },
          "required": [
            "wikiId"
          ]
        }
      },
      {
        "name": "backlog_delete_wiki",
        "description": "Delete an wiki using the Backlog Wiki API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "wikiId": {
              "type": "number",
              "description": "Wiki page ID"
            },
            "mailNotify": {
              "type": "boolean",
              "description": "True make to notify by Email"
            }
          },
          "required": [
            "wikiId"
          ]
        }
      }
    ]
  },
  {
    "name": "flutterninja9-better-fetch",
    "title": "Better Fetch",
    "description": "A Model Context Protocol server that intelligently fetches and processes web content, transforming websites and documentation into clean, structured markdown with nested URL crawling capabilities.",
    "icon": "https://avatars.githubusercontent.com/flutterninja9",
    "isOfficial": false,
    "homepage": "https://github.com/flutterninja9/better-fetch",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "better-fetch-mcp"
      ],
      "env": {
        "NODE_ENV": "<node-env>"
      }
    },
    "parameters": [
      {
        "name": "NODE_ENV",
        "description": "Environment mode for the server",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "fetch_website_nested",
        "description": "Fetch website content with nested URL crawling and convert to clean markdown",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The starting URL to fetch and crawl"
            },
            "timeout": {
              "type": "number",
              "default": 10000,
              "description": "Request timeout in milliseconds (default: 10000)"
            },
            "maxDepth": {
              "type": "number",
              "default": 2,
              "description": "Maximum depth to crawl (default: 2)"
            },
            "maxPages": {
              "type": "number",
              "default": 50,
              "description": "Maximum number of pages to fetch (default: 50)"
            },
            "sameDomainOnly": {
              "type": "boolean",
              "default": true,
              "description": "Only crawl URLs from the same domain (default: true)"
            },
            "excludePatterns": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Regex patterns for URLs to exclude"
            },
            "includePatterns": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Regex patterns for URLs to include (if specified, only matching URLs will be processed)"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "fetch_website_single",
        "description": "Fetch content from a single webpage and convert to clean markdown",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to fetch"
            },
            "timeout": {
              "type": "number",
              "default": 10000,
              "description": "Request timeout in milliseconds (default: 10000)"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "formulahendry-mcp-server-code-runner",
    "title": "mcp-server-code-runner",
    "description": "MCP Server for running code snippet and show the result.",
    "icon": "https://avatars.githubusercontent.com/formulahendry",
    "isOfficial": false,
    "homepage": "https://github.com/formulahendry/mcp-server-code-runner",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-server-code-runner"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "run-code",
        "description": "Run code snippet and return the result.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "Code Snippet"
            },
            "languageId": {
              "enum": [
                "javascript",
                "php",
                "python",
                "perl",
                "perl6",
                "ruby",
                "go",
                "lua",
                "groovy",
                "powershell",
                "bat",
                "shellscript",
                "fsharp",
                "csharp",
                "vbscript",
                "typescript",
                "coffeescript",
                "scala",
                "swift",
                "julia",
                "crystal",
                "ocaml",
                "r",
                "applescript",
                "clojure",
                "racket",
                "scheme",
                "ahk",
                "autoit",
                "dart",
                "haskell",
                "nim",
                "lisp",
                "kit",
                "v",
                "sass",
                "scss"
              ],
              "type": "string",
              "description": "Language ID"
            }
          },
          "required": [
            "code",
            "languageId"
          ]
        }
      }
    ]
  },
  {
    "name": "fortunto2-prefect-mcp-server",
    "title": "Prefect MCP Server",
    "description": "A server that enables interacting with Prefect workflow automation tools through the Model Context Protocol, offering enhanced reliability through uvx running mechanism and seamless integration with Cursor IDE.",
    "icon": "https://avatars.githubusercontent.com/fortunto2",
    "isOfficial": false,
    "homepage": "https://github.com/fortunto2/prefect-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "prefect-mcp-server"
      ],
      "env": {
        "PREFECT_API_KEY": "<prefect-api-key>",
        "PREFECT_API_URL": "<prefect-api-url>"
      }
    },
    "parameters": [
      {
        "name": "PREFECT_API_KEY",
        "description": "API key to authenticate with your Prefect server or Prefect Cloud",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "PREFECT_API_URL",
        "description": "The URL of the Prefect API server",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get_flow_by_id",
        "description": "Get a flow by its ID.\n\n    Args:\n        flow_id: ID of the flow to retrieve.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "flow_id": {
              "type": "string",
              "title": "Flow Id"
            }
          },
          "required": [
            "flow_id"
          ]
        }
      },
      {
        "name": "get_flow_by_name",
        "description": "Get a flow by its name.\n\n    Args:\n        name: Name of the flow to retrieve.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "list_flows",
        "description": "Get a list of flows from the Prefect API.\n\n    Args:\n        limit: Maximum number of flows to return (default 20).\n        offset: Number of flows to skip (default 0).\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 20
            },
            "offset": {
              "type": "integer",
              "title": "Offset",
              "default": 0
            }
          }
        }
      },
      {
        "name": "search_flows",
        "description": "Search for flows by name and/or tags.\n\n    Args:\n        name: Optional name to search for (case-insensitive contains match).\n        tags: Optional list of tags to filter by.\n        limit: Maximum number of flows to return (default 20).\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Name",
              "default": null
            },
            "tags": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags",
              "default": null
            },
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 20
            }
          }
        }
      },
      {
        "name": "get_flow_run_by_id",
        "description": "Get a flow run by its ID.\n\n    Args:\n        flow_run_id: ID of the flow run to retrieve.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "flow_run_id": {
              "type": "string",
              "title": "Flow Run Id"
            }
          },
          "required": [
            "flow_run_id"
          ]
        }
      },
      {
        "name": "list_flow_runs",
        "description": "Get a list of flow runs from the Prefect API.\n\n    Args:\n        limit: Maximum number of flow runs to return (default 20).\n        offset: Number of flow runs to skip (default 0).\n        flow_id: Optional ID of the flow to filter runs by.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 20
            },
            "offset": {
              "type": "integer",
              "title": "Offset",
              "default": 0
            },
            "flow_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Flow Id",
              "default": null
            }
          }
        }
      },
      {
        "name": "search_flow_runs_by_state",
        "description": "Search for flow runs by state.\n\n    Args:\n        state_type: Optional state type (e.g., \"COMPLETED\", \"FAILED\", \"CRASHED\").\n        state_name: Optional state name (e.g., \"Completed\", \"Failed\").\n        limit: Maximum number of flow runs to return (default 20).\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 20
            },
            "state_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "State Name",
              "default": null
            },
            "state_type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "State Type",
              "default": null
            }
          }
        }
      },
      {
        "name": "cancel_flow_run",
        "description": "Cancel a flow run.\n\n    Args:\n        flow_run_id: ID of the flow run to cancel.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "flow_run_id": {
              "type": "string",
              "title": "Flow Run Id"
            }
          },
          "required": [
            "flow_run_id"
          ]
        }
      },
      {
        "name": "get_deployment_by_id",
        "description": "Get a deployment by its ID.\n\n    Args:\n        deployment_id: ID of the deployment to retrieve.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "deployment_id": {
              "type": "string",
              "title": "Deployment Id"
            }
          },
          "required": [
            "deployment_id"
          ]
        }
      },
      {
        "name": "get_deployment_by_name",
        "description": "Get a deployment by its name.\n\n    Args:\n        name: Name of the deployment to retrieve, in format \"flow_name/deployment_name\".\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "list_deployments",
        "description": "Get a list of deployments from the Prefect API.\n\n    Args:\n        limit: Maximum number of deployments to return (default 20).\n        offset: Number of deployments to skip (default 0).\n        flow_id: Optional ID of the flow to filter deployments by.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 20
            },
            "offset": {
              "type": "integer",
              "title": "Offset",
              "default": 0
            },
            "flow_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Flow Id",
              "default": null
            }
          }
        }
      },
      {
        "name": "search_deployments_by_status",
        "description": "Search for deployments by schedule status.\n\n    Args:\n        is_schedule_active: Filter deployments by whether their schedule is active.\n        limit: Maximum number of deployments to return (default 20).\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 20
            },
            "is_schedule_active": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Is Schedule Active",
              "default": null
            }
          }
        }
      },
      {
        "name": "create_flow_run_from_deployment",
        "description": "Create a new flow run for the specified deployment.\n\n    Args:\n        deployment_id: ID of the deployment or name in format 'flow_name/deployment_name'.\n        parameters: Dictionary with parameters for the flow run (optional).\n        name: Optional name for the flow run.\n        timeout: Timeout in seconds, 0 means no waiting for completion (default 0).\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Name",
              "default": null
            },
            "timeout": {
              "type": "integer",
              "title": "Timeout",
              "default": 0
            },
            "parameters": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Parameters",
              "default": null
            },
            "deployment_id": {
              "type": "string",
              "title": "Deployment Id"
            }
          },
          "required": [
            "deployment_id"
          ]
        }
      },
      {
        "name": "filter_flows",
        "description": "Filter flows based on specified criteria.\n\n    Args:\n        filter_criteria: Dictionary with filter criteria according to Prefect API.\n                         Example: {\"flows\": {\"tags\": {\"all_\": [\"production\"]}}}\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filter_criteria": {
              "type": "object",
              "title": "Filter Criteria",
              "additionalProperties": true
            }
          },
          "required": [
            "filter_criteria"
          ]
        }
      },
      {
        "name": "filter_flow_runs",
        "description": "Filter flow runs based on specified criteria.\n\n    Args:\n        filter_criteria: Dictionary with filter criteria according to Prefect API.\n                         Example: {\"flow_runs\": {\"state\": {\"type\": {\"any_\": [\"FAILED\", \"CRASHED\"]}}}}\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filter_criteria": {
              "type": "object",
              "title": "Filter Criteria",
              "additionalProperties": true
            }
          },
          "required": [
            "filter_criteria"
          ]
        }
      },
      {
        "name": "filter_deployments",
        "description": "Filter deployments based on specified criteria.\n\n    Args:\n        filter_criteria: Dictionary with filter criteria according to Prefect API.\n                         Example: {\"deployments\": {\"is_schedule_active\": {\"eq_\": true}}}\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filter_criteria": {
              "type": "object",
              "title": "Filter Criteria",
              "additionalProperties": true
            }
          },
          "required": [
            "filter_criteria"
          ]
        }
      },
      {
        "name": "create_flow_run",
        "description": "Create a new flow run for the specified deployment (Legacy).\n\n    Args:\n        deployment_id: ID of the deployment to create a run for.\n        parameters: Dictionary with parameters for the flow run (optional).\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "parameters": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Parameters",
              "default": null
            },
            "deployment_id": {
              "type": "string",
              "title": "Deployment Id"
            }
          },
          "required": [
            "deployment_id"
          ]
        }
      }
    ]
  },
  {
    "name": "g0t4-mcp-server-macos-defaults",
    "title": "macOS Defaults MCP Server",
    "description": "MCP server that enables reading and writing macOS system preferences and application settings through the defaults system.",
    "icon": "https://avatars.githubusercontent.com/g0t4",
    "isOfficial": false,
    "homepage": "https://github.com/g0t4/mcp-server-macos-defaults",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-macos-defaults"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "list-domains",
        "description": "List all available macOS domains, same as `defaults domains`",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "find",
        "description": "Find entries container given word",
        "inputSchema": {
          "type": "object",
          "properties": {
            "word": {
              "type": "string",
              "description": "Word to search for"
            }
          }
        }
      },
      {
        "name": "defaults-read",
        "description": "use the `defaults read <domain> <key>` command",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "Key to read from"
            },
            "domain": {
              "type": "string",
              "description": "Domain to read from"
            }
          },
          "required": [
            "domain"
          ]
        }
      },
      {
        "name": "defaults-write",
        "description": "use the `defaults write <domain> <key> <value>` command",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "Key to write to"
            },
            "value": {
              "type": "string",
              "description": "Value to write"
            },
            "domain": {
              "type": "string",
              "description": "Domain to write to"
            }
          },
          "required": [
            "domain",
            "key",
            "value"
          ]
        }
      }
    ]
  },
  {
    "name": "g0t4-mcp-server-commands",
    "title": "mcp-server-commands",
    "description": "An MCP server to run commands.",
    "icon": "https://avatars.githubusercontent.com/g0t4",
    "isOfficial": false,
    "homepage": "https://github.com/g0t4/mcp-server-commands",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-server-commands"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "gannonh-firebase-mcp",
    "title": "Firebase MCP",
    "description": "The Firebase MCP server provides a standardized interface to interact with Firebase services, including Firebase Authentication, Firestore, and Firebase Storage.",
    "icon": "https://avatars.githubusercontent.com/gannonh",
    "isOfficial": false,
    "homepage": "https://github.com/gannonh/firebase-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@gannonh/firebase-mcp"
      ],
      "env": {
        "FIREBASE_STORAGE_BUCKET": "<firebase-storage-bucket>",
        "SERVICE_ACCOUNT_KEY_PATH": "<service-account-key-path>"
      }
    },
    "parameters": [
      {
        "name": "FIREBASE_STORAGE_BUCKET",
        "description": "Bucket name for Firebase Storage (defaults to [projectId].appspot.com if not provided)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "SERVICE_ACCOUNT_KEY_PATH",
        "description": "Path to your Firebase service account key JSON file",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "firestore_add_document",
        "description": "Add a document to a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "description": "Document data"
            },
            "collection": {
              "type": "string",
              "description": "Collection name"
            }
          },
          "required": [
            "collection",
            "data"
          ]
        }
      },
      {
        "name": "firestore_list_documents",
        "description": "List documents from a Firestore collection with filtering and ordering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 20,
              "description": "Number of documents to return"
            },
            "filters": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "field",
                  "operator",
                  "value"
                ],
                "properties": {
                  "field": {
                    "type": "string",
                    "description": "Field name to filter"
                  },
                  "value": {
                    "type": "string",
                    "description": "Value to compare against (use ISO format for dates)"
                  },
                  "operator": {
                    "type": "string",
                    "description": "Comparison operator (==, >, <, >=, <=, array-contains, in, array-contains-any)"
                  }
                }
              },
              "description": "Array of filter conditions"
            },
            "orderBy": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "field"
                ],
                "properties": {
                  "field": {
                    "type": "string",
                    "description": "Field name to order by"
                  },
                  "direction": {
                    "enum": [
                      "asc",
                      "desc"
                    ],
                    "type": "string",
                    "default": "asc",
                    "description": "Sort direction (asc or desc)"
                  }
                }
              },
              "description": "Array of fields to order by"
            },
            "pageToken": {
              "type": "string",
              "description": "Token for pagination to get the next page of results"
            },
            "collection": {
              "type": "string",
              "description": "Collection name"
            }
          },
          "required": [
            "collection"
          ]
        }
      },
      {
        "name": "firestore_get_document",
        "description": "Get a document from a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Document ID"
            },
            "collection": {
              "type": "string",
              "description": "Collection name"
            }
          },
          "required": [
            "collection",
            "id"
          ]
        }
      },
      {
        "name": "firestore_update_document",
        "description": "Update a document in a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Document ID"
            },
            "data": {
              "type": "object",
              "description": "Updated document data"
            },
            "collection": {
              "type": "string",
              "description": "Collection name"
            }
          },
          "required": [
            "collection",
            "id",
            "data"
          ]
        }
      },
      {
        "name": "firestore_delete_document",
        "description": "Delete a document from a Firestore collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Document ID"
            },
            "collection": {
              "type": "string",
              "description": "Collection name"
            }
          },
          "required": [
            "collection",
            "id"
          ]
        }
      },
      {
        "name": "auth_get_user",
        "description": "Get a user by ID or email from Firebase Authentication",
        "inputSchema": {
          "type": "object",
          "properties": {
            "identifier": {
              "type": "string",
              "description": "User ID or email address"
            }
          },
          "required": [
            "identifier"
          ]
        }
      },
      {
        "name": "storage_list_files",
        "description": "List files in a given path in Firebase Storage",
        "inputSchema": {
          "type": "object",
          "properties": {
            "directoryPath": {
              "type": "string",
              "description": "The optional path to list files from. If not provided, the root is used."
            }
          },
          "required": []
        }
      },
      {
        "name": "storage_get_file_info",
        "description": "Get file information including metadata and download URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The path of the file to get information for"
            }
          },
          "required": [
            "filePath"
          ]
        }
      },
      {
        "name": "storage_upload",
        "description": "Upload a file to Firebase Storage. Supports local file paths (preferred for binary files), base64 data, or plain text.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "Can be: 1) A local file path (e.g., \"/path/to/file.pdf\") - RECOMMENDED for all file types, especially binary files like PDFs and images, 2) A data URL (e.g., \"data:image/png;base64,...\") - may have issues with large files, or 3) Plain text content. Note: Document references are not directly accessible - always use the actual file path instead."
            },
            "filePath": {
              "type": "string",
              "description": "The destination path in Firebase Storage (e.g., \"images/logo.png\"). If necessary, rename files for optimal URL compatibility (e.g., \"my-document.pdf\" rather than \"My Document.pdf\")."
            },
            "metadata": {
              "type": "object",
              "description": "Optional additional metadata"
            },
            "contentType": {
              "type": "string",
              "description": "Optional MIME type. If not provided, it will be automatically detected"
            }
          },
          "required": [
            "filePath",
            "content"
          ]
        }
      },
      {
        "name": "storage_upload_from_url",
        "description": "Upload a file to Firebase Storage from an external URL. Perfect for images, documents, or any file accessible via URL.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The source URL to download from (e.g., \"https://example.com/image.jpg\"). For GitHub files, use the raw URL (add ?raw=true)"
            },
            "filePath": {
              "type": "string",
              "description": "The destination path in Firebase Storage (e.g., \"images/photo.jpg\"). If necessary, rename files for optimal URL compatibility (e.g., \"my-document.pdf\" rather than \"My Document.pdf\")."
            },
            "metadata": {
              "type": "object",
              "description": "Optional additional metadata"
            },
            "contentType": {
              "type": "string",
              "description": "Optional MIME type. If not provided, it will be automatically detected from the URL or response headers"
            }
          },
          "required": [
            "filePath",
            "url"
          ]
        }
      },
      {
        "name": "firestore_list_collections",
        "description": "List root collections in Firestore",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "firestore_query_collection_group",
        "description": "Query documents across all subcollections with the same name (collection group query)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of documents to return (default: 20, max: 100)"
            },
            "filters": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "field",
                  "operator",
                  "value"
                ],
                "properties": {
                  "field": {
                    "type": "string",
                    "description": "Field name to filter"
                  },
                  "value": {
                    "type": "string",
                    "description": "Value to compare against"
                  },
                  "operator": {
                    "type": "string",
                    "description": "Comparison operator (==, !=, <, <=, >, >=, array-contains, array-contains-any, in, not-in)"
                  }
                }
              },
              "description": "Optional filters to apply to the query"
            },
            "orderBy": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "field"
                ],
                "properties": {
                  "field": {
                    "type": "string",
                    "description": "Field name to order by"
                  },
                  "direction": {
                    "enum": [
                      "asc",
                      "desc"
                    ],
                    "type": "string",
                    "default": "asc",
                    "description": "Sort direction (asc or desc)"
                  }
                }
              },
              "description": "Optional fields to order results by"
            },
            "pageToken": {
              "type": "string",
              "description": "Token for pagination (document path to start after)"
            },
            "collectionId": {
              "type": "string",
              "description": "The collection ID to query across all documents (without parent path)"
            }
          },
          "required": [
            "collectionId"
          ]
        }
      }
    ]
  },
  {
    "name": "garylab-serper-mcp-server",
    "title": "Serper MCP Server",
    "description": "A Model Context Protocol server that enables LLMs to perform Google searches via the Serper API, allowing models to retrieve current information from the web.",
    "icon": "https://avatars.githubusercontent.com/garylab",
    "isOfficial": false,
    "homepage": "https://github.com/garylab/serper-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "serper-mcp-server"
      ],
      "env": {
        "SERPER_API_KEY": "<serper-api-key>"
      }
    },
    "parameters": [
      {
        "name": "SERPER_API_KEY",
        "description": "Your Serper API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "google_search",
        "description": "Search Google for a query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "title": "Q",
              "description": "The query to search for"
            },
            "gl": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Gl",
              "default": null,
              "description": "The country to search in, e.g. us, uk, ca, au, etc."
            },
            "hl": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Hl",
              "default": null,
              "description": "The language to search in, e.g. en, es, fr, de, etc."
            },
            "num": {
              "max": 100,
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Num",
              "default": 10,
              "description": "The number of results to return, max is 100"
            },
            "tbs": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tbs",
              "default": null,
              "description": "The time period to search in, e.g. d, w, m, y"
            },
            "page": {
              "min": 1,
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Page",
              "default": 1,
              "description": "The page number to return, first page is 1"
            },
            "location": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Location",
              "default": null,
              "description": "The location to search in, e.g. San Francisco, CA, USA"
            }
          },
          "required": [
            "q"
          ]
        }
      }
    ]
  },
  {
    "name": "genomoncology-biomcp",
    "title": "BioMCP",
    "description": "Provides LLMs with structured access to critical biomedical databases including PubTator3 (PubMed/PMC), ClinicalTrials.gov, and MyVariant.info through the Model Context Protocol.",
    "icon": "https://avatars.githubusercontent.com/genomoncology",
    "isOfficial": false,
    "homepage": "https://github.com/genomoncology/biomcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "biomcp-python"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "article_details",
        "description": "\n    Retrieves details for a single PubMed article given its\n    PubMed ID (PMID).\n    Input: A single PMID (e.g., 34397683)\n    Process: Calls the PubTator3 API to fetch the article's\n             title, abstract, and full text (if available).\n    Output: A Markdown formatted string containing the\n            retrieved article content.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pmid": {
              "type": "string",
              "title": "pmid"
            }
          },
          "required": [
            "pmid"
          ]
        }
      },
      {
        "name": "article_searcher",
        "description": "\n    Searches PubMed articles using structured criteria.\n    Input: A `PubmedRequest` object containing lists for `genes`,\n           `variants`, `diseases`, `chemicals`, and `keywords`.\n           Use full terms (\"Non-small cell lung carcinoma\") over\n           abbreviations (\"NSCLC\"). Use keywords to specify terms\n           that don't fit in disease, gene (\"EGFR\"), chemical (\"Cisplatin\"),\n           or variant (\"BRAF V600E\").\n    Process: Resolves entities then queries PubTator3's search API.\n    Output: A Markdown formatted list summarizing matching articles\n            (PMID, title, abstract, etc.). Limited to max 40 results.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "request": {
              "$ref": "#/$defs/PubmedRequest"
            }
          },
          "required": [
            "request"
          ]
        }
      },
      {
        "name": "trial_protocol",
        "description": "\n    Retrieves core protocol information for a single clinical\n    trial identified by its NCT ID.\n    Input: A single NCT ID (string, e.g., \"NCT04280705\").\n    Process: Fetches standard \"Protocol\" view modules (like ID,\n             Status, Sponsor, Design, Eligibility) from the\n             ClinicalTrials.gov v2 API.\n    Output: A Markdown formatted string detailing title, status,\n            sponsor, purpose, study design, phase, interventions,\n            eligibility criteria, etc. Returns error if invalid.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "nct_id": {
              "type": "string",
              "title": "Nct Id"
            }
          },
          "required": [
            "nct_id"
          ]
        }
      },
      {
        "name": "trial_locations",
        "description": "\n    Retrieves contact and location details for a single\n    clinical trial identified by its NCT ID.\n    Input: A single NCT ID (string, e.g., \"NCT04280705\").\n    Process: Fetches the `ContactsLocationsModule` from the\n             ClinicalTrials.gov v2 API for the given NCT ID.\n    Output: A Markdown formatted string detailing facility names,\n            addresses (city, state, country), and contact info.\n            Returns an error message if the NCT ID is invalid.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "nct_id": {
              "type": "string",
              "title": "Nct Id"
            }
          },
          "required": [
            "nct_id"
          ]
        }
      },
      {
        "name": "trial_outcomes",
        "description": "\n    Retrieves outcome measures, results (if available), and\n    adverse event data for a single clinical trial.\n    Input: A single NCT ID (string, e.g., \"NCT04280705\").\n    Process: Fetches the `OutcomesModule` and `ResultsSection`\n             from the ClinicalTrials.gov v2 API for the NCT ID.\n    Output: A Markdown formatted string detailing primary/secondary\n            outcomes, participant flow, results tables (if posted),\n            and adverse event summaries. Returns an error if invalid.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "nct_id": {
              "type": "string",
              "title": "Nct Id"
            }
          },
          "required": [
            "nct_id"
          ]
        }
      },
      {
        "name": "trial_references",
        "description": "\n    Retrieves publications and other references associated with\n    a single clinical trial identified by its NCT ID.\n    Input: A single NCT ID (string, e.g., \"NCT04280705\").\n    Process: Fetches the `ReferencesModule` from the\n             ClinicalTrials.gov v2 API for the NCT ID.\n    Output: A Markdown formatted string listing citations,\n            associated PubMed IDs (PMIDs), and reference types\n            (e.g., result publication). Returns error if invalid.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "nct_id": {
              "type": "string",
              "title": "Nct Id"
            }
          },
          "required": [
            "nct_id"
          ]
        }
      },
      {
        "name": "trial_searcher",
        "description": "\n    Searches for clinical trials based on specified criteria.\n    Input: A `TrialQuery` object containing fields like `conditions`,\n           `interventions`, `terms`, `recruiting_status`, `phase`,\n           `location` (lat/long/distance), date ranges, etc.\n    Process: Queries the ClinicalTrials.gov v2 API\n    Output: A Markdown formatted list summarizing matching trials\n            (NCT ID, Title, Status, Conditions, Interventions,\n            Summary). Results are typically paginated by the API.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "$ref": "#/$defs/TrialQuery"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "variant_searcher",
        "description": "\n    Searches for genetic variants based on specified criteria.\n    Input: A `VariantQuery` object containing fields like `gene`,\n           HGVS notations `hgvsp`, `hgvsc`), `rsid`, `region`,\n           `significance`, frequency ranges, prediction scores, etc.\n    Process: Constructs a query for the MyVariant.info query\n             endpoint (`/v1/query`) based on the input object.\n    Output: A Markdown formatted list summarizing matching variants\n            with key annotations (ID, gene, significance, frequency).\n            Includes a summary section with total hits found.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "$ref": "#/$defs/VariantQuery"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "variant_details",
        "description": "\n    Retrieves detailed information for a *single* genetic variant.\n    Input: A variant identifier (\"chr7:g.140453136A>T\")\n    Process: Queries the MyVariant.info GET endpoint\n    Output: A Markdown formatted string containing comprehensive\n            variant annotations (genomic context, frequencies,\n            predictions, clinical data). Returns error if invalid.\n    Note: Use the variant_searcher to find the variant id first.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "variant_id": {
              "type": "string",
              "title": "Variant Id"
            }
          },
          "required": [
            "variant_id"
          ]
        }
      }
    ]
  },
  {
    "name": "gerred-mcpmc",
    "title": "MCPMC (Minecraft MCP)",
    "description": "Enables AI agents to control Minecraft bots through a standardized JSON-RPC interface.",
    "icon": "https://avatars.githubusercontent.com/gerred",
    "isOfficial": false,
    "homepage": "https://github.com/gerred/mcpmc",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@gerred/mcpmc"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "gimjin-message-mcp",
    "title": "message-mcp",
    "description": "Real-time push notifications and alert sounds free you from staring at the screen. While the AI works, you can comfortably enjoy a cup of coffee.",
    "icon": "https://avatars.githubusercontent.com/gimjin",
    "isOfficial": false,
    "homepage": "https://github.com/gimjin/message-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "message-mcp"
      ],
      "env": {
        "SMTP_URL": "<smtp-url>",
        "WEBHOOK_URL": "<webhook-url>"
      }
    },
    "parameters": [
      {
        "name": "SMTP_URL",
        "description": "SMTP URL for email notifications (e.g., smtp://your-email@gmail.com:your-app-password@smtp.gmail.com:587)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "WEBHOOK_URL",
        "description": "URL endpoint for webhook notifications",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "notify",
        "description": "Send notifications and messages through multiple channels (desktop, email, API). Use this tool to notify users about any important information, progress updates, task completions, alerts, or any other communication needs.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "The main content of the notification message"
            }
          }
        }
      }
    ]
  },
  {
    "name": "gitmotion-ntfy-me-mcp",
    "title": "ntfy-me-mcp",
    "description": "A streamlined MCP server that enables AI assistants to send real-time notifications to your devices through the ntfy service, allowing you to receive alerts when tasks complete or important events occur.",
    "icon": "https://avatars.githubusercontent.com/gitmotion",
    "isOfficial": false,
    "homepage": "https://github.com/gitmotion/ntfy-me-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "ntfy-me-mcp"
      ],
      "env": {
        "NTFY_URL": "<ntfy-url>",
        "NTFY_TOKEN": "<ntfy-token>",
        "NTFY_TOPIC": "<ntfy-topic>",
        "PROTECTED_TOPIC": "<protected-topic>"
      }
    },
    "parameters": [
      {
        "name": "NTFY_URL",
        "description": "URL of the ntfy server (change to your self-hosted ntfy server URL if needed)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NTFY_TOKEN",
        "description": "Access token for authentication with protected topics/servers",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NTFY_TOPIC",
        "description": "Your ntfy topic name for sending notifications",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "PROTECTED_TOPIC",
        "description": "Set to 'true' if your topic requires authentication (helps prevent auth errors)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "ntfy_me",
        "description": "Send a notification to the user via ntfy. Use this tool when the user asks to 'send a notification', 'notify me', 'send me an alert', 'message me', 'ping me', or any similar request. This tool is perfect for sending status updates, alerts, reminders, or notifications about completed tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tags for the notification"
            },
            "actions": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "action",
                  "label",
                  "url"
                ],
                "properties": {
                  "url": {
                    "type": "string"
                  },
                  "clear": {
                    "type": "boolean"
                  },
                  "label": {
                    "type": "string"
                  },
                  "action": {
                    "type": "string",
                    "const": "view"
                  }
                },
                "additionalProperties": false
              },
              "description": "Optional array of view actions to add to the notification"
            },
            "ntfyUrl": {
              "type": "string",
              "description": "Optional custom ntfy URL (defaults to NTFY_URL env var or https://ntfy.sh)"
            },
            "markdown": {
              "type": "boolean",
              "description": "Whether to format the message with Markdown support"
            },
            "priority": {
              "enum": [
                "min",
                "low",
                "default",
                "high",
                "max"
              ],
              "type": "string",
              "description": "Message priority level"
            },
            "ntfyTopic": {
              "type": "string",
              "description": "Optional custom ntfy topic (defaults to NTFY_TOPIC env var)"
            },
            "taskTitle": {
              "type": "string",
              "description": "Current task title/status"
            },
            "accessToken": {
              "type": "string",
              "description": "Optional access token for authentication (defaults to NTFY_TOKEN env var)"
            },
            "taskSummary": {
              "type": "string",
              "description": "Current task summary"
            }
          },
          "required": [
            "taskTitle",
            "taskSummary"
          ]
        }
      },
      {
        "name": "ntfy_me_fetch",
        "description": "Fetch cached messages from an ntfy server topic. Use this tool when the user asks to 'show notifications', 'get my messages', 'show my alerts', 'find notifications', 'search notifications', or any similar request. Great for finding recent notifications, checking message history, or searching for specific notifications by content, title, tags, or priority.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Find messages with specific tags (e.g., 'error', 'warning', 'success')"
            },
            "since": {
              "type": [
                "string",
                "number"
              ],
              "description": "How far back to retrieve messages: timespan (e.g., '10m', '1h', '1d'), timestamp, message ID, or 'all' for all messages. Default: 10 minutes"
            },
            "ntfyUrl": {
              "type": "string",
              "description": "Optional custom ntfy server URL (defaults to NTFY_URL env var or https://ntfy.sh)"
            },
            "messageId": {
              "type": "string",
              "description": "Find a specific message by its ID"
            },
            "ntfyTopic": {
              "type": "string",
              "description": "Optional custom ntfy topic/channel to get messages from (defaults to NTFY_TOPIC env var)"
            },
            "priorities": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ],
              "description": "Find messages with specific priority levels (min, low, default, high, max)"
            },
            "accessToken": {
              "type": "string",
              "description": "Optional access token for authentication (defaults to NTFY_TOKEN env var)"
            },
            "messageText": {
              "type": "string",
              "description": "Find messages containing this exact text content"
            },
            "messageTitle": {
              "type": "string",
              "description": "Find messages with this exact title/subject"
            }
          }
        }
      }
    ]
  },
  {
    "name": "bsreeram08-git-commands-mcp",
    "title": "Git Repo Browser MCP",
    "description": "A Node.js implementation that enables browsing Git repositories through the Model Context Protocol, providing features like displaying directory structures, reading files, searching code, comparing branches, and viewing commit history.",
    "icon": "https://avatars.githubusercontent.com/bsreeram08",
    "isOfficial": false,
    "homepage": "https://github.com/bsreeram08/git-commands-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "git-commands-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "git_directory_structure",
        "description": "Clone a Git repository and return its directory structure in a tree format.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo_url": {
              "type": "string",
              "description": "The URL of the Git repository"
            }
          },
          "required": [
            "repo_url"
          ]
        }
      },
      {
        "name": "git_read_files",
        "description": "Read the contents of specified files in a given git repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo_url": {
              "type": "string",
              "description": "The URL of the Git repository"
            },
            "file_paths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of file paths to read (relative to repository root)"
            }
          },
          "required": [
            "repo_url",
            "file_paths"
          ]
        }
      },
      {
        "name": "git_branch_diff",
        "description": "Compare two branches and show files changed between them.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo_url": {
              "type": "string",
              "description": "The URL of the Git repository"
            },
            "show_patch": {
              "type": "boolean",
              "default": false,
              "description": "Whether to include the actual diff patches"
            },
            "source_branch": {
              "type": "string",
              "description": "The source branch name"
            },
            "target_branch": {
              "type": "string",
              "description": "The target branch name"
            }
          },
          "required": [
            "repo_url",
            "source_branch",
            "target_branch"
          ]
        }
      },
      {
        "name": "git_checkout_branch",
        "description": "Create and/or checkout a branch.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "create": {
              "type": "boolean",
              "default": false,
              "description": "Whether to create a new branch"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            },
            "branch_name": {
              "type": "string",
              "description": "The name of the branch to checkout"
            },
            "start_point": {
              "type": "string",
              "description": "Starting point for the branch (optional)"
            }
          },
          "required": [
            "repo_path",
            "branch_name"
          ]
        }
      },
      {
        "name": "git_delete_branch",
        "description": "Delete a branch from the repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "force": {
              "type": "boolean",
              "default": false,
              "description": "Whether to force deletion"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            },
            "branch_name": {
              "type": "string",
              "description": "The name of the branch to delete"
            }
          },
          "required": [
            "repo_path",
            "branch_name"
          ]
        }
      },
      {
        "name": "git_merge_branch",
        "description": "Merge a source branch into the current or target branch.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            },
            "source_branch": {
              "type": "string",
              "description": "Branch to merge from"
            },
            "target_branch": {
              "type": "string",
              "description": "Branch to merge into (optional, uses current branch if not provided)"
            },
            "no_fast_forward": {
              "type": "boolean",
              "default": false,
              "description": "Whether to create a merge commit even if fast-forward is possible"
            }
          },
          "required": [
            "repo_path",
            "source_branch"
          ]
        }
      },
      {
        "name": "git_commit_history",
        "description": "Get commit history for a branch with optional filtering.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "grep": {
              "type": "string",
              "description": "Filter commits by message content (optional)"
            },
            "since": {
              "type": "string",
              "description": "Get commits after this date (e.g., \"1 week ago\", \"2023-01-01\")"
            },
            "until": {
              "type": "string",
              "description": "Get commits before this date (e.g., \"yesterday\", \"2023-12-31\")"
            },
            "author": {
              "type": "string",
              "description": "Filter by author (optional)"
            },
            "branch": {
              "type": "string",
              "default": "main",
              "description": "The branch to get history from"
            },
            "repo_url": {
              "type": "string",
              "description": "The URL of the Git repository"
            },
            "max_count": {
              "type": "integer",
              "default": 10,
              "description": "Maximum number of commits to retrieve"
            }
          },
          "required": [
            "repo_url"
          ]
        }
      },
      {
        "name": "git_commits_details",
        "description": "Get detailed information about commits including full messages and diffs.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "grep": {
              "type": "string",
              "description": "Filter commits by message content (optional)"
            },
            "since": {
              "type": "string",
              "description": "Get commits after this date (e.g., \"1 week ago\", \"2023-01-01\")"
            },
            "until": {
              "type": "string",
              "description": "Get commits before this date (e.g., \"yesterday\", \"2023-12-31\")"
            },
            "author": {
              "type": "string",
              "description": "Filter by author (optional)"
            },
            "branch": {
              "type": "string",
              "default": "main",
              "description": "The branch to get commits from"
            },
            "repo_url": {
              "type": "string",
              "description": "The URL of the Git repository"
            },
            "max_count": {
              "type": "integer",
              "default": 10,
              "description": "Maximum number of commits to retrieve"
            },
            "include_diff": {
              "type": "boolean",
              "default": false,
              "description": "Whether to include the commit diffs"
            }
          },
          "required": [
            "repo_url"
          ]
        }
      },
      {
        "name": "git_commit",
        "description": "Create a commit with the specified message.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "The commit message"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path",
            "message"
          ]
        }
      },
      {
        "name": "git_track",
        "description": "Track (stage) specific files or all files.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "files": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [
                "."
              ],
              "description": "Array of file paths to track/stage (use [\".\"] for all files)"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path"
          ]
        }
      },
      {
        "name": "git_local_changes",
        "description": "Get uncommitted changes in the working directory.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path"
          ]
        }
      },
      {
        "name": "git_search_code",
        "description": "Search for patterns in repository code.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string",
              "description": "Search pattern (regex or string)"
            },
            "repo_url": {
              "type": "string",
              "description": "The URL of the Git repository"
            },
            "context_lines": {
              "type": "integer",
              "default": 2,
              "description": "Number of context lines to include"
            },
            "file_patterns": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional file patterns to filter (e.g., \"*.js\")"
            },
            "case_sensitive": {
              "type": "boolean",
              "default": false,
              "description": "Whether the search is case sensitive"
            }
          },
          "required": [
            "repo_url",
            "pattern"
          ]
        }
      },
      {
        "name": "git_push",
        "description": "Push changes to a remote repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "force": {
              "type": "boolean",
              "default": false,
              "description": "Whether to force push"
            },
            "branch": {
              "type": "string",
              "description": "Branch to push (default: current branch)"
            },
            "remote": {
              "type": "string",
              "default": "origin",
              "description": "Remote name"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path"
          ]
        }
      },
      {
        "name": "git_pull",
        "description": "Pull changes from a remote repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "branch": {
              "type": "string",
              "description": "Branch to pull (default: current branch)"
            },
            "rebase": {
              "type": "boolean",
              "default": false,
              "description": "Whether to rebase instead of merge"
            },
            "remote": {
              "type": "string",
              "default": "origin",
              "description": "Remote name"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path"
          ]
        }
      },
      {
        "name": "git_stash",
        "description": "Create or apply a stash.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "index": {
              "type": "integer",
              "default": 0,
              "description": "Stash index (for pop, apply, drop actions)"
            },
            "action": {
              "enum": [
                "save",
                "pop",
                "apply",
                "list",
                "drop"
              ],
              "type": "string",
              "default": "save",
              "description": "Stash action (save, pop, apply, list, drop)"
            },
            "message": {
              "type": "string",
              "default": "",
              "description": "Stash message (for save action)"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path"
          ]
        }
      },
      {
        "name": "git_create_tag",
        "description": "Create a tag.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "default": "",
              "description": "Tag message (for annotated tags)"
            },
            "tag_name": {
              "type": "string",
              "description": "Name of the tag"
            },
            "annotated": {
              "type": "boolean",
              "default": true,
              "description": "Whether to create an annotated tag"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path",
            "tag_name"
          ]
        }
      },
      {
        "name": "git_rebase",
        "description": "Rebase the current branch onto another branch or commit.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "onto": {
              "type": "string",
              "description": "Branch or commit to rebase onto"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            },
            "interactive": {
              "type": "boolean",
              "default": false,
              "description": "Whether to perform an interactive rebase"
            }
          },
          "required": [
            "repo_path",
            "onto"
          ]
        }
      },
      {
        "name": "git_config",
        "description": "Configure git settings for the repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "Configuration key"
            },
            "scope": {
              "enum": [
                "local",
                "global",
                "system"
              ],
              "type": "string",
              "default": "local",
              "description": "Configuration scope (local, global, system)"
            },
            "value": {
              "type": "string",
              "description": "Configuration value"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path",
            "key",
            "value"
          ]
        }
      },
      {
        "name": "git_reset",
        "description": "Reset repository to specified commit or state.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "string",
              "default": "HEAD",
              "description": "Commit or reference to reset to"
            },
            "mode": {
              "enum": [
                "soft",
                "mixed",
                "hard"
              ],
              "type": "string",
              "default": "mixed",
              "description": "Reset mode (soft, mixed, hard)"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path"
          ]
        }
      },
      {
        "name": "git_archive",
        "description": "Create a git archive (zip or tar).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "format": {
              "enum": [
                "zip",
                "tar"
              ],
              "type": "string",
              "default": "zip",
              "description": "Archive format (zip or tar)"
            },
            "prefix": {
              "type": "string",
              "description": "Prefix for files in the archive"
            },
            "treeish": {
              "type": "string",
              "default": "HEAD",
              "description": "Tree-ish to archive (default: HEAD)"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            },
            "output_path": {
              "type": "string",
              "description": "Output path for the archive"
            }
          },
          "required": [
            "repo_path",
            "output_path"
          ]
        }
      },
      {
        "name": "git_attributes",
        "description": "Manage git attributes for files.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "enum": [
                "get",
                "set",
                "list"
              ],
              "type": "string",
              "default": "list",
              "description": "Action (get, set, list)"
            },
            "pattern": {
              "type": "string",
              "description": "File pattern"
            },
            "attribute": {
              "type": "string",
              "description": "Attribute to set"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path",
            "action"
          ]
        }
      },
      {
        "name": "git_blame",
        "description": "Get blame information for a file.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "rev": {
              "type": "string",
              "default": "HEAD",
              "description": "Revision to blame (default: HEAD)"
            },
            "file_path": {
              "type": "string",
              "description": "Path to the file"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path",
            "file_path"
          ]
        }
      },
      {
        "name": "git_clean",
        "description": "Perform git clean operations.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "force": {
              "type": "boolean",
              "default": false,
              "description": "Whether to force clean"
            },
            "dry_run": {
              "type": "boolean",
              "default": true,
              "description": "Whether to perform a dry run"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            },
            "directories": {
              "type": "boolean",
              "default": false,
              "description": "Whether to remove directories as well"
            }
          },
          "required": [
            "repo_path"
          ]
        }
      },
      {
        "name": "git_hooks",
        "description": "Manage git hooks in the repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "enum": [
                "list",
                "get",
                "create",
                "enable",
                "disable"
              ],
              "type": "string",
              "default": "list",
              "description": "Hook action (list, get, create, enable, disable)"
            },
            "script": {
              "type": "string",
              "description": "Script content for the hook (for create action)"
            },
            "hook_name": {
              "type": "string",
              "description": "Name of the hook (e.g., 'pre-commit', 'post-merge')"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path",
            "action"
          ]
        }
      },
      {
        "name": "git_lfs",
        "description": "Manage Git LFS (Large File Storage).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "enum": [
                "install",
                "track",
                "untrack",
                "list"
              ],
              "type": "string",
              "default": "list",
              "description": "LFS action (install, track, untrack, list)"
            },
            "patterns": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "File patterns for track/untrack"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path",
            "action"
          ]
        }
      },
      {
        "name": "git_lfs_fetch",
        "description": "Fetch LFS objects from the remote repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dry_run": {
              "type": "boolean",
              "default": false,
              "description": "Whether to perform a dry run"
            },
            "pointers": {
              "type": "boolean",
              "default": false,
              "description": "Whether to convert pointers to objects"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path"
          ]
        }
      },
      {
        "name": "git_revert",
        "description": "Revert the current branch to a commit or state.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "commit": {
              "type": "string",
              "description": "Commit hash or reference to revert"
            },
            "no_commit": {
              "type": "boolean",
              "default": false,
              "description": "Whether to stage changes without committing"
            },
            "repo_path": {
              "type": "string",
              "description": "The path to the local Git repository"
            }
          },
          "required": [
            "repo_path"
          ]
        }
      }
    ]
  },
  {
    "name": "modelcontextprotocol-servers-google-search-mcp",
    "title": "Google Search MCP",
    "description": "A Playwright-based tool that performs Google searches and extracts results while bypassing anti-bot mechanisms, providing real-time search capabilities for AI assistants.",
    "icon": "https://avatars.githubusercontent.com/modelcontextprotocol-servers",
    "isOfficial": false,
    "homepage": "https://github.com/modelcontextprotocol-servers/google-search-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@mcp-server/google-search-mcp"
      ],
      "env": {
        "limit": "<limit>",
        "query": "<query>",
        "region": "<region>",
        "timeout": "<timeout>",
        "language": "<language>"
      }
    },
    "parameters": [
      {
        "name": "limit",
        "description": "Number of search results to return, default is 10",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "query",
        "description": "Search query string",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "region",
        "description": "Region for search results, e.g., cn, com, co.jp, default is cn",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "timeout",
        "description": "Search operation timeout in milliseconds, default is 60000",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "language",
        "description": "Language for search results, e.g., zh-CN, en-US, default is zh-CN",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "search",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "返回的搜索结果数量，默认为10"
            },
            "query": {
              "type": "string",
              "description": "搜索查询字符串"
            },
            "region": {
              "type": "string",
              "description": "搜索结果的地区，例如 cn, com, co.jp 等，默认为 cn"
            },
            "timeout": {
              "type": "number",
              "description": "搜索操作的超时时间(毫秒)，默认为60000"
            },
            "language": {
              "type": "string",
              "description": "搜索结果的语言，例如 zh-CN, en-US 等，默认为 zh-CN"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "graphlit-graphlit-mcp-server",
    "title": "Graphlit MCP Server",
    "description": "The Model Context Protocol (MCP) Server enables integration between MCP clients and the Graphlit service.\n\nIngest anything from Slack to Gmail to podcast feeds, in addition to web crawling, into a Graphlit project - and then retrieve relevant contents from the MCP client.",
    "icon": "https://avatars.githubusercontent.com/graphlit",
    "isOfficial": true,
    "homepage": "https://github.com/graphlit/graphlit-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "graphlit-mcp-server"
      ],
      "env": {
        "JIRA_EMAIL": "<jira-email>",
        "JIRA_TOKEN": "<jira-token>",
        "LINEAR_API_KEY": "<linear-api-key>",
        "NOTION_API_KEY": "<notion-api-key>",
        "SLACK_BOT_TOKEN": "<slack-bot-token>",
        "DISCORD_BOT_TOKEN": "<discord-bot-token>",
        "NOTION_DATABASE_ID": "<notion-database-id>",
        "GRAPHLIT_JWT_SECRET": "<graphlit-jwt-secret>",
        "GOOGLE_EMAIL_CLIENT_ID": "<google-email-client-id>",
        "GRAPHLIT_ENVIRONMENT_ID": "<graphlit-environment-id>",
        "GRAPHLIT_ORGANIZATION_ID": "<graphlit-organization-id>",
        "GOOGLE_EMAIL_CLIENT_SECRET": "<google-email-client-secret>",
        "GOOGLE_EMAIL_REFRESH_TOKEN": "<google-email-refresh-token>",
        "GITHUB_PERSONAL_ACCESS_TOKEN": "<github-personal-access-token>"
      }
    },
    "parameters": [
      {
        "name": "JIRA_EMAIL",
        "description": "Your Jira email for Jira data connector integration",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "JIRA_TOKEN",
        "description": "Your Jira token for Jira data connector integration",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "LINEAR_API_KEY",
        "description": "Your Linear API key for Linear data connector integration",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NOTION_API_KEY",
        "description": "Your Notion API key for Notion data connector integration",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "SLACK_BOT_TOKEN",
        "description": "Your Slack bot token for Slack data connector integration",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DISCORD_BOT_TOKEN",
        "description": "Your Discord bot token for Discord data connector integration",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NOTION_DATABASE_ID",
        "description": "Your Notion database ID for Notion data connector integration",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GRAPHLIT_JWT_SECRET",
        "description": "Your JWT secret for signing the JWT token found in the API settings dashboard",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "GOOGLE_EMAIL_CLIENT_ID",
        "description": "Your Google client ID for Google Mail data connector integration",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GRAPHLIT_ENVIRONMENT_ID",
        "description": "Your Graphlit environment ID found in the API settings dashboard",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "GRAPHLIT_ORGANIZATION_ID",
        "description": "Your Graphlit organization ID found in the API settings dashboard",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "GOOGLE_EMAIL_CLIENT_SECRET",
        "description": "Your Google client secret for Google Mail data connector integration",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GOOGLE_EMAIL_REFRESH_TOKEN",
        "description": "Your Google refresh token for Google Mail data connector integration",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GITHUB_PERSONAL_ACCESS_TOKEN",
        "description": "Your GitHub personal access token for GitHub data connector integration",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "retrieveContent",
        "description": "Retrieve content from Graphlit knowledge base.\n   Accepts a search prompt, optional recency filter (defaults to last 30 days), and optional content type and file type filters.\n   Prompt should be optimized for vector search, via text embeddings. Rewrite prompt as appropriate for higher relevance to search results.\n   Returns the content sources in XML format, including metadata and Markdown text.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inLast": {
              "type": "string",
              "default": "P30D",
              "description": "Recency filter for content 'in last' timespan, optional. Should be ISO 8601 format, for example, 'PT1H' for last hour, 'P1D' for last day, 'P7D' for last week, 'P30D' for last month. Doesn't support weeks or months explicitly."
            },
            "prompt": {
              "type": "string",
              "description": "Search prompt for content retrieval."
            },
            "fileType": {
              "enum": [
                "ANIMATION",
                "AUDIO",
                "CODE",
                "DATA",
                "DOCUMENT",
                "DRAWING",
                "EMAIL",
                "GEOMETRY",
                "IMAGE",
                "MANIFEST",
                "PACKAGE",
                "POINT_CLOUD",
                "SHAPE",
                "UNKNOWN",
                "VIDEO"
              ],
              "type": "string",
              "description": "File type filter, optional. One of: Animation, Audio, Code, Data, Document, Drawing, Email, Geometry, Image, Package, PointCloud, Shape, Video."
            },
            "contentType": {
              "enum": [
                "EMAIL",
                "EVENT",
                "FILE",
                "ISSUE",
                "MESSAGE",
                "PAGE",
                "POST",
                "TEXT"
              ],
              "type": "string",
              "description": "Content type filter, optional. One of: Email, Event, File, Issue, Message, Page, Post, Text."
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "queryFeeds",
        "description": "Query feeds by name and/or feed type.\n   Returns the feed name, identifier and other feed properties.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Feed name."
            },
            "feedType": {
              "enum": [
                "DISCORD",
                "EMAIL",
                "INTERCOM",
                "ISSUE",
                "MICROSOFT_TEAMS",
                "NOTION",
                "REDDIT",
                "RSS",
                "SEARCH",
                "SITE",
                "SLACK",
                "WEB",
                "YOU_TUBE",
                "ZENDESK"
              ],
              "type": "string",
              "description": "Feed type filter, optional. One of: Discord, Email, Intercom, Issue, MicrosoftTeams, Notion, Reddit, Rss, Search, Site, Slack, Web, YouTube, Zendesk."
            }
          }
        }
      },
      {
        "name": "deleteFeed",
        "description": "Delete a feed and all of its ingested content.\n   Accepts a feed identifier which was returned from one of the ingestion tools, like ingestGoogleDriveFiles.\n   Content deletion will happen asynchronously.\n   Returns the feed identifier and feed state, i.e. Deleted.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Feed identifier."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "isFeedDone",
        "description": "Check if an asynchronous feed has completed ingesting all the available content.\n   Accepts a feed identifier which was returned from one of the ingestion tools, like ingestGoogleDriveFiles.\n   Returns whether the feed is done or not.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Feed identifier."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "listMicrosoftTeamsTeams",
        "description": "Lists available Microsoft Teams teams.\n    Returns a list of Microsoft Teams teams, where the team identifier can be used with listMicrosoftTeamsChannels to enumerate Microsoft Teams channels.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "listMicrosoftTeamsChannels",
        "description": "Lists available Microsoft Teams channels.\n    Returns a list of Microsoft Teams channels, where the channel identifier can be used with ingestMicrosoftTeamsMessages to ingest messages into Graphlit knowledge base.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "teamId": {
              "type": "string"
            }
          },
          "required": [
            "teamId"
          ]
        }
      },
      {
        "name": "listSlackChannels",
        "description": "Lists available Slack channels.\n    Returns a list of Slack channels, where the channel name can be used with ingestSlackMessages to ingest messages into Graphlit knowledge base.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "listSharePointLibraries",
        "description": "Lists available SharePoint libraries.\n   Returns a list of SharePoint libraries, where the selected libraryId can be used with listSharePointFolders to enumerate SharePoint folders in a library.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "listSharePointFolders",
        "description": "Lists available SharePoint folders.\n    Returns a list of SharePoint folders, which can be used with ingestSharePointFiles to ingest files into Graphlit knowledge base.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "libraryId": {
              "type": "string"
            }
          },
          "required": [
            "libraryId"
          ]
        }
      },
      {
        "name": "ingestSharePointFiles",
        "description": "Ingests files from SharePoint library into Graphlit knowledge base.\n   Accepts a SharePoint libraryId and an optional folderId to ingest files from a specific SharePoint folder.\n   Libraries can be enumerated with listSharePointLibraries and library folders with listSharePointFolders.\n   Accepts an optional read limit for the number of files to ingest.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "folderId": {
              "type": "string"
            },
            "libraryId": {
              "type": "string"
            },
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "libraryId"
          ]
        }
      },
      {
        "name": "ingestOneDriveFiles",
        "description": "Ingests files from OneDrive folder into Graphlit knowledge base.\n   Accepts an optional read limit for the number of files to ingest.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestGoogleDriveFiles",
        "description": "Ingests files from Google Drive folder into Graphlit knowledge base.\n   Accepts an optional read limit for the number of files to ingest.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestDropboxFiles",
        "description": "Ingests files from Dropbox folder into Graphlit knowledge base.\n   Accepts optional relative path to Dropbox folder (i.e. /Pictures), and an optional read limit for the number of files to ingest.\n   If no path provided, ingests files from root Dropbox folder.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string"
            },
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestBoxFiles",
        "description": "Ingests files from Box folder into Graphlit knowledge base.\n   Accepts optional Box folder identifier, and an optional read limit for the number of files to ingest.\n   If no folder identifier provided, ingests files from root Box folder (i.e. \"0\").\n   Folder identifier can be inferred from Box URL. https://app.box.com/folder/123456 -> folder identifier is \"123456\".\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "folderId": {
              "type": "string",
              "default": "0"
            },
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestGitHubFiles",
        "description": "Ingests files from GitHub repository into Graphlit knowledge base.\n   Accepts GitHub repository owner and repository name and an optional read limit for the number of files to ingest.\n   For example, for GitHub repository (https://github.com/openai/tiktoken), 'openai' is the repository owner, and 'tiktoken' is the repository name.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of files to ingest, optional. Defaults to 100."
            },
            "repositoryName": {
              "type": "string",
              "description": "GitHub repository name."
            },
            "repositoryOwner": {
              "type": "string",
              "description": "GitHub repository owner."
            }
          },
          "required": [
            "repositoryName",
            "repositoryOwner"
          ]
        }
      },
      {
        "name": "ingestNotionPages",
        "description": "Ingests pages from Notion database into Graphlit knowledge base.\n    Accepts an optional read limit for the number of messages to ingest.\n    Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of pages to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestMicrosoftTeamsMessages",
        "description": "Ingests messages from Microsoft Teams channel into Graphlit knowledge base.\n   Accepts Microsoft Teams team identifier and channel identifier, and an optional read limit for the number of messages to ingest.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "teamId": {
              "type": "string"
            },
            "channelId": {
              "type": "string"
            },
            "readLimit": {
              "type": "number",
              "description": "Number of messages to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "teamId",
            "channelId"
          ]
        }
      },
      {
        "name": "ingestSlackMessages",
        "description": "Ingests messages from Slack channel into Graphlit knowledge base.\n    Accepts Slack channel name and an optional read limit for the number of messages to ingest.\n    Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of messages to ingest, optional. Defaults to 100."
            },
            "channelName": {
              "type": "string"
            }
          },
          "required": [
            "channelName"
          ]
        }
      },
      {
        "name": "ingestDiscordMessages",
        "description": "Ingests messages from Discord channel into Graphlit knowledge base.\n    Accepts Discord channel name and an optional read limit for the number of messages to ingest.\n    Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of messages to ingest, optional. Defaults to 100."
            },
            "channelName": {
              "type": "string"
            }
          },
          "required": [
            "channelName"
          ]
        }
      },
      {
        "name": "ingestRedditPosts",
        "description": "Ingests posts from Reddit subreddit into Graphlit knowledge base.\n    Accepts a subreddit name and an optional read limit for the number of posts to ingest.\n    Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of posts to ingest, optional. Defaults to 100."
            },
            "subredditName": {
              "type": "string"
            }
          },
          "required": [
            "subredditName"
          ]
        }
      },
      {
        "name": "ingestGoogleEmail",
        "description": "Ingests emails from Google Email account into Graphlit knowledge base.\n   Accepts an optional read limit for the number of emails to ingest.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of emails to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestMicrosoftEmail",
        "description": "Ingests emails from Microsoft Email account into Graphlit knowledge base.\n   Accepts an optional read limit for the number of emails to ingest.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of emails to ingest, optional. Defaults to 100."
            }
          }
        }
      },
      {
        "name": "ingestLinearIssues",
        "description": "Ingests issues from Linear project into Graphlit knowledge base.\n   Accepts Linear project name and an optional read limit for the number of issues to ingest.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of issues to ingest, optional. Defaults to 100."
            },
            "projectName": {
              "type": "string"
            }
          },
          "required": [
            "projectName"
          ]
        }
      },
      {
        "name": "ingestGitHubIssues",
        "description": "Ingests issues from GitHub repository into Graphlit knowledge base.\n   Accepts GitHub repository owner and repository name and an optional read limit for the number of issues to ingest.\n   For example, for GitHub repository (https://github.com/openai/tiktoken), 'openai' is the repository owner, and 'tiktoken' is the repository name.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "readLimit": {
              "type": "number",
              "description": "Number of issues to ingest, optional. Defaults to 100."
            },
            "repositoryName": {
              "type": "string",
              "description": "GitHub repository name."
            },
            "repositoryOwner": {
              "type": "string",
              "description": "GitHub repository owner."
            }
          },
          "required": [
            "repositoryName",
            "repositoryOwner"
          ]
        }
      },
      {
        "name": "ingestJiraIssues",
        "description": "Ingests issues from Atlassian Jira repository into Graphlit knowledge base.\n   Accepts Atlassian Jira server URL and project name, and an optional read limit for the number of issues to ingest.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            },
            "readLimit": {
              "type": "number",
              "description": "Number of issues to ingest, optional. Defaults to 100."
            },
            "projectName": {
              "type": "string"
            }
          },
          "required": [
            "url",
            "projectName"
          ]
        }
      },
      {
        "name": "webCrawl",
        "description": "Crawls web pages from web site into Graphlit knowledge base.\n   Accepts a URL and an optional read limit for the number of pages to crawl.\n   Uses sitemap.xml to discover pages to be crawled from website.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            },
            "readLimit": {
              "type": "number",
              "description": "Number of web pages to ingest, optional. Defaults to 100."
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "webScrape",
        "description": "Scrapes web page into Graphlit knowledge base.\n   Returns Markdown text and metadata extracted from web page.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "webMap",
        "description": "Enumerates the web pages at or beneath the provided URL using web sitemap.\n   Accepts web page URL as string.\n   Returns list of mapped URIs from web site.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "webSearch",
        "description": "Performs web search based on search query. Format the search query as what would be entered into a Google search.\n   Accepts search query as string, and optional search service type.\n   Search service types: Tavily, Exa. Defaults to Tavily.\n   Returns URL, title and relevant Markdown text from resulting web pages.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "search": {
              "type": "string"
            },
            "searchService": {
              "enum": [
                "EXA",
                "TAVILY"
              ],
              "type": "string",
              "default": "TAVILY"
            }
          },
          "required": [
            "search"
          ]
        }
      },
      {
        "name": "ingestRSS",
        "description": "Ingests posts from RSS feed into Graphlit knowledge base.\n   For podcast RSS feeds, audio will be downloaded, transcribed and ingested into Graphlit knowledge base.\n   Accepts RSS URL and an optional read limit for the number of posts to read.\n   Executes asynchonously and returns the feed identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            },
            "readLimit": {
              "type": "number",
              "description": "Number of issues to posts, optional. Defaults to 25."
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "ingestUrl",
        "description": "Ingests content from URL into Graphlit knowledge base.\n   Can ingest individual Word documents, PDFs, audio recordings, videos, images, or any other unstructured data.\n   Executes asynchonously and returns the content identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "jorgeraad-mcp4gql",
    "title": "mcp4gql",
    "description": "GraphQL MCP Server that acts as a bridge allowing MCP clients (like Cursor or Claude Desktop) to interact with target GraphQL APIs through standard tools for schema introspection and operation execution.",
    "icon": "https://avatars.githubusercontent.com/jorgeraad",
    "isOfficial": false,
    "homepage": "https://github.com/jorgeraad/mcp4gql",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp4gql"
      ],
      "env": {
        "AUTH_TOKEN": "<auth-token>",
        "GRAPHQL_ENDPOINT": "<graphql-endpoint>"
      }
    },
    "parameters": [
      {
        "name": "AUTH_TOKEN",
        "description": "A bearer token for an optional `Authorization: Bearer <token>` header for authenticating with the GraphQL API",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GRAPHQL_ENDPOINT",
        "description": "The URL of the target GraphQL API",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "introspectGraphQLSchema",
        "description": "Fetches the schema of the target GraphQL API using introspection. Returns the schema in JSON format.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "executeGraphQLOperation",
        "description": "Executes an arbitrary GraphQL query or mutation against the target API. Use introspectGraphQLSchema first to understand the available operations.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The GraphQL query string to execute."
            },
            "variables": {
              "type": "object",
              "description": "An optional object containing variables for the query.",
              "additionalProperties": {}
            },
            "operationName": {
              "type": "string",
              "description": "An optional name for the operation, if the query contains multiple operations."
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "greirson-mcp-todoist",
    "title": "Todoist MCP Server",
    "description": "An MCP server that connects Claude with Todoist for complete task and project management through natural language.",
    "icon": "https://avatars.githubusercontent.com/greirson",
    "isOfficial": false,
    "homepage": "https://github.com/greirson/mcp-todoist",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@greirson/mcp-todoist"
      ],
      "env": {
        "TODOIST_API_TOKEN": "<todoist-api-token>"
      }
    },
    "parameters": [
      {
        "name": "TODOIST_API_TOKEN",
        "description": "Your Todoist API token from Settings → Integrations → Developer section",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "todoist_task_create",
        "description": "Create a new task in Todoist with optional description, due date, priority, labels, deadline, project, and section",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of label names to assign to the task (optional)"
            },
            "content": {
              "type": "string",
              "description": "The content/title of the task"
            },
            "priority": {
              "enum": [
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "Task priority from 1 (normal) to 4 (urgent) (optional)"
            },
            "due_string": {
              "type": "string",
              "description": "Natural language due date like 'tomorrow', 'next Monday', 'Jan 23' (optional)"
            },
            "project_id": {
              "type": "string",
              "description": "Project ID to assign the task to (optional)"
            },
            "section_id": {
              "type": "string",
              "description": "Section ID within the project to assign the task to (optional)"
            },
            "description": {
              "type": "string",
              "description": "Detailed description of the task (optional)"
            },
            "deadline_date": {
              "type": "string",
              "description": "Task deadline in YYYY-MM-DD format (when user mentions 'deadline') (optional)"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "todoist_task_get",
        "description": "Retrieve tasks from Todoist with optional filtering or get a specific task by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "lang": {
              "type": "string",
              "description": "Language for filter parsing, defaults to 'en' (optional)"
            },
            "limit": {
              "type": "number",
              "minimum": 1,
              "description": "Maximum number of tasks to return (optional)"
            },
            "filter": {
              "type": "string",
              "description": "Todoist filter string like 'today', 'overdue', 'p1' (optional)"
            },
            "task_id": {
              "type": "string",
              "description": "Get a specific task by its ID (optional, takes precedence over filtering)"
            },
            "label_id": {
              "type": "string",
              "description": "Filter tasks by label ID (optional)"
            },
            "priority": {
              "enum": [
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "Filter tasks by priority level 1-4 (optional)"
            },
            "project_id": {
              "type": "string",
              "description": "Filter tasks by project ID (optional)"
            }
          },
          "required": []
        }
      },
      {
        "name": "todoist_task_update",
        "description": "Update an existing task found by ID or partial name search. Supports updating content, description, due date, priority, labels, deadline, project, and section",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of label names to assign to the task (optional)"
            },
            "content": {
              "type": "string",
              "description": "New content/title for the task (optional)"
            },
            "task_id": {
              "type": "string",
              "description": "Task ID to update (optional, takes precedence over task_name)"
            },
            "priority": {
              "enum": [
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "New priority from 1 (normal) to 4 (urgent) (optional)"
            },
            "task_name": {
              "type": "string",
              "description": "Partial task name to search for (case-insensitive, used if task_id not provided)"
            },
            "due_string": {
              "type": "string",
              "description": "New due date in natural language like 'tomorrow', 'next Monday' (optional)"
            },
            "project_id": {
              "type": "string",
              "description": "Move task to this project ID (optional)"
            },
            "section_id": {
              "type": "string",
              "description": "Move task to this section ID (optional)"
            },
            "description": {
              "type": "string",
              "description": "New description for the task (optional)"
            },
            "deadline_date": {
              "type": "string",
              "description": "New deadline in YYYY-MM-DD format (optional)"
            }
          },
          "required": []
        }
      },
      {
        "name": "todoist_task_delete",
        "description": "Delete a task found by ID or partial name search (case-insensitive)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "Task ID to delete (optional, takes precedence over task_name)"
            },
            "task_name": {
              "type": "string",
              "description": "Partial task name to search for deletion (used if task_id not provided)"
            }
          },
          "required": []
        }
      },
      {
        "name": "todoist_task_complete",
        "description": "Mark a task as complete found by ID or partial name search (case-insensitive)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "Task ID to complete (optional, takes precedence over task_name)"
            },
            "task_name": {
              "type": "string",
              "description": "Partial task name to search for completion (used if task_id not provided)"
            }
          },
          "required": []
        }
      },
      {
        "name": "todoist_tasks_bulk_create",
        "description": "Create multiple tasks at once for improved efficiency. Each task can have full attributes like individual task creation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tasks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "content"
                ],
                "properties": {
                  "labels": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "Array of label names to assign to the task (optional)"
                  },
                  "content": {
                    "type": "string",
                    "description": "The content/title of the task"
                  },
                  "priority": {
                    "enum": [
                      1,
                      2,
                      3,
                      4
                    ],
                    "type": "number",
                    "description": "Task priority from 1 (normal) to 4 (urgent) (optional)"
                  },
                  "due_string": {
                    "type": "string",
                    "description": "Natural language due date like 'tomorrow', 'next Monday' (optional)"
                  },
                  "project_id": {
                    "type": "string",
                    "description": "Project ID to assign the task to (optional)"
                  },
                  "section_id": {
                    "type": "string",
                    "description": "Section ID to assign the task to (optional)"
                  },
                  "description": {
                    "type": "string",
                    "description": "Detailed description of the task (optional)"
                  },
                  "deadline_date": {
                    "type": "string",
                    "description": "Task deadline in YYYY-MM-DD format (optional)"
                  }
                }
              },
              "minItems": 1,
              "description": "Array of task objects to create"
            }
          },
          "required": [
            "tasks"
          ]
        }
      },
      {
        "name": "todoist_tasks_bulk_update",
        "description": "Update multiple tasks at once based on search criteria. Very efficient for updating many tasks with the same changes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "updates": {
              "type": "object",
              "properties": {
                "labels": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Array of label names to assign (optional)"
                },
                "content": {
                  "type": "string",
                  "description": "New content/title for matching tasks (optional)"
                },
                "priority": {
                  "enum": [
                    1,
                    2,
                    3,
                    4
                  ],
                  "type": "number",
                  "description": "New priority from 1 (normal) to 4 (urgent) (optional)"
                },
                "due_string": {
                  "type": "string",
                  "description": "New due date in natural language (optional)"
                },
                "project_id": {
                  "type": "string",
                  "description": "Move matching tasks to this project ID or name (optional)"
                },
                "section_id": {
                  "type": "string",
                  "description": "Move matching tasks to this section (optional)"
                },
                "description": {
                  "type": "string",
                  "description": "New description for matching tasks (optional)"
                }
              },
              "description": "Updates to apply to matching tasks"
            },
            "search_criteria": {
              "type": "object",
              "properties": {
                "priority": {
                  "enum": [
                    1,
                    2,
                    3,
                    4
                  ],
                  "type": "number",
                  "description": "Filter tasks by priority level 1-4 (optional)"
                },
                "due_after": {
                  "type": "string",
                  "description": "Filter tasks due after this date (YYYY-MM-DD) (optional)"
                },
                "due_before": {
                  "type": "string",
                  "description": "Filter tasks due before this date (YYYY-MM-DD) (optional)"
                },
                "project_id": {
                  "type": "string",
                  "description": "Filter tasks by project ID (optional, does not support names)"
                },
                "content_contains": {
                  "type": "string",
                  "description": "Filter tasks containing this text in content (optional)"
                }
              },
              "description": "Criteria to find tasks to update"
            }
          },
          "required": [
            "search_criteria",
            "updates"
          ]
        }
      },
      {
        "name": "todoist_tasks_bulk_delete",
        "description": "Delete multiple tasks at once based on search criteria. Use with caution - this will permanently delete matching tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "priority": {
              "enum": [
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "Delete tasks with this priority level 1-4 (optional)"
            },
            "due_after": {
              "type": "string",
              "description": "Delete tasks due after this date (YYYY-MM-DD) (optional)"
            },
            "due_before": {
              "type": "string",
              "description": "Delete tasks due before this date (YYYY-MM-DD) (optional)"
            },
            "project_id": {
              "type": "string",
              "description": "Delete tasks from this project ID (optional)"
            },
            "content_contains": {
              "type": "string",
              "description": "Delete tasks containing this text in content (optional)"
            }
          },
          "required": []
        }
      },
      {
        "name": "todoist_tasks_bulk_complete",
        "description": "Complete multiple tasks at once based on search criteria. Efficiently mark many tasks as done.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "priority": {
              "enum": [
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "Complete tasks with this priority level 1-4 (optional)"
            },
            "due_after": {
              "type": "string",
              "description": "Complete tasks due after this date (YYYY-MM-DD) (optional)"
            },
            "due_before": {
              "type": "string",
              "description": "Complete tasks due before this date (YYYY-MM-DD) (optional)"
            },
            "project_id": {
              "type": "string",
              "description": "Complete tasks from this project ID (optional)"
            },
            "content_contains": {
              "type": "string",
              "description": "Complete tasks containing this text in content (optional)"
            }
          },
          "required": []
        }
      },
      {
        "name": "todoist_project_get",
        "description": "Get a list of all projects from Todoist with their IDs and names",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "todoist_section_get",
        "description": "Get a list of sections within a project from Todoist with their IDs and names",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "Project ID to get sections for (optional - if not provided, gets sections for all projects)"
            }
          }
        }
      },
      {
        "name": "todoist_project_create",
        "description": "Create a new project in Todoist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the project"
            },
            "color": {
              "type": "string",
              "description": "Color for the project (optional)"
            },
            "is_favorite": {
              "type": "boolean",
              "description": "Whether to mark the project as favorite (optional)"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "todoist_section_create",
        "description": "Create a new section within a project in Todoist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the section"
            },
            "project_id": {
              "type": "string",
              "description": "Project ID where the section will be created"
            }
          },
          "required": [
            "name",
            "project_id"
          ]
        }
      },
      {
        "name": "todoist_comment_create",
        "description": "Add a comment to a task in Todoist by task ID or task name",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "Content of the comment"
            },
            "task_id": {
              "type": "string",
              "description": "ID of the task to comment on (optional if task_name is provided)"
            },
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to comment on (optional if task_id is provided)"
            },
            "attachment": {
              "type": "object",
              "required": [
                "file_name",
                "file_url",
                "file_type"
              ],
              "properties": {
                "file_url": {
                  "type": "string",
                  "description": "URL of the attached file"
                },
                "file_name": {
                  "type": "string",
                  "description": "Name of the attached file"
                },
                "file_type": {
                  "type": "string",
                  "description": "MIME type of the attached file"
                }
              },
              "description": "Optional file attachment (optional)"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "todoist_comment_get",
        "description": "Get comments for a task or project in Todoist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "ID of the task to get comments for (optional)"
            },
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to get comments for (optional)"
            },
            "project_id": {
              "type": "string",
              "description": "ID of the project to get comments for (optional)"
            }
          }
        }
      },
      {
        "name": "todoist_label_get",
        "description": "Get all labels in Todoist",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "todoist_label_create",
        "description": "Create a new label in Todoist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the label to create"
            },
            "color": {
              "type": "string",
              "description": "Color of the label (optional) - can be a Todoist color name or hex code"
            },
            "order": {
              "type": "number",
              "description": "Order position of the label (optional)"
            },
            "is_favorite": {
              "type": "boolean",
              "description": "Whether the label should be marked as favorite (optional)"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "todoist_label_update",
        "description": "Update an existing label in Todoist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "New name for the label (optional)"
            },
            "color": {
              "type": "string",
              "description": "New color for the label (optional)"
            },
            "order": {
              "type": "number",
              "description": "New order position for the label (optional)"
            },
            "label_id": {
              "type": "string",
              "description": "ID of the label to update (optional if label_name is provided)"
            },
            "label_name": {
              "type": "string",
              "description": "Name of the label to update (optional if label_id is provided)"
            },
            "is_favorite": {
              "type": "boolean",
              "description": "Whether the label should be marked as favorite (optional)"
            }
          }
        }
      },
      {
        "name": "todoist_label_delete",
        "description": "Delete a label from Todoist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "label_id": {
              "type": "string",
              "description": "ID of the label to delete (optional if label_name is provided)"
            },
            "label_name": {
              "type": "string",
              "description": "Name of the label to delete (optional if label_id is provided)"
            }
          }
        }
      },
      {
        "name": "todoist_label_stats",
        "description": "Get usage statistics for all labels in Todoist",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "todoist_subtask_create",
        "description": "Create a new subtask under a parent task in Todoist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of label names to apply to the subtask"
            },
            "content": {
              "type": "string",
              "description": "Content of the subtask"
            },
            "priority": {
              "type": "number",
              "maximum": 4,
              "minimum": 1,
              "description": "Priority level (1-4, where 4 is highest priority)"
            },
            "due_string": {
              "type": "string",
              "description": "Human-readable due date string (e.g., 'tomorrow', 'next Monday')"
            },
            "description": {
              "type": "string",
              "description": "Description of the subtask (optional)"
            },
            "deadline_date": {
              "type": "string",
              "description": "Deadline date in YYYY-MM-DD format"
            },
            "parent_task_id": {
              "type": "string",
              "description": "ID of the parent task (optional if parent_task_name is provided)"
            },
            "parent_task_name": {
              "type": "string",
              "description": "Name/content of the parent task (optional if parent_task_id is provided)"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "todoist_subtasks_bulk_create",
        "description": "Create multiple subtasks under a parent task in a single operation",
        "inputSchema": {
          "type": "object",
          "properties": {
            "subtasks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "content"
                ],
                "properties": {
                  "labels": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "Array of label names"
                  },
                  "content": {
                    "type": "string",
                    "description": "Content of the subtask"
                  },
                  "priority": {
                    "type": "number",
                    "maximum": 4,
                    "minimum": 1,
                    "description": "Priority level (1-4)"
                  },
                  "due_string": {
                    "type": "string",
                    "description": "Human-readable due date string"
                  },
                  "description": {
                    "type": "string",
                    "description": "Description of the subtask (optional)"
                  },
                  "deadline_date": {
                    "type": "string",
                    "description": "Deadline date in YYYY-MM-DD format"
                  }
                }
              },
              "description": "Array of subtasks to create"
            },
            "parent_task_id": {
              "type": "string",
              "description": "ID of the parent task (optional if parent_task_name is provided)"
            },
            "parent_task_name": {
              "type": "string",
              "description": "Name/content of the parent task (optional if parent_task_id is provided)"
            }
          },
          "required": [
            "subtasks"
          ]
        }
      },
      {
        "name": "todoist_task_convert_to_subtask",
        "description": "Convert an existing task to a subtask of another task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "ID of the task to convert (optional if task_name is provided)"
            },
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to convert (optional if task_id is provided)"
            },
            "parent_task_id": {
              "type": "string",
              "description": "ID of the parent task (optional if parent_task_name is provided)"
            },
            "parent_task_name": {
              "type": "string",
              "description": "Name/content of the parent task (optional if parent_task_id is provided)"
            }
          }
        }
      },
      {
        "name": "todoist_subtask_promote",
        "description": "Promote a subtask to a main task (remove parent relationship)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "ID of the project to move the task to (optional)"
            },
            "section_id": {
              "type": "string",
              "description": "ID of the section to move the task to (optional)"
            },
            "subtask_id": {
              "type": "string",
              "description": "ID of the subtask to promote (optional if subtask_name is provided)"
            },
            "subtask_name": {
              "type": "string",
              "description": "Name/content of the subtask to promote (optional if subtask_id is provided)"
            }
          }
        }
      },
      {
        "name": "todoist_task_hierarchy_get",
        "description": "Get a task with all its subtasks in a hierarchical structure",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_id": {
              "type": "string",
              "description": "ID of the task to get hierarchy for (optional if task_name is provided)"
            },
            "task_name": {
              "type": "string",
              "description": "Name/content of the task to get hierarchy for (optional if task_id is provided)"
            },
            "include_completed": {
              "type": "boolean",
              "default": false,
              "description": "Include completed tasks in the hierarchy (default: false)"
            }
          }
        }
      },
      {
        "name": "todoist_test_connection",
        "description": "Test the connection to Todoist API and verify API token validity",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "todoist_test_all_features",
        "description": "Run comprehensive tests on all Todoist MCP features to verify functionality",
        "inputSchema": {
          "type": "object",
          "properties": {
            "mode": {
              "enum": [
                "basic",
                "enhanced"
              ],
              "type": "string",
              "default": "basic",
              "description": "Test mode: 'basic' for read-only API tests, 'enhanced' for full CRUD testing (default: basic)"
            }
          }
        }
      },
      {
        "name": "todoist_test_performance",
        "description": "Measure performance and response times of Todoist API operations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "iterations": {
              "type": "number",
              "default": 5,
              "description": "Number of iterations to run for each test (default: 5)"
            }
          }
        }
      }
    ]
  },
  {
    "name": "growthbook-growthbook-mcp",
    "title": "GrowthBook MCP Server",
    "description": "GrowthBook MCP Server",
    "icon": "https://avatars.githubusercontent.com/growthbook",
    "isOfficial": true,
    "homepage": "https://github.com/growthbook/growthbook-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@growthbook/mcp"
      ],
      "env": {
        "GB_USER": "<gb-user>",
        "GB_API_KEY": "<gb-api-key>",
        "GB_API_URL": "<gb-api-url>",
        "GB_APP_ORIGIN": "<gb-app-origin>"
      }
    },
    "parameters": [
      {
        "name": "GB_USER",
        "description": "Your name. Used when creating a feature flag.",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "GB_API_KEY",
        "description": "A GrowthBook API key.",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "GB_API_URL",
        "description": "Your GrowthBook API URL.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GB_APP_ORIGIN",
        "description": "Your GrowthBook app URL.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get_environments",
        "description": "Fetches all environments from the GrowthBook API. GrowthBook comes with one environment by default (production), but you can add as many as you need. Feature flags can be enabled and disabled on a per-environment basis. You can also set the default feature state for any new environment. Additionally, you can scope environments to only be available in specific projects, allowing for further control and segmentation over feature delivery.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_projects",
        "description": "Fetches all projects from the GrowthBook API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10
            },
            "offset": {
              "type": "number",
              "default": 0
            }
          }
        }
      },
      {
        "name": "get_sdk_connections",
        "description": "Get all SDK connections, \n    which are how GrowthBook connects to an app. \n    Importantly, users need the key, which is a public client key that allows the app to fetch features and experiments the API ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 100
            },
            "offset": {
              "type": "number",
              "default": 0
            },
            "project": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "create_sdk_connection",
        "description": "Create an SDK connection for a user. Returns an SDK clientKey that can be used to fetch features and experiments.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the SDK connection in GrowthBook. Should reflect the current project."
            },
            "language": {
              "enum": [
                "nocode-webflow",
                "nocode-wordpress",
                "nocode-shopify",
                "nocode-other",
                "javascript",
                "nodejs",
                "react",
                "php",
                "ruby",
                "python",
                "go",
                "java",
                "csharp",
                "android",
                "ios",
                "flutter",
                "elixir",
                "edge-cloudflare",
                "edge-fastly",
                "edge-lambda",
                "edge-other",
                "other"
              ],
              "type": "string",
              "description": "The language of the SDK. Either 'javascript' or 'typescript'."
            },
            "environment": {
              "type": "string",
              "description": "The environment associated with the SDK connection."
            }
          },
          "required": [
            "name",
            "language"
          ]
        }
      },
      {
        "name": "create_feature_flag",
        "description": "Create, add, or wrap an element with a feature flag.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "pattern": "^[a-zA-Z0-9_-]+$",
              "description": "A unique key name for the feature"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tags for the feature flag"
            },
            "project": {
              "type": "string",
              "default": "",
              "description": "The project the feature flag belongs to"
            },
            "archived": {
              "type": "boolean",
              "default": false,
              "description": "Whether the feature flag is archived"
            },
            "valueType": {
              "enum": [
                "string",
                "number",
                "boolean",
                "json"
              ],
              "type": "string",
              "description": "The value type the feature flag will return"
            },
            "description": {
              "type": "string",
              "default": "",
              "description": "A description of the feature flag"
            },
            "defaultValue": {
              "type": "string",
              "description": "The default value of the feature flag"
            },
            "fileExtension": {
              "enum": [
                ".tsx",
                ".jsx",
                ".ts",
                ".js",
                ".vue",
                ".py",
                ".go",
                ".php",
                ".rb",
                ".java",
                ".cs"
              ],
              "type": "string",
              "description": "The extension of the current file. If it's unclear, ask the user."
            }
          },
          "required": [
            "id",
            "valueType",
            "defaultValue",
            "fileExtension"
          ]
        }
      },
      {
        "name": "get_feature_flags",
        "description": "Fetches all feature flags from the GrowthBook API. Flags are returned in the order they were created, from oldest to newest.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 100
            },
            "offset": {
              "type": "number",
              "default": 0
            },
            "project": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "get_single_feature_flag",
        "description": "Fetches a specific feature flag from the GrowthBook API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the feature flag"
            },
            "project": {
              "type": "string"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_stale_safe_rollouts",
        "description": "Fetches all complete safe rollouts (rolled-back or released) from the GrowthBook API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 100
            },
            "offset": {
              "type": "number",
              "default": 0
            },
            "project": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "generate_flag_types",
        "description": "Generate types for feature flags",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_experiments",
        "description": "Fetches all experiments from the GrowthBook API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 100
            },
            "offset": {
              "type": "number",
              "default": 0
            },
            "project": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "create_force_rule",
        "description": "Create a new force rule on an existing feature. If the existing feature isn't apparent, create a new feature using create_feature_flag first. A force rule sets a feature to a specific value for a specific environment based on a condition. For A/B tests and experiments, use create_experiment instead.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "value": {
              "type": "string",
              "description": "The type of the value should match the feature type"
            },
            "condition": {
              "type": "string",
              "description": "Applied to everyone by default. Write conditions in MongoDB-style query syntax."
            },
            "featureId": {
              "type": "string",
              "description": "The ID of the feature to create the rule on"
            },
            "description": {
              "type": "string"
            },
            "environments": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "fileExtension": {
              "enum": [
                ".tsx",
                ".jsx",
                ".ts",
                ".js",
                ".vue",
                ".py",
                ".go",
                ".php",
                ".rb",
                ".java",
                ".cs"
              ],
              "type": "string",
              "description": "The extension of the current file. If it's unclear, ask the user."
            }
          },
          "required": [
            "featureId",
            "value",
            "environments",
            "fileExtension"
          ]
        }
      },
      {
        "name": "get_experiment",
        "description": "Gets a single experiment from GrowthBook",
        "inputSchema": {
          "type": "object",
          "properties": {
            "experimentId": {
              "type": "string",
              "description": "The ID of the experiment to get"
            }
          },
          "required": [
            "experimentId"
          ]
        }
      },
      {
        "name": "get_attributes",
        "description": "Get all attributes",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "search_growthbook_docs",
        "description": "Search the GrowthBook docs on how to use a feature",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The search query to look up in the GrowthBook docs."
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "haltakov-meme-mcp",
    "title": "Meme MCP Server",
    "description": "A simple Model Context Protocol server that allows AI models to generate meme images using the ImgFlip API, enabling users to create memes from text prompts.",
    "icon": "https://avatars.githubusercontent.com/haltakov",
    "isOfficial": false,
    "homepage": "https://github.com/haltakov/meme-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "meme-mcp"
      ],
      "env": {
        "IMGFLIP_PASSWORD": "<imgflip-password>",
        "IMGFLIP_USERNAME": "<imgflip-username>"
      }
    },
    "parameters": [
      {
        "name": "IMGFLIP_PASSWORD",
        "description": "Your ImgFlip account password",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "IMGFLIP_USERNAME",
        "description": "Your ImgFlip account username (create a free account on ImgFlip)",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "generateMeme",
        "description": "Generate a meme image from Imgflip using the numeric template id and text",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text0": {
              "type": "string"
            },
            "text1": {
              "type": "string"
            },
            "templateNumericId": {
              "type": "string"
            }
          },
          "required": [
            "templateNumericId",
            "text0"
          ]
        }
      }
    ]
  },
  {
    "name": "hannesj-mcp-graphql-schema",
    "title": "mcp-graphql-schema",
    "description": "A MCP server that exposes GraphQL schema information to LLMs like Claude. This server allows an LLM to explore and understand large GraphQL schemas through a set of specialized tools, without needing to load the whole schema into the context",
    "icon": "https://avatars.githubusercontent.com/hannesj",
    "isOfficial": false,
    "homepage": "https://github.com/hannesj/mcp-graphql-schema",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-graphql-schema"
      ],
      "env": {
        "SCHEMA_PATH": "<schema-path>"
      }
    },
    "parameters": [
      {
        "name": "SCHEMA_PATH",
        "description": "Path to the GraphQL schema file. If not provided, defaults to schema.graphqls in the current directory.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "list-query-fields",
        "description": "Lists all of the available root-level fields for a GraphQL query.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-query-field",
        "description": "Gets a single GraphQL query field definition in GraphQL Schema Definition Language.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fieldName": {
              "type": "string"
            }
          },
          "required": [
            "fieldName"
          ]
        }
      },
      {
        "name": "list-types",
        "description": "Lists all of the types defined in the GraphQL schema.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get-type",
        "description": "Gets a single GraphQL type from the schema in the GraphQL Schema Definition Language",
        "inputSchema": {
          "type": "object",
          "properties": {
            "typeName": {
              "type": "string"
            }
          },
          "required": [
            "typeName"
          ]
        }
      },
      {
        "name": "get-type-fields",
        "description": "Gets a simplified list of fields for a specific GraphQL type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "typeName": {
              "type": "string"
            }
          },
          "required": [
            "typeName"
          ]
        }
      },
      {
        "name": "search-schema",
        "description": "Search for types or fields in the schema by name pattern",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string"
            }
          },
          "required": [
            "pattern"
          ]
        }
      }
    ]
  },
  {
    "name": "haris-musa-excel-mcp-server",
    "title": "Excel MCP Server",
    "description": "Provides Excel file manipulation capabilities. This server enables workbook creation, data manipulation, formatting, and advanced Excel features.",
    "icon": "https://avatars.githubusercontent.com/haris-musa",
    "isOfficial": false,
    "homepage": "https://github.com/haris-musa/excel-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "excel-mcp-server"
      ],
      "env": {
        "FASTMCP_PORT": "<fastmcp-port>",
        "EXCEL_FILES_PATH": "<excel-files-path>"
      }
    },
    "parameters": [
      {
        "name": "FASTMCP_PORT",
        "description": "Port the server listens on when using SSE transport",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "EXCEL_FILES_PATH",
        "description": "Directory where Excel files are read from and written to when using SSE transport",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "apply_formula",
        "description": "\n    Apply Excel formula to cell.\n    Excel formula will write to cell with verification.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cell": {
              "type": "string",
              "title": "Cell"
            },
            "formula": {
              "type": "string",
              "title": "Formula"
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "cell",
            "formula"
          ]
        }
      },
      {
        "name": "validate_formula_syntax",
        "description": "Validate Excel formula syntax without applying it.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cell": {
              "type": "string",
              "title": "Cell"
            },
            "formula": {
              "type": "string",
              "title": "Formula"
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "cell",
            "formula"
          ]
        }
      },
      {
        "name": "format_range",
        "description": "Apply formatting to a range of cells.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bold": {
              "type": "boolean",
              "title": "Bold",
              "default": false
            },
            "italic": {
              "type": "boolean",
              "title": "Italic",
              "default": false
            },
            "bg_color": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Bg Color",
              "default": null
            },
            "end_cell": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "End Cell",
              "default": null
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "alignment": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Alignment",
              "default": null
            },
            "font_size": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Font Size",
              "default": null
            },
            "underline": {
              "type": "boolean",
              "title": "Underline",
              "default": false
            },
            "wrap_text": {
              "type": "boolean",
              "title": "Wrap Text",
              "default": false
            },
            "font_color": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Font Color",
              "default": null
            },
            "protection": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Protection",
              "default": null
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            },
            "start_cell": {
              "type": "string",
              "title": "Start Cell"
            },
            "merge_cells": {
              "type": "boolean",
              "title": "Merge Cells",
              "default": false
            },
            "border_color": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Border Color",
              "default": null
            },
            "border_style": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Border Style",
              "default": null
            },
            "number_format": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Number Format",
              "default": null
            },
            "conditional_format": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "null"
                }
              ],
              "title": "Conditional Format",
              "default": null
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "start_cell"
          ]
        }
      },
      {
        "name": "read_data_from_excel",
        "description": "\n    Read data from Excel worksheet with cell metadata including validation rules.\n    \n    Args:\n        filepath: Path to Excel file\n        sheet_name: Name of worksheet\n        start_cell: Starting cell (default A1)\n        end_cell: Ending cell (optional, auto-expands if not provided)\n        preview_only: Whether to return preview only\n    \n    Returns:  \n    JSON string containing structured cell data with validation metadata.\n    Each cell includes: address, value, row, column, and validation info (if any).\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end_cell": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "End Cell",
              "default": null
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            },
            "start_cell": {
              "type": "string",
              "title": "Start Cell",
              "default": "A1"
            },
            "preview_only": {
              "type": "boolean",
              "title": "Preview Only",
              "default": false
            }
          },
          "required": [
            "filepath",
            "sheet_name"
          ]
        }
      },
      {
        "name": "write_data_to_excel",
        "description": "\n    Write data to Excel worksheet.\n    Excel formula will write to cell without any verification.\n\n    PARAMETERS:  \n    filepath: Path to Excel file\n    sheet_name: Name of worksheet to write to\n    data: List of lists containing data to write to the worksheet, sublists are assumed to be rows\n    start_cell: Cell to start writing to, default is \"A1\"\n  \n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "array",
                "items": {}
              },
              "title": "Data"
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            },
            "start_cell": {
              "type": "string",
              "title": "Start Cell",
              "default": "A1"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "data"
          ]
        }
      },
      {
        "name": "create_workbook",
        "description": "Create new Excel workbook.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            }
          },
          "required": [
            "filepath"
          ]
        }
      },
      {
        "name": "create_worksheet",
        "description": "Create new worksheet in workbook.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            }
          },
          "required": [
            "filepath",
            "sheet_name"
          ]
        }
      },
      {
        "name": "create_chart",
        "description": "Create chart in worksheet.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "title": "Title",
              "default": ""
            },
            "x_axis": {
              "type": "string",
              "title": "X Axis",
              "default": ""
            },
            "y_axis": {
              "type": "string",
              "title": "Y Axis",
              "default": ""
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "chart_type": {
              "type": "string",
              "title": "Chart Type"
            },
            "data_range": {
              "type": "string",
              "title": "Data Range"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            },
            "target_cell": {
              "type": "string",
              "title": "Target Cell"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "data_range",
            "chart_type",
            "target_cell"
          ]
        }
      },
      {
        "name": "create_pivot_table",
        "description": "Create pivot table in worksheet.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "rows": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "Rows"
            },
            "values": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "Values"
            },
            "columns": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Columns",
              "default": null
            },
            "agg_func": {
              "type": "string",
              "title": "Agg Func",
              "default": "mean"
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "data_range": {
              "type": "string",
              "title": "Data Range"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "data_range",
            "rows",
            "values"
          ]
        }
      },
      {
        "name": "create_table",
        "description": "Creates a native Excel table from a specified range of data.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "data_range": {
              "type": "string",
              "title": "Data Range"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            },
            "table_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Table Name",
              "default": null
            },
            "table_style": {
              "type": "string",
              "title": "Table Style",
              "default": "TableStyleMedium9"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "data_range"
          ]
        }
      },
      {
        "name": "copy_worksheet",
        "description": "Copy worksheet within workbook.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "source_sheet": {
              "type": "string",
              "title": "Source Sheet"
            },
            "target_sheet": {
              "type": "string",
              "title": "Target Sheet"
            }
          },
          "required": [
            "filepath",
            "source_sheet",
            "target_sheet"
          ]
        }
      },
      {
        "name": "delete_worksheet",
        "description": "Delete worksheet from workbook.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            }
          },
          "required": [
            "filepath",
            "sheet_name"
          ]
        }
      },
      {
        "name": "rename_worksheet",
        "description": "Rename worksheet in workbook.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "new_name": {
              "type": "string",
              "title": "New Name"
            },
            "old_name": {
              "type": "string",
              "title": "Old Name"
            }
          },
          "required": [
            "filepath",
            "old_name",
            "new_name"
          ]
        }
      },
      {
        "name": "get_workbook_metadata",
        "description": "Get metadata about workbook including sheets, ranges, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "include_ranges": {
              "type": "boolean",
              "title": "Include Ranges",
              "default": false
            }
          },
          "required": [
            "filepath"
          ]
        }
      },
      {
        "name": "merge_cells",
        "description": "Merge a range of cells.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end_cell": {
              "type": "string",
              "title": "End Cell"
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            },
            "start_cell": {
              "type": "string",
              "title": "Start Cell"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "start_cell",
            "end_cell"
          ]
        }
      },
      {
        "name": "unmerge_cells",
        "description": "Unmerge a range of cells.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end_cell": {
              "type": "string",
              "title": "End Cell"
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            },
            "start_cell": {
              "type": "string",
              "title": "Start Cell"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "start_cell",
            "end_cell"
          ]
        }
      },
      {
        "name": "get_merged_cells",
        "description": "Get merged cells in a worksheet.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            }
          },
          "required": [
            "filepath",
            "sheet_name"
          ]
        }
      },
      {
        "name": "copy_range",
        "description": "Copy a range of cells to another location.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            },
            "source_end": {
              "type": "string",
              "title": "Source End"
            },
            "source_start": {
              "type": "string",
              "title": "Source Start"
            },
            "target_sheet": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Target Sheet",
              "default": null
            },
            "target_start": {
              "type": "string",
              "title": "Target Start"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "source_start",
            "source_end",
            "target_start"
          ]
        }
      },
      {
        "name": "delete_range",
        "description": "Delete a range of cells and shift remaining cells.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end_cell": {
              "type": "string",
              "title": "End Cell"
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            },
            "start_cell": {
              "type": "string",
              "title": "Start Cell"
            },
            "shift_direction": {
              "type": "string",
              "title": "Shift Direction",
              "default": "up"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "start_cell",
            "end_cell"
          ]
        }
      },
      {
        "name": "validate_excel_range",
        "description": "Validate if a range exists and is properly formatted.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end_cell": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "End Cell",
              "default": null
            },
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            },
            "start_cell": {
              "type": "string",
              "title": "Start Cell"
            }
          },
          "required": [
            "filepath",
            "sheet_name",
            "start_cell"
          ]
        }
      },
      {
        "name": "get_data_validation_info",
        "description": "\n    Get all data validation rules in a worksheet.\n    \n    This tool helps identify which cell ranges have validation rules\n    and what types of validation are applied.\n    \n    Args:\n        filepath: Path to Excel file\n        sheet_name: Name of worksheet\n        \n    Returns:\n        JSON string containing all validation rules in the worksheet\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filepath": {
              "type": "string",
              "title": "Filepath"
            },
            "sheet_name": {
              "type": "string",
              "title": "Sheet Name"
            }
          },
          "required": [
            "filepath",
            "sheet_name"
          ]
        }
      }
    ]
  },
  {
    "name": "heilgar-shadcn-ui-mcp-server",
    "title": "Shadcn UI MCP Server",
    "description": "A Model Control Protocol server that allows users to discover, install, and manage Shadcn UI components and blocks through natural language interactions in compatible AI tools.",
    "icon": "https://avatars.githubusercontent.com/heilgar",
    "isOfficial": false,
    "homepage": "https://github.com/heilgar/shadcn-ui-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@heilgar/shadcn-ui-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "githejie-mcp-server-calculator",
    "title": "Calculator MCP Server",
    "description": "A Model Context Protocol server that enables LLMs to perform precise numerical calculations by evaluating mathematical expressions.",
    "icon": "https://avatars.githubusercontent.com/githejie",
    "isOfficial": false,
    "homepage": "https://github.com/githejie/mcp-server-calculator",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-calculator"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "calculate",
        "description": "Calculates/evaluates the given expression.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "expression": {
              "type": "string",
              "title": "Expression"
            }
          },
          "required": [
            "expression"
          ]
        }
      }
    ]
  },
  {
    "name": "horizondatawave-hdw-mcp-server",
    "title": "HDW MCP Server",
    "description": "A Model Context Protocol server that provides comprehensive access to LinkedIn data and functionality, enabling data retrieval and user account management through the HorizonDataWave API.",
    "icon": "https://avatars.githubusercontent.com/horizondatawave",
    "isOfficial": false,
    "homepage": "https://github.com/horizondatawave/hdw-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@horizondatawave/mcp"
      ],
      "env": {
        "HDW_ACCOUNT_ID": "<hdw-account-id>",
        "HDW_ACCESS_TOKEN": "<hdw-access-token>"
      }
    },
    "parameters": [
      {
        "name": "HDW_ACCOUNT_ID",
        "description": "Your HorizonDataWave account ID obtained from app.horizondatawave.ai",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "HDW_ACCESS_TOKEN",
        "description": "Your HorizonDataWave API access token obtained from app.horizondatawave.ai",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "search_linkedin_users",
        "description": "Search for LinkedIn users with various filters like keywords, name, title, company, location etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of results (max 1000)"
            },
            "title": {
              "type": "string",
              "description": "Exact word in the title"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds (20-1500)"
            },
            "industry": {
              "type": "string",
              "description": "Industry URN or name"
            },
            "keywords": {
              "type": "string",
              "description": "Any keyword for searching in the user page."
            },
            "location": {
              "type": "string",
              "description": "Location name or URN"
            },
            "education": {
              "type": "string",
              "description": "Education URN or name"
            },
            "last_name": {
              "type": "string",
              "description": "Exact last name"
            },
            "first_name": {
              "type": "string",
              "description": "Exact first name"
            },
            "past_company": {
              "type": "string",
              "description": "Past company URN or name"
            },
            "current_company": {
              "type": "string",
              "description": "Company URN or name"
            },
            "school_keywords": {
              "type": "string",
              "description": "Exact word in the school name"
            },
            "company_keywords": {
              "type": "string",
              "description": "Exact word in the company name"
            }
          },
          "required": [
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_profile",
        "description": "Get detailed information about a LinkedIn user profile",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "User alias, URL, or URN"
            },
            "with_skills": {
              "type": "boolean",
              "default": true,
              "description": "Include skills info"
            },
            "with_education": {
              "type": "boolean",
              "default": true,
              "description": "Include education info"
            },
            "with_experience": {
              "type": "boolean",
              "default": true,
              "description": "Include experience info"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "get_linkedin_email_user",
        "description": "Get LinkedIn user details by email",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "default": 5,
              "description": "Max results"
            },
            "email": {
              "type": "string",
              "description": "Email address"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            }
          },
          "required": [
            "email"
          ]
        }
      },
      {
        "name": "get_linkedin_user_posts",
        "description": "Get LinkedIn posts for a user by URN (must include prefix, example: fsd_profile:ACoAAEWn01QBWENVMWqyM3BHfa1A-xsvxjdaXsY)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "User URN (must include prefix, example: fsd_profile:ACoAA...)"
            },
            "count": {
              "type": "number",
              "default": 10,
              "description": "Max posts"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            }
          },
          "required": [
            "urn"
          ]
        }
      },
      {
        "name": "get_linkedin_user_reactions",
        "description": "Get LinkedIn reactions for a user by URN (must include prefix, example: fsd_profile:ACoAA...)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "User URN (must include prefix, example: fsd_profile:ACoAA...)"
            },
            "count": {
              "type": "number",
              "default": 10,
              "description": "Max reactions"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            }
          },
          "required": [
            "urn"
          ]
        }
      },
      {
        "name": "get_linkedin_chat_messages",
        "description": "Get top chat messages from LinkedIn management API. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "User URN for filtering messages (must include prefix, e.g. fsd_profile:ACoAA...)"
            },
            "count": {
              "type": "number",
              "default": 20,
              "description": "Max messages to return"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "send_linkedin_chat_message",
        "description": "Send a chat message via LinkedIn management API. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Message text"
            },
            "user": {
              "type": "string",
              "description": "Recipient user URN (must include prefix, e.g. fsd_profile:ACoAA...)"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            }
          },
          "required": [
            "user",
            "text"
          ]
        }
      },
      {
        "name": "send_linkedin_connection",
        "description": "Send a connection invitation to LinkedIn user. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user": {
              "type": "string",
              "description": "Recipient user URN (must include prefix, e.g. fsd_profile:ACoAA...)"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            }
          },
          "required": [
            "user"
          ]
        }
      },
      {
        "name": "send_linkedin_post_comment",
        "description": "Create a comment on a LinkedIn post or on another comment. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "URN of the activity or comment to comment on (e.g., 'activity:123' or 'comment:(activity:123,456)')"
            },
            "text": {
              "type": "string",
              "description": "Comment text"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            }
          },
          "required": [
            "text",
            "urn"
          ]
        }
      },
      {
        "name": "get_linkedin_user_connections",
        "description": "Get list of LinkedIn user connections. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "default": 20,
              "description": "Max connections to return"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            },
            "connected_after": {
              "type": "number",
              "description": "Filter users that added after the specified date (timestamp)"
            }
          },
          "required": []
        }
      },
      {
        "name": "get_linkedin_post_reposts",
        "description": "Get LinkedIn reposts for a post by URN",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "Post URN, only activity urn type is allowed (example: activity:7234173400267538433)"
            },
            "count": {
              "type": "number",
              "default": 50,
              "description": "Max reposts to return"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            }
          },
          "required": [
            "urn",
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_post_comments",
        "description": "Get LinkedIn comments for a post by URN",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urn": {
              "type": "string",
              "description": "Post URN, only activity urn type is allowed (example: activity:7234173400267538433)"
            },
            "sort": {
              "enum": [
                "relevance",
                "recent"
              ],
              "type": "string",
              "default": "relevance",
              "description": "Sort type (relevance or recent)"
            },
            "count": {
              "type": "number",
              "default": 10,
              "description": "Max comments to return"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            }
          },
          "required": [
            "urn",
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_google_company",
        "description": "Search for LinkedIn companies using Google search. First result is usually the best match.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            },
            "keywords": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "examples": [
                [
                  "Software as a Service (SaaS)"
                ],
                [
                  "google.com"
                ]
              ],
              "description": "Company keywords for search. For example, company name or company website"
            },
            "with_urn": {
              "type": "boolean",
              "default": false,
              "description": "Include URNs in response (increases execution time)"
            },
            "count_per_keyword": {
              "type": "number",
              "default": 1,
              "maximum": 10,
              "minimum": 1,
              "description": "Max results per keyword"
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "get_linkedin_company",
        "description": "Get detailed information about a LinkedIn company",
        "inputSchema": {
          "type": "object",
          "properties": {
            "company": {
              "type": "string",
              "description": "Company Alias or URL or URN (example: 'openai' or 'company:1441')"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            }
          },
          "required": [
            "company"
          ]
        }
      },
      {
        "name": "get_linkedin_company_employees",
        "description": "Get employees of a LinkedIn company",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of results"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            },
            "keywords": {
              "type": "string",
              "examples": [
                "Alex"
              ],
              "description": "Any keyword for searching employees"
            },
            "companies": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Company URNs (example: ['company:14064608'])"
            },
            "last_name": {
              "type": "string",
              "examples": [
                "Gates"
              ],
              "description": "Search for exact last name"
            },
            "first_name": {
              "type": "string",
              "examples": [
                "Bill"
              ],
              "description": "Search for exact first name"
            }
          },
          "required": [
            "companies",
            "count"
          ]
        }
      },
      {
        "name": "send_linkedin_post",
        "description": "Create a post on LinkedIn. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Post text content"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            },
            "visibility": {
              "enum": [
                "ANYONE",
                "CONNECTIONS_ONLY"
              ],
              "type": "string",
              "default": "ANYONE",
              "description": "Post visibility"
            },
            "comment_scope": {
              "enum": [
                "ALL",
                "CONNECTIONS_ONLY",
                "NONE"
              ],
              "type": "string",
              "default": "ALL",
              "description": "Who can comment on the post"
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "linkedin_sn_search_users",
        "description": "Advanced search for LinkedIn users using Sales Navigator filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "default": 10,
              "maximum": 2500,
              "minimum": 1,
              "description": "Maximum number of results (max 2500)"
            },
            "levels": {
              "type": "array",
              "items": {
                "enum": [
                  "Entry",
                  "Director",
                  "Owner",
                  "CXO",
                  "Vice President",
                  "Experienced Manager",
                  "Entry Manager",
                  "Strategic",
                  "Senior",
                  "Trainy"
                ],
                "type": "string"
              },
              "description": "Job seniority levels"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "maximum": 1500,
              "minimum": 20,
              "description": "Timeout in seconds (20-1500)"
            },
            "industry": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Industry URN (industry:*) or name, or array of them"
            },
            "keywords": {
              "type": "string",
              "description": "Any keyword for searching in the user profile. Using this may reduce result count."
            },
            "location": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Location URN (geo:*) or name, or array of them"
            },
            "education": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Education URN (company:*) or name, or array of them"
            },
            "functions": {
              "type": "array",
              "items": {
                "enum": [
                  "Accounting",
                  "Administrative",
                  "Arts and Design",
                  "Business",
                  "Development",
                  "Community and Social Services",
                  "Consulting",
                  "Education",
                  "Engineering",
                  "Entrepreneurship",
                  "Finance",
                  "Healthcare Services",
                  "Human Resources",
                  "Information Technology",
                  "Legal",
                  "Marketing",
                  "Media and Communication",
                  "Military and Protective Services",
                  "Operations",
                  "Product Management",
                  "Program and Project Management",
                  "Purchasing",
                  "Quality Assurance",
                  "Research",
                  "Real Estate",
                  "Sales",
                  "Customer Success and Support"
                ],
                "type": "string"
              },
              "description": "Job functions"
            },
            "languages": {
              "type": "array",
              "items": {
                "enum": [
                  "Arabic",
                  "English",
                  "Spanish",
                  "Portuguese",
                  "Chinese",
                  "French",
                  "Italian",
                  "Russian",
                  "German",
                  "Dutch",
                  "Turkish",
                  "Tagalog",
                  "Polish",
                  "Korean",
                  "Japanese",
                  "Malay",
                  "Norwegian",
                  "Danish",
                  "Romanian",
                  "Swedish",
                  "Bahasa Indonesia",
                  "Czech"
                ],
                "type": "string"
              },
              "description": "Profile languages"
            },
            "last_names": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact last names to search for"
            },
            "first_names": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact first names to search for"
            },
            "past_titles": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact words to search in past titles"
            },
            "company_sizes": {
              "type": "array",
              "items": {
                "enum": [
                  "Self-employed",
                  "1-10",
                  "11-50",
                  "51-200",
                  "201-500",
                  "501-1,000",
                  "1,001-5,000",
                  "5,001-10,000",
                  "10,001+"
                ],
                "type": "string"
              },
              "description": "Company size ranges"
            },
            "company_types": {
              "type": "array",
              "items": {
                "enum": [
                  "Public Company",
                  "Privately Held",
                  "Non Profit",
                  "Educational Institution",
                  "Partnership",
                  "Self Employed",
                  "Self Owned",
                  "Government Agency"
                ],
                "type": "string"
              },
              "description": "Company types"
            },
            "current_titles": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exact words to search in current titles"
            },
            "past_companies": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Past company URN (company:*) or name, or array of them"
            },
            "company_locations": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Company location URN (geo:*) or name, or array of them"
            },
            "current_companies": {
              "type": [
                "string",
                "array"
              ],
              "items": {
                "type": "string"
              },
              "description": "Current company URN (company:*) or name, or array of them"
            },
            "years_in_the_current_company": {
              "type": "array",
              "items": {
                "enum": [
                  "0-1",
                  "1-2",
                  "3-5",
                  "6-10",
                  "10+"
                ],
                "type": "string"
              },
              "description": "Years in current company ranges"
            },
            "years_in_the_current_position": {
              "type": "array",
              "items": {
                "enum": [
                  "0-1",
                  "1-2",
                  "3-5",
                  "6-10",
                  "10+"
                ],
                "type": "string"
              },
              "description": "Years in current position ranges"
            }
          },
          "required": [
            "count"
          ]
        }
      },
      {
        "name": "get_linkedin_conversations",
        "description": "Get list of LinkedIn conversations from the messaging interface. Account ID is taken from environment.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "default": 20,
              "description": "Max conversations to return"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds"
            },
            "connected_after": {
              "type": "number",
              "description": "Filter conversations created after the specified date (timestamp)"
            }
          },
          "required": []
        }
      },
      {
        "name": "google_search",
        "description": "Search for information using Google search API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of results (from 1 to 20)"
            },
            "query": {
              "type": "string",
              "description": "Search query. For example: 'python fastapi'"
            },
            "timeout": {
              "type": "number",
              "default": 300,
              "description": "Timeout in seconds (20-1500)"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "hyperbrowserai-mcp",
    "title": "Hyperbrowser",
    "description": "Welcome to Hyperbrowser, the Internet for AI. Hyperbrowser is the next-generation platform empowering AI agents and enabling effortless, scalable browser automation. Built specifically for AI developers, it eliminates the headaches of local infrastructure and performance bottlenecks, allowing you to",
    "icon": "https://avatars.githubusercontent.com/hyperbrowserai",
    "isOfficial": false,
    "homepage": "https://github.com/hyperbrowserai/mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "hyperbrowser-mcp"
      ],
      "env": {
        "HYPERBROWSER_API_KEY": "<hyperbrowser-api-key>"
      }
    },
    "parameters": [
      {
        "name": "HYPERBROWSER_API_KEY",
        "description": "Your Hyperbrowser API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "scrape_webpage",
        "description": "Scrape a webpage and extract its content in various formats. This tool allows fetching content from a single URL with configurable browser behavior options. Use this for extracting text content, HTML structure, collecting links, or capturing screenshots of webpages.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri",
              "description": "The URL of the webpage to scrape"
            },
            "outputFormat": {
              "type": "array",
              "items": {
                "enum": [
                  "markdown",
                  "html",
                  "links",
                  "screenshot"
                ],
                "type": "string"
              },
              "minItems": 1,
              "description": "The format of the output"
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "profile": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "ID of the persistent profile to use for the session"
                    },
                    "persistChanges": {
                      "type": "boolean",
                      "default": true,
                      "description": "Whether changes made during the session should be saved to the profile. Recommended true."
                    }
                  },
                  "description": "Options for using a persistent Hyperbrowser profile",
                  "additionalProperties": false
                },
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                }
              },
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly",
              "additionalProperties": false
            }
          },
          "required": [
            "url",
            "outputFormat"
          ]
        }
      },
      {
        "name": "crawl_webpages",
        "description": "Crawl a website starting from a URL and explore linked pages. This tool allows systematic collection of content from multiple pages within a domain. Use this for larger data collection tasks, content indexing, or site mapping.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "format": "uri",
              "description": "The URL of the webpage to crawl."
            },
            "maxPages": {
              "type": "integer",
              "default": 10,
              "maximum": 100,
              "minimum": 1,
              "exclusiveMinimum": 0
            },
            "followLinks": {
              "type": "boolean",
              "description": "Whether to follow links on the crawled webpages"
            },
            "outputFormat": {
              "type": "array",
              "items": {
                "enum": [
                  "markdown",
                  "html",
                  "links",
                  "screenshot"
                ],
                "type": "string"
              },
              "minItems": 1,
              "description": "The format of the output"
            },
            "ignoreSitemap": {
              "type": "boolean",
              "default": false
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "profile": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "ID of the persistent profile to use for the session"
                    },
                    "persistChanges": {
                      "type": "boolean",
                      "default": true,
                      "description": "Whether changes made during the session should be saved to the profile. Recommended true."
                    }
                  },
                  "description": "Options for using a persistent Hyperbrowser profile",
                  "additionalProperties": false
                },
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                }
              },
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly",
              "additionalProperties": false
            }
          },
          "required": [
            "url",
            "outputFormat",
            "followLinks"
          ]
        }
      },
      {
        "name": "extract_structured_data",
        "description": "Extract structured data from a webpage. This tool allows you to extract structured data from a webpage using a schema.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uri"
              },
              "description": "The list of URLs of the webpages to extract structured information from. Can include wildcards (e.g. https://example.com/*)"
            },
            "prompt": {
              "type": "string",
              "description": "The prompt to use for the extraction"
            },
            "schema": {
              "description": "The json schema to use for the extraction. Must provide an object describing a spec compliant json schema, any other types are invalid."
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "profile": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "ID of the persistent profile to use for the session"
                    },
                    "persistChanges": {
                      "type": "boolean",
                      "default": true,
                      "description": "Whether changes made during the session should be saved to the profile. Recommended true."
                    }
                  },
                  "description": "Options for using a persistent Hyperbrowser profile",
                  "additionalProperties": false
                },
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                }
              },
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly",
              "additionalProperties": false
            }
          },
          "required": [
            "urls",
            "prompt"
          ]
        }
      },
      {
        "name": "browser_use_agent",
        "description": "This tool employs an open-source browser automation agent optimized specifically for fast, efficient, and cost-effective browser tasks using a cloud browser. It requires explicit, detailed instructions to perform highly specific interactions quickly.\n\nOptimal for tasks requiring:\n- Precise, explicitly defined interactions and actions\n- Speed and efficiency with clear, unambiguous instructions\n- Cost-effective automation at scale with straightforward workflows\n\nBest suited use cases include:\n- Explicitly defined registration and login processes\n- Clearly guided navigation through web apps\n- Structured, step-by-step web scraping with detailed guidance\n- Extracting data via explicitly specified browser interactions\n\nYou must provide extremely detailed step-by-step instructions, including exact elements, actions, and explicit context. Clearly define the desired outcome for optimal results. Returns the completed result or an error message if issues arise.\n\nNote: This agent trades off flexibility for significantly faster performance and lower costs compared to Claude and OpenAI agents.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "The task to perform inside the browser"
            },
            "maxSteps": {
              "type": "integer",
              "default": 25,
              "maximum": 100,
              "minimum": 1,
              "exclusiveMinimum": 0
            },
            "returnStepInfo": {
              "type": "boolean",
              "default": false,
              "description": "Whether to return step-by-step information about the task.Should be false by default. May contain excessive information, so we strongly recommend setting this to false."
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "profile": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "ID of the persistent profile to use for the session"
                    },
                    "persistChanges": {
                      "type": "boolean",
                      "default": true,
                      "description": "Whether changes made during the session should be saved to the profile. Recommended true."
                    }
                  },
                  "description": "Options for using a persistent Hyperbrowser profile",
                  "additionalProperties": false
                },
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                }
              },
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly",
              "additionalProperties": false
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "openai_computer_use_agent",
        "description": "This tool utilizes OpenAI's model to autonomously execute general-purpose browser-based tasks with balanced performance and reliability using a cloud browser. It handles complex interactions effectively with practical reasoning and clear execution.\n\nOptimal for tasks requiring:\n- Reliable, general-purpose browser automation\n- Clear, structured interactions with moderate complexity\n- Efficient handling of common web tasks and workflows\n\nBest suited use cases include:\n- Standard multi-step registration or form submissions\n- Navigating typical web applications requiring multiple interactions\n- Conducting structured web research tasks\n- Extracting data through interactive web processes\n\nProvide a clear step-by-step description, necessary context, and expected outcomes. Returns the completed result or an error message if issues arise.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "The task to perform inside the browser"
            },
            "maxSteps": {
              "type": "integer",
              "default": 25,
              "maximum": 100,
              "minimum": 1,
              "exclusiveMinimum": 0
            },
            "returnStepInfo": {
              "type": "boolean",
              "default": false,
              "description": "Whether to return step-by-step information about the task.Should be false by default. May contain excessive information, so we strongly recommend setting this to false."
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "profile": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "ID of the persistent profile to use for the session"
                    },
                    "persistChanges": {
                      "type": "boolean",
                      "default": true,
                      "description": "Whether changes made during the session should be saved to the profile. Recommended true."
                    }
                  },
                  "description": "Options for using a persistent Hyperbrowser profile",
                  "additionalProperties": false
                },
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                }
              },
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly",
              "additionalProperties": false
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "claude_computer_use_agent",
        "description": "This tool leverages Anthropic's Claude model to autonomously execute complex browser tasks with sophisticated reasoning capabilities using a cloud browser. It specializes in handling intricate, nuanced, or highly context-sensitive web interactions.\n\nOptimal for tasks requiring:\n- Complex reasoning over multiple web pages\n- Nuanced interpretation and flexible decision-making\n- Human-like interaction with detailed context awareness\n\nBest suited use cases include:\n- Multi-step processes requiring reasoning (e.g., detailed registrations or onboarding)\n- Interacting intelligently with advanced web apps\n- Conducting in-depth research with complex conditions\n- Extracting information from dynamic or interactive websites\n\nProvide detailed task instructions, relevant context, and clearly specify the desired outcome for best results. Returns the completed result or an error message if issues arise.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "The task to perform inside the browser"
            },
            "maxSteps": {
              "type": "integer",
              "default": 25,
              "maximum": 100,
              "minimum": 1,
              "exclusiveMinimum": 0
            },
            "returnStepInfo": {
              "type": "boolean",
              "default": false,
              "description": "Whether to return step-by-step information about the task.Should be false by default. May contain excessive information, so we strongly recommend setting this to false."
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "profile": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "ID of the persistent profile to use for the session"
                    },
                    "persistChanges": {
                      "type": "boolean",
                      "default": true,
                      "description": "Whether changes made during the session should be saved to the profile. Recommended true."
                    }
                  },
                  "description": "Options for using a persistent Hyperbrowser profile",
                  "additionalProperties": false
                },
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                }
              },
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly",
              "additionalProperties": false
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "search_with_bing",
        "description": "Search the web using Bing. This tool allows you to search the web using bing.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The search query to submit to Bing"
            },
            "numResults": {
              "type": "integer",
              "default": 10,
              "maximum": 50,
              "minimum": 1,
              "description": "Number of search results to return",
              "exclusiveMinimum": 0
            },
            "sessionOptions": {
              "type": "object",
              "properties": {
                "profile": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "description": "ID of the persistent profile to use for the session"
                    },
                    "persistChanges": {
                      "type": "boolean",
                      "default": true,
                      "description": "Whether changes made during the session should be saved to the profile. Recommended true."
                    }
                  },
                  "description": "Options for using a persistent Hyperbrowser profile",
                  "additionalProperties": false
                },
                "useProxy": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use a proxy. Recommended false."
                },
                "useStealth": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to use stealth mode. Recommended false."
                },
                "acceptCookies": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to automatically close the accept cookies popup. Recommended false."
                },
                "solveCaptchas": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to solve captchas. Recommended false."
                }
              },
              "description": "Options for the browser session. Avoid setting these if not mentioned explicitly",
              "additionalProperties": false
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "create_profile",
        "description": "Creates a new persistent Hyperbrowser profile.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "delete_profile",
        "description": "Deletes an existing persistent Hyperbrowser profile.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "profileId": {
              "type": "string",
              "description": "ID of the profile to delete"
            }
          },
          "required": [
            "profileId"
          ]
        }
      },
      {
        "name": "list_profiles",
        "description": "Lists existing persistent Hyperbrowser profiles, with optional pagination.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "description": "Page number for pagination (optional)",
              "exclusiveMinimum": 0
            },
            "limit": {
              "type": "integer",
              "description": "Number of profiles per page (optional)",
              "exclusiveMinimum": 0
            }
          }
        }
      }
    ]
  },
  {
    "name": "iamjzx-dida",
    "title": "Dida365 (TickTick) MCP Server",
    "description": "Provides tools for AI assistants to interact with the Dida365 (TickTick) task management API, allowing management of tasks and projects after user authorization.",
    "icon": "https://avatars.githubusercontent.com/iamjzx",
    "isOfficial": false,
    "homepage": "https://github.com/iamjzx/dida",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "my-mcp-server"
      ],
      "env": {
        "CLIENT_ID": "<client-id>",
        "SERVER_PORT": "<server-port>",
        "CLIENT_SECRET": "<client-secret>"
      }
    },
    "parameters": [
      {
        "name": "CLIENT_ID",
        "description": "Your Dida365 (TickTick) Client ID from the developer portal",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "SERVER_PORT",
        "description": "The port on which the MCP server will run",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CLIENT_SECRET",
        "description": "Your Dida365 (TickTick) Client Secret from the developer portal",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "localTime",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "createTask",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "desc": {
              "type": "string"
            },
            "items": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "title"
                ],
                "properties": {
                  "title": {
                    "type": "string"
                  },
                  "status": {
                    "type": "number"
                  },
                  "isAllDay": {
                    "type": "boolean"
                  },
                  "timeZone": {
                    "type": "string"
                  },
                  "sortOrder": {
                    "type": "number"
                  },
                  "startDate": {
                    "type": "string"
                  },
                  "completedTime": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "title": {
              "type": "string"
            },
            "content": {
              "type": "string"
            },
            "dueDate": {
              "type": "string"
            },
            "isAllDay": {
              "type": "boolean"
            },
            "priority": {
              "type": "string"
            },
            "timeZone": {
              "type": "string"
            },
            "reminders": {
              "type": "array"
            },
            "sortOrder": {
              "type": "number"
            },
            "startDate": {
              "type": "string"
            },
            "repeatFlag": {
              "type": "string"
            }
          },
          "required": [
            "title",
            "content"
          ]
        }
      },
      {
        "name": "getUserProject",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getProjectById",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "getProjectWithData",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "getTaskById",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            },
            "projectId": {
              "type": "string"
            }
          },
          "required": [
            "projectId",
            "taskId"
          ]
        }
      },
      {
        "name": "updateTask",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string"
            },
            "desc": {
              "type": "string"
            },
            "items": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "title"
                ],
                "properties": {
                  "title": {
                    "type": "string"
                  },
                  "status": {
                    "type": "number"
                  },
                  "isAllDay": {
                    "type": "boolean"
                  },
                  "timeZone": {
                    "type": "string"
                  },
                  "sortOrder": {
                    "type": "number"
                  },
                  "startDate": {
                    "type": "string"
                  },
                  "completedTime": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "title": {
              "type": "string"
            },
            "taskId": {
              "type": "string"
            },
            "content": {
              "type": "string"
            },
            "dueDate": {
              "type": "string"
            },
            "isAllDay": {
              "type": "boolean"
            },
            "priority": {
              "type": "string"
            },
            "timeZone": {
              "type": "string"
            },
            "projectId": {
              "type": "string"
            },
            "reminders": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "type",
                  "time",
                  "title",
                  "content",
                  "isAllDay"
                ],
                "properties": {
                  "time": {
                    "type": "string"
                  },
                  "type": {
                    "type": "string"
                  },
                  "title": {
                    "type": "string"
                  },
                  "content": {
                    "type": "string"
                  },
                  "isAllDay": {
                    "type": "boolean"
                  }
                },
                "additionalProperties": false
              }
            },
            "sortOrder": {
              "type": "number"
            },
            "startDate": {
              "type": "string"
            },
            "repeatFlag": {
              "type": "string"
            }
          },
          "required": [
            "projectId",
            "id",
            "taskId"
          ]
        }
      },
      {
        "name": "completeTask",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            },
            "projectId": {
              "type": "string"
            }
          },
          "required": [
            "projectId",
            "taskId"
          ]
        }
      },
      {
        "name": "deleteTask",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            },
            "projectId": {
              "type": "string"
            }
          },
          "required": [
            "projectId",
            "taskId"
          ]
        }
      },
      {
        "name": "createProject",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "kind": {
              "type": "string"
            },
            "name": {
              "type": "string"
            },
            "color": {
              "type": "string"
            },
            "viewMode": {
              "type": "string"
            },
            "sortOrder": {
              "type": "number"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "updateProject",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "kind": {
              "type": "string"
            },
            "name": {
              "type": "string"
            },
            "color": {
              "type": "string"
            },
            "viewMode": {
              "type": "string"
            },
            "projectId": {
              "type": "string"
            }
          }
        }
      }
    ]
  },
  {
    "name": "icraft2170-youtube-data-mcp-server",
    "title": "YouTube MCP Server",
    "description": "Enables AI language models to interact with YouTube content through a standardized interface, providing tools for retrieving video information, transcripts, channel analytics, and trend analysis.",
    "icon": "https://avatars.githubusercontent.com/icraft2170",
    "isOfficial": false,
    "homepage": "https://github.com/icraft2170/youtube-data-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "youtube-data-mcp-server"
      ],
      "env": {
        "YOUTUBE_API_KEY": "<youtube-api-key>",
        "YOUTUBE_TRANSCRIPT_LANG": "<youtube-transcript-lang>"
      }
    },
    "parameters": [
      {
        "name": "YOUTUBE_API_KEY",
        "description": "YouTube Data API key (required)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "YOUTUBE_TRANSCRIPT_LANG",
        "description": "Default caption language",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "getVideoDetails",
        "description": "Get detailed information about multiple YouTube videos. Returns comprehensive data including video metadata, statistics, and content details. Use this when you need complete information about specific videos.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "videoIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "videoIds"
          ]
        }
      },
      {
        "name": "searchVideos",
        "description": "Searches for videos based on a query string. Returns a list of videos matching the search criteria, including titles, descriptions, and metadata. Use this when you need to find videos related to specific topics or keywords.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string"
            },
            "maxResults": {
              "type": "number"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "getTranscripts",
        "description": "Retrieves transcripts for multiple videos. Returns the text content of videos' captions, useful for accessibility and content analysis. Use this when you need the spoken content of multiple videos.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "lang": {
              "type": "string"
            },
            "videoIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "videoIds"
          ]
        }
      },
      {
        "name": "getRelatedVideos",
        "description": "Retrieves related videos for a specific video. Returns a list of videos that are similar or related to the specified video, based on YouTube's recommendation algorithm. Use this when you want to discover content similar to a particular video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "videoId": {
              "type": "string"
            },
            "maxResults": {
              "type": "number"
            }
          },
          "required": [
            "videoId"
          ]
        }
      },
      {
        "name": "getChannelStatistics",
        "description": "Retrieves statistics for multiple channels. Returns detailed metrics including subscriber count, view count, and video count for each channel. Use this when you need to analyze the performance and reach of multiple YouTube channels.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channelIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "channelIds"
          ]
        }
      },
      {
        "name": "getChannelTopVideos",
        "description": "Retrieves the top videos from a specific channel. Returns a list of the most viewed or popular videos from the channel, based on view count. Use this when you want to identify the most successful content from a channel.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channelId": {
              "type": "string"
            },
            "maxResults": {
              "type": "number"
            }
          },
          "required": [
            "channelId"
          ]
        }
      },
      {
        "name": "getVideoEngagementRatio",
        "description": "Calculates the engagement ratio for multiple videos. Returns metrics such as view count, like count, comment count, and the calculated engagement ratio for each video. Use this when you want to measure the audience interaction with videos.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "videoIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "videoIds"
          ]
        }
      },
      {
        "name": "getTrendingVideos",
        "description": "Retrieves trending videos based on region and category. Returns a list of videos that are currently popular in the specified region and category. Use this when you want to discover what's trending in specific areas or categories. Available category IDs: 1 (Film & Animation), 2 (Autos & Vehicles), 10 (Music), 15 (Pets & Animals), 17 (Sports), 18 (Short Movies), 19 (Travel & Events), 20 (Gaming), 21 (Videoblogging), 22 (People & Blogs), 23 (Comedy), 24 (Entertainment), 25 (News & Politics), 26 (Howto & Style), 27 (Education), 28 (Science & Technology), 29 (Nonprofits & Activism), 30 (Movies), 31 (Anime/Animation), 32 (Action/Adventure), 33 (Classics), 34 (Comedy), 35 (Documentary), 36 (Drama), 37 (Family), 38 (Foreign), 39 (Horror), 40 (Sci-Fi/Fantasy), 41 (Thriller), 42 (Shorts), 43 (Shows), 44 (Trailers).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "categoryId": {
              "type": "string"
            },
            "maxResults": {
              "type": "number"
            },
            "regionCode": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "compareVideos",
        "description": "Compares multiple videos based on their statistics. Returns a comparison of view counts, like counts, comment counts, and other metrics for the specified videos. Use this when you want to analyze the performance of multiple videos side by side.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "videoIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "videoIds"
          ]
        }
      }
    ]
  },
  {
    "name": "idoru-influxdb-mcp-server",
    "title": "InfluxDB MCP Server",
    "description": "A Model Context Protocol server that provides Claude with access to InfluxDB time-series database instances, enabling data writing, querying, and management of organizations and buckets through natural language.",
    "icon": "https://avatars.githubusercontent.com/idoru",
    "isOfficial": false,
    "homepage": "https://github.com/idoru/influxdb-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "influxdb-mcp-server"
      ],
      "env": {
        "INFLUXDB_ORG": "<influxdb-org>",
        "INFLUXDB_URL": "<influxdb-url>",
        "INFLUXDB_TOKEN": "<influxdb-token>"
      }
    },
    "parameters": [
      {
        "name": "INFLUXDB_ORG",
        "description": "Default organization name for certain operations",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "INFLUXDB_URL",
        "description": "URL of the InfluxDB instance",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "INFLUXDB_TOKEN",
        "description": "Authentication token for the InfluxDB API",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "write-data",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "org": {
              "type": "string",
              "description": "The organization name"
            },
            "data": {
              "type": "string",
              "description": "Data in InfluxDB line protocol format"
            },
            "bucket": {
              "type": "string",
              "description": "The bucket name"
            },
            "precision": {
              "enum": [
                "ns",
                "us",
                "ms",
                "s"
              ],
              "type": "string",
              "description": "Timestamp precision (ns, us, ms, s)"
            }
          },
          "required": [
            "org",
            "bucket",
            "data"
          ]
        }
      },
      {
        "name": "query-data",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "org": {
              "type": "string",
              "description": "The organization name"
            },
            "query": {
              "type": "string",
              "description": "Flux query string"
            }
          },
          "required": [
            "org",
            "query"
          ]
        }
      },
      {
        "name": "create-bucket",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The bucket name"
            },
            "orgID": {
              "type": "string",
              "description": "The organization ID"
            },
            "retentionPeriodSeconds": {
              "type": "number",
              "description": "Retention period in seconds (optional)"
            }
          },
          "required": [
            "name",
            "orgID"
          ]
        }
      },
      {
        "name": "create-org",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The organization name"
            },
            "description": {
              "type": "string",
              "description": "Organization description (optional)"
            }
          },
          "required": [
            "name"
          ]
        }
      }
    ]
  },
  {
    "name": "inkdropapp-mcp-server",
    "title": "Inkdrop MCP Server",
    "description": "Integrates Inkdrop note-taking app with Claude AI through Model Context Protocol, allowing Claude to search, read, create, and update notes in your Inkdrop database.",
    "icon": "https://avatars.githubusercontent.com/inkdropapp",
    "isOfficial": true,
    "homepage": "https://github.com/inkdropapp/mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@inkdropapp/mcp-server"
      ],
      "env": {
        "INKDROP_LOCAL_PASSWORD": "<inkdrop-local-password>",
        "INKDROP_LOCAL_USERNAME": "<inkdrop-local-username>",
        "INKDROP_LOCAL_SERVER_URL": "<inkdrop-local-server-url>"
      }
    },
    "parameters": [
      {
        "name": "INKDROP_LOCAL_PASSWORD",
        "description": "Password for the Inkdrop Local HTTP Server",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "INKDROP_LOCAL_USERNAME",
        "description": "Username for the Inkdrop Local HTTP Server",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "INKDROP_LOCAL_SERVER_URL",
        "description": "URL for the Inkdrop Local HTTP Server",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "read-note",
        "description": "Retrieve the complete contents of the note by its ID from the database.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string",
              "description": "ID of the note to retrieve. It can be found as `_id` in the note docs. It always starts with `note:`."
            }
          },
          "required": [
            "noteId"
          ]
        }
      },
      {
        "name": "search-notes",
        "description": "List all notes that contain a given keyword.\nThe result does not include entire note bodies as they are truncated in 200 characters.\nYou have to retrieve the full note content by calling `read-note`.\nHere are tips to specify keywords effectively:\n\n## Use special qualifiers to narrow down results\n\nYou can use special qualifiers to get more accurate results. See the qualifiers and their usage examples:\n\n- **book**  \n  `book:Blog`: Searches for notes in the 'Blog' notebook.\n  `book:\"Desktop App\"`: Searches for notes in the 'Desktop App' notebook.\n- **bookId**\n  `bookId:kGlLniaV`: Searches for notes in the notebook ID 'book:kGlLniaV'.\n- **tag**  \n  `tag:JavaScript`: Searches for all notes having the 'JavaScript' tag. Read more about [tags](https://docs.inkdrop.app/manual/write-notes#tag-notes).\n- **status**  \n  `status:onHold`: Searches for all notes with the 'On hold' status. Read more about [statuses](/reference/note-statuses).\n- **title**  \n  `title:\"JavaScript setTimeout\"`: Searches for the note with the specified title.\n- **body**  \n  `body:KEYWORD`: Searches for a specific word in all notes. Equivalent to a [global search](#search-for-notes-across-all-notebooks).\n\n### Combine qualifiers\n\nYou can combine the filter qualifiers to refine data even more.\n\n**Find notes that contain the word 'Hello' and have the 'Issue' tag.**\n\n```text\nHello tag:Issue\n```\n\n**Find notes that contain the word 'Typescript,' have the 'Contribution' tag, and the 'Completed' status**\n\n```text\nTypescript tag:Contribution status:Completed\n```\n\n## Search for text with spaces\n\nTo find the text that includes spaces, put the text into the double quotation marks (\"):\n\n```text\n\"database associations\"\n```\n\n## Exclude text from search\n\nTo exclude text from the search results or ignore a specific qualifier, put the minus sign (-) before it. You can also combine the exclusions. See the examples:\n\n- `-book:Backend \"closure functions\"`: Ignores the 'Backend' notebook while searching for the 'closure functions' phrase.\n- `-tag:JavaScript`: Ignores all notes having the 'JavaScript' tag.\n- `-book:Typescript tag:work \"Data types\"`: Ignores the 'Typescript' notebook and the 'work' tag while searching for the 'Data types' phrase.\n- `-status:dropped title:\"Sprint 10.0\" debounce`: Ignores notes with the 'Dropped' status while searching for the 'debounce' word in the note with the 'Sprint 10.0' title.\n- `-\"Phrase to ignore\" \"in the rest of a sentence\"`: Ignores the 'Phrase to ignore' part while searching for 'in the rest of a sentence'.\n\nNote that you can't specify excluding modifiers only without including conditions.\n\n**WARNING**: Make sure to enter a text to search for after the exclusion modifier.\n\n- ✅ Will work  \n  `-book:Backend \"closure functions\"`\n\n- ⛔️ Won't work  \n   `-book:Backend`. There's no query. Inkdrop doesn't understand what to search for.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keyword": {
              "type": "string",
              "description": "Keyword to search for."
            }
          },
          "required": [
            "keyword"
          ]
        }
      },
      {
        "name": "list-notes",
        "description": "List all notes in a specified notebook with ID.\nThe result does not include entire note bodies as they are truncated in 200 characters.\nYou have to retrieve the full note content by calling `read-note`.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "enum": [
                "updatedAt",
                "createdAt",
                "title"
              ],
              "type": "string",
              "default": "updatedAt",
              "description": "Sort the documents by the specified field"
            },
            "bookId": {
              "type": "string",
              "description": "ID of the notebook. It always starts with 'book:'. You can retrieve a list of notebooks with `list-notebooks`"
            },
            "tagIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "An array of tag IDs to filter. It always starts with 'tag:'. You can retrieve a list of available tags from `list-tags`."
            },
            "keyword": {
              "type": "string",
              "description": "Keyword to filter notes"
            },
            "descending": {
              "type": "boolean",
              "default": true,
              "description": "Reverse the order of the output documents"
            }
          },
          "required": [
            "bookId"
          ]
        }
      },
      {
        "name": "create-note",
        "description": "Create a new note in the database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "maxLength": 1048576,
              "description": "The content of the note represented with Markdown"
            },
            "title": {
              "type": "string",
              "maxLength": 128,
              "description": "The note title"
            },
            "bookId": {
              "type": "string",
              "pattern": "^(book:|trash$)",
              "maxLength": 128,
              "minLength": 5,
              "description": "The notebook ID"
            },
            "status": {
              "enum": [
                "none",
                "active",
                "onHold",
                "completed",
                "dropped"
              ],
              "type": "string",
              "description": "The status of the note"
            }
          },
          "required": [
            "bookId",
            "title",
            "body"
          ]
        }
      },
      {
        "name": "update-note",
        "description": "Update the existing note in the database. You should retrieve the existing note with `read-note` first. When updating the note, you must specify not only the changed fields but also all the un-changed fields.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "_id": {
              "type": "string",
              "pattern": "^note:",
              "maxLength": 128,
              "minLength": 6,
              "description": "The unique document ID which should start with `note:` and the remains are randomly generated string"
            },
            "_rev": {
              "type": "string",
              "description": "This is a CouchDB specific field. The current MVCC-token/revision of this document (mandatory and immutable)."
            },
            "body": {
              "type": "string",
              "maxLength": 1048576,
              "description": "The content of the note in Markdown. NOTE: Do not escape special characters like `\\n`."
            },
            "title": {
              "type": "string",
              "maxLength": 128,
              "description": "The note title"
            },
            "bookId": {
              "type": "string",
              "pattern": "^(book:|trash$)",
              "maxLength": 128,
              "minLength": 5,
              "description": "The notebook ID"
            },
            "status": {
              "enum": [
                "none",
                "active",
                "onHold",
                "completed",
                "dropped"
              ],
              "type": "string",
              "description": "The status of the note"
            }
          },
          "required": [
            "_id",
            "_rev",
            "bookId",
            "title",
            "body"
          ]
        }
      },
      {
        "name": "list-notebooks",
        "description": "Retrieve a list of all notebooks",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list-tags",
        "description": "Retrieve a list of all tags",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "isaacwasserman-mcp-snowflake-server",
    "title": "mcp-snowflake-server",
    "description": "Snowflake integration implementing read and (optional) write operations as well as insight tracking",
    "icon": "https://avatars.githubusercontent.com/isaacwasserman",
    "isOfficial": false,
    "homepage": "https://github.com/isaacwasserman/mcp-snowflake-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp_snowflake_server"
      ],
      "env": {
        "SNOWFLAKE_ROLE": "<snowflake-role>",
        "SNOWFLAKE_USER": "<snowflake-user>",
        "SNOWFLAKE_SCHEMA": "<snowflake-schema>",
        "SNOWFLAKE_ACCOUNT": "<snowflake-account>",
        "SNOWFLAKE_DATABASE": "<snowflake-database>",
        "SNOWFLAKE_PASSWORD": "<snowflake-password>",
        "SNOWFLAKE_WAREHOUSE": "<snowflake-warehouse>"
      }
    },
    "parameters": [
      {
        "name": "SNOWFLAKE_ROLE",
        "description": "Your Snowflake role",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "SNOWFLAKE_USER",
        "description": "Your Snowflake username",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "SNOWFLAKE_SCHEMA",
        "description": "Your Snowflake schema",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "SNOWFLAKE_ACCOUNT",
        "description": "Your Snowflake account identifier",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "SNOWFLAKE_DATABASE",
        "description": "Your Snowflake database",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "SNOWFLAKE_PASSWORD",
        "description": "Your Snowflake password",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "SNOWFLAKE_WAREHOUSE",
        "description": "Your Snowflake warehouse",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "itseasy21-mcp-knowledge-graph",
    "title": "Knowledge Graph Memory Server",
    "description": "An implementation of persistent memory for Claude using a local knowledge graph, allowing the AI to remember information about users across conversations with customizable storage location.",
    "icon": "https://avatars.githubusercontent.com/itseasy21",
    "isOfficial": false,
    "homepage": "https://github.com/itseasy21/mcp-knowledge-graph",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@itseasy21/mcp-knowledge-graph"
      ],
      "env": {
        "MEMORY_FILE_PATH": "<memory-file-path>"
      }
    },
    "parameters": [
      {
        "name": "MEMORY_FILE_PATH",
        "description": "Custom path for the memory file",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "create_entities",
        "description": "Create multiple new entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entities": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "name",
                  "entityType",
                  "observations"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "The name of the entity"
                  },
                  "entityType": {
                    "type": "string",
                    "description": "The type of the entity"
                  },
                  "observations": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "An array of observation contents associated with the entity"
                  }
                }
              }
            }
          },
          "required": [
            "entities"
          ]
        }
      },
      {
        "name": "create_relations",
        "description": "Create multiple new relations between entities in the knowledge graph. Relations should be in active voice",
        "inputSchema": {
          "type": "object",
          "properties": {
            "relations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "from",
                  "to",
                  "relationType"
                ],
                "properties": {
                  "to": {
                    "type": "string",
                    "description": "The name of the entity where the relation ends"
                  },
                  "from": {
                    "type": "string",
                    "description": "The name of the entity where the relation starts"
                  },
                  "relationType": {
                    "type": "string",
                    "description": "The type of the relation"
                  }
                }
              }
            }
          },
          "required": [
            "relations"
          ]
        }
      },
      {
        "name": "add_observations",
        "description": "Add new observations to existing entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "observations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "entityName",
                  "contents"
                ],
                "properties": {
                  "contents": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "An array of observation contents to add"
                  },
                  "entityName": {
                    "type": "string",
                    "description": "The name of the entity to add the observations to"
                  }
                }
              }
            }
          },
          "required": [
            "observations"
          ]
        }
      },
      {
        "name": "delete_entities",
        "description": "Delete multiple entities and their associated relations from the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entityNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "An array of entity names to delete"
            }
          },
          "required": [
            "entityNames"
          ]
        }
      },
      {
        "name": "delete_observations",
        "description": "Delete specific observations from entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "deletions": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "entityName",
                  "observations"
                ],
                "properties": {
                  "entityName": {
                    "type": "string",
                    "description": "The name of the entity containing the observations"
                  },
                  "observations": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "An array of observations to delete"
                  }
                }
              }
            }
          },
          "required": [
            "deletions"
          ]
        }
      },
      {
        "name": "delete_relations",
        "description": "Delete multiple relations from the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "relations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "from",
                  "to",
                  "relationType"
                ],
                "properties": {
                  "to": {
                    "type": "string",
                    "description": "The name of the entity where the relation ends"
                  },
                  "from": {
                    "type": "string",
                    "description": "The name of the entity where the relation starts"
                  },
                  "relationType": {
                    "type": "string",
                    "description": "The type of the relation"
                  }
                }
              },
              "description": "An array of relations to delete"
            }
          },
          "required": [
            "relations"
          ]
        }
      },
      {
        "name": "read_graph",
        "description": "Read the entire knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "search_nodes",
        "description": "Search for nodes in the knowledge graph based on a query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The search query to match against entity names, types, and observation content"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "open_nodes",
        "description": "Open specific nodes in the knowledge graph by their names",
        "inputSchema": {
          "type": "object",
          "properties": {
            "names": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "An array of entity names to retrieve"
            }
          },
          "required": [
            "names"
          ]
        }
      }
    ]
  },
  {
    "name": "ivo-toby-contentful-mcp",
    "title": "contentful-mcp",
    "description": "Update, create, delete content, content-models and assets in your Contentful Space",
    "icon": "https://avatars.githubusercontent.com/ivo-toby",
    "isOfficial": false,
    "homepage": "https://github.com/ivo-toby/contentful-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@ivotoby/contentful-management-mcp-server"
      ],
      "env": {
        "SPACE_ID": "<space-id>",
        "ENVIRONMENT_ID": "<environment-id>",
        "CONTENTFUL_HOST": "<contentful-host>",
        "CONTENTFUL_MANAGEMENT_ACCESS_TOKEN": "<contentful-management-access-token>"
      }
    },
    "parameters": [
      {
        "name": "SPACE_ID",
        "description": "Optional space ID to scope operations to a specific space",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ENVIRONMENT_ID",
        "description": "Optional environment ID to scope operations to a specific environment",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CONTENTFUL_HOST",
        "description": "Contentful Management API Endpoint",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CONTENTFUL_MANAGEMENT_ACCESS_TOKEN",
        "description": "Your Content Management API token",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "search_entries",
        "description": "Search for entries using query parameters. Returns a maximum of 3 items per request. Use skip parameter to paginate through results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "object",
              "required": [
                "limit",
                "skip"
              ],
              "properties": {
                "skip": {
                  "type": "number",
                  "default": 0,
                  "description": "Number of items to skip for pagination"
                },
                "limit": {
                  "type": "number",
                  "default": 3,
                  "maximum": 3,
                  "description": "Maximum number of items to return (max: 3)"
                },
                "order": {
                  "type": "string"
                },
                "query": {
                  "type": "string"
                },
                "select": {
                  "type": "string"
                },
                "content_type": {
                  "type": "string"
                }
              },
              "description": "Query parameters for searching entries"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "query",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "create_entry",
        "description": "Create a new entry in Contentful. Before executing this function, you need to know the contentTypeId (not the content type NAME) and the fields of that contentType. You can get the fields definition by using the GET_CONTENT_TYPE tool. IMPORTANT: All field values MUST include a locale key (e.g., 'en-US') for each value, like: { title: { 'en-US': 'My Title' } }. Every field in Contentful requires a locale even for single-language content.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fields": {
              "type": "object",
              "description": "The fields of the entry with localized values. Example: { title: { 'en-US': 'My Title' }, description: { 'en-US': 'My Description' } }"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "contentTypeId": {
              "type": "string",
              "description": "The ID of the content type for the new entry"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "contentTypeId",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_entry",
        "description": "Retrieve an existing entry",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_entry",
        "description": "Update an existing entry. The handler will merge your field updates with the existing entry fields, so you only need to provide the fields and locales you want to change. IMPORTANT: All field values MUST include a locale key (e.g., 'en-US') for each value, like: { title: { 'en-US': 'My Updated Title' } }. Every field in Contentful requires a locale even for single-language content.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fields": {
              "type": "object",
              "description": "The fields to update with localized values. Example: { title: { 'en-US': 'My Updated Title' } }"
            },
            "entryId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "entryId",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_entry",
        "description": "Delete an entry",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_entry",
        "description": "Publish an entry or multiple entries. Accepts either a single entryId (string) or an array of entryIds (up to 100 entries). For a single entry, it uses the standard publish operation. For multiple entries, it automatically uses bulk publishing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "maxItems": 100,
                  "description": "Array of entry IDs to publish (max: 100)"
                }
              ],
              "description": "ID of the entry to publish, or an array of entry IDs (max: 100)"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "unpublish_entry",
        "description": "Unpublish an entry or multiple entries. Accepts either a single entryId (string) or an array of entryIds (up to 100 entries). For a single entry, it uses the standard unpublish operation. For multiple entries, it automatically uses bulk unpublishing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entryId": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "maxItems": 100,
                  "description": "Array of entry IDs to unpublish (max: 100)"
                }
              ],
              "description": "ID of the entry to unpublish, or an array of entry IDs (max: 100)"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "entryId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_assets",
        "description": "List assets in a space. Returns a maximum of 3 items per request. Use skip parameter to paginate through results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "skip": {
              "type": "number",
              "default": 0,
              "description": "Number of items to skip for pagination"
            },
            "limit": {
              "type": "number",
              "default": 3,
              "maximum": 3,
              "description": "Maximum number of items to return (max: 3)"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "limit",
            "skip",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "upload_asset",
        "description": "Upload a new asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "object",
              "required": [
                "upload",
                "fileName",
                "contentType"
              ],
              "properties": {
                "upload": {
                  "type": "string"
                },
                "fileName": {
                  "type": "string"
                },
                "contentType": {
                  "type": "string"
                }
              }
            },
            "title": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "description": {
              "type": "string"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "title",
            "file",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_asset",
        "description": "Retrieve an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_asset",
        "description": "Update an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "file": {
              "type": "object",
              "required": [
                "url",
                "fileName",
                "contentType"
              ],
              "properties": {
                "url": {
                  "type": "string"
                },
                "fileName": {
                  "type": "string"
                },
                "contentType": {
                  "type": "string"
                }
              }
            },
            "title": {
              "type": "string"
            },
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "description": {
              "type": "string"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_asset",
        "description": "Delete an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_asset",
        "description": "Publish an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "unpublish_asset",
        "description": "Unpublish an asset",
        "inputSchema": {
          "type": "object",
          "properties": {
            "assetId": {
              "type": "string"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "assetId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_content_types",
        "description": "List content types in a space. Returns a maximum of 10 items per request. Use skip parameter to paginate through results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "skip": {
              "type": "number",
              "default": 0,
              "description": "Number of items to skip for pagination"
            },
            "limit": {
              "type": "number",
              "default": 10,
              "maximum": 20,
              "description": "Maximum number of items to return (max: 3)"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "limit",
            "skip",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_content_type",
        "description": "Get details of a specific content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "contentTypeId": {
              "type": "string"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "contentTypeId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "create_content_type",
        "description": "Create a new content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "fields": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "name",
                  "type"
                ],
                "properties": {
                  "id": {
                    "type": "string",
                    "description": "The ID of the field"
                  },
                  "name": {
                    "type": "string",
                    "description": "Display name of the field"
                  },
                  "type": {
                    "enum": [
                      "Symbol",
                      "Text",
                      "Integer",
                      "Number",
                      "Date",
                      "Location",
                      "Object",
                      "Boolean",
                      "Link",
                      "Array"
                    ],
                    "type": "string",
                    "description": "Type of the field (Text, Number, Date, Location, Media, Boolean, JSON, Link, Array, etc)"
                  },
                  "items": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "enum": [
                          "Symbol",
                          "Link"
                        ],
                        "type": "string"
                      },
                      "linkType": {
                        "enum": [
                          "Entry",
                          "Asset"
                        ],
                        "type": "string"
                      },
                      "validations": {
                        "type": "array",
                        "items": {
                          "type": "object"
                        }
                      }
                    },
                    "description": "Required for Array fields. Specifies the type of items in the array"
                  },
                  "linkType": {
                    "enum": [
                      "Entry",
                      "Asset"
                    ],
                    "type": "string",
                    "description": "Required for Link fields. Specifies what type of resource this field links to"
                  },
                  "required": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether this field is required"
                  },
                  "localized": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether this field can be localized"
                  },
                  "validations": {
                    "type": "array",
                    "items": {
                      "type": "object"
                    },
                    "description": "Array of validation rules for the field"
                  }
                }
              },
              "description": "Array of field definitions for the content type"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "description": {
              "type": "string"
            },
            "displayField": {
              "type": "string"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "name",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_content_type",
        "description": "Update an existing content type. The handler will merge your field updates with existing content type data, so you only need to provide the fields and properties you want to change.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "fields": {
              "type": "array",
              "items": {
                "type": "object"
              }
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "description": {
              "type": "string"
            },
            "displayField": {
              "type": "string"
            },
            "contentTypeId": {
              "type": "string"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "contentTypeId",
            "fields",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_content_type",
        "description": "Delete a content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "contentTypeId": {
              "type": "string"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "contentTypeId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_content_type",
        "description": "Publish a content type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "contentTypeId": {
              "type": "string"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "contentTypeId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_spaces",
        "description": "List all available spaces",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_space",
        "description": "Get details of a space",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            }
          },
          "required": [
            "spaceId"
          ]
        }
      },
      {
        "name": "list_environments",
        "description": "List all environments in a space",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            }
          },
          "required": [
            "spaceId"
          ]
        }
      },
      {
        "name": "create_environment",
        "description": "Create a new environment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "spaceId": {
              "type": "string"
            },
            "environmentId": {
              "type": "string"
            }
          },
          "required": [
            "spaceId",
            "environmentId",
            "name"
          ]
        }
      },
      {
        "name": "delete_environment",
        "description": "Delete an environment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string"
            },
            "environmentId": {
              "type": "string"
            }
          },
          "required": [
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "bulk_validate",
        "description": "Validate multiple entries at once",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "entryIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of entry IDs to validate"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "entryIds",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "list_ai_actions",
        "description": "List all AI Actions in a space",
        "inputSchema": {
          "type": "object",
          "properties": {
            "skip": {
              "type": "number",
              "default": 0,
              "description": "Number of AI Actions to skip for pagination"
            },
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Maximum number of AI Actions to return"
            },
            "status": {
              "enum": [
                "all",
                "published"
              ],
              "type": "string",
              "description": "Filter AI Actions by status"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_ai_action",
        "description": "Get a specific AI Action by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to retrieve"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "create_ai_action",
        "description": "Create a new AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the AI Action"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "testCases": {
              "type": "array",
              "items": {
                "type": "object"
              },
              "description": "Optional array of test cases for the AI Action"
            },
            "description": {
              "type": "string",
              "description": "The description of the AI Action"
            },
            "instruction": {
              "type": "object",
              "required": [
                "template",
                "variables"
              ],
              "properties": {
                "template": {
                  "type": "string",
                  "description": "The prompt template with variable placeholders"
                },
                "variables": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "Array of variable definitions"
                },
                "conditions": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "Optional array of conditions for the template"
                }
              },
              "description": "The instruction object containing the template and variables"
            },
            "configuration": {
              "type": "object",
              "required": [
                "modelType",
                "modelTemperature"
              ],
              "properties": {
                "modelType": {
                  "type": "string",
                  "description": "The type of model to use (e.g., gpt-4)"
                },
                "modelTemperature": {
                  "type": "number",
                  "maximum": 1,
                  "minimum": 0,
                  "description": "The temperature setting for the model (0.0 to 1.0)"
                }
              },
              "description": "The model configuration"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "name",
            "description",
            "instruction",
            "configuration",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "update_ai_action",
        "description": "Update an existing AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the AI Action"
            },
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "testCases": {
              "type": "array",
              "items": {
                "type": "object"
              },
              "description": "Optional array of test cases for the AI Action"
            },
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to update"
            },
            "description": {
              "type": "string",
              "description": "The description of the AI Action"
            },
            "instruction": {
              "type": "object",
              "required": [
                "template",
                "variables"
              ],
              "properties": {
                "template": {
                  "type": "string",
                  "description": "The prompt template with variable placeholders"
                },
                "variables": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "Array of variable definitions"
                },
                "conditions": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  },
                  "description": "Optional array of conditions for the template"
                }
              },
              "description": "The instruction object containing the template and variables"
            },
            "configuration": {
              "type": "object",
              "required": [
                "modelType",
                "modelTemperature"
              ],
              "properties": {
                "modelType": {
                  "type": "string",
                  "description": "The type of model to use (e.g., gpt-4)"
                },
                "modelTemperature": {
                  "type": "number",
                  "maximum": 1,
                  "minimum": 0,
                  "description": "The temperature setting for the model (0.0 to 1.0)"
                }
              },
              "description": "The model configuration"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "aiActionId",
            "name",
            "description",
            "instruction",
            "configuration",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "delete_ai_action",
        "description": "Delete an AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to delete"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "publish_ai_action",
        "description": "Publish an AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to publish"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "unpublish_ai_action",
        "description": "Unpublish an AI Action",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to unpublish"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "invoke_ai_action",
        "description": "Invoke an AI Action with variables",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "variables": {
              "type": "object",
              "description": "Key-value pairs of variable IDs and their values",
              "additionalProperties": {
                "type": "string"
              }
            },
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action to invoke"
            },
            "outputFormat": {
              "enum": [
                "Markdown",
                "RichText",
                "PlainText"
              ],
              "type": "string",
              "default": "Markdown",
              "description": "The format of the output content"
            },
            "rawVariables": {
              "type": "array",
              "items": {
                "type": "object"
              },
              "description": "Array of raw variable objects (for complex variable types like references)"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            },
            "waitForCompletion": {
              "type": "boolean",
              "default": true,
              "description": "Whether to wait for the AI Action to complete before returning"
            }
          },
          "required": [
            "aiActionId",
            "spaceId",
            "environmentId"
          ]
        }
      },
      {
        "name": "get_ai_action_invocation",
        "description": "Get the result of a previous AI Action invocation",
        "inputSchema": {
          "type": "object",
          "properties": {
            "spaceId": {
              "type": "string",
              "description": "The ID of the Contentful space. This must be the space's ID, not its name, ask for this ID if it's unclear."
            },
            "aiActionId": {
              "type": "string",
              "description": "The ID of the AI Action"
            },
            "invocationId": {
              "type": "string",
              "description": "The ID of the specific invocation to retrieve"
            },
            "environmentId": {
              "type": "string",
              "default": "master",
              "description": "The ID of the environment within the space, by default this will be called Master"
            }
          },
          "required": [
            "aiActionId",
            "invocationId",
            "spaceId",
            "environmentId"
          ]
        }
      }
    ]
  },
  {
    "name": "janwilmake-uithub-mcp",
    "title": "UIThub MCP Server",
    "description": "Model Context Protocol server that enables Claude to retrieve and analyze code from GitHub repositories through the uithub API.",
    "icon": "https://avatars.githubusercontent.com/janwilmake",
    "isOfficial": false,
    "homepage": "https://github.com/janwilmake/uithub-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "uithub-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "getRepositoryContents",
        "description": "Get repository contents from GitHub. Unless otherwise instructed, ensure to always first get the tree only (omitFiles:true) to get an idea of the file structure. Afterwards, use the different filters to get only the context relevant to cater to the user request.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dir": {
              "type": "string",
              "description": "Comma-separated list of directories to include"
            },
            "ext": {
              "type": "string",
              "description": "Comma-separated list of file extensions to include"
            },
            "path": {
              "type": "string",
              "description": "File or directory path within the repository"
            },
            "repo": {
              "type": "string",
              "description": "GitHub repository name"
            },
            "owner": {
              "type": "string",
              "description": "GitHub repository owner"
            },
            "branch": {
              "type": "string",
              "description": "Branch name (defaults to main if not provided)"
            },
            "omitTree": {
              "type": "boolean",
              "description": "If true, response will not include the directory tree"
            },
            "maxTokens": {
              "type": "integer",
              "description": "Limit the response to a maximum number of tokens (defaults to 50000)"
            },
            "omitFiles": {
              "type": "boolean",
              "description": "If true, response will not include the file contents"
            },
            "excludeDir": {
              "type": "string",
              "description": "Comma-separated list of directories to exclude"
            },
            "excludeExt": {
              "type": "string",
              "description": "Comma-separated list of file extensions to exclude"
            },
            "maxFileSize": {
              "type": "integer",
              "description": "Maximum file size to include (in bytes)"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      }
    ]
  },
  {
    "name": "thirdstrandstudio-mcp-figma",
    "title": "mcp-figma",
    "description": "Figma MCP with full API functionality",
    "icon": "https://avatars.githubusercontent.com/thirdstrandstudio",
    "isOfficial": false,
    "homepage": "https://github.com/thirdstrandstudio/mcp-figma",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@jayarrowz/mcp-figma"
      ],
      "env": {
        "FIGMA_API_KEY": "<figma-api-key>"
      }
    },
    "parameters": [
      {
        "name": "FIGMA_API_KEY",
        "description": "Your Figma API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "figma_get_me",
        "description": "Get the current user",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "figma_get_file",
        "description": "Get a Figma file by key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "string",
              "description": "Comma separated list of nodes that you care about in the document"
            },
            "depth": {
              "type": "number",
              "description": "Positive integer representing how deep into the document tree to traverse"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "version": {
              "type": "string",
              "description": "A specific version ID to get"
            },
            "geometry": {
              "type": "string",
              "description": "Set to \"paths\" to export vector data"
            },
            "branch_data": {
              "type": "boolean",
              "description": "Returns branch metadata for the requested file"
            },
            "plugin_data": {
              "type": "string",
              "description": "A comma separated list of plugin IDs and/or the string \"shared\""
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_get_file_nodes",
        "description": "Get specific nodes from a Figma file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "string",
              "description": "A comma separated list of node IDs to retrieve and convert"
            },
            "depth": {
              "type": "number",
              "description": "Positive integer representing how deep into the node tree to traverse"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "version": {
              "type": "string",
              "description": "A specific version ID to get"
            },
            "geometry": {
              "type": "string",
              "description": "Set to \"paths\" to export vector data"
            },
            "plugin_data": {
              "type": "string",
              "description": "A comma separated list of plugin IDs and/or the string \"shared\""
            }
          },
          "required": [
            "fileKey",
            "ids"
          ]
        }
      },
      {
        "name": "figma_get_images",
        "description": "Render images from a Figma file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "string",
              "description": "A comma separated list of node IDs to render"
            },
            "scale": {
              "type": "number",
              "description": "A number between 0.01 and 4, the image scaling factor"
            },
            "format": {
              "enum": [
                "jpg",
                "png",
                "svg",
                "pdf"
              ],
              "type": "string",
              "description": "A string enum for the image output format"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "version": {
              "type": "string",
              "description": "A specific version ID to get"
            },
            "contents_only": {
              "type": "boolean",
              "description": "Whether content that overlaps the node should be excluded from rendering"
            },
            "svg_include_id": {
              "type": "boolean",
              "description": "Whether to include id attributes for all SVG elements"
            },
            "svg_outline_text": {
              "type": "boolean",
              "description": "Whether text elements are rendered as outlines (vector paths) or as <text> elements in SVGs"
            },
            "svg_include_node_id": {
              "type": "boolean",
              "description": "Whether to include node id attributes for all SVG elements"
            },
            "svg_simplify_stroke": {
              "type": "boolean",
              "description": "Whether to simplify inside/outside strokes and use stroke attribute if possible"
            },
            "use_absolute_bounds": {
              "type": "boolean",
              "description": "Use the full dimensions of the node regardless of whether or not it is cropped"
            }
          },
          "required": [
            "fileKey",
            "ids"
          ]
        }
      },
      {
        "name": "figma_get_image_fills",
        "description": "Get image fills in a Figma file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_get_file_versions",
        "description": "Get version history of a Figma file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "number",
              "description": "A version ID for one of the versions in the history. Gets versions after this ID"
            },
            "before": {
              "type": "number",
              "description": "A version ID for one of the versions in the history. Gets versions before this ID"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "page_size": {
              "type": "number",
              "description": "The number of items returned in a page of the response"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_get_comments",
        "description": "Get comments in a Figma file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "as_md": {
              "type": "boolean",
              "default": false,
              "description": "Whether to return the comments as markdown"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_post_comment",
        "description": "Add a comment to a Figma file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "message": {
              "type": "string",
              "description": "The text contents of the comment to post"
            },
            "comment_id": {
              "type": "string",
              "description": "The ID of the comment to reply to, if any"
            },
            "client_meta": {
              "description": "The position where to place the comment"
            }
          },
          "required": [
            "fileKey",
            "message"
          ]
        }
      },
      {
        "name": "figma_delete_comment",
        "description": "Delete a comment from a Figma file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "commentId": {
              "type": "string",
              "description": "The ID of the comment to delete"
            }
          },
          "required": [
            "fileKey",
            "commentId"
          ]
        }
      },
      {
        "name": "figma_get_comment_reactions",
        "description": "Get reactions for a comment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "commentId": {
              "type": "string",
              "description": "The ID of the comment to get reactions for"
            }
          },
          "required": [
            "fileKey",
            "commentId"
          ]
        }
      },
      {
        "name": "figma_post_comment_reaction",
        "description": "Add a reaction to a comment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "emoji": {
              "type": "string",
              "description": "The emoji to react with"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "commentId": {
              "type": "string",
              "description": "The ID of the comment to add a reaction to"
            }
          },
          "required": [
            "fileKey",
            "commentId",
            "emoji"
          ]
        }
      },
      {
        "name": "figma_delete_comment_reaction",
        "description": "Delete a reaction from a comment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "emoji": {
              "type": "string",
              "description": "The emoji to remove"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "commentId": {
              "type": "string",
              "description": "The ID of the comment to delete a reaction from"
            }
          },
          "required": [
            "fileKey",
            "commentId",
            "emoji"
          ]
        }
      },
      {
        "name": "figma_get_team_projects",
        "description": "Get projects in a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "teamId": {
              "type": "string",
              "description": "The ID of the team to get projects for"
            }
          },
          "required": [
            "teamId"
          ]
        }
      },
      {
        "name": "figma_get_project_files",
        "description": "Get files in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string",
              "description": "The ID of the project to get files for"
            },
            "branch_data": {
              "type": "boolean",
              "description": "Returns branch metadata in the response"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "figma_get_team_components",
        "description": "Get components in a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "number",
              "description": "Cursor indicating which id after which to start retrieving components for"
            },
            "before": {
              "type": "number",
              "description": "Cursor indicating which id before which to start retrieving components for"
            },
            "teamId": {
              "type": "string",
              "description": "The ID of the team to get components for"
            },
            "page_size": {
              "type": "number",
              "description": "Number of items to return in a paged list of results"
            }
          },
          "required": [
            "teamId"
          ]
        }
      },
      {
        "name": "figma_get_file_components",
        "description": "Get components in a file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_get_component",
        "description": "Get a component by key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "The key of the component to get"
            }
          },
          "required": [
            "key"
          ]
        }
      },
      {
        "name": "figma_get_team_component_sets",
        "description": "Get component sets in a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "number",
              "description": "Cursor indicating which id after which to start retrieving component sets for"
            },
            "before": {
              "type": "number",
              "description": "Cursor indicating which id before which to start retrieving component sets for"
            },
            "teamId": {
              "type": "string",
              "description": "The ID of the team to get component sets for"
            },
            "page_size": {
              "type": "number",
              "description": "Number of items to return in a paged list of results"
            }
          },
          "required": [
            "teamId"
          ]
        }
      },
      {
        "name": "figma_get_file_component_sets",
        "description": "Get component sets in a file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_get_component_set",
        "description": "Get a component set by key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "The key of the component set to get"
            }
          },
          "required": [
            "key"
          ]
        }
      },
      {
        "name": "figma_get_team_styles",
        "description": "Get styles in a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "number",
              "description": "Cursor indicating which id after which to start retrieving styles for"
            },
            "before": {
              "type": "number",
              "description": "Cursor indicating which id before which to start retrieving styles for"
            },
            "teamId": {
              "type": "string",
              "description": "The ID of the team to get styles for"
            },
            "page_size": {
              "type": "number",
              "description": "Number of items to return in a paged list of results"
            }
          },
          "required": [
            "teamId"
          ]
        }
      },
      {
        "name": "figma_get_file_styles",
        "description": "Get styles in a file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            }
          },
          "required": [
            "fileKey"
          ]
        }
      },
      {
        "name": "figma_get_style",
        "description": "Get a style by key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "The key of the style to get"
            }
          },
          "required": [
            "key"
          ]
        }
      },
      {
        "name": "figma_post_webhook",
        "description": "Create a webhook",
        "inputSchema": {
          "type": "object",
          "properties": {
            "status": {
              "type": "string",
              "description": "State of the webhook, including any error state it may be in"
            },
            "team_id": {
              "type": "string",
              "description": "Team id to receive updates about"
            },
            "endpoint": {
              "type": "string",
              "description": "The HTTP endpoint that will receive a POST request when the event triggers"
            },
            "passcode": {
              "type": "string",
              "description": "String that will be passed back to your webhook endpoint to verify that it is being called by Figma"
            },
            "event_type": {
              "type": "string",
              "description": "An enum representing the possible events that a webhook can subscribe to"
            },
            "description": {
              "type": "string",
              "description": "User provided description or name for the webhook"
            }
          },
          "required": [
            "event_type",
            "team_id",
            "endpoint",
            "passcode"
          ]
        }
      },
      {
        "name": "figma_get_webhook",
        "description": "Get a webhook by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "webhook_id": {
              "type": "string",
              "description": "The ID of the webhook to get"
            }
          },
          "required": [
            "webhook_id"
          ]
        }
      },
      {
        "name": "figma_update_webhook",
        "description": "Update a webhook",
        "inputSchema": {
          "type": "object",
          "properties": {
            "status": {
              "type": "string",
              "description": "State of the webhook, including any error state it may be in"
            },
            "endpoint": {
              "type": "string",
              "description": "The HTTP endpoint that will receive a POST request when the event triggers"
            },
            "passcode": {
              "type": "string",
              "description": "String that will be passed back to your webhook endpoint to verify that it is being called by Figma"
            },
            "webhook_id": {
              "type": "string",
              "description": "The ID of the webhook to update"
            },
            "description": {
              "type": "string",
              "description": "User provided description or name for the webhook"
            }
          },
          "required": [
            "webhook_id"
          ]
        }
      },
      {
        "name": "figma_delete_webhook",
        "description": "Delete a webhook",
        "inputSchema": {
          "type": "object",
          "properties": {
            "webhook_id": {
              "type": "string",
              "description": "The ID of the webhook to delete"
            }
          },
          "required": [
            "webhook_id"
          ]
        }
      },
      {
        "name": "figma_get_team_webhooks",
        "description": "Get webhooks for a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "team_id": {
              "type": "string",
              "description": "The ID of the team to get webhooks for"
            }
          },
          "required": [
            "team_id"
          ]
        }
      },
      {
        "name": "figma_get_library_analytics_component_usages",
        "description": "Get library analytics component usage data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "type": "string",
              "description": "Cursor indicating what page of data to fetch"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "group_by": {
              "enum": [
                "component",
                "file"
              ],
              "type": "string",
              "description": "A dimension to group returned analytics data by"
            }
          },
          "required": [
            "fileKey",
            "group_by"
          ]
        }
      },
      {
        "name": "figma_get_library_analytics_style_usages",
        "description": "Get library analytics style usage data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "type": "string",
              "description": "Cursor indicating what page of data to fetch"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "group_by": {
              "enum": [
                "style",
                "file"
              ],
              "type": "string",
              "description": "A dimension to group returned analytics data by"
            }
          },
          "required": [
            "fileKey",
            "group_by"
          ]
        }
      },
      {
        "name": "figma_get_library_analytics_variable_usages",
        "description": "Get library analytics variable usage data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cursor": {
              "type": "string",
              "description": "Cursor indicating what page of data to fetch"
            },
            "fileKey": {
              "type": "string",
              "description": "The file key to use for the operation"
            },
            "group_by": {
              "enum": [
                "variable",
                "file"
              ],
              "type": "string",
              "description": "A dimension to group returned analytics data by"
            }
          },
          "required": [
            "fileKey",
            "group_by"
          ]
        }
      }
    ]
  },
  {
    "name": "thirdstrandstudio-mcp-xpath",
    "title": "mcp-xpath",
    "description": "MCP Server for executing XPath queries on XML content",
    "icon": "https://avatars.githubusercontent.com/thirdstrandstudio",
    "isOfficial": false,
    "homepage": "https://github.com/thirdstrandstudio/mcp-xpath",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@jayarrowz/mcp-xpath"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "xpath",
        "description": "Select query XML content using XPath",
        "inputSchema": {
          "type": "object",
          "properties": {
            "xml": {
              "type": "string",
              "description": "The XML content to query"
            },
            "query": {
              "type": "string",
              "description": "The XPath query to execute"
            },
            "mimeType": {
              "type": "string",
              "default": "text/html",
              "description": "The MIME type (e.g. text/xml, application/xml, text/html, application/xhtml+xml)"
            }
          },
          "required": [
            "xml",
            "query"
          ]
        }
      },
      {
        "name": "xpathwithurl",
        "description": "Fetch content from a URL and select query it using XPath",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to fetch XML/HTML content from"
            },
            "query": {
              "type": "string",
              "description": "The XPath query to execute"
            },
            "mimeType": {
              "type": "string",
              "default": "text/html",
              "description": "The MIME type (e.g. text/xml, application/xml, text/html, application/xhtml+xml)"
            }
          },
          "required": [
            "url",
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "jbrower95-mcp-asset-gen",
    "title": "MCP Asset Generator",
    "description": "An MCP server that allows Claude to use OpenAI's image generation capabilities (gpt-image-1) to create image assets for users, which is particularly useful for game and web development projects.",
    "icon": "https://avatars.githubusercontent.com/jbrower95",
    "isOfficial": false,
    "homepage": "https://github.com/jbrower95/mcp-asset-gen",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-asset-gen"
      ],
      "env": {
        "API_KEY": "<api-key>"
      }
    },
    "parameters": [
      {
        "name": "API_KEY",
        "description": "OpenAI API Key required for accessing the image generation service",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "generateImage",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "size": {
              "enum": [
                "1024x1024",
                "1024x1536",
                "1536x1024",
                "auto"
              ],
              "type": "string",
              "description": "Size of the generated image"
            },
            "prompt": {
              "type": "string",
              "description": "Text description of the desired image content"
            },
            "quality": {
              "enum": [
                "auto",
                "low",
                "medium",
                "high"
              ],
              "type": "string",
              "description": "The quality of the image."
            },
            "outputPathAbsolute": {
              "type": "string",
              "description": "The absolute path where the image should be written out."
            }
          },
          "required": [
            "outputPathAbsolute",
            "prompt"
          ]
        }
      }
    ]
  },
  {
    "name": "jhgaylor-hirebase-mcp",
    "title": "HireBase MCP Server",
    "description": "Provides tools to interact with the HireBase Job API, enabling users to search for jobs using various criteria and retrieve detailed job information through natural language.",
    "icon": "https://avatars.githubusercontent.com/jhgaylor",
    "isOfficial": false,
    "homepage": "https://github.com/jhgaylor/hirebase-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "hirebase-mcp"
      ],
      "env": {
        "HIREBASE_API_KEY": "<hirebase-api-key>"
      }
    },
    "parameters": [
      {
        "name": "HIREBASE_API_KEY",
        "description": "Your API key for accessing the HireBase API. The server needs this to make authenticated requests for job data.",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "search_jobs",
        "description": "Search for jobs using the HireBase API\n\n    Args:\n        query: Full text search query\n        and_keywords: Keywords that must all appear in results\n        or_keywords: Keywords where at least one must appear\n        not_keywords: Keywords that must not appear\n        title: Job titles to search for\n        category: Job categories to filter by\n        country: Countries to filter by\n        city: Cities to filter by\n        location_type: Location types (Remote, In-Person, Hybrid)\n        company: Companies to filter by\n        salary_from: Minimum salary\n        salary_to: Maximum salary\n        salary_currency: Salary currency (e.g. USD)\n        years_from: Minimum years of experience\n        years_to: Maximum years of experience\n        visa: Whether job offers visa sponsorship\n        limit: Maximum number of results to return\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "city": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "City",
              "default": null
            },
            "visa": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Visa",
              "default": null
            },
            "limit": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Limit",
              "default": 10
            },
            "query": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Query",
              "default": null
            },
            "title": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Title",
              "default": null
            },
            "company": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Company",
              "default": null
            },
            "country": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Country",
              "default": null
            },
            "category": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Category",
              "default": null
            },
            "years_to": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Years To",
              "default": null
            },
            "salary_to": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Salary To",
              "default": null
            },
            "years_from": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Years From",
              "default": null
            },
            "or_keywords": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Or Keywords",
              "default": null
            },
            "salary_from": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Salary From",
              "default": null
            },
            "and_keywords": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "And Keywords",
              "default": null
            },
            "not_keywords": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Not Keywords",
              "default": null
            },
            "location_type": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Location Type",
              "default": null
            },
            "salary_currency": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Salary Currency",
              "default": null
            }
          }
        }
      },
      {
        "name": "get_job",
        "description": "Get detailed information about a specific job\n\n    Args:\n        job_id: The unique identifier of the job\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "job_id": {
              "type": "string",
              "title": "Job Id"
            }
          },
          "required": [
            "job_id"
          ]
        }
      }
    ]
  },
  {
    "name": "jiayao-mcp-chess",
    "title": "MCP Chess Server",
    "description": "A server that enables users to play chess against any LLM, with features for visualizing the board, making moves in standard notation, and analyzing positions from PGN files.",
    "icon": "https://avatars.githubusercontent.com/jiayao",
    "isOfficial": false,
    "homepage": "https://github.com/jiayao/mcp-chess",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-chess"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_board_visualization",
        "description": "Provides the current state of the chessboard as an image.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_turn",
        "description": "Indicates whose turn it is ('white' or 'black').",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_valid_moves",
        "description": "Lists all legal moves for the current player in UCI notation.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "make_move",
        "description": "\n    Makes a move on the board using standard algebraic notation (SAN).\n    Args:\n        move_san: The player's move in algebraic notation (e.g., 'e4', 'Nf3', 'Bxe5').\n    Returns:\n        A dictionary containing the move in SAN format, the move in UCI format, the new board FEN,\n        whether the game is over, and the result if applicable.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "move_san": {
              "type": "string",
              "title": "Move San"
            }
          },
          "required": [
            "move_san"
          ]
        }
      },
      {
        "name": "new_game",
        "description": "\n    Starts a new game, resetting the board to the initial position.\n\n    Args:\n        user_plays_white: Whether the user will play as white. Defaults to True.\n    \n    Returns:\n        A confirmation message indicating the game has started and the user's color.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user_plays_white": {
              "type": "boolean",
              "title": "User Plays White",
              "default": true
            }
          }
        }
      },
      {
        "name": "find_position_in_pgn",
        "description": "\n    Finds the first board position in a PGN string that matches a given condition\n    (e.g., 'bishop on a3') and returns an image of that board.\n\n    Args:\n        pgn_string: The PGN string of the game.\n        condition: A string describing the condition, format: \"piece_type on square_name\"\n                   (e.g., \"bishop on a3\", \"knight on f6\", \"king on g1\").\n\n    Returns:\n        An Image dictionary containing the PNG data of the board state if found,\n        or a string with an error message.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "condition": {
              "type": "string",
              "title": "Condition"
            },
            "pgn_string": {
              "type": "string",
              "title": "Pgn String"
            }
          },
          "required": [
            "pgn_string",
            "condition"
          ]
        }
      }
    ]
  },
  {
    "name": "jinzcdev-leetcode-mcp-server",
    "title": "LeetCode MCP Server",
    "description": "A Model Context Protocol server that provides integration with LeetCode APIs, enabling automated interaction with programming problems, contests, solutions, and user data across both leetcode.com and leetcode.cn platforms.",
    "icon": "https://avatars.githubusercontent.com/jinzcdev",
    "isOfficial": false,
    "homepage": "https://github.com/jinzcdev/leetcode-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@jinzcdev/leetcode-mcp-server"
      ],
      "env": {
        "LEETCODE_SITE": "<leetcode-site>",
        "LEETCODE_SESSION": "<leetcode-session>"
      }
    },
    "parameters": [
      {
        "name": "LEETCODE_SITE",
        "description": "LeetCode API endpoint ('global' or 'cn')",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "LEETCODE_SESSION",
        "description": "LeetCode session cookie for authenticated API access",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get_daily_challenge",
        "description": "Retrieves today's LeetCode Daily Challenge problem with complete details, including problem description, constraints, and examples",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_problem",
        "description": "Retrieves details about a specific LeetCode problem, including its description, examples, constraints, and related information",
        "inputSchema": {
          "type": "object",
          "properties": {
            "titleSlug": {
              "type": "string",
              "description": "The URL slug/identifier of the problem (e.g., 'two-sum', 'add-two-numbers') as it appears in the LeetCode URL"
            }
          },
          "required": [
            "titleSlug"
          ]
        }
      },
      {
        "name": "search_problems",
        "description": "Searches for LeetCode problems based on multiple filter criteria including categories, tags, difficulty levels, and keywords, with pagination support",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "type": "array",
              "items": {
                "enum": [
                  "array",
                  "string",
                  "hash-table",
                  "dynamic-programming",
                  "math",
                  "sorting",
                  "greedy",
                  "depth-first-search",
                  "binary-search",
                  "database",
                  "tree",
                  "breadth-first-search",
                  "matrix",
                  "bit-manipulation",
                  "two-pointers",
                  "binary-tree",
                  "heap-priority-queue",
                  "prefix-sum",
                  "stack",
                  "simulation",
                  "graph",
                  "counting",
                  "sliding-window",
                  "design",
                  "backtracking",
                  "enumeration",
                  "linked-list",
                  "union-find",
                  "ordered-set",
                  "monotonic-stack",
                  "number-theory",
                  "trie",
                  "segment-tree",
                  "recursion",
                  "divide-and-conquer",
                  "queue",
                  "combinatorics",
                  "binary-search-tree",
                  "bitmask",
                  "memoization",
                  "geometry",
                  "binary-indexed-tree",
                  "hash-function",
                  "topological-sort",
                  "string-matching",
                  "shortest-path",
                  "rolling-hash",
                  "game-theory",
                  "data-stream",
                  "interactive",
                  "monotonic-queue",
                  "brainteaser",
                  "doubly-linked-list",
                  "merge-sort",
                  "randomized",
                  "quickselect",
                  "counting-sort",
                  "iterator",
                  "probability-and-statistics",
                  "concurrency",
                  "bucket-sort",
                  "suffix-array",
                  "line-sweep",
                  "minimum-spanning-tree",
                  "shell",
                  "reservoir-sampling",
                  "strongly-connected-component",
                  "eulerian-circuit",
                  "radix-sort",
                  "biconnected-component",
                  "rejection-sampling"
                ],
                "type": "string"
              },
              "description": "List of topic tags to filter problems by (e.g., ['array', 'dynamic-programming', 'tree'])"
            },
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of problems to return in a single request (for pagination)"
            },
            "offset": {
              "type": "number",
              "description": "Number of problems to skip (for pagination)"
            },
            "category": {
              "enum": [
                "all-code-essentials",
                "algorithms",
                "database",
                "pandas",
                "javascript",
                "shell",
                "concurrency"
              ],
              "type": "string",
              "default": "all-code-essentials",
              "description": "Problem category filter (e.g., 'algorithms', 'database', 'shell') to narrow down the problem domain"
            },
            "difficulty": {
              "enum": [
                "EASY",
                "MEDIUM",
                "HARD"
              ],
              "type": "string",
              "description": "Problem difficulty level filter to show only problems of a specific difficulty"
            },
            "searchKeywords": {
              "type": "string",
              "description": "Keywords to search in problem titles and descriptions"
            }
          }
        }
      },
      {
        "name": "get_user_profile",
        "description": "Retrieves profile information about a LeetCode user, including user stats, solved problems, and profile details",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "description": "LeetCode username to retrieve profile information for"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_recent_submissions",
        "description": "Retrieves a user's recent submissions on LeetCode Global, including both accepted and failed submissions with detailed metadata",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of submissions to return (optional, defaults to server-defined limit)"
            },
            "username": {
              "type": "string",
              "description": "LeetCode username to retrieve recent submissions for"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_recent_ac_submissions",
        "description": "Retrieves a user's recent accepted (AC) submissions on LeetCode Global, focusing only on successfully completed problems",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of accepted submissions to return (optional, defaults to server-defined limit)"
            },
            "username": {
              "type": "string",
              "description": "LeetCode username to retrieve recent accepted submissions for"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_user_status",
        "description": "Retrieves the current user's status on LeetCode, including login status, premium membership details, and user information (requires authentication)",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_problem_submission_report",
        "description": "Retrieves detailed information about a specific LeetCode submission by its ID, including source code, runtime stats, and test results (requires authentication)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "number",
              "description": "The numerical submission ID to retrieve detailed information for"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_problem_progress",
        "description": "Retrieves the current user's problem-solving status with filtering options, including detailed solution history for attempted or solved questions (requires authentication)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 100,
              "description": "The maximum number of questions to return in a single request"
            },
            "offset": {
              "type": "number",
              "default": 0,
              "description": "The number of questions to skip for pagination purposes"
            },
            "difficulty": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter by difficulty levels as an array (e.g., ['EASY', 'MEDIUM', 'HARD']); if not provided, questions of all difficulty levels will be returned"
            },
            "questionStatus": {
              "enum": [
                "ATTEMPTED",
                "SOLVED"
              ],
              "type": "string",
              "description": "Filter by question status: 'ATTEMPTED' for questions that have been tried but not necessarily solved, 'SOLVED' for questions that have been successfully completed"
            }
          }
        }
      },
      {
        "name": "get_all_submissions",
        "description": "Retrieves a paginated list of the current user's submissions for a specific problem or all problems on LeetCode Global, with detailed submission metadata (requires authentication)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 20,
              "description": "Maximum number of submissions to return per page (typically defaults to 20 if not specified)"
            },
            "offset": {
              "type": "number",
              "default": 0,
              "description": "Number of submissions to skip for pagination purposes"
            },
            "questionSlug": {
              "type": "string",
              "description": "Optional problem identifier (slug) to filter submissions for a specific problem (e.g., 'two-sum'); if omitted, returns submissions across all problems"
            }
          }
        }
      },
      {
        "name": "get_user_contest_ranking",
        "description": "Retrieves a user's contest ranking information on LeetCode, including overall ranking, participation history, and performance metrics across contests",
        "inputSchema": {
          "type": "object",
          "properties": {
            "attended": {
              "type": "boolean",
              "default": true,
              "description": "Whether to include only the contests the user has participated in (true) or all contests (false); defaults to true"
            },
            "username": {
              "type": "string",
              "description": "LeetCode username to retrieve contest ranking information for"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "list_problem_solutions",
        "description": "Retrieves a list of community solutions for a specific LeetCode problem, including only metadata like topicId. To view the full content of a solution, use the 'get_problem_solution' tool with the topicId returned by this tool.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "skip": {
              "type": "number",
              "description": "Number of solutions to skip before starting to collect results. Used in conjunction with 'limit' for implementing pagination. Default is 0 if not specified. Must be a non-negative integer."
            },
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of solutions to return per request. Used for pagination and controlling response size. Default is 20 if not specified. Must be a positive integer."
            },
            "orderBy": {
              "enum": [
                "HOT",
                " MOST_RECENT",
                "MOST_VOTES"
              ],
              "type": "string",
              "default": "HOT",
              "description": "Sorting criteria for the returned solutions. 'DEFAULT' sorts by LeetCode's default algorithm (typically a combination of recency and popularity), 'MOST_VOTES' sorts by the number of upvotes (highest first), and 'MOST_RECENT' sorts by publication date (newest first)."
            },
            "tagSlugs": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Array of tag identifiers to filter solutions by programming languages (e.g., 'python', 'java') or problem algorithm/data-structure tags (e.g., 'dynamic-programming', 'recursion'). Only solutions tagged with at least one of the specified tags will be returned."
            },
            "userInput": {
              "type": "string",
              "description": "Search term to filter solutions by title, content, or author name. Case insensitive. Useful for finding specific approaches or algorithms mentioned in solutions."
            },
            "questionSlug": {
              "type": "string",
              "description": "The URL slug/identifier of the problem to retrieve solutions for (e.g., 'two-sum', 'add-two-numbers'). This is the same string that appears in the LeetCode problem URL after '/problems/'"
            }
          },
          "required": [
            "questionSlug"
          ]
        }
      },
      {
        "name": "get_problem_solution",
        "description": "Retrieves the complete content and metadata of a specific solution, including the full article text, author information, and related navigation links",
        "inputSchema": {
          "type": "object",
          "properties": {
            "topicId": {
              "type": "string",
              "description": "The unique topic ID of the solution to retrieve. This ID can be obtained from the 'topicId' field in the response of the 'list_problem_solutions' tool. Format is typically a string of numbers and letters that uniquely identifies the solution in LeetCode's database."
            }
          },
          "required": [
            "topicId"
          ]
        }
      }
    ]
  },
  {
    "name": "jinzcdev-markmap-mcp-server",
    "title": "Markmap MCP Server",
    "description": "A Model Context Protocol server that converts Markdown text to interactive mind maps with support for rich interactive operations and multi-format exports.",
    "icon": "https://avatars.githubusercontent.com/jinzcdev",
    "isOfficial": false,
    "homepage": "https://github.com/jinzcdev/markmap-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@jinzcdev/markmap-mcp-server"
      ],
      "env": {
        "MARKMAP_DIR": "<markmap-dir>"
      }
    },
    "parameters": [
      {
        "name": "MARKMAP_DIR",
        "description": "Specify the output directory for mind maps (optional, defaults to system temp directory)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "markdown_to_mindmap",
        "description": "Convert a Markdown document into an interactive mind map",
        "inputSchema": {
          "type": "object",
          "properties": {
            "open": {
              "type": "boolean",
              "default": false,
              "description": "Whether to open the generated mind map in a browser (default: false)"
            },
            "markdown": {
              "type": "string",
              "description": "Markdown content to convert into a mind map"
            }
          },
          "required": [
            "markdown"
          ]
        }
      }
    ]
  },
  {
    "name": "jjikky-dynamo-readonly-mcp",
    "title": "DynamoDB Read-Only MCP",
    "description": "A server that enables LLMs like Claude to query AWS DynamoDB databases through natural language requests, supporting table management, data querying, and schema analysis.",
    "icon": "https://avatars.githubusercontent.com/jjikky",
    "isOfficial": false,
    "homepage": "https://github.com/jjikky/dynamo-readonly-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "dynamo-readonly-mcp"
      ],
      "env": {
        "AWS_REGION": "<aws-region>",
        "AWS_ACCESS_KEY_ID": "<aws-access-key-id>",
        "AWS_SECRET_ACCESS_KEY": "<aws-secret-access-key>"
      }
    },
    "parameters": [
      {
        "name": "AWS_REGION",
        "description": "The AWS region of your DynamoDB tables",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "AWS_ACCESS_KEY_ID",
        "description": "Your AWS access key for authentication",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "AWS_SECRET_ACCESS_KEY",
        "description": "Your AWS secret access key for authentication",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "list-tables",
        "description": "Get a list of all DynamoDB tables",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "describe-table",
        "description": "Get detailed information about a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tableName": {
              "type": "string",
              "description": "Name of the table to get details for"
            }
          },
          "required": [
            "tableName"
          ]
        }
      },
      {
        "name": "scan-table",
        "description": "Scan items from a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of items to return (default: 20)"
            },
            "tableName": {
              "type": "string",
              "description": "Name of the table to scan"
            },
            "filterExpression": {
              "type": "string",
              "description": "Filter expression (e.g: 'age > :minAge')"
            },
            "projectionExpression": {
              "type": "string",
              "description": "Projection expression (e.g: \"id\")"
            },
            "expressionAttributeValues": {
              "type": "object",
              "description": "Filter expression attribute values (JSON format)",
              "additionalProperties": {}
            }
          },
          "required": [
            "tableName"
          ]
        }
      },
      {
        "name": "query-table",
        "description": "Query items from a DynamoDB table based on conditions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of items to return"
            },
            "indexName": {
              "type": "string",
              "description": "Name of the index to use (optional)"
            },
            "tableName": {
              "type": "string",
              "description": "Name of the table to query"
            },
            "filterExpression": {
              "type": "string",
              "description": "Filter expression (optional)"
            },
            "projectionExpression": {
              "type": "string",
              "description": "Projection expression (optional)"
            },
            "keyConditionExpression": {
              "type": "string",
              "description": "Key condition expression (e.g: 'PK = :pk')"
            },
            "expressionAttributeValues": {
              "type": "object",
              "description": "Filter expression attribute values (JSON format)",
              "additionalProperties": {}
            }
          },
          "required": [
            "tableName",
            "keyConditionExpression",
            "expressionAttributeValues"
          ]
        }
      },
      {
        "name": "paginate-query-table",
        "description": "Paginate query results",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tableName": {
              "type": "string",
              "description": "Table name"
            },
            "projectionExpression": {
              "type": "string",
              "description": "Projection expression (optional)"
            },
            "keyConditionExpression": {
              "type": "string",
              "description": "Key condition expression (e.g: 'PK = :pk')"
            },
            "expressionAttributeValues": {
              "type": "object",
              "description": "Filter expression attribute values (JSON format)",
              "additionalProperties": {}
            }
          },
          "required": [
            "tableName",
            "keyConditionExpression",
            "expressionAttributeValues"
          ]
        }
      },
      {
        "name": "get-item",
        "description": "Get an item from a DynamoDB table based on a specific key",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "object",
              "description": "Item key (JSON format)",
              "additionalProperties": {}
            },
            "tableName": {
              "type": "string",
              "description": "Table name"
            }
          },
          "required": [
            "tableName",
            "key"
          ]
        }
      },
      {
        "name": "count-items",
        "description": "Count items in a DynamoDB table",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tableName": {
              "type": "string",
              "description": "Table name"
            },
            "filterExpression": {
              "type": "string",
              "description": "Filter expression (optional)"
            },
            "expressionAttributeValues": {
              "type": "object",
              "description": "Filter expression attribute values (optional)",
              "additionalProperties": {}
            }
          },
          "required": [
            "tableName"
          ]
        }
      }
    ]
  },
  {
    "name": "jkingsman-qanon-mcp-server",
    "title": "https://github.com/jkingsman/qanon-mcp-server",
    "description": "Enables search, exploration, and analysis of all QAnon posts for sociological study.",
    "icon": "https://avatars.githubusercontent.com/jkingsman",
    "isOfficial": false,
    "homepage": "https://github.com/jkingsman/qanon-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "qanon_mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "search_posts",
        "description": "\n    Search for posts/drops containing a specific keyword or phrase.\n\n    Args:\n        query: The keyword or phrase to search for\n        limit: Maximum number of results to return (default: 10)\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10
            },
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_posts_by_date",
        "description": "\n    Get posts/drops within a specific date range.\n\n    Args:\n        start_date: Start date in YYYY-MM-DD format\n        end_date: End date in YYYY-MM-DD format (defaults to start_date if not provided)\n        limit: Maximum number of results to return (default: 10)\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10
            },
            "end_date": {
              "type": "string",
              "title": "End Date",
              "default": null
            },
            "start_date": {
              "type": "string",
              "title": "Start Date"
            }
          },
          "required": [
            "start_date"
          ]
        }
      },
      {
        "name": "get_posts_by_author_id",
        "description": "\n    Get posts/drops by a specific author ID.\n\n    Args:\n        author_id: The author ID to search for\n        limit: Maximum number of results to return (default: 10)\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10
            },
            "author_id": {
              "type": "string",
              "title": "Author Id"
            }
          },
          "required": [
            "author_id"
          ]
        }
      },
      {
        "name": "analyze_post",
        "description": "\n    Get detailed analysis of a specific post/drop including references and context.\n\n    Args:\n        post_id: The ID of the post to analyze\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "post_id": {
              "type": "integer",
              "title": "Post Id"
            }
          },
          "required": [
            "post_id"
          ]
        }
      },
      {
        "name": "get_timeline_summary",
        "description": "\n    Get a timeline summary of posts/drops, optionally within a date range.\n\n    Args:\n        start_date: Optional start date in YYYY-MM-DD format\n        end_date: Optional end date in YYYY-MM-DD format\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end_date": {
              "type": "string",
              "title": "End Date",
              "default": null
            },
            "start_date": {
              "type": "string",
              "title": "Start Date",
              "default": null
            }
          }
        }
      }
    ]
  },
  {
    "name": "jlcases-paelladoc",
    "title": "PAELLADOC",
    "description": "A Model Context Protocol (MCP) server that implements AI-First Development framework principles, allowing LLMs to interact with context-first documentation tools and workflows for preserving knowledge and intent alongside code.",
    "icon": "https://avatars.githubusercontent.com/jlcases",
    "isOfficial": false,
    "homepage": "https://github.com/jlcases/paelladoc",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "paelladoc"
      ],
      "env": {
        "PAELLADOC_DB_PATH": "<paelladoc-db-path>"
      }
    },
    "parameters": [
      {
        "name": "PAELLADOC_DB_PATH",
        "description": "Path where PAELLADOC will store its memory database",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "core.continue",
        "description": "Continues work on an existing PAELLADOC project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_name": {
              "type": "string",
              "title": "Project Name"
            }
          },
          "required": [
            "project_name"
          ]
        }
      },
      {
        "name": "core.help",
        "description": "This ensures that users can quickly access help without needing to know the specific HELP command syntax.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "core.list_projects",
        "description": "Lists the names of existing PAELLADOC projects found in the memory.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "db_path": {
              "type": "string",
              "title": "Db Path",
              "default": null
            }
          }
        }
      },
      {
        "name": "paella_init",
        "description": "\n    Initialize a new PAELLADOC project.\n\n    Args:\n        base_path: Base path for project documentation\n        documentation_language: Language for documentation (e.g. 'es', 'en')\n        interaction_language: Language for interaction (e.g. 'es', 'en')\n        new_project_name: Name of the new project\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base_path": {
              "type": "string",
              "title": "Base Path"
            },
            "new_project_name": {
              "type": "string",
              "title": "New Project Name"
            },
            "interaction_language": {
              "type": "string",
              "title": "Interaction Language"
            },
            "documentation_language": {
              "type": "string",
              "title": "Documentation Language"
            }
          },
          "required": [
            "base_path",
            "documentation_language",
            "interaction_language",
            "new_project_name"
          ]
        }
      },
      {
        "name": "paella_list",
        "description": "List all available PAELLADOC projects.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "paella_select",
        "description": "\n    Select an existing PAELLADOC project.\n\n    Args:\n        project_name: Name of the project to select\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_name": {
              "type": "string",
              "title": "Project Name"
            }
          },
          "required": [
            "project_name"
          ]
        }
      },
      {
        "name": "core.verification",
        "description": "- **Overall Quality Score**: Composite score of all metrics",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "ping",
        "description": "\n    Basic health check; returns pong.\n    \n    Args:\n        random_string (str, optional): Dummy parameter for no-parameter tools\n\n    Returns:\n        Dict[str, Any]: Response with status and message\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "random_string": {
              "type": "string",
              "title": "Random String",
              "default": ""
            }
          }
        }
      }
    ]
  },
  {
    "name": "john-zhang-dev-xero-mcp",
    "title": "Xero MCP Server",
    "description": "An MCP server allowing Clients to interact with Xero Accounting Software",
    "icon": "https://avatars.githubusercontent.com/john-zhang-dev",
    "isOfficial": false,
    "homepage": "https://github.com/john-zhang-dev/xero-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "xero-mcp"
      ],
      "env": {
        "XERO_CLIENT_ID": "<xero-client-id>",
        "XERO_REDIRECT_URI": "<xero-redirect-uri>",
        "XERO_CLIENT_SECRET": "<xero-client-secret>"
      }
    },
    "parameters": [
      {
        "name": "XERO_CLIENT_ID",
        "description": "Your Xero OAuth 2.0 app client ID",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "XERO_REDIRECT_URI",
        "description": "The OAuth 2.0 redirect URI",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "XERO_CLIENT_SECRET",
        "description": "Your Xero OAuth 2.0 app client secret",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "authenticate",
        "description": "Authenticate with Xero using OAuth2",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_bank_transactions",
        "description": "Creates one or more spent or received money transaction. Only use this tool when user has directly and explicitly ask you to create transactions.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "Warnings": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ValidationError"
              },
              "description": "Displays array of warning messages from the API"
            },
            "pagination": {
              "$ref": "#/components/schemas/Pagination"
            },
            "BankTransactions": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/BankTransaction"
              }
            }
          }
        }
      },
      {
        "name": "create_contacts",
        "description": "Creates one or multiple contacts in a Xero organisation. Only use this tool when user has directly and explicitly ask you to create contact.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "Contacts": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Contact"
              }
            },
            "Warnings": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ValidationError"
              },
              "description": "Displays array of warning messages from the API"
            },
            "pagination": {
              "$ref": "#/components/schemas/Pagination"
            }
          }
        }
      },
      {
        "name": "get_balance_sheet",
        "description": "Returns a balance sheet for the end of the month of the specified date. It also returns the value at the end of the same month for the previous year.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_accounts",
        "description": "Retrieves the full chart of accounts",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_bank_transactions",
        "description": "Retrieves any spent or received money transactions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "where": {
              "type": "string",
              "example": "Date >= DateTime(2015, 01, 01) && Date < DateTime(2015, 12, 31)",
              "description": "Filter bank transactions. See example"
            }
          }
        }
      },
      {
        "name": "list_contacts",
        "description": "Retrieves all contacts in a Xero organisation",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_invoices",
        "description": "Retrieves sales invoices or purchase bills",
        "inputSchema": {
          "type": "object",
          "properties": {
            "where": {
              "type": "string",
              "example": "Date >= DateTime(2015, 01, 01) && Date < DateTime(2015, 12, 31), DueDate < DateTime(2015, 12, 31)",
              "description": "Filter invoices. See example"
            }
          }
        }
      },
      {
        "name": "list_journals",
        "description": "Retrieves journals",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_organisations",
        "description": "Retrieves Xero organisation details",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_payments",
        "description": "Retrieves payments for invoices and credit notes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "where": {
              "type": "string",
              "example": "Date >= DateTime(2015, 01, 01) && Date < DateTime(2015, 12, 31)",
              "description": "Filter payments. See example"
            }
          }
        }
      },
      {
        "name": "list_quotes",
        "description": "Retrieves sales quotes",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "johnnyoshika-mcp-server-sqlite-npx",
    "title": "MCP SQLite Server",
    "description": "A Node.js implementation of the Model Context Protocol server using SQLite, providing a npx-based alternative for environments lacking Python's UVX runner.",
    "icon": "https://avatars.githubusercontent.com/johnnyoshika",
    "isOfficial": false,
    "homepage": "https://github.com/johnnyoshika/mcp-server-sqlite-npx",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-server-sqlite-npx"
      ],
      "env": {
        "PATH": "<path>",
        "NODE_PATH": "<node-path>"
      }
    },
    "parameters": [
      {
        "name": "PATH",
        "description": "The system PATH environment variable used for executable lookups.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NODE_PATH",
        "description": "The NODE_PATH environment variable pointing to Node.js modules.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "joshuayoes-ios-simulator-mcp",
    "title": "iOS Simulator MCP",
    "description": "Enables interaction with iOS simulators by providing tools to inspect UI elements, control UI interactions, and manage simulators through natural language commands.",
    "icon": "https://avatars.githubusercontent.com/joshuayoes",
    "isOfficial": false,
    "homepage": "https://github.com/joshuayoes/ios-simulator-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "ios-simulator-mcp"
      ],
      "env": {
        "IOS_SIMULATOR_MCP_FILTERED_TOOLS": "<ios-simulator-mcp-filtered-tools>"
      }
    },
    "parameters": [
      {
        "name": "IOS_SIMULATOR_MCP_FILTERED_TOOLS",
        "description": "A comma-separated list of tool names to filter out from being registered. For example: screenshot,record_video,stop_recording",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get_booted_sim_id",
        "description": "Get the ID of the currently booted iOS simulator",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "ui_describe_all",
        "description": "Describes accessibility information for the entire screen in the iOS Simulator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "udid": {
              "type": "string",
              "description": "Udid of target, can also be set with the IDB_UDID env var"
            }
          }
        }
      },
      {
        "name": "ui_tap",
        "description": "Tap on the screen in the iOS Simulator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "description": "The x-coordinate"
            },
            "y": {
              "type": "number",
              "description": "The x-coordinate"
            },
            "udid": {
              "type": "string",
              "description": "Udid of target, can also be set with the IDB_UDID env var"
            },
            "duration": {
              "type": "string",
              "description": "Press duration"
            }
          },
          "required": [
            "x",
            "y"
          ]
        }
      },
      {
        "name": "ui_type",
        "description": "Input text into the iOS Simulator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "Text to input"
            },
            "udid": {
              "type": "string",
              "description": "Udid of target, can also be set with the IDB_UDID env var"
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "ui_swipe",
        "description": "Swipe on the screen in the iOS Simulator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "udid": {
              "type": "string",
              "description": "Udid of target, can also be set with the IDB_UDID env var"
            },
            "delta": {
              "type": "number",
              "default": 1,
              "description": "The size of each step in the swipe (default is 1)"
            },
            "x_end": {
              "type": "number",
              "description": "The ending x-coordinate"
            },
            "y_end": {
              "type": "number",
              "description": "The ending y-coordinate"
            },
            "x_start": {
              "type": "number",
              "description": "The starting x-coordinate"
            },
            "y_start": {
              "type": "number",
              "description": "The starting y-coordinate"
            }
          },
          "required": [
            "x_start",
            "y_start",
            "x_end",
            "y_end"
          ]
        }
      },
      {
        "name": "ui_describe_point",
        "description": "Returns the accessibility element at given co-ordinates on the iOS Simulator's screen",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "description": "The x-coordinate"
            },
            "y": {
              "type": "number",
              "description": "The y-coordinate"
            },
            "udid": {
              "type": "string",
              "description": "Udid of target, can also be set with the IDB_UDID env var"
            }
          },
          "required": [
            "x",
            "y"
          ]
        }
      },
      {
        "name": "screenshot",
        "description": "Takes a screenshot of the iOS Simulator",
        "inputSchema": {
          "type": "object",
          "properties": {
            "mask": {
              "enum": [
                "ignored",
                "alpha",
                "black"
              ],
              "type": "string",
              "description": "For non-rectangular displays, handle the mask by policy (ignored, alpha, or black)"
            },
            "type": {
              "enum": [
                "png",
                "tiff",
                "bmp",
                "gif",
                "jpeg"
              ],
              "type": "string",
              "description": "Image format (png, tiff, bmp, gif, or jpeg). Default is png."
            },
            "udid": {
              "type": "string",
              "description": "Udid of target, can also be set with the IDB_UDID env var"
            },
            "display": {
              "enum": [
                "internal",
                "external"
              ],
              "type": "string",
              "description": "Display to capture (internal or external). Default depends on device type."
            },
            "output_path": {
              "type": "string",
              "description": "File path where the screenshot will be saved (if relative, ~/Downloads will be used as base directory)"
            }
          },
          "required": [
            "output_path"
          ]
        }
      },
      {
        "name": "record_video",
        "description": "Records a video of the iOS Simulator using simctl directly",
        "inputSchema": {
          "type": "object",
          "properties": {
            "mask": {
              "enum": [
                "ignored",
                "alpha",
                "black"
              ],
              "type": "string",
              "description": "For non-rectangular displays, handle the mask by policy: \"ignored\", \"alpha\", or \"black\"."
            },
            "codec": {
              "enum": [
                "h264",
                "hevc"
              ],
              "type": "string",
              "description": "Specifies the codec type: \"h264\" or \"hevc\". Default is \"hevc\"."
            },
            "force": {
              "type": "boolean",
              "description": "Force the output file to be written to, even if the file already exists."
            },
            "display": {
              "enum": [
                "internal",
                "external"
              ],
              "type": "string",
              "description": "Display to capture: \"internal\" or \"external\". Default depends on device type."
            },
            "output_path": {
              "type": "string",
              "description": "Optional output path (defaults to ~/Downloads/simulator_recording_$DATE.mp4)"
            }
          }
        }
      },
      {
        "name": "stop_recording",
        "description": "Stops the simulator video recording using killall",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "jsonallen-perplexity-mcp",
    "title": "Perplexity MCP Server",
    "description": "A server facilitating web search functionality by utilizing Perplexity AI's API, designed to integrate with the Claude desktop client for enhanced search queries.",
    "icon": "https://avatars.githubusercontent.com/jsonallen",
    "isOfficial": false,
    "homepage": "https://github.com/jsonallen/perplexity-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "perplexity-mcp"
      ],
      "env": {
        "PERPLEXITY_API_KEY": "<perplexity-api-key>"
      }
    },
    "parameters": [
      {
        "name": "PERPLEXITY_API_KEY",
        "description": "Your Perplexity AI API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "juhemcp-jnews-mcp-server",
    "title": "Juhe News MCP Server",
    "description": "A Model Context Protocol server that enables large language models to access the latest trending news headlines and detailed content across various categories including recommended, domestic, technology, and sports news.",
    "icon": "https://avatars.githubusercontent.com/juhemcp",
    "isOfficial": true,
    "homepage": "https://github.com/juhemcp/jnews-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "jnews-mcp-server"
      ],
      "env": {
        "JUHE_NEWS_API_KEY": "<juhe-news-api-key>"
      }
    },
    "parameters": [
      {
        "name": "JUHE_NEWS_API_KEY",
        "description": "聚合数据的新闻头条API密钥。获取：https://www.juhe.cn/docs/api/id/235",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_news_list",
        "description": "通过新闻类型获取今日热点新闻头条",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "description": "当前页数, 默认1, 最大50"
            },
            "type": {
              "type": "string",
              "description": "新闻类型:top(推荐,默认),guonei(国内),guoji(国际),yule(娱乐),tiyu(体育),junshi(军事),keji(科技),caijing(财经),youxi(游戏),qiche(汽车),jiankang(健康)"
            },
            "page_size": {
              "type": "number",
              "description": "每页返回新闻条数, 默认20, 最大50"
            }
          }
        }
      },
      {
        "name": "get_news_content",
        "description": "根据新闻ID获取新闻的详细内容",
        "inputSchema": {
          "type": "object",
          "properties": {
            "uniquekey": {
              "type": "string",
              "description": "新闻ID(gew_news_list中返回的uniquekey)"
            }
          },
          "required": [
            "uniquekey"
          ]
        }
      }
    ]
  },
  {
    "name": "kaliaboi-mcp-zotero",
    "title": "MCP Zotero",
    "description": "Allows AI to interact with your Zotero library.",
    "icon": "https://avatars.githubusercontent.com/kaliaboi",
    "isOfficial": false,
    "homepage": "https://github.com/kaliaboi/mcp-zotero",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-zotero"
      ],
      "env": {
        "ZOTERO_API_KEY": "<zotero-api-key>",
        "ZOTERO_USER_ID": "<zotero-user-id>"
      }
    },
    "parameters": [
      {
        "name": "ZOTERO_API_KEY",
        "description": "Your Zotero API key created at https://www.zotero.org/settings/keys",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "ZOTERO_USER_ID",
        "description": "Your Zotero user ID obtained from the API",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "kazuph-mcp-browser-tabs",
    "title": "MCP Browser Tabs Server",
    "description": "Enables interaction with Google Chrome tabs through the MCP protocol, allowing clients to retrieve information and control tabs on macOS using AppleScript.",
    "icon": "https://avatars.githubusercontent.com/kazuph",
    "isOfficial": false,
    "homepage": "https://github.com/kazuph/mcp-browser-tabs",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@kazuph/mcp-browser-tabs"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "kazuph-mcp-fetch",
    "title": "@kazuph/mcp-fetch",
    "description": "Model Context Protocol server for fetching web content and processing images. This allows Claude Desktop (or any MCP client) to fetch web content and handle images appropriately.",
    "icon": "https://avatars.githubusercontent.com/kazuph",
    "isOfficial": false,
    "homepage": "https://github.com/kazuph/mcp-fetch",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@kazuph/mcp-fetch"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "fetch",
        "description": "\nRetrieves URLs from the Internet and extracts their content as markdown.\nImages from the page will be processed and included with the response automatically.\n\nParameters:\n  - url (required): The URL to fetch\n  - maxLength (default: 20000): Maximum length of content to return\n  - startIndex (default: 0): Starting position in content\n  - imageStartIndex (default: 0): Starting position for image collection\n  - raw (default: false): Return raw content instead of processed markdown\n  - imageMaxCount (default: 3): Maximum number of images to process per request\n  - imageMaxHeight (default: 4000): Maximum height of merged image\n  - imageMaxWidth (default: 1000): Maximum width of merged image\n  - imageQuality (default: 80): JPEG quality (1-100)\n  - disableImages (default: true): Skip image processing\n  - ignoreRobotsTxt (default: false): Ignore robots.txt restrictions\n\nImage Processing:\n  - Multiple images are merged vertically into a single JPEG\n  - Images are automatically optimized and resized\n  - GIF animations are converted to static images (first frame)\n  - Use imageStartIndex and imageMaxCount to paginate through all images\n  - Response includes remaining image count and current position\n\nIMPORTANT: All parameters must be in proper JSON format - use double quotes for keys\nand string values, and no quotes for numbers and booleans.\n\nExamples:\n# Initial fetch:\n{\n  \"url\": \"https://example.com\",\n  \"maxLength\": 10000,\n  \"imageMaxCount\": 2\n}\n\n# Fetch next set of images:\n{\n  \"url\": \"https://example.com\",\n  \"imageStartIndex\": 2,\n  \"imageMaxCount\": 2\n}",
        "inputSchema": {
          "type": "object",
          "properties": {
            "raw": {
              "type": [
                "boolean",
                "string"
              ],
              "default": false
            },
            "url": {
              "type": "string",
              "format": "uri"
            },
            "maxLength": {
              "allOf": [
                {
                  "type": [
                    "number",
                    "string"
                  ]
                },
                {
                  "type": "number",
                  "maximum": 1000000,
                  "exclusiveMinimum": 0
                }
              ],
              "default": 20000
            },
            "startIndex": {
              "allOf": [
                {
                  "type": [
                    "number",
                    "string"
                  ]
                },
                {
                  "type": "number",
                  "minimum": 0
                }
              ],
              "default": 0
            },
            "imageQuality": {
              "allOf": [
                {
                  "type": [
                    "number",
                    "string"
                  ]
                },
                {
                  "type": "number",
                  "maximum": 100,
                  "minimum": 1
                }
              ],
              "default": 80
            },
            "disableImages": {
              "type": [
                "boolean",
                "string"
              ],
              "default": true
            },
            "imageMaxCount": {
              "allOf": [
                {
                  "type": [
                    "number",
                    "string"
                  ]
                },
                {
                  "type": "number",
                  "maximum": 10,
                  "minimum": 0
                }
              ],
              "default": 3
            },
            "imageMaxWidth": {
              "allOf": [
                {
                  "type": [
                    "number",
                    "string"
                  ]
                },
                {
                  "type": "number",
                  "maximum": 10000,
                  "minimum": 100
                }
              ],
              "default": 1000
            },
            "imageMaxHeight": {
              "allOf": [
                {
                  "type": [
                    "number",
                    "string"
                  ]
                },
                {
                  "type": "number",
                  "maximum": 10000,
                  "minimum": 100
                }
              ],
              "default": 4000
            },
            "ignoreRobotsTxt": {
              "type": [
                "boolean",
                "string"
              ],
              "default": false
            },
            "imageStartIndex": {
              "allOf": [
                {
                  "type": [
                    "number",
                    "string"
                  ]
                },
                {
                  "type": "number",
                  "minimum": 0
                }
              ],
              "default": 0
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "kazuph-mcp-github-pera1",
    "title": "@kazuph/mcp-github-pera1",
    "description": "A Model Context Protocol server that connects GitHub code to Claude.ai. This server utilizes the Pera1 service to extract code from GitHub repositories and provide better context to Claude.",
    "icon": "https://avatars.githubusercontent.com/kazuph",
    "isOfficial": false,
    "homepage": "https://github.com/kazuph/mcp-github-pera1",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@kazuph/mcp-github-pera1"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "github_get_code",
        "description": "\nRetrieves code from a GitHub repository URL and combines it into a single file. The URL must start with \"https://\".\n\nQuery Parameters:\n- dir: Filter files by directory paths (comma-separated)\n  Example: ?dir=src/components,tests/unit\n- ext: Filter files by extensions (comma-separated)\n  Example: ?ext=ts,tsx,js\n- mode: Display mode\n  Example: ?mode=tree (Shows directory structure only)\n- branch: Specify the branch to fetch from (optional)\n  Example: ?branch=feature/new-feature\n\nExamples:\n1. For GitHub tree URLs with branch:\n  https://github.com/kazuph/pera1/tree/feature/great-branch\n  This URL will be automatically parsed to extract the branch information.\n\n2. For specific directory in a branch:\n  url: https://github.com/modelcontextprotocol/servers\n  dir: src/fetch\n  branch: develop\n\nThe tool will correctly parse the repository structure and fetch the files from the specified branch.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dir": {
              "type": "string"
            },
            "ext": {
              "type": "string"
            },
            "url": {
              "type": "string",
              "format": "uri"
            },
            "mode": {
              "enum": [
                "tree"
              ],
              "type": "string"
            },
            "branch": {
              "type": "string"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "kazuph-mcp-taskmanager",
    "title": "@kazuph/mcp-taskmanager",
    "description": "Model Context Protocol server for Task Management. This allows Claude Desktop (or any MCP client) to manage and execute tasks in a queue-based system.",
    "icon": "https://avatars.githubusercontent.com/kazuph",
    "isOfficial": false,
    "homepage": "https://github.com/kazuph/mcp-taskmanager",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@kazuph/mcp-taskmanager"
      ],
      "env": {
        "PUBMED_EMAIL": "<pubmed-email>",
        "PUBMED_API_KEY": "<pubmed-api-key>"
      }
    },
    "parameters": [
      {
        "name": "PUBMED_EMAIL",
        "description": "Your email address (required by NCBI)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "PUBMED_API_KEY",
        "description": "Optional API key for higher rate limits",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "request_planning",
        "description": "Register a new user request and plan its associated tasks. You must provide 'originalRequest' and 'tasks', and optionally 'splitDetails'.\n\nThis tool initiates a new workflow for handling a user's request. The workflow is as follows:\n1. Use 'request_planning' to register a request and its tasks.\n2. After adding tasks, you MUST use 'get_next_task' to retrieve the first task. A progress table will be displayed.\n3. Use 'get_next_task' to retrieve the next uncompleted task.\n4. **IMPORTANT:** After marking a task as done, the assistant MUST NOT proceed to another task without the user's approval. The user must explicitly approve the completed task using 'approve_task_completion'. A progress table will be displayed before each approval request.\n5. Once a task is approved, you can proceed to 'get_next_task' again to fetch the next pending task.\n6. Repeat this cycle until all tasks are done.\n7. After all tasks are completed (and approved), 'get_next_task' will indicate that all tasks are done and that the request awaits approval for full completion.\n8. The user must then approve the entire request's completion using 'approve_request_completion'. If the user does not approve and wants more tasks, you can again use 'request_planning' to add new tasks and continue the cycle.\n\nThe critical point is to always wait for user approval after completing each task and after all tasks are done, wait for request completion approval. Do not proceed automatically.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tasks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "title",
                  "description"
                ],
                "properties": {
                  "title": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  }
                }
              }
            },
            "splitDetails": {
              "type": "string"
            },
            "originalRequest": {
              "type": "string"
            }
          },
          "required": [
            "originalRequest",
            "tasks"
          ]
        }
      },
      {
        "name": "get_next_task",
        "description": "Given a 'requestId', return the next pending task (not done yet). If all tasks are completed, it will indicate that no more tasks are left and that you must wait for the request completion approval.\n\nA progress table showing the current status of all tasks will be displayed with each response.\n\nIf the same task is returned again or if no new task is provided after a task was marked as done but not yet approved, you MUST NOT proceed. In such a scenario, you must prompt the user for approval via 'approve_task_completion' before calling 'get_next_task' again. Do not skip the user's approval step.\nIn other words:\n- After calling 'mark_task_done', do not call 'get_next_task' again until 'approve_task_completion' is called by the user.\n- If 'get_next_task' returns 'all_tasks_done', it means all tasks have been completed. At this point, you must not start a new request or do anything else until the user decides to 'approve_request_completion' or possibly add more tasks via 'request_planning'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "requestId": {
              "type": "string"
            }
          },
          "required": [
            "requestId"
          ]
        }
      },
      {
        "name": "mark_task_done",
        "description": "Mark a given task as done after you've completed it. Provide 'requestId' and 'taskId', and optionally 'completedDetails'.\n\nAfter marking a task as done, a progress table will be displayed showing the updated status of all tasks.\n\nAfter this, DO NOT proceed to 'get_next_task' again until the user has explicitly approved this completed task using 'approve_task_completion'.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            },
            "requestId": {
              "type": "string"
            },
            "completedDetails": {
              "type": "string"
            }
          },
          "required": [
            "requestId",
            "taskId"
          ]
        }
      },
      {
        "name": "approve_task_completion",
        "description": "Once the assistant has marked a task as done using 'mark_task_done', the user must call this tool to approve that the task is genuinely completed. Only after this approval can you proceed to 'get_next_task' to move on.\n\nA progress table will be displayed before requesting approval, showing the current status of all tasks.\n\nIf the user does not approve, do not call 'get_next_task'. Instead, the user may request changes, or even re-plan tasks by using 'request_planning' again.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            },
            "requestId": {
              "type": "string"
            }
          },
          "required": [
            "requestId",
            "taskId"
          ]
        }
      },
      {
        "name": "approve_request_completion",
        "description": "After all tasks are done and approved, this tool finalizes the entire request. The user must call this to confirm that the request is fully completed.\n\nA progress table showing the final status of all tasks will be displayed before requesting final approval.\n\nIf not approved, the user can add new tasks using 'request_planning' and continue the process.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "requestId": {
              "type": "string"
            }
          },
          "required": [
            "requestId"
          ]
        }
      },
      {
        "name": "open_task_details",
        "description": "Get details of a specific task by 'taskId'. This is for inspecting task information at any point.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "list_requests",
        "description": "List all requests with their basic information and summary of tasks. This provides a quick overview of all requests in the system.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "add_tasks_to_request",
        "description": "Add new tasks to an existing request. This allows extending a request with additional tasks.\n\nA progress table will be displayed showing all tasks including the newly added ones.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tasks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "title",
                  "description"
                ],
                "properties": {
                  "title": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  }
                }
              }
            },
            "requestId": {
              "type": "string"
            }
          },
          "required": [
            "requestId",
            "tasks"
          ]
        }
      },
      {
        "name": "update_task",
        "description": "Update an existing task's title and/or description. Only uncompleted tasks can be updated.\n\nA progress table will be displayed showing the updated task information.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string"
            },
            "taskId": {
              "type": "string"
            },
            "requestId": {
              "type": "string"
            },
            "description": {
              "type": "string"
            }
          },
          "required": [
            "requestId",
            "taskId"
          ]
        }
      },
      {
        "name": "delete_task",
        "description": "Delete a specific task from a request. Only uncompleted tasks can be deleted.\n\nA progress table will be displayed showing the remaining tasks after deletion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            },
            "requestId": {
              "type": "string"
            }
          },
          "required": [
            "requestId",
            "taskId"
          ]
        }
      }
    ]
  },
  {
    "name": "keegancsmith-linear-issues-mcp-server",
    "title": "Linear Issues MCP Server",
    "description": "An MCP server providing read-only access to Linear issues for language models, allowing them to fetch issue details and comments using a Linear API token.",
    "icon": "https://avatars.githubusercontent.com/keegancsmith",
    "isOfficial": false,
    "homepage": "https://github.com/keegancsmith/linear-issues-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@keegancsmith/linear-issues-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "linear_get_issue",
        "description": "Fetch details of a single Linear issue by providing its URL or identifier.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue": {
              "type": "string",
              "description": "Linear issue URL or identifier (e.g., 'ENG-123' or 'https://linear.app/team/issue/ENG-123/issue-title')"
            }
          },
          "required": [
            "issue"
          ]
        }
      },
      {
        "name": "linear_get_issue_with_comments",
        "description": "Fetch a Linear issue with all its comments and complete information.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue": {
              "type": "string",
              "description": "Linear issue URL or identifier (e.g., 'ENG-123' or 'https://linear.app/team/issue/ENG-123/issue-title')"
            }
          },
          "required": [
            "issue"
          ]
        }
      }
    ]
  },
  {
    "name": "kiliczsh-mcp-mongo-server",
    "title": "MongoDB",
    "description": "A Model Context Protocol server that provides access to MongoDB databases. This server enables LLMs to inspect collection schemas and execute read-only queries.",
    "icon": "https://avatars.githubusercontent.com/kiliczsh",
    "isOfficial": false,
    "homepage": "https://github.com/kiliczsh/mcp-mongo-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-mongo-server"
      ],
      "env": {
        "MCP_MONGODB_URI": "<mcp-mongodb-uri>",
        "MCP_MONGODB_READONLY": "<mcp-mongodb-readonly>"
      }
    },
    "parameters": [
      {
        "name": "MCP_MONGODB_URI",
        "description": "MongoDB Connection URL",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MCP_MONGODB_READONLY",
        "description": "MongoDB Connection Read-Only mode. If read-only set to 'true'.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "kimtaeyoon83-mcp-server-youtube-transcript",
    "title": "mcp-server-youtube-transcript",
    "description": "A Model Context Protocol server that enables retrieval of transcripts from YouTube videos. This server provides direct access to video captions and subtitles through a simple interface.",
    "icon": "https://avatars.githubusercontent.com/kimtaeyoon83",
    "isOfficial": false,
    "homepage": "https://github.com/kimtaeyoon83/mcp-server-youtube-transcript",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@kimtaeyoon83/mcp-server-youtube-transcript"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_transcript",
        "description": "Extract transcript from a YouTube video URL or ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "YouTube video URL or ID"
            },
            "lang": {
              "type": "string",
              "default": "en",
              "description": "Language code for transcript (e.g., 'ko', 'en')"
            }
          },
          "required": [
            "url",
            "lang"
          ]
        }
      }
    ]
  },
  {
    "name": "kingdomseed-structured-workflow-mcp",
    "title": "Structured Workflow MCP",
    "description": "Enforces disciplined programming practices by requiring AI assistants to audit their work and produce verified outputs at each phase of development, following structured workflows for refactoring, feature development, and testing.",
    "icon": "https://avatars.githubusercontent.com/kingdomseed",
    "isOfficial": false,
    "homepage": "https://github.com/kingdomseed/structured-workflow-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "structured-workflow-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "refactor_workflow",
        "description": "Start a structured refactoring workflow to improve existing code without changing functionality",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "Description of what you want to refactor"
            },
            "context": {
              "type": "object",
              "properties": {
                "scope": {
                  "enum": [
                    "file",
                    "directory",
                    "project"
                  ],
                  "type": "string",
                  "description": "The scope of the refactoring"
                },
                "constraints": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Any constraints or requirements"
                },
                "targetFiles": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Specific files to refactor"
                }
              },
              "description": "Additional context (optional)"
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "create_feature_workflow",
        "description": "Start a structured workflow for adding new functionality with integrated testing",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "Description of the feature to create"
            },
            "context": {
              "type": "object",
              "properties": {
                "scope": {
                  "enum": [
                    "file",
                    "directory",
                    "project"
                  ],
                  "type": "string",
                  "description": "The scope of the feature"
                },
                "targetFiles": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Files where the feature will be added"
                },
                "requirements": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Feature requirements and acceptance criteria"
                }
              },
              "description": "Additional context (optional)"
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "test_workflow",
        "description": "Start a focused workflow for writing or improving test coverage",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "Description of what to test or test coverage to add"
            },
            "context": {
              "type": "object",
              "properties": {
                "testType": {
                  "enum": [
                    "unit",
                    "integration",
                    "e2e",
                    "all"
                  ],
                  "type": "string",
                  "description": "Type of tests to write"
                },
                "targetFiles": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Files that need test coverage"
                },
                "coverageGoals": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Specific coverage goals or scenarios to test"
                },
                "testFramework": {
                  "type": "string",
                  "description": "Testing framework being used (e.g., jest, mocha, pytest)"
                }
              },
              "description": "Additional context (optional)"
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "tdd_workflow",
        "description": "Start a Test-Driven Development workflow with Red-Green-Refactor cycles",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "Description of the feature to develop using TDD"
            },
            "context": {
              "type": "object",
              "properties": {
                "testFirst": {
                  "type": "boolean",
                  "default": true,
                  "description": "Always write the test first (TDD principle)"
                },
                "targetFiles": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Files where tests and implementation will be added"
                },
                "testFramework": {
                  "type": "string",
                  "description": "Testing framework to use"
                },
                "acceptanceCriteria": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Clear acceptance criteria for the feature"
                }
              },
              "description": "Additional context (optional)"
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "build_custom_workflow",
        "description": "Build a custom workflow with full control over phases and configuration. Use specific workflow tools (refactor_workflow, create_feature_workflow, etc.) for optimized presets.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task": {
              "type": "string",
              "description": "Description of the programming task"
            },
            "workflowType": {
              "enum": [
                "refactor",
                "feature",
                "test",
                "tdd",
                "custom"
              ],
              "type": "string",
              "default": "custom",
              "description": "Use a predefined workflow type or custom for full control"
            },
            "selectedPhases": {
              "type": "array",
              "items": {
                "enum": [
                  "SETUP",
                  "AUDIT_INVENTORY",
                  "COMPARE_ANALYZE",
                  "QUESTION_DETERMINE",
                  "WRITE_OR_REFACTOR",
                  "TEST",
                  "LINT",
                  "ITERATE",
                  "PRESENT"
                ],
                "type": "string"
              },
              "default": [
                "SETUP",
                "AUDIT_INVENTORY",
                "WRITE_OR_REFACTOR",
                "TEST",
                "LINT",
                "PRESENT"
              ],
              "description": "Select which phases to include in your workflow"
            },
            "iterationLimits": {
              "type": "object",
              "properties": {
                "LINT": {
                  "type": "number",
                  "default": 10,
                  "description": "Max lint/fix cycles before user input"
                },
                "TEST": {
                  "type": "number",
                  "default": 5,
                  "description": "Max test failure cycles before user input"
                },
                "ITERATE": {
                  "type": "number",
                  "default": 15,
                  "description": "Max overall iterations before user input"
                }
              },
              "description": "Set iteration limits before escalation to user input"
            },
            "userCheckpoints": {
              "type": "object",
              "properties": {
                "beforeMajorChanges": {
                  "type": "boolean",
                  "default": true
                },
                "afterFailedIterations": {
                  "type": "boolean",
                  "default": true
                },
                "beforeFinalPresentation": {
                  "type": "boolean",
                  "default": false
                }
              }
            },
            "outputPreferences": {
              "type": "object",
              "properties": {
                "formats": {
                  "type": "array",
                  "items": {
                    "enum": [
                      "markdown",
                      "json"
                    ],
                    "type": "string"
                  },
                  "default": [
                    "markdown"
                  ],
                  "description": "Output formats for documentation"
                },
                "outputDirectory": {
                  "type": "string",
                  "default": "workflow-output"
                },
                "realTimeUpdates": {
                  "type": "boolean",
                  "default": true
                },
                "generateDiagrams": {
                  "type": "boolean",
                  "default": true
                },
                "includeCodeSnippets": {
                  "type": "boolean",
                  "default": true
                }
              }
            }
          },
          "required": [
            "task"
          ]
        }
      },
      {
        "name": "setup_guidance",
        "description": "Get guidance for the SETUP phase - initialize workflow and establish patterns",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "audit_inventory_guidance",
        "description": "Get guidance for the AUDIT_INVENTORY phase - analyze code and catalog changes",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "compare_analyze_guidance",
        "description": "Get guidance for the COMPARE/ANALYZE phase - evaluating approaches",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "question_determine_guidance",
        "description": "Get guidance for the QUESTION_DETERMINE phase - clarify and finalize plan",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "refactor_guidance",
        "description": "Get guidance for the WRITE/REFACTOR phase - implementing changes",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "lint_guidance",
        "description": "Get guidance for the LINT phase - verifying code quality",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "iterate_guidance",
        "description": "Get guidance for the ITERATE phase - fixing issues",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "present_guidance",
        "description": "Get guidance for the PRESENT phase - summarizing work",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "test_guidance",
        "description": "Get MANDATORY guidance for the TEST phase - execute tests and validate functionality after refactoring",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "validate_action",
        "description": "Check if an action follows critical safety rules",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "type": "string",
              "description": "The action you want to take"
            },
            "targetFile": {
              "type": "string",
              "description": "The file you want to act on"
            }
          },
          "required": [
            "action",
            "targetFile"
          ]
        }
      },
      {
        "name": "validate_phase_completion",
        "description": "Validate that current phase meets all completion requirements before allowing progression",
        "inputSchema": {
          "type": "object",
          "properties": {
            "phase": {
              "enum": [
                "SETUP",
                "AUDIT_INVENTORY",
                "COMPARE_ANALYZE",
                "QUESTION_DETERMINE",
                "WRITE_OR_REFACTOR",
                "TEST",
                "LINT",
                "ITERATE",
                "PRESENT"
              ],
              "type": "string",
              "description": "The phase to validate"
            },
            "createdFiles": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of files created during this phase"
            },
            "completedWork": {
              "type": "object",
              "description": "Description of work completed in this phase",
              "additionalProperties": true
            }
          },
          "required": [
            "phase",
            "completedWork"
          ]
        }
      },
      {
        "name": "user_input_required_guidance",
        "description": "Handle escalation to user input when iteration limits reached or checkpoints triggered",
        "inputSchema": {
          "type": "object",
          "properties": {
            "context": {
              "type": "object",
              "properties": {
                "lastError": {
                  "type": "string"
                },
                "failedPhase": {
                  "type": "string"
                },
                "attemptCount": {
                  "type": "number"
                },
                "specificIssues": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "description": "Additional context about the escalation"
            },
            "trigger": {
              "enum": [
                "iteration_limit",
                "user_checkpoint",
                "validation_failure",
                "time_limit"
              ],
              "type": "string",
              "description": "What triggered the escalation"
            }
          },
          "required": [
            "trigger"
          ]
        }
      },
      {
        "name": "workflow_status",
        "description": "Check current workflow progress and session state",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "phase_output",
        "description": "Record the output/results when completing a workflow phase - REQUIRES ACTUAL OUTPUT ARTIFACTS with numbered file naming",
        "inputSchema": {
          "type": "object",
          "properties": {
            "phase": {
              "enum": [
                "AUDIT_INVENTORY",
                "COMPARE_ANALYZE",
                "QUESTION_DETERMINE",
                "WRITE_OR_REFACTOR",
                "TEST",
                "LINT",
                "ITERATE",
                "PRESENT"
              ],
              "type": "string",
              "description": "The phase you are completing"
            },
            "output": {
              "type": "object",
              "description": "The results/findings from this phase",
              "additionalProperties": true
            },
            "outputArtifacts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "path",
                  "format",
                  "description",
                  "content"
                ],
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "File path if written to disk, OR descriptive identifier for JSON output provided in response"
                  },
                  "format": {
                    "enum": [
                      "markdown",
                      "json",
                      "text"
                    ],
                    "type": "string",
                    "description": "Format of the output"
                  },
                  "content": {
                    "type": "string",
                    "description": "REQUIRED: The actual content/JSON of your output (for validation)"
                  },
                  "description": {
                    "type": "string",
                    "description": "Brief description of what this artifact contains"
                  }
                }
              },
              "minItems": 1,
              "description": "MANDATORY: List of actual output artifacts you created for this phase (use numbered file names)"
            }
          },
          "required": [
            "phase",
            "output",
            "outputArtifacts"
          ]
        }
      },
      {
        "name": "discover_workflow_tools",
        "description": "List the workflow guidance tools provided by this MCP server",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "kj455-mcp-kibela",
    "title": "MCP Kibela",
    "description": "A Model Context Protocol server that enables AI assistants to search and access information stored in Kibela, supporting note search, retrieval, creation and updating.",
    "icon": "https://avatars.githubusercontent.com/kj455",
    "isOfficial": false,
    "homepage": "https://github.com/kj455/mcp-kibela",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@kj455/mcp-kibela"
      ],
      "env": {
        "KIBELA_TEAM": "<kibela-team>",
        "KIBELA_TOKEN": "<kibela-token>"
      }
    },
    "parameters": [
      {
        "name": "KIBELA_TEAM",
        "description": "Your Kibela team name. You can find it from the URL of your Kibela team page. e.g. https://[team-name].kibe.la",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "KIBELA_TOKEN",
        "description": "Your Kibela API token",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "kibela_search_notes",
        "description": "Search Kibela notes by query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "kibela_get_my_notes",
        "description": "Get my latest notes from Kibela",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of notes to fetch"
            }
          }
        }
      },
      {
        "name": "kibela_get_note_content",
        "description": "Get note content by note ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Note ID"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "kibela_get_note_from_path",
        "description": "Get note content by note path",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Note path (e.g. /notes/123)"
            }
          },
          "required": [
            "path"
          ]
        }
      }
    ]
  },
  {
    "name": "k-jarzyna-mcp-miro",
    "title": "Miro MCP",
    "description": "Miro MCP server, exposing all functionalities available in official Miro SDK.",
    "icon": "https://avatars.githubusercontent.com/k-jarzyna",
    "isOfficial": false,
    "homepage": "https://github.com/k-jarzyna/mcp-miro",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@k-jarzyna/mcp-miro"
      ],
      "env": {
        "MIRO_ACCESS_TOKEN": "<miro-access-token>"
      }
    },
    "parameters": [
      {
        "name": "MIRO_ACCESS_TOKEN",
        "description": "Your Miro access token with necessary permissions (boards:read, boards:write, identity:read, identity:write, team:read, team:write)",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "list-boards",
        "description": "List all available Miro boards",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of boards to return (default: 50)"
            },
            "offset": {
              "type": "number",
              "description": "Offset for pagination (default: 0)"
            }
          }
        }
      },
      {
        "name": "create-board",
        "description": "Create a new Miro board with specified name and sharing policies",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the board to create"
            },
            "teamId": {
              "type": "string",
              "description": "Team ID to assign the board to"
            },
            "description": {
              "type": "string",
              "description": "Description of the board"
            },
            "sharingPolicy": {
              "enum": [
                "private",
                "view",
                "comment",
                "edit"
              ],
              "type": "string",
              "description": "Sharing policy for the board"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "update-board",
        "description": "Update an existing Miro board with new settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "New name for the board"
            },
            "teamId": {
              "type": "string",
              "description": "New team ID to assign the board to"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that you want to update"
            },
            "description": {
              "type": "string",
              "description": "New description for the board"
            },
            "sharingPolicy": {
              "enum": [
                "private",
                "view",
                "comment",
                "edit"
              ],
              "type": "string",
              "description": "New sharing policy for the board"
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "delete-board",
        "description": "Delete a Miro board by its ID. Deleted boards go to Trash (on paid plans) and can be restored via UI within 90 days after deletion.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that you want to delete"
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "copy-board",
        "description": "Create a copy of an existing Miro board with optional new settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name for the new copied board"
            },
            "teamId": {
              "type": "string",
              "description": "Team ID to assign the new copied board to"
            },
            "copyFrom": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that you want to copy"
            },
            "description": {
              "type": "string",
              "description": "Description for the new copied board"
            },
            "sharingPolicy": {
              "enum": [
                "private",
                "view",
                "comment",
                "edit"
              ],
              "type": "string",
              "description": "Sharing policy for the new copied board"
            }
          },
          "required": [
            "copyFrom"
          ]
        }
      },
      {
        "name": "get-specific-board",
        "description": "Retrieve information about a specific Miro board by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that you want to retrieve"
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "get-items-on-board",
        "description": "Retrieve all items on a specific Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of items to return (default: 50)"
            },
            "offset": {
              "type": "number",
              "description": "Offset for pagination (default: 0)"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board whose items you want to retrieve"
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "get-specific-item",
        "description": "Retrieve information about a specific item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the item that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the item"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-item-position",
        "description": "Update the position or parent of a specific item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the item that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the item"
            },
            "parentId": {
              "type": "string",
              "description": "Unique identifier (ID) of the new parent item"
            },
            "position": {
              "type": "object",
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the item"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the item"
                }
              },
              "description": "New position coordinates for the item",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "delete-item",
        "description": "Delete a specific item from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the item that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the item"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "create-app-card-item",
        "description": "Create a new app card item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "title"
              ],
              "properties": {
                "title": {
                  "type": "string",
                  "description": "Title of the app card"
                },
                "fields": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "value"
                    ],
                    "properties": {
                      "value": {
                        "type": "string",
                        "description": "Value of the field"
                      },
                      "fillColor": {
                        "type": "string",
                        "description": "Fill color of the field"
                      },
                      "iconShape": {
                        "type": "string",
                        "description": "Shape of the icon"
                      },
                      "textColor": {
                        "type": "string",
                        "description": "Color of the text"
                      }
                    },
                    "additionalProperties": false
                  },
                  "description": "Custom fields to display on the app card"
                },
                "status": {
                  "type": "string",
                  "description": "Status text of the app card"
                },
                "description": {
                  "type": "string",
                  "description": "Description of the app card"
                }
              },
              "description": "The content and configuration of the app card",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the app card will be created"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Width of the app card"
                },
                "height": {
                  "type": "number",
                  "description": "Height of the app card"
                }
              },
              "description": "Dimensions of the app card",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the app card"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the app card"
                }
              },
              "description": "Position of the app card on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "data",
            "position"
          ]
        }
      },
      {
        "name": "get-app-card-item",
        "description": "Retrieve information about a specific app card item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the app card that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the app card"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-app-card-item",
        "description": "Update an existing app card item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "description": "Updated title of the app card"
                },
                "fields": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "value"
                    ],
                    "properties": {
                      "value": {
                        "type": "string",
                        "description": "Value of the field"
                      },
                      "fillColor": {
                        "type": "string",
                        "description": "Fill color of the field"
                      },
                      "iconShape": {
                        "type": "string",
                        "description": "Shape of the icon"
                      },
                      "textColor": {
                        "type": "string",
                        "description": "Color of the text"
                      }
                    },
                    "additionalProperties": false
                  },
                  "description": "Updated custom fields to display on the app card"
                },
                "status": {
                  "type": "string",
                  "description": "Updated status text of the app card"
                },
                "description": {
                  "type": "string",
                  "description": "Updated description of the app card"
                }
              },
              "description": "The updated content and configuration of the app card",
              "additionalProperties": false
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the app card that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the app card"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Updated width of the app card"
                },
                "height": {
                  "type": "number",
                  "description": "Updated height of the app card"
                }
              },
              "description": "Updated dimensions of the app card",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "Updated X coordinate of the app card"
                },
                "y": {
                  "type": "number",
                  "description": "Updated Y coordinate of the app card"
                }
              },
              "description": "Updated position of the app card on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "delete-app-card-item",
        "description": "Delete a specific app card item from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the app card that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the app card"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "create-card-item",
        "description": "Create a new card item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "title"
              ],
              "properties": {
                "title": {
                  "type": "string",
                  "description": "Title of the card"
                },
                "dueDate": {
                  "type": "string",
                  "description": "Due date for the card (ISO 8601 format)"
                },
                "assigneeId": {
                  "type": "string",
                  "description": "User ID of the assignee"
                },
                "description": {
                  "type": "string",
                  "description": "Description of the card"
                }
              },
              "description": "The content and configuration of the card",
              "additionalProperties": false
            },
            "style": {
              "type": "object",
              "properties": {
                "fillColor": {
                  "type": "string",
                  "description": "Fill color of the card"
                },
                "textColor": {
                  "type": "string",
                  "description": "Color of the text on the card"
                }
              },
              "description": "Style configuration of the card",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the card will be created"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Width of the card"
                },
                "height": {
                  "type": "number",
                  "description": "Height of the card"
                }
              },
              "description": "Dimensions of the card",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the card"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the card"
                }
              },
              "description": "Position of the card on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "data",
            "position"
          ]
        }
      },
      {
        "name": "get-card-item",
        "description": "Retrieve information about a specific card item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the card that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the card"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-card-item",
        "description": "Update an existing card item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "description": "Updated title of the card"
                },
                "dueDate": {
                  "type": "string",
                  "description": "Updated due date for the card (ISO 8601 format)"
                },
                "assigneeId": {
                  "type": "string",
                  "description": "Updated user ID of the assignee"
                },
                "description": {
                  "type": "string",
                  "description": "Updated description of the card"
                }
              },
              "description": "The updated content and configuration of the card",
              "additionalProperties": false
            },
            "style": {
              "type": "object",
              "properties": {
                "fillColor": {
                  "type": "string",
                  "description": "Updated fill color of the card"
                },
                "textColor": {
                  "type": "string",
                  "description": "Updated color of the text on the card"
                }
              },
              "description": "Updated style configuration of the card",
              "additionalProperties": false
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the card that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the card"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Updated width of the card"
                },
                "height": {
                  "type": "number",
                  "description": "Updated height of the card"
                }
              },
              "description": "Updated dimensions of the card",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "Updated X coordinate of the card"
                },
                "y": {
                  "type": "number",
                  "description": "Updated Y coordinate of the card"
                }
              },
              "description": "Updated position of the card on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "delete-card-item",
        "description": "Delete a specific card item from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the card that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the card"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "create-connector",
        "description": "Create a new connector between items on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "style": {
              "type": "object",
              "properties": {
                "strokeColor": {
                  "type": "string",
                  "description": "Color of the connector stroke"
                },
                "strokeStyle": {
                  "type": "string",
                  "description": "Style of the connector stroke (normal, dashed, etc.)"
                },
                "strokeWidth": {
                  "type": "number",
                  "description": "Width of the connector stroke"
                },
                "endStrokeCap": {
                  "type": "string",
                  "description": "End stroke cap style"
                },
                "startStrokeCap": {
                  "type": "string",
                  "description": "Start stroke cap style"
                }
              },
              "description": "Style configuration of the connector",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the connector will be created"
            },
            "endItem": {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "description": "ID of the item at the end of the connector"
                }
              },
              "description": "End item of the connector",
              "additionalProperties": false
            },
            "startItem": {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "description": "ID of the item at the start of the connector"
                }
              },
              "description": "Start item of the connector",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "startItem",
            "endItem"
          ]
        }
      },
      {
        "name": "get-connectors",
        "description": "Retrieve all connectors on a specific Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of connectors to return (default: 50)"
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board whose connectors you want to retrieve"
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "get-specific-connector",
        "description": "Retrieve information about a specific connector on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the connector"
            },
            "connectorId": {
              "type": "string",
              "description": "Unique identifier (ID) of the connector that you want to retrieve"
            }
          },
          "required": [
            "boardId",
            "connectorId"
          ]
        }
      },
      {
        "name": "update-connector",
        "description": "Update an existing connector on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "style": {
              "type": "object",
              "properties": {
                "strokeColor": {
                  "type": "string",
                  "description": "Updated color of the connector stroke"
                },
                "strokeStyle": {
                  "type": "string",
                  "description": "Updated style of the connector stroke (normal, dashed, etc.)"
                },
                "strokeWidth": {
                  "type": "number",
                  "description": "Updated width of the connector stroke"
                },
                "endStrokeCap": {
                  "type": "string",
                  "description": "Updated end stroke cap style"
                },
                "startStrokeCap": {
                  "type": "string",
                  "description": "Updated start stroke cap style"
                }
              },
              "description": "Updated style configuration of the connector",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the connector"
            },
            "endItem": {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "description": "ID of the item at the end of the connector"
                }
              },
              "description": "End item of the connector",
              "additionalProperties": false
            },
            "startItem": {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "description": "ID of the item at the start of the connector"
                }
              },
              "description": "Start item of the connector",
              "additionalProperties": false
            },
            "connectorId": {
              "type": "string",
              "description": "Unique identifier (ID) of the connector that you want to update"
            }
          },
          "required": [
            "boardId",
            "connectorId"
          ]
        }
      },
      {
        "name": "delete-connector",
        "description": "Delete a specific connector from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the connector"
            },
            "connectorId": {
              "type": "string",
              "description": "Unique identifier (ID) of the connector that you want to delete"
            }
          },
          "required": [
            "boardId",
            "connectorId"
          ]
        }
      },
      {
        "name": "create-sticky-note-item",
        "description": "Create a new sticky note item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "content"
              ],
              "properties": {
                "shape": {
                  "type": "string",
                  "description": "Shape of the sticky note (square, rectangle, circle, triangle, rhombus)"
                },
                "content": {
                  "type": "string",
                  "description": "Text content of the sticky note"
                }
              },
              "description": "The content and configuration of the sticky note",
              "additionalProperties": false
            },
            "style": {
              "type": "object",
              "properties": {
                "fillColor": {
                  "type": "string",
                  "description": "Fill color of the sticky note (use predefined values like 'light_yellow', 'light_green', etc.)"
                },
                "textAlign": {
                  "type": "string",
                  "description": "Alignment of the text (left, center, right)"
                }
              },
              "description": "Style configuration of the sticky note",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the sticky note will be created"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Width of the sticky note"
                },
                "height": {
                  "type": "number",
                  "description": "Height of the sticky note"
                }
              },
              "description": "Dimensions of the sticky note",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the sticky note"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the sticky note"
                },
                "origin": {
                  "type": "string",
                  "description": "Origin of the sticky note (center, top-left, etc.)"
                },
                "relativeTo": {
                  "type": "string",
                  "description": "Reference point (canvas_center, etc.)"
                }
              },
              "description": "Position of the sticky note on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "data",
            "position"
          ]
        }
      },
      {
        "name": "get-sticky-note-item",
        "description": "Retrieve information about a specific sticky note item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the sticky note that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the sticky note"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-sticky-note-item",
        "description": "Update an existing sticky note item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "properties": {
                "shape": {
                  "type": "string",
                  "description": "Updated shape of the sticky note (square, rectangle, circle, triangle, rhombus)"
                },
                "content": {
                  "type": "string",
                  "description": "Updated text content of the sticky note"
                }
              },
              "description": "Updated content and configuration of the sticky note",
              "additionalProperties": false
            },
            "style": {
              "type": "object",
              "properties": {
                "fillColor": {
                  "type": "string",
                  "description": "Updated fill color of the sticky note (use predefined values)"
                },
                "textAlign": {
                  "type": "string",
                  "description": "Updated alignment of the text (left, center, right)"
                },
                "textColor": {
                  "type": "string",
                  "description": "Updated color of the text on the sticky note"
                }
              },
              "description": "Updated style configuration of the sticky note",
              "additionalProperties": false
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the sticky note that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the sticky note"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Updated width of the sticky note"
                },
                "height": {
                  "type": "number",
                  "description": "Updated height of the sticky note"
                }
              },
              "description": "Updated dimensions of the sticky note",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "properties": {
                "x": {
                  "type": "number",
                  "description": "Updated X coordinate of the sticky note"
                },
                "y": {
                  "type": "number",
                  "description": "Updated Y coordinate of the sticky note"
                },
                "origin": {
                  "type": "string",
                  "description": "Origin of the sticky note (center, top-left, etc.)"
                },
                "relativeTo": {
                  "type": "string",
                  "description": "Reference point (canvas_center, etc.)"
                }
              },
              "description": "Updated position of the sticky note on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "delete-sticky-note-item",
        "description": "Delete a specific sticky note item from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the sticky note that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the sticky note"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "create-frame",
        "description": "Create a new frame on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "description": "Type of the frame. Only 'freeform' is supported currently."
                },
                "title": {
                  "type": "string",
                  "description": "Title of the frame. This title appears at the top of the frame."
                },
                "format": {
                  "type": "string",
                  "description": "Format of the frame. Only 'custom' is supported currently."
                },
                "showContent": {
                  "type": "boolean",
                  "description": "Hide or reveal the content inside a frame (Enterprise plan only)."
                }
              },
              "description": "The content and configuration of the frame",
              "additionalProperties": false
            },
            "style": {
              "type": "object",
              "properties": {
                "fillColor": {
                  "type": "string",
                  "description": "Fill color for the frame. Hex values like #f5f6f8, #d5f692, etc."
                }
              },
              "description": "Style configuration of the frame",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the frame will be created"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Width of the frame"
                },
                "height": {
                  "type": "number",
                  "description": "Height of the frame"
                }
              },
              "description": "Dimensions of the frame",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the frame"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the frame"
                }
              },
              "description": "Position of the frame on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "data",
            "position"
          ]
        }
      },
      {
        "name": "get-frame-item",
        "description": "Retrieve information for a specific frame on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the frame that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the frame that you want to retrieve"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-frame-item",
        "description": "Update a frame on a Miro board based on the data, style, or geometry properties provided in the request body",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "description": "Type of the frame. Only 'freeform' is supported currently."
                },
                "title": {
                  "type": "string",
                  "description": "Title of the frame. This title appears at the top of the frame."
                },
                "format": {
                  "type": "string",
                  "description": "Format of the frame. Only 'custom' is supported currently."
                },
                "showContent": {
                  "type": "boolean",
                  "description": "Hide or reveal the content inside a frame (Enterprise plan only)."
                }
              },
              "description": "The updated content and configuration of the frame",
              "additionalProperties": false
            },
            "style": {
              "type": "object",
              "properties": {
                "fillColor": {
                  "type": "string",
                  "description": "Fill color for the frame. Hex values like #f5f6f8, #d5f692, etc."
                }
              },
              "description": "Updated style configuration of the frame",
              "additionalProperties": false
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the frame that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where you want to update the frame"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Width of the frame"
                },
                "height": {
                  "type": "number",
                  "description": "Height of the frame"
                }
              },
              "description": "Updated dimensions of the frame",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the frame"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the frame"
                }
              },
              "description": "Updated position of the frame on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "delete-frame-item",
        "description": "Delete a frame from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the frame that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board from which you want to delete the frame"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "create-document-item",
        "description": "Create a new document item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "url"
              ],
              "properties": {
                "url": {
                  "type": "string",
                  "description": "URL of the document to be added to the board"
                },
                "title": {
                  "type": "string",
                  "description": "Title of the document"
                }
              },
              "description": "The content and configuration of the document",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the document will be created"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Width of the document"
                },
                "height": {
                  "type": "number",
                  "description": "Height of the document"
                }
              },
              "description": "Dimensions of the document",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the document"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the document"
                }
              },
              "description": "Position of the document on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "data",
            "position"
          ]
        }
      },
      {
        "name": "get-document-item",
        "description": "Retrieve information about a specific document item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the document that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the document"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-document-item",
        "description": "Update an existing document item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "properties": {
                "url": {
                  "type": "string",
                  "description": "Updated URL of the document"
                },
                "title": {
                  "type": "string",
                  "description": "Updated title of the document"
                }
              },
              "description": "The updated content and configuration of the document",
              "additionalProperties": false
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the document that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the document"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Updated width of the document"
                },
                "height": {
                  "type": "number",
                  "description": "Updated height of the document"
                }
              },
              "description": "Updated dimensions of the document",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "properties": {
                "x": {
                  "type": "number",
                  "description": "Updated X coordinate of the document"
                },
                "y": {
                  "type": "number",
                  "description": "Updated Y coordinate of the document"
                }
              },
              "description": "Updated position of the document on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "delete-document-item",
        "description": "Delete a specific document item from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the document that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the document"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "create-text-item",
        "description": "Create a new text item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "content"
              ],
              "properties": {
                "content": {
                  "type": "string",
                  "description": "Text content of the text item"
                }
              },
              "description": "The content of the text item",
              "additionalProperties": false
            },
            "style": {
              "type": "object",
              "properties": {
                "color": {
                  "type": "string",
                  "description": "Color of the text"
                },
                "fontSize": {
                  "type": "number",
                  "description": "Font size of the text"
                },
                "textAlign": {
                  "type": "string",
                  "description": "Alignment of the text (left, center, right)"
                }
              },
              "description": "Style configuration of the text item",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the text will be created"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Width of the text item"
                }
              },
              "description": "Dimensions of the text item",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the text item"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the text item"
                }
              },
              "description": "Position of the text item on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "data",
            "position"
          ]
        }
      },
      {
        "name": "get-text-item",
        "description": "Retrieve information about a specific text item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the text item that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the text item"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-text-item",
        "description": "Update an existing text item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "properties": {
                "content": {
                  "type": "string",
                  "description": "Updated text content of the text item"
                }
              },
              "description": "The updated content of the text item",
              "additionalProperties": false
            },
            "style": {
              "type": "object",
              "properties": {
                "color": {
                  "type": "string",
                  "description": "Updated color of the text"
                },
                "fontSize": {
                  "type": "number",
                  "description": "Updated font size of the text"
                },
                "textAlign": {
                  "type": "string",
                  "description": "Updated alignment of the text (left, center, right)"
                }
              },
              "description": "Updated style configuration of the text item",
              "additionalProperties": false
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the text item that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the text item"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Updated width of the text item"
                }
              },
              "description": "Updated dimensions of the text item",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "properties": {
                "x": {
                  "type": "number",
                  "description": "Updated X coordinate of the text item"
                },
                "y": {
                  "type": "number",
                  "description": "Updated Y coordinate of the text item"
                }
              },
              "description": "Updated position of the text item on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "delete-text-item",
        "description": "Delete a specific text item from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the text item that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the text item"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "create-items-in-bulk",
        "description": "Create multiple items on a Miro board in a single operation",
        "inputSchema": {
          "type": "object",
          "properties": {
            "items": {
              "type": "array",
              "items": {
                "anyOf": [
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "data",
                      "position"
                    ],
                    "properties": {
                      "data": {
                        "type": "object",
                        "required": [
                          "content"
                        ],
                        "properties": {
                          "shape": {
                            "enum": [
                              "square",
                              "rectangle"
                            ],
                            "type": "string",
                            "description": "Shape of the sticky note"
                          },
                          "content": {
                            "type": "string",
                            "description": "Text content of the sticky note"
                          }
                        },
                        "additionalProperties": false
                      },
                      "type": {
                        "type": "string",
                        "const": "sticky_note"
                      },
                      "style": {
                        "type": "object",
                        "properties": {
                          "fillColor": {
                            "type": "string",
                            "description": "Fill color of the sticky note"
                          },
                          "textAlign": {
                            "enum": [
                              "left",
                              "center",
                              "right"
                            ],
                            "type": "string",
                            "description": "Text alignment"
                          }
                        },
                        "additionalProperties": false
                      },
                      "position": {
                        "type": "object",
                        "required": [
                          "x",
                          "y"
                        ],
                        "properties": {
                          "x": {
                            "type": "number",
                            "description": "X coordinate"
                          },
                          "y": {
                            "type": "number",
                            "description": "Y coordinate"
                          }
                        },
                        "additionalProperties": false
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "data",
                      "position"
                    ],
                    "properties": {
                      "data": {
                        "type": "object",
                        "required": [
                          "title"
                        ],
                        "properties": {
                          "title": {
                            "type": "string",
                            "description": "Title of the card"
                          },
                          "dueDate": {
                            "type": "string",
                            "description": "Due date in ISO 8601 format"
                          },
                          "assigneeId": {
                            "type": "string",
                            "description": "User ID of the assignee"
                          },
                          "description": {
                            "type": "string",
                            "description": "Description of the card"
                          }
                        },
                        "additionalProperties": false
                      },
                      "type": {
                        "type": "string",
                        "const": "card"
                      },
                      "style": {
                        "type": "object",
                        "properties": {
                          "fillColor": {
                            "type": "string",
                            "description": "Fill color"
                          },
                          "textColor": {
                            "type": "string",
                            "description": "Text color"
                          }
                        },
                        "additionalProperties": false
                      },
                      "position": {
                        "type": "object",
                        "required": [
                          "x",
                          "y"
                        ],
                        "properties": {
                          "x": {
                            "type": "number",
                            "description": "X coordinate"
                          },
                          "y": {
                            "type": "number",
                            "description": "Y coordinate"
                          }
                        },
                        "additionalProperties": false
                      }
                    },
                    "additionalProperties": false
                  },
                  {
                    "type": "object",
                    "required": [
                      "type",
                      "data",
                      "position"
                    ],
                    "properties": {
                      "data": {
                        "type": "object",
                        "required": [
                          "content"
                        ],
                        "properties": {
                          "content": {
                            "type": "string",
                            "description": "Text content"
                          }
                        },
                        "additionalProperties": false
                      },
                      "type": {
                        "type": "string",
                        "const": "text"
                      },
                      "style": {
                        "type": "object",
                        "properties": {
                          "color": {
                            "type": "string",
                            "description": "Text color (hex format, e.g. #000000)"
                          },
                          "fontSize": {
                            "type": "number",
                            "description": "Font size"
                          },
                          "textAlign": {
                            "enum": [
                              "left",
                              "center",
                              "right"
                            ],
                            "type": "string",
                            "description": "Text alignment"
                          }
                        },
                        "additionalProperties": false
                      },
                      "position": {
                        "type": "object",
                        "required": [
                          "x",
                          "y"
                        ],
                        "properties": {
                          "x": {
                            "type": "number",
                            "description": "X coordinate"
                          },
                          "y": {
                            "type": "number",
                            "description": "Y coordinate"
                          }
                        },
                        "additionalProperties": false
                      }
                    },
                    "additionalProperties": false
                  }
                ]
              },
              "description": "Array of items to create"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the items will be created"
            }
          },
          "required": [
            "boardId",
            "items"
          ]
        }
      },
      {
        "name": "create-image-item-using-url",
        "description": "Create a new image item on a Miro board using a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "url"
              ],
              "properties": {
                "url": {
                  "type": "string",
                  "description": "URL of the image to be added to the board"
                },
                "title": {
                  "type": "string",
                  "description": "Title of the image"
                }
              },
              "description": "The content and configuration of the image",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the image will be created"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Width of the image"
                },
                "height": {
                  "type": "number",
                  "description": "Height of the image"
                }
              },
              "description": "Dimensions of the image",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the image"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the image"
                },
                "origin": {
                  "type": "string",
                  "description": "Origin of the image (center, top-left, etc.)"
                },
                "relativeTo": {
                  "type": "string",
                  "description": "Reference point (canvas_center, etc.)"
                }
              },
              "description": "Position of the image on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "data",
            "position"
          ]
        }
      },
      {
        "name": "create-image-item-using-file",
        "description": "Create a new image item on a Miro board using file from device or from chat",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "Title of the image"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the image will be created"
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the image"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the image"
                },
                "origin": {
                  "type": "string",
                  "description": "Origin of the image (center, top-left, etc.)"
                },
                "relativeTo": {
                  "type": "string",
                  "description": "Reference point (canvas_center, etc.)"
                }
              },
              "description": "Position of the image on the board",
              "additionalProperties": false
            },
            "imageData": {
              "type": "string",
              "description": "Base64 encoded image data from the chat"
            }
          },
          "required": [
            "boardId",
            "imageData",
            "position"
          ]
        }
      },
      {
        "name": "get-image-item",
        "description": "Retrieve information about a specific image item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the image that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the image"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-image-item",
        "description": "Update an existing image item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "description": "Updated title of the image"
                }
              },
              "description": "The updated content of the image",
              "additionalProperties": false
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the image that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where you want to update the item"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Updated width of the image"
                },
                "height": {
                  "type": "number",
                  "description": "Updated height of the image"
                }
              },
              "description": "Updated dimensions of the image",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "properties": {
                "x": {
                  "type": "number",
                  "description": "Updated X coordinate of the image"
                },
                "y": {
                  "type": "number",
                  "description": "Updated Y coordinate of the image"
                },
                "origin": {
                  "type": "string",
                  "description": "Updated origin of the image (center, top-left, etc.)"
                },
                "relativeTo": {
                  "type": "string",
                  "description": "Updated reference point (canvas_center, etc.)"
                }
              },
              "description": "Updated position of the image on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-image-item-using-file",
        "description": "Update an existing image item on a Miro board using file from device",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "Updated title of the image"
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the image that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where you want to update the item"
            },
            "filePath": {
              "type": "string",
              "description": "Path to the new image file on the device"
            },
            "position": {
              "type": "object",
              "properties": {
                "x": {
                  "type": "number",
                  "description": "Updated X coordinate of the image"
                },
                "y": {
                  "type": "number",
                  "description": "Updated Y coordinate of the image"
                },
                "origin": {
                  "type": "string",
                  "description": "Updated origin of the image (center, top-left, etc.)"
                },
                "relativeTo": {
                  "type": "string",
                  "description": "Updated reference point (canvas_center, etc.)"
                }
              },
              "description": "Updated position of the image on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId",
            "filePath"
          ]
        }
      },
      {
        "name": "delete-image-item",
        "description": "Delete a specific image item from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the image that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the image"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "create-shape-item",
        "description": "Create a new shape item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "type": {
                  "type": "string",
                  "description": "Type of the shape (rectangle, circle, triangle, etc.)"
                },
                "content": {
                  "type": "string",
                  "description": "Text content to display inside the shape"
                }
              },
              "description": "The content and configuration of the shape",
              "additionalProperties": false
            },
            "style": {
              "type": "object",
              "properties": {
                "fillColor": {
                  "type": "string",
                  "description": "Fill color of the shape (hex format, e.g. #000000)"
                },
                "textColor": {
                  "type": "string",
                  "description": "Color of the text in the shape (hex format, e.g. #000000)"
                },
                "borderColor": {
                  "type": "string",
                  "description": "Color of the shape border (hex format, e.g. #000000)"
                },
                "borderStyle": {
                  "type": "string",
                  "description": "Style of the shape border (normal, dashed, etc.)"
                },
                "borderWidth": {
                  "type": "number",
                  "description": "Width of the shape border"
                },
                "fillOpacity": {
                  "type": "number",
                  "description": "Opacity of the shape fill (0-1)"
                },
                "borderOpacity": {
                  "type": "number",
                  "description": "Opacity of the shape border (0-1)"
                }
              },
              "description": "Style configuration of the shape",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the shape will be created"
            },
            "geometry": {
              "type": "object",
              "required": [
                "width",
                "height"
              ],
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Width of the shape"
                },
                "height": {
                  "type": "number",
                  "description": "Height of the shape"
                }
              },
              "description": "Dimensions of the shape",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the shape"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the shape"
                },
                "origin": {
                  "type": "string",
                  "description": "Origin of the shape (center, top-left, etc.)"
                },
                "relativeTo": {
                  "type": "string",
                  "description": "Reference point (canvas_center, etc.)"
                }
              },
              "description": "Position of the shape on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "data",
            "position",
            "geometry"
          ]
        }
      },
      {
        "name": "get-shape-item",
        "description": "Retrieve information about a specific shape item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the shape that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the shape"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-shape-item",
        "description": "Update an existing shape item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "description": "Updated type of the shape (rectangle, circle, triangle, etc.)"
                },
                "content": {
                  "type": "string",
                  "description": "Updated text content to display inside the shape"
                }
              },
              "description": "The updated content and configuration of the shape",
              "additionalProperties": false
            },
            "style": {
              "type": "object",
              "properties": {
                "fillColor": {
                  "type": "string",
                  "description": "Updated fill color of the shape (hex format, e.g. #000000)"
                },
                "textColor": {
                  "type": "string",
                  "description": "Updated color of the text in the shape (hex format, e.g. #000000)"
                },
                "borderColor": {
                  "type": "string",
                  "description": "Updated color of the shape border (hex format, e.g. #000000)"
                },
                "borderStyle": {
                  "type": "string",
                  "description": "Updated style of the shape border (normal, dashed, etc.)"
                },
                "borderWidth": {
                  "type": "number",
                  "description": "Updated width of the shape border"
                },
                "fillOpacity": {
                  "type": "number",
                  "description": "Updated opacity of the shape fill (0-1)"
                },
                "borderOpacity": {
                  "type": "number",
                  "description": "Updated opacity of the shape border (0-1)"
                }
              },
              "description": "Updated style configuration of the shape",
              "additionalProperties": false
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the shape that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the shape"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Updated width of the shape"
                },
                "height": {
                  "type": "number",
                  "description": "Updated height of the shape"
                }
              },
              "description": "Updated dimensions of the shape",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "Updated X coordinate of the shape"
                },
                "y": {
                  "type": "number",
                  "description": "Updated Y coordinate of the shape"
                },
                "origin": {
                  "type": "string",
                  "description": "Origin of the shape (center, top-left, etc.)"
                },
                "relativeTo": {
                  "type": "string",
                  "description": "Reference point (canvas_center, etc.)"
                }
              },
              "description": "Updated position of the shape on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "delete-shape-item",
        "description": "Delete a specific shape item from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the shape that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the shape"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "create-embed-item",
        "description": "Create a new embed item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "url"
              ],
              "properties": {
                "url": {
                  "type": "string",
                  "description": "URL to be embedded on the board"
                },
                "mode": {
                  "type": "string",
                  "description": "Mode of the embed (normal, inline, etc.)"
                }
              },
              "description": "The content and configuration of the embed",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the embed will be created"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Width of the embed"
                },
                "height": {
                  "type": "number",
                  "description": "Height of the embed"
                }
              },
              "description": "Dimensions of the embed",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the embed"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the embed"
                },
                "origin": {
                  "type": "string",
                  "description": "Origin of the embed (center, top-left, etc.)"
                },
                "relativeTo": {
                  "type": "string",
                  "description": "Reference point (canvas_center, etc.)"
                }
              },
              "description": "Position of the embed on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "data",
            "position",
            "geometry"
          ]
        }
      },
      {
        "name": "get-embed-item",
        "description": "Retrieve information about a specific embed item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the embed that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the embed"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "update-embed-item",
        "description": "Update an existing embed item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "properties": {
                "mode": {
                  "type": "string",
                  "description": "Updated mode of the embed (normal, inline, etc.)"
                }
              },
              "description": "The updated configuration of the embed",
              "additionalProperties": false
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the embed that you want to update"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the embed"
            },
            "geometry": {
              "type": "object",
              "properties": {
                "width": {
                  "type": "number",
                  "description": "Updated width of the embed"
                },
                "height": {
                  "type": "number",
                  "description": "Updated height of the embed"
                }
              },
              "description": "Updated dimensions of the embed",
              "additionalProperties": false
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "Updated X coordinate of the embed"
                },
                "y": {
                  "type": "number",
                  "description": "Updated Y coordinate of the embed"
                },
                "origin": {
                  "type": "string",
                  "description": "Origin of the embed (center, top-left, etc.)"
                },
                "relativeTo": {
                  "type": "string",
                  "description": "Reference point (canvas_center, etc.)"
                }
              },
              "description": "Updated position of the embed on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "delete-embed-item",
        "description": "Delete a specific embed item from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the embed that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the embed"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "create-tag",
        "description": "Create a new tag on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "title"
              ],
              "properties": {
                "title": {
                  "type": "string",
                  "description": "Title of the tag"
                }
              },
              "description": "The content and configuration of the tag",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the tag will be created"
            },
            "fillColor": {
              "type": "string",
              "description": "Fill color of the tag (hex format, e.g. #000000)"
            }
          },
          "required": [
            "boardId",
            "data"
          ]
        }
      },
      {
        "name": "get-tag",
        "description": "Retrieve information about a specific tag on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tagId": {
              "type": "string",
              "description": "Unique identifier (ID) of the tag that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the tag"
            }
          },
          "required": [
            "boardId",
            "tagId"
          ]
        }
      },
      {
        "name": "get-all-tags",
        "description": "Retrieve all tags on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of tags to return (default: 50)"
            },
            "offset": {
              "type": "number",
              "description": "Offset for pagination (default: 0)"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board for which you want to retrieve all tags"
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "update-tag",
        "description": "Update an existing tag on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tagId": {
              "type": "string",
              "description": "Unique identifier (ID) of the tag that you want to update"
            },
            "title": {
              "type": "string",
              "description": "Updated title of the tag"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the tag"
            },
            "fillColor": {
              "type": "string",
              "description": "Updated fill color of the tag (hex format, e.g. #000000)"
            }
          },
          "required": [
            "boardId",
            "tagId"
          ]
        }
      },
      {
        "name": "delete-tag",
        "description": "Delete a specific tag from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tagId": {
              "type": "string",
              "description": "Unique identifier (ID) of the tag that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the tag"
            }
          },
          "required": [
            "boardId",
            "tagId"
          ]
        }
      },
      {
        "name": "attach-tag",
        "description": "Attach a tag to an item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tagId": {
              "type": "string",
              "description": "Unique identifier (ID) of the tag that you want to attach"
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the item to which you want to attach the tag"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the tag and item"
            }
          },
          "required": [
            "boardId",
            "tagId",
            "itemId"
          ]
        }
      },
      {
        "name": "detach-tag",
        "description": "Detach a tag from an item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tagId": {
              "type": "string",
              "description": "Unique identifier (ID) of the tag that you want to detach"
            },
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the item from which you want to detach the tag"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the tag and item"
            }
          },
          "required": [
            "boardId",
            "tagId",
            "itemId"
          ]
        }
      },
      {
        "name": "get-item-tags",
        "description": "Retrieve all tags attached to a specific item on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the item whose tags you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board that contains the item"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "get-all-board-members",
        "description": "Retrieve all members of a specific Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of members to retrieve (default: 50)"
            },
            "offset": {
              "type": "number",
              "description": "Offset for pagination (default: 0)"
            },
            "boardId": {
              "type": "string",
              "description": "ID of the board to retrieve members from"
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "get-specific-board-member",
        "description": "Retrieve details of a specific member on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "ID of the board"
            },
            "memberId": {
              "type": "string",
              "description": "ID of the specific board member to retrieve"
            }
          },
          "required": [
            "boardId",
            "memberId"
          ]
        }
      },
      {
        "name": "remove-board-member",
        "description": "Remove a specific member from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "ID of the board"
            },
            "memberId": {
              "type": "string",
              "description": "ID of the board member to remove"
            }
          },
          "required": [
            "boardId",
            "memberId"
          ]
        }
      },
      {
        "name": "share-board",
        "description": "Share a Miro board with specific access level and optional team assignment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "teamId": {
              "type": "string",
              "description": "Team ID to assign the board to"
            },
            "boardId": {
              "type": "string",
              "description": "ID of the board to share"
            },
            "accessLevel": {
              "enum": [
                "private",
                "view",
                "comment",
                "edit"
              ],
              "type": "string",
              "description": "Access level for shared board"
            }
          },
          "required": [
            "boardId",
            "accessLevel"
          ]
        }
      },
      {
        "name": "update-board-member",
        "description": "Update a specific member's role or status on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "role": {
              "enum": [
                "member",
                "admin",
                "owner"
              ],
              "type": "string",
              "description": "New role for the board member"
            },
            "status": {
              "enum": [
                "active",
                "pending",
                "blocked"
              ],
              "type": "string",
              "description": "New status for the board member"
            },
            "boardId": {
              "type": "string",
              "description": "ID of the board"
            },
            "memberId": {
              "type": "string",
              "description": "ID of the board member to update"
            }
          },
          "required": [
            "boardId",
            "memberId"
          ]
        }
      },
      {
        "name": "create-group",
        "description": "Create a new group on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "List of item IDs to include in the group"
                }
              },
              "description": "Group data with item IDs to include in the group",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "ID of the board where the group will be created"
            }
          },
          "required": [
            "boardId",
            "data"
          ]
        }
      },
      {
        "name": "get-all-groups",
        "description": "Retrieve all groups on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of groups to return (default: 50)"
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            },
            "boardId": {
              "type": "string",
              "description": "ID of the board whose groups you want to retrieve"
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "get-group",
        "description": "Retrieve information about a specific group on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "ID of the board that contains the group"
            },
            "groupId": {
              "type": "string",
              "description": "ID of the group that you want to retrieve"
            }
          },
          "required": [
            "boardId",
            "groupId"
          ]
        }
      },
      {
        "name": "get-group-items",
        "description": "Retrieve all items in a specific group on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of items to return (default: 50)"
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            },
            "boardId": {
              "type": "string",
              "description": "ID of the board that contains the group"
            },
            "groupId": {
              "type": "string",
              "description": "ID of the group whose items you want to retrieve"
            }
          },
          "required": [
            "boardId",
            "groupId"
          ]
        }
      },
      {
        "name": "update-group",
        "description": "Update a specific group on a Miro board with new items",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Updated list of item IDs to include in the group"
                }
              },
              "description": "Updated group data with item IDs to include in the group",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "ID of the board that contains the group"
            },
            "groupId": {
              "type": "string",
              "description": "ID of the group that you want to update"
            }
          },
          "required": [
            "boardId",
            "groupId",
            "data"
          ]
        }
      },
      {
        "name": "ungroup-items",
        "description": "Ungroup a specific group on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "ID of the board that contains the group"
            },
            "groupId": {
              "type": "string",
              "description": "ID of the group that you want to ungroup"
            },
            "deleteItems": {
              "type": "boolean",
              "description": "Indicates whether the items should be removed. By default, false."
            }
          },
          "required": [
            "boardId",
            "groupId"
          ]
        }
      },
      {
        "name": "delete-group",
        "description": "Delete a specific group from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "ID of the board that contains the group"
            },
            "groupId": {
              "type": "string",
              "description": "ID of the group that you want to delete"
            },
            "deleteItems": {
              "type": "boolean",
              "description": "Indicates whether the items should be removed. Set to true to delete items in the group, false to keep them"
            }
          },
          "required": [
            "boardId",
            "groupId"
          ]
        }
      },
      {
        "name": "create-items-in-bulk-using-file",
        "description": "Create multiple items on a Miro board in a single operation using a JSON file from device",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where the items will be created"
            },
            "fileData": {
              "type": "string",
              "description": "Base64 encoded JSON file data containing items to create"
            }
          },
          "required": [
            "boardId",
            "fileData"
          ]
        }
      },
      {
        "name": "create-mindmap-node",
        "description": "Create a new mind map node on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "required": [
                "content"
              ],
              "properties": {
                "style": {
                  "type": "object",
                  "properties": {
                    "fillColor": {
                      "type": "string",
                      "description": "Fill color for the node"
                    },
                    "textColor": {
                      "type": "string",
                      "description": "Text color for the node"
                    }
                  },
                  "additionalProperties": false
                },
                "content": {
                  "type": "string",
                  "description": "Text content for the mind map node"
                },
                "parentId": {
                  "type": "string",
                  "description": "ID of the parent node (if this is a child node)"
                }
              },
              "description": "The content and style configuration of the mind map node",
              "additionalProperties": false
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board where you want to create the node"
            },
            "position": {
              "type": "object",
              "required": [
                "x",
                "y"
              ],
              "properties": {
                "x": {
                  "type": "number",
                  "description": "X coordinate of the node"
                },
                "y": {
                  "type": "number",
                  "description": "Y coordinate of the node"
                }
              },
              "description": "Position of the node on the board",
              "additionalProperties": false
            }
          },
          "required": [
            "boardId",
            "data",
            "position"
          ]
        }
      },
      {
        "name": "get-mindmap-node",
        "description": "Retrieve information about a specific mind map node on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the mind map node that you want to retrieve"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board from which you want to retrieve a mind map node"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "get-mindmap-nodes",
        "description": "Retrieve a list of mind map nodes on a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return (default: 50)"
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board from which you want to retrieve mind map nodes"
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "delete-mindmap-node",
        "description": "Delete a mind map node from a Miro board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string",
              "description": "Unique identifier (ID) of the mind map node that you want to delete"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier (ID) of the board from which you want to delete the mind map node"
            }
          },
          "required": [
            "boardId",
            "itemId"
          ]
        }
      },
      {
        "name": "get-board-classification",
        "description": "Retrieves board classification for a board (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "orgId": {
              "type": "string",
              "description": "id of the organization"
            },
            "teamId": {
              "type": "string",
              "description": "id of the team"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier of the board that you want to retrieve"
            }
          },
          "required": [
            "orgId",
            "teamId",
            "boardId"
          ]
        }
      },
      {
        "name": "update-board-classification",
        "description": "Updates board classification for an existing board (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "orgId": {
              "type": "string",
              "description": "id of the organization"
            },
            "teamId": {
              "type": "string",
              "description": "id of the team"
            },
            "boardId": {
              "type": "string",
              "description": "Unique identifier of the board that you want to update"
            },
            "labelId": {
              "type": "string",
              "description": "Unique identifier of the classification label to apply"
            }
          },
          "required": [
            "orgId",
            "teamId",
            "boardId",
            "labelId"
          ]
        }
      },
      {
        "name": "create-board-export-job",
        "description": "Creates an export job for one or more boards (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "orgId": {
              "type": "string",
              "description": "Unique identifier of the organization"
            },
            "format": {
              "enum": [
                "pdf",
                "csv"
              ],
              "type": "string",
              "description": "Export format (default: pdf)"
            },
            "boardIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of board IDs to export"
            },
            "requestId": {
              "type": "string",
              "description": "Unique identifier of the board export job"
            }
          },
          "required": [
            "orgId",
            "requestId",
            "boardIds"
          ]
        }
      },
      {
        "name": "get-board-export-job-status",
        "description": "Retrieves the status of a board export job (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "jobId": {
              "type": "string",
              "description": "Unique identifier of the board export job"
            },
            "orgId": {
              "type": "string",
              "description": "Unique identifier of the organization"
            }
          },
          "required": [
            "orgId",
            "jobId"
          ]
        }
      },
      {
        "name": "get-board-export-job-results",
        "description": "Retrieves the results of a board export job (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "jobId": {
              "type": "string",
              "description": "Unique identifier of the job"
            },
            "orgId": {
              "type": "string",
              "description": "Unique identifier of the organization"
            }
          },
          "required": [
            "orgId",
            "jobId"
          ]
        }
      },
      {
        "name": "get-audit-logs",
        "description": "Retrieves a page of audit events from the last 90 days (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return (default: 100)"
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            },
            "sorting": {
              "enum": [
                "ASC",
                "DESC"
              ],
              "type": "string",
              "description": "Sort order for results (default: ASC)"
            },
            "createdAfter": {
              "type": "string",
              "description": "Retrieve audit logs created after this date (ISO 8601 format)"
            },
            "createdBefore": {
              "type": "string",
              "description": "Retrieve audit logs created before this date (ISO 8601 format)"
            }
          },
          "required": [
            "createdAfter",
            "createdBefore"
          ]
        }
      },
      {
        "name": "get-organization-info",
        "description": "Retrieves organization information (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "orgId": {
              "type": "string",
              "description": "id of the organization"
            }
          },
          "required": [
            "orgId"
          ]
        }
      },
      {
        "name": "get-organization-members",
        "description": "Retrieves a list of members for an organization (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "role": {
              "enum": [
                "organization_internal_admin",
                "organization_internal_user",
                "organization_external_user",
                "organization_team_guest_user",
                "unknown"
              ],
              "type": "string",
              "description": "Filter by user role"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "orgId": {
              "type": "string",
              "description": "id of the organization"
            },
            "active": {
              "type": "boolean",
              "description": "Filter by active status"
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            },
            "emails": {
              "type": "string",
              "description": "Filter by comma-separated email addresses"
            },
            "license": {
              "enum": [
                "full",
                "occasional",
                "free",
                "free_restricted",
                "full_trial",
                "unknown"
              ],
              "type": "string",
              "description": "Filter by license type"
            }
          },
          "required": [
            "orgId"
          ]
        }
      },
      {
        "name": "get-organization-member",
        "description": "Retrieves information about a specific organization member (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "orgId": {
              "type": "string",
              "description": "id of the organization"
            },
            "memberId": {
              "type": "string",
              "description": "id of the organization member"
            }
          },
          "required": [
            "orgId",
            "memberId"
          ]
        }
      },
      {
        "name": "add-project-member",
        "description": "Adds a member to a project (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "role": {
              "enum": [
                "owner",
                "editor",
                "commenter",
                "viewer"
              ],
              "type": "string",
              "description": "Role to assign to the user"
            },
            "email": {
              "type": "string",
              "description": "Email ID of the user to add to the project"
            },
            "orgId": {
              "type": "string",
              "description": "The ID of the organization to which the project belongs"
            },
            "teamId": {
              "type": "string",
              "description": "The ID of the team to which the project belongs"
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project to which you want to add a user"
            }
          },
          "required": [
            "orgId",
            "teamId",
            "projectId",
            "email",
            "role"
          ]
        }
      },
      {
        "name": "get-project-member",
        "description": "Retrieves information about a specific project member (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "orgId": {
              "type": "string",
              "description": "The ID of the organization to which the project belongs"
            },
            "teamId": {
              "type": "string",
              "description": "The ID of the team to which the project belongs"
            },
            "memberId": {
              "type": "string",
              "description": "The ID of the member for which you want to retrieve information"
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project from which you want to retrieve specific member information"
            }
          },
          "required": [
            "orgId",
            "teamId",
            "projectId",
            "memberId"
          ]
        }
      },
      {
        "name": "remove-project-member",
        "description": "Removes a member from a project (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "orgId": {
              "type": "string",
              "description": "The ID of the organization to which the project belongs"
            },
            "teamId": {
              "type": "string",
              "description": "The ID of the team to which the project belongs"
            },
            "memberId": {
              "type": "string",
              "description": "The ID of the member that you want to remove from a project"
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project from which you want to remove a member"
            }
          },
          "required": [
            "orgId",
            "teamId",
            "projectId",
            "memberId"
          ]
        }
      },
      {
        "name": "get-all-cases",
        "description": "Retrieves the list of eDiscovery cases in an organization (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "The maximum number of items in the result list"
            },
            "orgId": {
              "type": "string",
              "description": "The ID of the organization for which you want to retrieve the list of cases"
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            }
          },
          "required": [
            "limit",
            "orgId"
          ]
        }
      },
      {
        "name": "get-case",
        "description": "Retrieves information about a specific eDiscovery case (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "orgId": {
              "type": "string",
              "description": "The ID of the organization for which you want to retrieve the case information"
            },
            "caseId": {
              "type": "string",
              "description": "The ID of the case you want to retrieve"
            }
          },
          "required": [
            "orgId",
            "caseId"
          ]
        }
      },
      {
        "name": "get-all-legal-holds",
        "description": "Retrieves the list of all legal holds within a case (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "The maximum number of items in the result list"
            },
            "orgId": {
              "type": "string",
              "description": "The ID of the organization for which you want to retrieve the list of legal holds"
            },
            "caseId": {
              "type": "string",
              "description": "The ID of the case for which you want to retrieve the list of legal holds"
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            }
          },
          "required": [
            "limit",
            "orgId",
            "caseId"
          ]
        }
      },
      {
        "name": "get-legal-hold",
        "description": "Retrieves information about a specific legal hold (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "orgId": {
              "type": "string",
              "description": "The ID of the organization for which you want to retrieve the legal hold information"
            },
            "caseId": {
              "type": "string",
              "description": "The ID of the case for which you want to retrieve the legal hold information"
            },
            "legalHoldId": {
              "type": "string",
              "description": "The ID of the legal hold you want to retrieve"
            }
          },
          "required": [
            "orgId",
            "caseId",
            "legalHoldId"
          ]
        }
      },
      {
        "name": "get-legal-hold-content-items",
        "description": "Retrieves the list of content items under legal hold (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "The maximum number of items in the result list"
            },
            "orgId": {
              "type": "string",
              "description": "The ID of the organization for which you want to retrieve the list of content items under hold"
            },
            "caseId": {
              "type": "string",
              "description": "The ID of the case for which you want to retrieve the list of content items under hold"
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            },
            "legalHoldId": {
              "type": "string",
              "description": "The ID of the legal hold for which you want to retrieve the list of content items under hold"
            }
          },
          "required": [
            "orgId",
            "caseId",
            "legalHoldId",
            "limit"
          ]
        }
      },
      {
        "name": "get-board-content-logs",
        "description": "Retrieves content change logs of board items (Enterprise only)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "string",
              "description": "End date for filtering (ISO 8601 format)"
            },
            "from": {
              "type": "string",
              "description": "Start date for filtering (ISO 8601 format)"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "orgId": {
              "type": "string",
              "description": "Unique identifier of the organization"
            },
            "cursor": {
              "type": "string",
              "description": "Cursor for pagination"
            },
            "emails": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of user emails to filter by"
            },
            "sorting": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "description": "Sort order for results"
            },
            "boardIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of board IDs to filter by"
            }
          },
          "required": [
            "orgId",
            "from",
            "to"
          ]
        }
      }
    ]
  },
  {
    "name": "kmexnx-excel-to-pdf-mcp",
    "title": "Excel to PDF Converter",
    "description": "An MCP server that converts Excel and Apple Numbers files to PDF format, enabling AI assistants like Claude to perform file conversion directly through conversation.",
    "icon": "https://avatars.githubusercontent.com/kmexnx",
    "isOfficial": false,
    "homepage": "https://github.com/kmexnx/excel-to-pdf-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "excel-to-pdf-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "convert_excel_to_pdf",
        "description": "Converts Excel files (.xls, .xlsx) to PDF format",
        "inputSchema": {
          "type": "object",
          "properties": {
            "input_path": {
              "type": "string",
              "minLength": 1,
              "description": "Relative path to the Excel file (.xls, .xlsx) to convert"
            },
            "output_format": {
              "enum": [
                "pdf"
              ],
              "type": "string",
              "default": "pdf",
              "description": "Output format (currently only PDF is supported)"
            }
          },
          "required": [
            "input_path"
          ]
        }
      },
      {
        "name": "convert_numbers_to_pdf",
        "description": "Converts Apple Numbers files (.numbers) to PDF format",
        "inputSchema": {
          "type": "object",
          "properties": {
            "input_path": {
              "type": "string",
              "minLength": 1,
              "description": "Relative path to the Numbers file (.numbers) to convert"
            },
            "output_format": {
              "enum": [
                "pdf"
              ],
              "type": "string",
              "default": "pdf",
              "description": "Output format (currently only PDF is supported)"
            }
          },
          "required": [
            "input_path"
          ]
        }
      }
    ]
  },
  {
    "name": "kpsunil97-devrev-mcp-server",
    "title": "DevRev MCP Server",
    "description": "A Model Context Protocol server that enables searching and retrieving information from DevRev using its APIs with Claude.",
    "icon": "https://avatars.githubusercontent.com/kpsunil97",
    "isOfficial": false,
    "homepage": "https://github.com/kpsunil97/devrev-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "devrev-mcp"
      ],
      "env": {
        "DEVREV_API_KEY": "<devrev-api-key>"
      }
    },
    "parameters": [
      {
        "name": "DEVREV_API_KEY",
        "description": "Your DevRev API key obtained from the DevRev developer portal",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "krzko-google-cloud-mcp",
    "title": "Google Cloud MCP Server",
    "description": "A Model Context Protocol server that connects to Google Cloud services, allowing users to query logs, interact with Spanner databases, and analyze Cloud Monitoring metrics through natural language interaction.",
    "icon": "https://avatars.githubusercontent.com/krzko",
    "isOfficial": false,
    "homepage": "https://github.com/krzko/google-cloud-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "google-cloud-mcp"
      ],
      "env": {
        "GOOGLE_PRIVATE_KEY": "<google-private-key>",
        "GOOGLE_CLIENT_EMAIL": "<google-client-email>",
        "GOOGLE_CLOUD_PROJECT": "<google-cloud-project>",
        "GOOGLE_APPLICATION_CREDENTIALS": "<google-application-credentials>"
      }
    },
    "parameters": [
      {
        "name": "GOOGLE_PRIVATE_KEY",
        "description": "Your Google Cloud service account private key (method 2)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GOOGLE_CLIENT_EMAIL",
        "description": "Your Google Cloud service account email (method 2)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GOOGLE_CLOUD_PROJECT",
        "description": "Your Google Cloud project ID (optional, will attempt to determine from credentials if not set)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GOOGLE_APPLICATION_CREDENTIALS",
        "description": "Path to your Google Cloud service account key file (method 1)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "query-logs",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 50,
              "maximum": 1000,
              "minimum": 1,
              "description": "Maximum number of log entries to return"
            },
            "filter": {
              "type": "string",
              "description": "The filter to apply to logs"
            }
          },
          "required": [
            "filter"
          ]
        }
      },
      {
        "name": "logs-time-range",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 50,
              "maximum": 1000,
              "minimum": 1,
              "description": "Maximum number of log entries to return"
            },
            "filter": {
              "type": "string",
              "description": "Additional filter criteria"
            },
            "endTime": {
              "type": "string",
              "description": "End time in ISO format (defaults to now)"
            },
            "startTime": {
              "type": "string",
              "description": "Start time in ISO format or relative time (e.g., \"1h\", \"2d\")"
            }
          },
          "required": [
            "startTime"
          ]
        }
      },
      {
        "name": "execute-spanner-query",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sql": {
              "type": "string",
              "description": "The SQL query to execute"
            },
            "params": {
              "type": "object",
              "description": "Query parameters",
              "additionalProperties": {}
            },
            "databaseId": {
              "type": "string",
              "description": "Spanner database ID (defaults to SPANNER_DATABASE env var)"
            },
            "instanceId": {
              "type": "string",
              "description": "Spanner instance ID (defaults to SPANNER_INSTANCE env var)"
            }
          },
          "required": [
            "sql"
          ]
        }
      },
      {
        "name": "list-spanner-tables",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "databaseId": {
              "type": "string",
              "description": "Spanner database ID (defaults to SPANNER_DATABASE env var)"
            },
            "instanceId": {
              "type": "string",
              "description": "Spanner instance ID (defaults to SPANNER_INSTANCE env var)"
            }
          }
        }
      },
      {
        "name": "list-spanner-instances",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "_dummy": {
              "type": "string",
              "description": "Not used, just to ensure parameter compatibility"
            }
          }
        }
      },
      {
        "name": "list-spanner-databases",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instanceId": {
              "type": "string",
              "description": "Spanner instance ID"
            }
          },
          "required": [
            "instanceId"
          ]
        }
      },
      {
        "name": "natural-language-spanner-query",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Natural language description of the query you want to execute"
            },
            "databaseId": {
              "type": "string",
              "description": "Spanner database ID (defaults to SPANNER_DATABASE env var)"
            },
            "instanceId": {
              "type": "string",
              "description": "Spanner instance ID (defaults to SPANNER_INSTANCE env var)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "spanner-query-count",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "status": {
              "enum": [
                "ALL",
                "OK",
                "ERROR"
              ],
              "type": "string",
              "default": "ALL",
              "description": "Status of queries to count (ALL, OK, ERROR)"
            },
            "endTime": {
              "type": "string",
              "description": "End time for the query (defaults to now)"
            },
            "queryType": {
              "enum": [
                "ALL",
                "READ",
                "QUERY"
              ],
              "type": "string",
              "default": "ALL",
              "description": "Type of queries to count (ALL, READ, QUERY)"
            },
            "startTime": {
              "type": "string",
              "default": "1h",
              "description": "Start time for the query (e.g., \"1h\", \"2d\", \"30m\")"
            },
            "databaseId": {
              "type": "string",
              "description": "Spanner database ID (optional, if not provided will show all databases)"
            },
            "instanceId": {
              "type": "string",
              "description": "Spanner instance ID (optional, if not provided will show all instances)"
            },
            "alignmentPeriod": {
              "type": "string",
              "default": "60s",
              "description": "Alignment period for aggregating data points (e.g., \"60s\", \"5m\", \"1h\")"
            }
          }
        }
      },
      {
        "name": "query-metrics",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filter": {
              "type": "string",
              "description": "The filter to apply to metrics"
            },
            "endTime": {
              "type": "string",
              "description": "End time in ISO format (defaults to now)"
            },
            "startTime": {
              "type": "string",
              "description": "Start time in ISO format or relative time (e.g., \"1h\", \"2d\")"
            },
            "alignmentPeriod": {
              "type": "string",
              "description": "Alignment period (e.g., \"60s\", \"300s\")"
            }
          },
          "required": [
            "filter",
            "startTime"
          ]
        }
      },
      {
        "name": "list-metric-types",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filter": {
              "type": "string",
              "description": "Simple search term (e.g., \"spanner\") or full filter expression (e.g., \"metric.type = starts_with(\\\"spanner\\\")\")"
            },
            "timeout": {
              "type": "number",
              "default": 30,
              "maximum": 60,
              "minimum": 5,
              "description": "Timeout in seconds for the request"
            },
            "pageSize": {
              "type": "number",
              "default": 20,
              "maximum": 100,
              "minimum": 1,
              "description": "Maximum number of metric types to return"
            }
          }
        }
      },
      {
        "name": "natural-language-metrics-query",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Natural language description of the query you want to execute"
            },
            "endTime": {
              "type": "string",
              "description": "End time in ISO format (defaults to now)"
            },
            "startTime": {
              "type": "string",
              "description": "Start time in ISO format or relative time (e.g., \"1h\", \"2d\")"
            },
            "alignmentPeriod": {
              "type": "string",
              "description": "Alignment period (e.g., \"60s\", \"300s\")"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get-trace",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "traceId": {
              "type": "string",
              "description": "The trace ID to retrieve"
            },
            "projectId": {
              "type": "string",
              "description": "Optional Google Cloud project ID"
            }
          },
          "required": [
            "traceId"
          ]
        }
      },
      {
        "name": "list-traces",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "maximum": 100,
              "minimum": 1,
              "description": "Maximum number of traces to return"
            },
            "filter": {
              "type": "string",
              "description": "Optional filter for traces (e.g., \"status.code != 0\" for errors)"
            },
            "projectId": {
              "type": "string",
              "description": "Optional Google Cloud project ID"
            },
            "startTime": {
              "type": "string",
              "description": "Start time in ISO format or relative time (e.g., \"1h\", \"2d\")"
            }
          }
        }
      },
      {
        "name": "find-traces-from-logs",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "maximum": 100,
              "minimum": 1,
              "description": "Maximum number of logs to check"
            },
            "filter": {
              "type": "string",
              "description": "Filter for logs (e.g., \"severity>=ERROR AND timestamp>\"-1d\"\")"
            },
            "projectId": {
              "type": "string",
              "description": "Optional Google Cloud project ID"
            }
          },
          "required": [
            "filter"
          ]
        }
      },
      {
        "name": "natural-language-trace-query",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Natural language query about traces (e.g., \"Show me failed traces from the last hour\")"
            },
            "projectId": {
              "type": "string",
              "description": "Optional Google Cloud project ID"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "set-project-id",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string",
              "description": "The Google Cloud project ID to set as default"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "get-project-id",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "ks0318-p-sound-notification-mcp",
    "title": "Sound Notification MCP",
    "description": "An MCP server that plays notification sounds when AI coding assistants like Windsurf or Cursor require user attention, such as when coding is complete or when user approval is needed.",
    "icon": "https://avatars.githubusercontent.com/ks0318-p",
    "isOfficial": false,
    "homepage": "https://github.com/ks0318-p/sound-notification-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "sound-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "play-completion-sound",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "soundType": {
              "enum": [
                "default",
                "success",
                "error"
              ],
              "type": "string"
            }
          }
        }
      }
    ]
  },
  {
    "name": "ktanaka101-mcp-server-duckdb",
    "title": "mcp-server-duckdb",
    "description": "A Model Context Protocol (MCP) server implementation for DuckDB, providing database interaction capabilities through MCP tools. It would be interesting to have LLM analyze it. DuckDB is suitable for local analysis.",
    "icon": "https://avatars.githubusercontent.com/ktanaka101",
    "isOfficial": false,
    "homepage": "https://github.com/ktanaka101/mcp-server-duckdb",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-duckdb"
      ],
      "env": {
        "db-path": "<db-path>"
      }
    },
    "parameters": [
      {
        "name": "db-path",
        "description": "Path to the DuckDB database file. The server will automatically create the database file and parent directories if they don't exist.",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "kydycode-todoist-mcp-server-ext",
    "title": "Enhanced Todoist MCP Server Extended",
    "description": "A comprehensive MCP server that provides full integration between Claude and Todoist, enabling task, project, section, and label management through 24 different tools with the complete Todoist API.",
    "icon": "https://avatars.githubusercontent.com/kydycode",
    "isOfficial": false,
    "homepage": "https://github.com/kydycode/todoist-mcp-server-ext",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@kydycode/todoist-mcp-server-ext"
      ],
      "env": {
        "TODOIST_API_TOKEN": "<todoist-api-token>"
      }
    },
    "parameters": [
      {
        "name": "TODOIST_API_TOKEN",
        "description": "Your Todoist API token from Settings → Integrations → Developer",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "todoist_create_task",
        "description": "Create a new task in Todoist with comprehensive options including subtasks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of label names to assign to the task (optional)"
            },
            "content": {
              "type": "string",
              "description": "The content/title of the task"
            },
            "parentId": {
              "type": "string",
              "description": "Parent task ID to create this as a subtask (optional)"
            },
            "priority": {
              "enum": [
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "Task priority from 1 (normal) to 4 (urgent) (optional)"
            },
            "dueString": {
              "type": "string",
              "description": "Natural language due date like 'tomorrow', 'next Monday', 'Jan 23' (optional)"
            },
            "projectId": {
              "type": "string",
              "description": "Project ID to create the task in (optional)"
            },
            "sectionId": {
              "type": "string",
              "description": "Section ID to create the task in (optional)"
            },
            "description": {
              "type": "string",
              "description": "Detailed description of the task (optional)"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "todoist_quick_add_task",
        "description": "Create a task using Todoist's Quick Add feature with natural language parsing",
        "inputSchema": {
          "type": "object",
          "properties": {
            "note": {
              "type": "string",
              "description": "Additional note for the task (optional)"
            },
            "text": {
              "type": "string",
              "description": "Natural language text for quick task creation (e.g., 'Buy milk tomorrow at 2pm #shopping')"
            },
            "reminder": {
              "type": "string",
              "description": "Reminder time (optional)"
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "todoist_get_tasks",
        "description": "Get tasks with comprehensive filtering and pagination support",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of task IDs to retrieve (optional)"
            },
            "label": {
              "type": "string",
              "description": "Filter tasks by label name (optional)"
            },
            "limit": {
              "type": "number",
              "default": 50,
              "description": "Maximum number of tasks to return (default: 50, max: 200) (optional)"
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for next page (optional)"
            },
            "parentId": {
              "type": "string",
              "description": "Filter tasks by parent ID (get subtasks) (optional)"
            },
            "projectId": {
              "type": "string",
              "description": "Filter tasks by project ID (optional)"
            },
            "sectionId": {
              "type": "string",
              "description": "Filter tasks by section ID (optional)"
            }
          }
        }
      },
      {
        "name": "todoist_get_task",
        "description": "Get a specific task by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to retrieve"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "todoist_update_task",
        "description": "Update an existing task by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "New array of label names (optional)"
            },
            "taskId": {
              "type": "string",
              "description": "The ID of the task to update"
            },
            "content": {
              "type": "string",
              "description": "New content/title for the task (optional)"
            },
            "priority": {
              "enum": [
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "New priority level from 1 (normal) to 4 (urgent) (optional)"
            },
            "dueString": {
              "type": "string",
              "description": "New due date in natural language (optional)"
            },
            "description": {
              "type": "string",
              "description": "New description for the task (optional)"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "todoist_delete_task",
        "description": "Delete a task by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to delete"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "todoist_complete_task",
        "description": "Mark a task as complete by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to complete"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "todoist_reopen_task",
        "description": "Reopen a completed task by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the completed task to reopen"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "todoist_search_tasks",
        "description": "Search for tasks by content/name (fallback for when ID is not known)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of results (default: 10) (optional)"
            },
            "query": {
              "type": "string",
              "description": "Search query to find tasks by content"
            },
            "projectId": {
              "type": "string",
              "description": "Limit search to specific project (optional)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "todoist_move_task",
        "description": "Move a single task (and its subtasks, if any) to a different project, section, or make it a subtask of another task. Provide the taskId and exactly one of: projectId, sectionId, or parentId.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "The ID of the task to move."
            },
            "parentId": {
              "type": "string",
              "description": "The ID of the parent task to move this task under. (Optional, use only one of projectId, sectionId, parentId)"
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the destination project. (Optional, use only one of projectId, sectionId, parentId)"
            },
            "sectionId": {
              "type": "string",
              "description": "The ID of the destination section. (Optional, use only one of projectId, sectionId, parentId)"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "todoist_bulk_move_tasks",
        "description": "Move multiple tasks (and their respective subtasks, if any; e.g., up to 10-20 parent tasks for best performance) to a different project, section, or make them subtasks of another task. Provide an array of taskIds and exactly one destination (projectId, sectionId, or parentId).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minItems": 1,
              "description": "An array of task IDs to move."
            },
            "parentId": {
              "type": "string",
              "description": "The ID of the parent task to move these tasks under. (Optional, use only one of projectId, sectionId, parentId)"
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the destination project. (Optional, use only one of projectId, sectionId, parentId)"
            },
            "sectionId": {
              "type": "string",
              "description": "The ID of the destination section. (Optional, use only one of projectId, sectionId, parentId)"
            }
          },
          "required": [
            "taskIds"
          ]
        }
      },
      {
        "name": "todoist_get_projects",
        "description": "Get all active projects with pagination support",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 50,
              "description": "Maximum number of projects to return (default: 50, max: 200) (optional)"
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for next page (optional)"
            }
          }
        }
      },
      {
        "name": "todoist_get_project",
        "description": "Get a specific project by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string",
              "description": "The ID of the project to retrieve"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "todoist_create_project",
        "description": "Create a new project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the project"
            },
            "color": {
              "type": "string",
              "description": "Project color (optional)"
            },
            "parentId": {
              "type": "string",
              "description": "Parent project ID for creating a sub-project (optional)"
            },
            "viewStyle": {
              "enum": [
                "list",
                "board"
              ],
              "type": "string",
              "description": "Project view style: 'list' or 'board' (optional)"
            },
            "isFavorite": {
              "type": "boolean",
              "description": "Whether to mark as favorite (optional)"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "todoist_update_project",
        "description": "Update an existing project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "New name for the project (optional)"
            },
            "color": {
              "type": "string",
              "description": "New color for the project (optional)"
            },
            "projectId": {
              "type": "string",
              "description": "The ID of the project to update"
            },
            "viewStyle": {
              "enum": [
                "list",
                "board"
              ],
              "type": "string",
              "description": "Project view style: 'list' or 'board' (optional)"
            },
            "isFavorite": {
              "type": "boolean",
              "description": "Whether to mark as favorite (optional)"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "todoist_delete_project",
        "description": "Delete a project by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string",
              "description": "The ID of the project to delete"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "todoist_get_sections",
        "description": "Get all sections, or sections for a specific project. Supports pagination.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of sections to return (default: 50) (optional)."
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for next page (optional)."
            },
            "projectId": {
              "type": "string",
              "description": "Filter sections by project ID (optional)."
            }
          }
        }
      },
      {
        "name": "todoist_create_section",
        "description": "Create a new section in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the section"
            },
            "order": {
              "type": "number",
              "description": "Order of the section (optional)"
            },
            "projectId": {
              "type": "string",
              "description": "The project ID where the section will be created"
            }
          },
          "required": [
            "name",
            "projectId"
          ]
        }
      },
      {
        "name": "todoist_update_section",
        "description": "Update an existing section",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "New name for the section"
            },
            "sectionId": {
              "type": "string",
              "description": "The ID of the section to update"
            }
          },
          "required": [
            "sectionId",
            "name"
          ]
        }
      },
      {
        "name": "todoist_delete_section",
        "description": "Delete a section by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sectionId": {
              "type": "string",
              "description": "The ID of the section to delete"
            }
          },
          "required": [
            "sectionId"
          ]
        }
      },
      {
        "name": "todoist_create_label",
        "description": "Create a new label.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the label."
            },
            "color": {
              "type": "string",
              "description": "Label color name or code (e.g., 'berry_red', '#FF0000') (optional)."
            },
            "order": {
              "type": "number",
              "description": "The order of the label in the list (optional)."
            },
            "isFavorite": {
              "type": "boolean",
              "description": "Whether the label should be a favorite (optional)."
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "todoist_get_label",
        "description": "Get a specific label by its ID.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labelId": {
              "type": "string",
              "description": "The ID of the label to retrieve."
            }
          },
          "required": [
            "labelId"
          ]
        }
      },
      {
        "name": "todoist_get_labels",
        "description": "Get all labels. Supports pagination.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of labels to return (default: 50) (optional)."
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for next page (optional)."
            }
          }
        }
      },
      {
        "name": "todoist_update_label",
        "description": "Update an existing label by its ID.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "New name for the label (optional)."
            },
            "color": {
              "type": "string",
              "description": "New color for the label (optional)."
            },
            "order": {
              "type": "number",
              "description": "New order for the label (optional)."
            },
            "labelId": {
              "type": "string",
              "description": "The ID of the label to update."
            },
            "isFavorite": {
              "type": "boolean",
              "description": "New favorite status (optional)."
            }
          },
          "required": [
            "labelId"
          ]
        }
      },
      {
        "name": "todoist_delete_label",
        "description": "Delete a label by its ID.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labelId": {
              "type": "string",
              "description": "The ID of the label to delete."
            }
          },
          "required": [
            "labelId"
          ]
        }
      },
      {
        "name": "todoist_create_comment",
        "description": "Create a new comment on a task or project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "description": "Task ID to add comment to (provide either taskId or projectId, not both)"
            },
            "content": {
              "type": "string",
              "description": "The content/text of the comment"
            },
            "projectId": {
              "type": "string",
              "description": "Project ID to add comment to (provide either taskId or projectId, not both)"
            },
            "attachment": {
              "type": "object",
              "properties": {
                "fileUrl": {
                  "type": "string"
                },
                "fileName": {
                  "type": "string"
                },
                "fileType": {
                  "type": "string"
                },
                "resourceType": {
                  "type": "string"
                }
              },
              "description": "Optional file attachment (optional)"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "todoist_get_comment",
        "description": "Get a specific comment by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "commentId": {
              "type": "string",
              "description": "The ID of the comment to retrieve"
            }
          },
          "required": [
            "commentId"
          ]
        }
      },
      {
        "name": "todoist_get_comments",
        "description": "Get comments for a task or project with pagination support",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of comments to return (optional)"
            },
            "cursor": {
              "type": "string",
              "description": "Pagination cursor for next page (optional)"
            },
            "taskId": {
              "type": "string",
              "description": "Task ID to get comments for (provide either taskId or projectId, not both)"
            },
            "projectId": {
              "type": "string",
              "description": "Project ID to get comments for (provide either taskId or projectId, not both)"
            }
          }
        }
      },
      {
        "name": "todoist_update_comment",
        "description": "Update an existing comment by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "New content/text for the comment"
            },
            "commentId": {
              "type": "string",
              "description": "The ID of the comment to update"
            }
          },
          "required": [
            "commentId",
            "content"
          ]
        }
      },
      {
        "name": "todoist_delete_comment",
        "description": "Delete a comment by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "commentId": {
              "type": "string",
              "description": "The ID of the comment to delete"
            }
          },
          "required": [
            "commentId"
          ]
        }
      }
    ]
  },
  {
    "name": "landicefu-divide-and-conquer-mcp-server",
    "title": "Divide and Conquer MCP Server",
    "description": "Enables AI agents to break down complex tasks into manageable pieces using a structured JSON format with task tracking, context preservation, and progress monitoring capabilities.",
    "icon": "https://avatars.githubusercontent.com/landicefu",
    "isOfficial": false,
    "homepage": "https://github.com/landicefu/divide-and-conquer-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@landicefu/divide-and-conquer-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "initialize_task",
        "description": "Creates a new task with the specified description and optional initial checklist items.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "metadata": {
              "type": "object",
              "properties": {
                "tags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Tags to categorize the task"
                },
                "priority": {
                  "enum": [
                    "high",
                    "medium",
                    "low"
                  ],
                  "type": "string",
                  "description": "Priority level of the task"
                },
                "estimated_completion_time": {
                  "type": "string",
                  "description": "Estimated completion time (ISO timestamp or duration)"
                }
              },
              "description": "Optional metadata for the task"
            },
            "task_description": {
              "type": "string",
              "description": "A medium-level detailed description about the whole task"
            },
            "initial_checklist": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "task",
                  "detailed_description"
                ],
                "properties": {
                  "done": {
                    "type": "boolean",
                    "default": false,
                    "description": "Whether the task is already completed"
                  },
                  "task": {
                    "type": "string",
                    "description": "A short yet comprehensive name for the task"
                  },
                  "context_and_plan": {
                    "type": "string",
                    "description": "Related information, files the agent should read, and more details from other tasks, as well as a detailed plan for this task"
                  },
                  "detailed_description": {
                    "type": "string",
                    "description": "A longer description about what we want to achieve with this task"
                  }
                }
              },
              "description": "Optional initial checklist items"
            },
            "context_for_all_tasks": {
              "type": "string",
              "description": "Information that all tasks in the checklist should include"
            }
          },
          "required": [
            "task_description"
          ]
        }
      },
      {
        "name": "update_task_description",
        "description": "Updates the main task description.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "task_description": {
              "type": "string",
              "description": "The new task description"
            }
          },
          "required": [
            "task_description"
          ]
        }
      },
      {
        "name": "update_context",
        "description": "Updates the context information for all tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "context_for_all_tasks": {
              "type": "string",
              "description": "The new context information for all tasks"
            }
          },
          "required": [
            "context_for_all_tasks"
          ]
        }
      },
      {
        "name": "add_checklist_item",
        "description": "Adds a new item to the checklist.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "done": {
              "type": "boolean",
              "default": false,
              "description": "Whether the task is already completed"
            },
            "task": {
              "type": "string",
              "description": "A short yet comprehensive name for the task"
            },
            "position": {
              "type": "number",
              "description": "Optional position to insert the task (0-based index). If not provided, the task will be added at the end."
            },
            "context_and_plan": {
              "type": "string",
              "description": "Related information, files the agent should read, and more details from other tasks, as well as a detailed plan for this task"
            },
            "detailed_description": {
              "type": "string",
              "description": "A longer description about what we want to achieve with this task"
            }
          },
          "required": [
            "task",
            "detailed_description"
          ]
        }
      },
      {
        "name": "update_checklist_item",
        "description": "Updates an existing checklist item.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "done": {
              "type": "boolean",
              "description": "Whether the task is completed"
            },
            "task": {
              "type": "string",
              "description": "A short yet comprehensive name for the task"
            },
            "index": {
              "type": "number",
              "description": "The index of the checklist item to update (0-based)"
            },
            "context_and_plan": {
              "type": "string",
              "description": "Related information, files the agent should read, and more details from other tasks, as well as a detailed plan for this task"
            },
            "detailed_description": {
              "type": "string",
              "description": "A longer description about what we want to achieve with this task"
            }
          },
          "required": [
            "index"
          ]
        }
      },
      {
        "name": "mark_task_done",
        "description": "Marks a checklist item as done.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "index": {
              "type": "number",
              "description": "The index of the checklist item to mark as done (0-based)"
            }
          },
          "required": [
            "index"
          ]
        }
      },
      {
        "name": "mark_task_undone",
        "description": "Marks a checklist item as not done.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "index": {
              "type": "number",
              "description": "The index of the checklist item to mark as not done (0-based)"
            }
          },
          "required": [
            "index"
          ]
        }
      },
      {
        "name": "remove_checklist_item",
        "description": "Removes a checklist item.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "index": {
              "type": "number",
              "description": "The index of the checklist item to remove (0-based)"
            }
          },
          "required": [
            "index"
          ]
        }
      },
      {
        "name": "reorder_checklist_item",
        "description": "Moves a checklist item to a new position.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to_index": {
              "type": "number",
              "description": "The new index for the checklist item (0-based)"
            },
            "from_index": {
              "type": "number",
              "description": "The current index of the checklist item (0-based)"
            }
          },
          "required": [
            "from_index",
            "to_index"
          ]
        }
      },
      {
        "name": "add_note",
        "description": "Adds a note to the task.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string",
              "description": "The content of the note"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "add_resource",
        "description": "Adds a resource to the task.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL or file path of the resource"
            },
            "name": {
              "type": "string",
              "description": "Name of the resource"
            },
            "description": {
              "type": "string",
              "description": "Description of the resource"
            }
          },
          "required": [
            "name",
            "url"
          ]
        }
      },
      {
        "name": "update_metadata",
        "description": "Updates the task metadata.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tags to categorize the task"
            },
            "priority": {
              "enum": [
                "high",
                "medium",
                "low"
              ],
              "type": "string",
              "description": "Priority level of the task"
            },
            "estimated_completion_time": {
              "type": "string",
              "description": "Estimated completion time (ISO timestamp or duration)"
            }
          }
        }
      },
      {
        "name": "clear_task",
        "description": "Clears the current task data.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "get_checklist_summary",
        "description": "Returns a summary of the checklist with completion status.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "include_descriptions": {
              "type": "boolean",
              "default": false,
              "description": "Whether to include detailed descriptions in the summary"
            }
          }
        }
      },
      {
        "name": "get_current_task_details",
        "description": "Retrieves details of the current task (first uncompleted task) with full context. This is the recommended tool to use when working with tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      }
    ]
  },
  {
    "name": "langchain-ai-mcpdoc",
    "title": "MCP LLMS-TXT Documentation Server",
    "description": "An MCP server that provides tools to load and fetch documentation from any llms.txt source, giving users full control over context retrieval for LLMs in IDE agents and applications.",
    "icon": "https://avatars.githubusercontent.com/langchain-ai",
    "isOfficial": false,
    "homepage": "https://github.com/langchain-ai/mcpdoc",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcpdoc"
      ],
      "env": {
        "host": "<host>",
        "json": "<json>",
        "port": "<port>",
        "urls": "<urls>",
        "yaml": "<yaml>",
        "timeout": "<timeout>",
        "transport": "<transport>",
        "follow_redirects": "<follow-redirects>"
      }
    },
    "parameters": [
      {
        "name": "host",
        "description": "Host to bind the server to when using non-stdio transport",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "json",
        "description": "Path to a JSON config file containing documentation sources",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "port",
        "description": "Port to run the server on when using non-stdio transport",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "urls",
        "description": "URLs of llms.txt files to use, can be specified as plain URLs or with optional names using the format 'name:url'",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "yaml",
        "description": "Path to a YAML config file containing documentation sources",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "timeout",
        "description": "HTTP request timeout in seconds",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "transport",
        "description": "Transport method to use (e.g., 'stdio', 'sse')",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "follow_redirects",
        "description": "Follow HTTP redirects",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "list_doc_sources",
        "description": "List all available documentation sources.\n\n        This is the first tool you should call in the documentation workflow.\n        It provides URLs to llms.txt files or local file paths that the user has made available.\n\n        Returns:\n            A string containing a formatted list of documentation sources with their URLs or file paths\n        ",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "fetch_docs",
        "description": "Fetch and parse documentation from a given URL or local file.\n\nUse this tool after list_doc_sources to:\n1. First fetch the llms.txt file from a documentation source\n2. Analyze the URLs listed in the llms.txt file\n3. Then fetch specific documentation pages relevant to the user's question\n\nArgs:\n    url: The URL to fetch documentation from.\n\nReturns:\n    The fetched documentation content converted to markdown, or an error message\n    if the request fails or the URL is not from an allowed domain.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "title": "Url"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "leafeye-lunchmoney-mcp-server",
    "title": "lunchmoney-mcp",
    "description": "An MCP server that lets AI assistants interact with your Lunchmoney data, enabling natural language queries about transactions, budgets, and spending patterns.",
    "icon": "https://avatars.githubusercontent.com/leafeye",
    "isOfficial": false,
    "homepage": "https://github.com/leafeye/lunchmoney-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "lunchmoney-mcp"
      ],
      "env": {
        "LUNCHMONEY_TOKEN": "<lunchmoney-token>"
      }
    },
    "parameters": [
      {
        "name": "LUNCHMONEY_TOKEN",
        "description": "Your Lunchmoney API token, which you can get from your Lunchmoney developer settings (https://my.lunchmoney.app/developers)",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get-budget-summary",
        "description": "Get budget summary for a specific time period",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end_date": {
              "type": "string",
              "description": "End date (YYYY-MM-DD, should be end of month)"
            },
            "start_date": {
              "type": "string",
              "description": "Start date (YYYY-MM-DD, should be start of month)"
            }
          },
          "required": [
            "start_date",
            "end_date"
          ]
        }
      },
      {
        "name": "get-recent-transactions",
        "description": "Get recent transactions",
        "inputSchema": {
          "type": "object",
          "properties": {
            "days": {
              "type": "number",
              "default": 30,
              "description": "Number of days to look back"
            },
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of transactions to return"
            }
          }
        }
      },
      {
        "name": "search-transactions",
        "description": "Search transactions by keyword",
        "inputSchema": {
          "type": "object",
          "properties": {
            "days": {
              "type": "number",
              "default": 90,
              "description": "Number of days to look back"
            },
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Maximum number of transactions to return"
            },
            "keyword": {
              "type": "string",
              "description": "Search term to look for"
            }
          },
          "required": [
            "keyword"
          ]
        }
      },
      {
        "name": "get-category-spending",
        "description": "Get spending in a category",
        "inputSchema": {
          "type": "object",
          "properties": {
            "days": {
              "type": "number",
              "default": 30,
              "description": "Number of days to look back"
            },
            "category": {
              "type": "string",
              "description": "Category name"
            }
          },
          "required": [
            "category"
          ]
        }
      }
    ]
  },
  {
    "name": "liorfranko-mcp-chain-of-thought",
    "title": "mcp-chain-of-thought",
    "description": "mcp-chain-of-thought",
    "icon": "https://avatars.githubusercontent.com/liorfranko",
    "isOfficial": false,
    "homepage": "https://github.com/liorfranko/mcp-chain-of-thought",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-chain-of-thought"
      ],
      "env": {
        "DATA_DIR": "<data-dir>",
        "ENABLE_GUI": "<enable-gui>",
        "TEMPLATES_USE": "<templates-use>",
        "ENABLE_DETAILED_MODE": "<enable-detailed-mode>",
        "ENABLE_THOUGHT_CHAIN": "<enable-thought-chain>"
      }
    },
    "parameters": [
      {
        "name": "DATA_DIR",
        "description": "Directory for storing task data (absolute path required)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "ENABLE_GUI",
        "description": "Enables web interface",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TEMPLATES_USE",
        "description": "Template language",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ENABLE_DETAILED_MODE",
        "description": "Shows conversation history",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ENABLE_THOUGHT_CHAIN",
        "description": "Controls detailed thinking process",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "plan_task",
        "description": "Initialize and detail the task flow, establish clear goals and success criteria, optionally reference existing tasks for continuation planning\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "description": {
              "type": "string",
              "minLength": 10,
              "description": "Complete detailed task problem description, should include task objectives, background and expected outcomes"
            },
            "requirements": {
              "type": "string",
              "description": "Specific technical requirements, business constraints or quality standards for the task (optional)"
            },
            "existingTasksReference": {
              "type": "boolean",
              "default": false,
              "description": "Whether to reference existing tasks as a planning basis, used for task adjustment and continuity planning"
            }
          },
          "required": [
            "description"
          ]
        }
      },
      {
        "name": "analyze_task",
        "description": "Deeply analyze task requirements and systematically check the codebase, evaluate technical feasibility and potential risks. If code is needed, use pseudocode format providing only high-level logic flow and key steps, avoiding complete code.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "summary": {
              "type": "string",
              "minLength": 10,
              "description": "Structured task summary including task objectives, scope and key technical challenges, minimum 10 characters"
            },
            "initialConcept": {
              "type": "string",
              "minLength": 50,
              "description": "At least 50 characters of initial solution concept, including technical solution, architectural design and implementation strategy, if code is needed use pseudocode format and only provide high-level logic flow and key steps avoiding complete code"
            },
            "previousAnalysis": {
              "type": "string",
              "description": "Analysis results from previous iterations, used for continuous improvement of solutions (only required for reanalysis)"
            }
          },
          "required": [
            "summary",
            "initialConcept"
          ]
        }
      },
      {
        "name": "reflect_task",
        "description": "Critically review analysis results, evaluate solution completeness and identify optimization opportunities, ensuring the solution aligns with best practices. If code is needed, use pseudocode format providing only high-level logic flow and key steps, avoiding complete code.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "summary": {
              "type": "string",
              "minLength": 10,
              "description": "Structured task summary, keeping consistent with the analysis phase to ensure continuity"
            },
            "analysis": {
              "type": "string",
              "minLength": 100,
              "description": "Comprehensive technical analysis results, including all technical details, dependent components and implementation plans, if code is needed use pseudocode format and only provide high-level logic flow and key steps avoiding complete code"
            }
          },
          "required": [
            "summary",
            "analysis"
          ]
        }
      },
      {
        "name": "split_tasks",
        "description": "Decompose complex tasks into independent subtasks, establishing dependencies and priorities.\n\n## updateMode\n\n- **append**: Keep existing tasks and add new ones\n- **overwrite**: Delete unfinished tasks, keep completed ones\n- **selective**: Intelligently match and update existing tasks based on name\n- **clearAllTasks**: Clear all tasks and create a backup (preferred mode)\n\n## Key Requirements\n\n- **Provide concise pseudocode**: Only provide high-level logic flow and key steps, avoid complete code\n- **Consolidate when necessary**: Simple modifications can be integrated with other tasks to avoid excessive task count\n- **Submit in batches**: If there are too many tasks, use the \"split_tasks\" tool with parameters not exceeding 5000 characters\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tasks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "name",
                  "description",
                  "implementationGuide"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "maxLength": 100,
                    "description": "Brief and clear task name, should be able to express the purpose of the task"
                  },
                  "notes": {
                    "type": "string",
                    "description": "Supplementary notes, special processing requirements or implementation suggestions (optional)"
                  },
                  "description": {
                    "type": "string",
                    "minLength": 10,
                    "description": "Detailed task description, including implementation points, technical details and acceptance standards"
                  },
                  "dependencies": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "List of previous task IDs or task names this task depends on, supports two referencing methods, name referencing is more intuitive, and is a string array"
                  },
                  "relatedFiles": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "path",
                        "type",
                        "description"
                      ],
                      "properties": {
                        "path": {
                          "type": "string",
                          "minLength": 1,
                          "description": "File path, can be a path relative to the project root directory or an absolute path"
                        },
                        "type": {
                          "enum": [
                            "TO_MODIFY",
                            "REFERENCE",
                            "CREATE",
                            "DEPENDENCY",
                            "OTHER"
                          ],
                          "type": "string",
                          "description": "File type (TO_MODIFY: to be modified, REFERENCE: reference material, CREATE: to be created, DEPENDENCY: dependency file, OTHER: other)"
                        },
                        "lineEnd": {
                          "type": "integer",
                          "description": "Ending line of the relevant code block (optional)",
                          "exclusiveMinimum": 0
                        },
                        "lineStart": {
                          "type": "integer",
                          "description": "Starting line of the relevant code block (optional)",
                          "exclusiveMinimum": 0
                        },
                        "description": {
                          "type": "string",
                          "minLength": 1,
                          "description": "File description, used to explain the purpose and content of the file"
                        }
                      },
                      "additionalProperties": false
                    },
                    "description": "List of files related to the task, used to record code files, reference materials, files to be created, etc. related to the task (optional)"
                  },
                  "implementationGuide": {
                    "type": "string",
                    "description": "Specific implementation method and steps for this task, please refer to previous analysis results and provide simplified pseudocode"
                  },
                  "verificationCriteria": {
                    "type": "string",
                    "description": "Verification criteria and inspection methods for this specific task"
                  }
                },
                "additionalProperties": false
              },
              "minItems": 1,
              "description": "Structured task list, each task should be atomic and have a clear completion standard, avoid overly simple tasks, simple modifications can be integrated with other tasks, avoid too many tasks"
            },
            "updateMode": {
              "enum": [
                "append",
                "overwrite",
                "selective",
                "clearAllTasks"
              ],
              "type": "string",
              "description": "Task update mode selection: 'append' (preserve all existing tasks and add new tasks), 'overwrite' (clear all unfinished tasks and completely replace, preserve completed tasks), 'selective' (intelligent update: match and update existing tasks by name, preserve tasks not in the list, recommended for minor task adjustments), 'clearAllTasks' (clear all tasks and create a backup).\nDefault is 'clearAllTasks' mode, only use other modes when the user requests changes or modifications to the plan content"
            },
            "globalAnalysisResult": {
              "type": "string",
              "description": "Global analysis result: complete analysis result from reflect_task, applicable to the common parts of all tasks"
            }
          },
          "required": [
            "updateMode",
            "tasks"
          ]
        }
      },
      {
        "name": "list_tasks",
        "description": "Generate a structured task list, including complete status tracking, priority, and dependencies\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "status": {
              "enum": [
                "all",
                "pending",
                "in_progress",
                "completed"
              ],
              "type": "string",
              "description": "Task status to list, can choose 'all' to list all tasks, or specify specific status"
            }
          },
          "required": [
            "status"
          ]
        }
      },
      {
        "name": "execute_task",
        "description": "Execute a specific task according to the predefined plan, ensuring the output of each step meets quality standards\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier of the task to execute, must be an existing valid task ID in the system"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "verify_task",
        "description": "Comprehensively verify task completion, ensuring all requirements and technical standards are met without missing details\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier of the task to verify, must be an existing valid task ID in the system"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "complete_task",
        "description": "Formally mark a task as completed, generate a detailed completion report, and update the dependency status of related tasks\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier of the task to mark as completed, must be a valid unfinished task ID in the status of \"in progress\""
            },
            "summary": {
              "type": "string",
              "minLength": 30,
              "description": "Task completion summary, concise description of implementation results and important decisions (optional, will be automatically generated if not provided)"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "delete_task",
        "description": "Delete unfinished tasks, but does not allow deleting completed tasks, ensuring the integrity of system records\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier of the task to delete, must be an existing unfinished task ID in the system"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "clear_all_tasks",
        "description": "Clear unfinished tasks and reset the task list\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "confirm": {
              "type": "boolean",
              "description": "Confirm to delete all unfinished tasks (this operation is irreversible)"
            }
          },
          "required": [
            "confirm"
          ]
        }
      },
      {
        "name": "update_task",
        "description": "Update task content, including name, description and notes, dependent tasks, related files, implementation guide and verification criteria. Completed tasks only allow updating summary and related files\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "New name for the task (optional)"
            },
            "notes": {
              "type": "string",
              "description": "New supplementary notes for the task (optional)"
            },
            "taskId": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier of the task to update, must be an existing and unfinished task ID in the system"
            },
            "description": {
              "type": "string",
              "description": "New description content for the task (optional)"
            },
            "dependencies": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "New dependency relationships for the task (optional)"
            },
            "relatedFiles": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "path",
                  "type"
                ],
                "properties": {
                  "path": {
                    "type": "string",
                    "minLength": 1,
                    "description": "File path, can be a path relative to the project root directory or an absolute path"
                  },
                  "type": {
                    "enum": [
                      "TO_MODIFY",
                      "REFERENCE",
                      "CREATE",
                      "DEPENDENCY",
                      "OTHER"
                    ],
                    "type": "string",
                    "description": "Relationship type between the file and task (TO_MODIFY, REFERENCE, CREATE, DEPENDENCY, OTHER)"
                  },
                  "lineEnd": {
                    "type": "integer",
                    "description": "Ending line of the relevant code block (optional)",
                    "exclusiveMinimum": 0
                  },
                  "lineStart": {
                    "type": "integer",
                    "description": "Starting line of the relevant code block (optional)",
                    "exclusiveMinimum": 0
                  },
                  "description": {
                    "type": "string",
                    "description": "Supplementary description of the file (optional)"
                  }
                },
                "additionalProperties": false
              },
              "description": "List of files related to the task, used to record code files, reference materials, files to be created, etc. related to the task (optional)"
            },
            "implementationGuide": {
              "type": "string",
              "description": "New implementation guide for the task (optional)"
            },
            "verificationCriteria": {
              "type": "string",
              "description": "New verification criteria for the task (optional)"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "query_task",
        "description": "Search tasks by keyword or ID, displaying abbreviated task information\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "isId": {
              "type": "boolean",
              "default": false,
              "description": "Specify whether it's ID query mode, default is no (keyword mode)"
            },
            "page": {
              "type": "integer",
              "default": 1,
              "description": "Page number, default is page 1",
              "exclusiveMinimum": 0
            },
            "query": {
              "type": "string",
              "minLength": 1,
              "description": "Search query text, can be task ID or multiple keywords (space separated)"
            },
            "pageSize": {
              "type": "integer",
              "default": 5,
              "maximum": 20,
              "minimum": 1,
              "description": "Number of tasks to display per page, default is 5, maximum 20",
              "exclusiveMinimum": 0
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_task_detail",
        "description": "Get the complete detailed information of a task based on its ID, including unabridged implementation guides and verification criteria, etc.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string",
              "minLength": 1,
              "description": "Task ID to view details"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "process_thought",
        "description": "Engage in a flexible and evolving thinking process by creating, questioning, validating, and refining ideas to progressively deepen understanding and generate effective solutions. When needing to gather data, analyze, or research, prioritize reviewing relevant project code; if such code doesn't exist, search the web rather than speculating. Set nextThoughtNeeded to false when thinking is sufficient, otherwise adjust total_thoughts to extend the process\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Thought tags, an array of strings"
            },
            "stage": {
              "type": "string",
              "minLength": 1,
              "description": "Thinking stage, available stages include: problem definition, information gathering, research, analysis, synthesis, conclusion, questioning, planning"
            },
            "thought": {
              "type": "string",
              "minLength": 1,
              "description": "Thought content"
            },
            "axioms_used": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Axioms used, an array of strings"
            },
            "thought_number": {
              "type": "integer",
              "description": "Current thought number",
              "exclusiveMinimum": 0
            },
            "total_thoughts": {
              "type": "integer",
              "description": "Estimated total number of thoughts, can be changed anytime if more thinking is needed",
              "exclusiveMinimum": 0
            },
            "next_thought_needed": {
              "type": "boolean",
              "description": "Whether next thought step is needed"
            },
            "assumptions_challenged": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Assumptions challenged, an array of strings"
            }
          },
          "required": [
            "thought",
            "thought_number",
            "total_thoughts",
            "next_thought_needed",
            "stage"
          ]
        }
      },
      {
        "name": "init_project_rules",
        "description": "Initialize project rules. Call this tool when the user requests to generate or initialize the project specification file, or if the user requests to change or update the project specification.\n",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "lumile-mercadolibre-mcp",
    "title": "MercadoLibre MCP Server",
    "description": "Enables interaction with MercadoLibre's API for product search, reviews, descriptions, and seller reputation insights.",
    "icon": "https://avatars.githubusercontent.com/lumile",
    "isOfficial": false,
    "homepage": "https://github.com/lumile/mercadolibre-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mercadolibre-mcp"
      ],
      "env": {
        "SITE_ID": "<site-id>",
        "CLIENT_ID": "<client-id>",
        "CLIENT_SECRET": "<client-secret>"
      }
    },
    "parameters": [
      {
        "name": "SITE_ID",
        "description": "The MercadoLibre site ID to use (MLA: Argentina, MLB: Brasil, MCO: Colombia, MEX: México, MLU: Uruguay, MLC: Chile)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "CLIENT_ID",
        "description": "Your MercadoLibre Client ID obtained from https://developers.mercadolibre.com/",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "CLIENT_SECRET",
        "description": "Your MercadoLibre Client Secret obtained from https://developers.mercadolibre.com/",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "search_products",
        "description": "Busca productos en MercadoLibre",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "description": "Cantidad de resultados a devolver"
            },
            "query": {
              "type": "string",
              "description": "Consulta de búsqueda"
            },
            "offset": {
              "type": "number",
              "default": 0,
              "description": "Cantidad de resultados a saltar"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "seller_reputation",
        "description": "Obtiene la reputación de un vendedor",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sellerId": {
              "type": "string",
              "description": "ID del vendedor"
            }
          }
        }
      },
      {
        "name": "product_reviews",
        "description": "Obtiene las reseñas de un producto",
        "inputSchema": {
          "type": "object",
          "properties": {
            "productId": {
              "type": "string",
              "description": "ID del producto"
            }
          }
        }
      },
      {
        "name": "product_description",
        "description": "Obtiene la descripción de un producto",
        "inputSchema": {
          "type": "object",
          "properties": {
            "productId": {
              "type": "string",
              "description": "ID del producto"
            }
          }
        }
      }
    ]
  },
  {
    "name": "lupuletic-onyx-mcp-server",
    "title": "onyx-mcp-server",
    "description": "Connect your MCP-compatible clients to Onyx AI knowledge bases for enhanced semantic search and chat capabilities. Retrieve relevant context from your documents seamlessly, enabling powerful interactions and comprehensive answers. Streamline knowledge management and improve access to information acr",
    "icon": "https://avatars.githubusercontent.com/lupuletic",
    "isOfficial": false,
    "homepage": "https://github.com/lupuletic/onyx-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "onyx-mcp-server"
      ],
      "env": {
        "ONYX_API_URL": "<onyx-api-url>",
        "ONYX_API_TOKEN": "<onyx-api-token>"
      }
    },
    "parameters": [
      {
        "name": "ONYX_API_URL",
        "description": "The URL of your Onyx API instance",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ONYX_API_TOKEN",
        "description": "Your Onyx API token for authentication",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "search_onyx",
        "description": "Search the Onyx backend for relevant documents",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The topic to search for"
            },
            "maxResults": {
              "type": "integer",
              "maximum": 10,
              "minimum": 1,
              "description": "Maximum number of results to return (default: 5)"
            },
            "chunksAbove": {
              "type": "integer",
              "default": 1,
              "description": "Number of chunks to include above the matching chunk (default: 1)"
            },
            "chunksBelow": {
              "type": "integer",
              "default": 1,
              "description": "Number of chunks to include below the matching chunk (default: 1)"
            },
            "documentSets": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of document set names to search within (empty for all)"
            },
            "retrieveFullDocuments": {
              "type": "boolean",
              "default": false,
              "description": "Whether to retrieve full documents instead of just matching chunks (default: false)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "chat_with_onyx",
        "description": "Chat with Onyx to get comprehensive answers",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The question to ask Onyx"
            },
            "personaId": {
              "type": "integer",
              "default": 15,
              "description": "The ID of the persona to use (default: 15)"
            },
            "documentSets": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of document set names to search within (empty for all)"
            },
            "chatSessionId": {
              "type": "string",
              "description": "Existing chat session ID to continue a conversation (optional)"
            },
            "enableAutoDetectFilters": {
              "type": "boolean",
              "default": true,
              "description": "Whether to enable auto-detection of filters (default: true)"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "mackenly-mcp-fathom-analytics",
    "title": "MCP Fathom Analytics",
    "description": "An unofficial server that allows AI assistants to access Fathom Analytics data, enabling users to retrieve account information, site statistics, events, aggregated reports, and real-time visitor tracking.",
    "icon": "https://avatars.githubusercontent.com/mackenly",
    "isOfficial": false,
    "homepage": "https://github.com/mackenly/mcp-fathom-analytics",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-fathom-analytics"
      ],
      "env": {
        "FATHOM_API_KEY": "<fathom-api-key>"
      }
    },
    "parameters": [
      {
        "name": "FATHOM_API_KEY",
        "description": "Your Fathom Analytics API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get-account",
        "description": "Get Fathom Analytics account information",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list-sites",
        "description": "List all Fathom Analytics sites on the account",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Optional limit on the number of sites to return",
              "exclusiveMinimum": 0
            }
          }
        }
      },
      {
        "name": "list-events",
        "description": "List all events for a Fathom Analytics site (automatically handles pagination)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Optional limit on the number of events to return",
              "exclusiveMinimum": 0
            },
            "site_id": {
              "type": "string",
              "description": "ID of the site to retrieve events for"
            }
          },
          "required": [
            "site_id"
          ]
        }
      },
      {
        "name": "get-aggregation",
        "description": "Get aggregated analytics data from Fathom",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Limit on number of results",
              "exclusiveMinimum": 0
            },
            "entity": {
              "enum": [
                "pageview",
                "event"
              ],
              "type": "string",
              "description": "The entity to aggregate (pageview or event)"
            },
            "date_to": {
              "type": "string",
              "description": "End date (e.g., 2025-12-31 23:59:59 or 2025-12-31)"
            },
            "filters": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "property",
                  "operator",
                  "value"
                ],
                "properties": {
                  "value": {
                    "type": "string"
                  },
                  "operator": {
                    "enum": [
                      "is",
                      "is not",
                      "is like",
                      "is not like"
                    ],
                    "type": "string"
                  },
                  "property": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "description": "Array of filter objects"
            },
            "sort_by": {
              "type": "string",
              "description": "Field to sort by (e.g., pageviews:desc)"
            },
            "timezone": {
              "type": "string",
              "description": "Timezone for date calculations (default: UTC)"
            },
            "date_from": {
              "type": "string",
              "description": "Start date (e.g., 2025-01-01 00:00:00 or 2025-01-01)"
            },
            "entity_id": {
              "type": "string",
              "description": "ID of the entity (site ID or event ID)"
            },
            "aggregates": {
              "type": "string",
              "description": "Comma-separated list of aggregates to include (visits,uniques,pageviews,avg_duration,bounce_rate,conversions,unique_conversions,value)"
            },
            "date_grouping": {
              "enum": [
                "hour",
                "day",
                "month",
                "year"
              ],
              "type": "string",
              "description": "Optional date grouping"
            },
            "field_grouping": {
              "type": "string",
              "description": "Comma-separated fields to group by (e.g., hostname,pathname)"
            }
          },
          "required": [
            "entity",
            "entity_id",
            "aggregates",
            "date_from",
            "date_to"
          ]
        }
      },
      {
        "name": "get-current-visitors",
        "description": "Get current visitors for a Fathom Analytics site",
        "inputSchema": {
          "type": "object",
          "properties": {
            "site_id": {
              "type": "string",
              "description": "ID of the site to retrieve current visitors for"
            },
            "detailed": {
              "type": "boolean",
              "description": "Whether to include detailed content and referrer information"
            }
          },
          "required": [
            "site_id"
          ]
        }
      }
    ]
  },
  {
    "name": "magarcia-mcp-server-giphy",
    "title": "MCP Server Giphy",
    "description": "Enables AI models to search, retrieve, and utilize GIFs from Giphy with features like content filtering, multiple search methods, and comprehensive metadata.",
    "icon": "https://avatars.githubusercontent.com/magarcia",
    "isOfficial": false,
    "homepage": "https://github.com/magarcia/mcp-server-giphy",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-server-giphy"
      ],
      "env": {
        "GIPHY_API_KEY": "<giphy-api-key>"
      }
    },
    "parameters": [
      {
        "name": "GIPHY_API_KEY",
        "description": "Your Giphy API key obtained from the Giphy Developer dashboard",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "search_gifs",
        "description": "Search for GIFs on Giphy with a query string",
        "inputSchema": {
          "type": "object",
          "properties": {
            "lang": {
              "type": "string",
              "description": "Language code (default: en)"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of objects to return (default: 10, max: 50)"
            },
            "query": {
              "type": "string",
              "description": "Search query term or phrase"
            },
            "offset": {
              "type": "number",
              "description": "Results offset (default: 0)"
            },
            "rating": {
              "enum": [
                "g",
                "pg",
                "pg-13",
                "r"
              ],
              "type": "string",
              "description": "Content rating (g, pg, pg-13, r)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_random_gif",
        "description": "Get a random GIF from Giphy, optionally filtered by tag",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "Tag to limit random results (optional)"
            },
            "rating": {
              "enum": [
                "g",
                "pg",
                "pg-13",
                "r"
              ],
              "type": "string",
              "description": "Content rating (g, pg, pg-13, r)"
            }
          }
        }
      },
      {
        "name": "get_trending_gifs",
        "description": "Get currently trending GIFs on Giphy",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of objects to return (default: 10, max: 50)"
            },
            "offset": {
              "type": "number",
              "description": "Results offset (default: 0)"
            },
            "rating": {
              "enum": [
                "g",
                "pg",
                "pg-13",
                "r"
              ],
              "type": "string",
              "description": "Content rating (g, pg, pg-13, r)"
            }
          }
        }
      }
    ]
  },
  {
    "name": "magicuidesign-mcp",
    "title": "Magic UI MCP Server",
    "description": "ModelContextProtocol server for Magic UI that allows AI assistants to easily implement UI components for web applications by providing code for components like marquees, animations, special effects, and interactive backgrounds.",
    "icon": "https://avatars.githubusercontent.com/magicuidesign",
    "isOfficial": false,
    "homepage": "https://github.com/magicuidesign/mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@magicuidesign/mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "getUIComponents",
        "description": "Provides a comprehensive list of all Magic UI components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getLayout",
        "description": "Provides implementation details for bento-grid, dock, file-tree, grid-pattern, interactive-grid-pattern, dot-pattern components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getMedia",
        "description": "Provides implementation details for hero-video-dialog, terminal, marquee, script-copy-btn, code-comparison components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getMotion",
        "description": "Provides implementation details for blur-fade, scroll-progress, scroll-based-velocity, orbiting-circles, animated-circular-progress-bar components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getTextReveal",
        "description": "Provides implementation details for text-animate, line-shadow-text, aurora-text, animated-shiny-text, animated-gradient-text, text-reveal, typing-animation, box-reveal, number-ticker components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getTextEffects",
        "description": "Provides implementation details for word-rotate, flip-text, hyper-text, morphing-text, spinning-text, sparkles-text components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getButtons",
        "description": "Provides implementation details for rainbow-button, shimmer-button, shiny-button, interactive-hover-button, animated-subscribe-button, pulsating-button, ripple-button components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getEffects",
        "description": "Provides implementation details for animated-beam, border-beam, shine-border, magic-card, meteors, neon-gradient-card, confetti, particles, cool-mode, scratch-to-reveal components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getWidgets",
        "description": "Provides implementation details for animated-list, tweet-card, client-tweet-card, lens, pointer, avatar-circles, icon-cloud, globe components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getBackgrounds",
        "description": "Provides implementation details for warp-background, flickering-grid, animated-grid-pattern, retro-grid, ripple components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getDevices",
        "description": "Provides implementation details for safari, iphone-15-pro, android components.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "mahdin75-gis-mcp",
    "title": "GIS MCP Server",
    "description": "A Model Context Protocol server that connects LLMs to GIS operations, enabling AI assistants to perform accurate geospatial analysis including geometric operations, coordinate transformations, and spatial measurements.",
    "icon": "https://avatars.githubusercontent.com/mahdin75",
    "isOfficial": false,
    "homepage": "https://github.com/mahdin75/gis-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "gis-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "buffer",
        "description": "Create a buffer around a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "distance": {
              "type": "number",
              "title": "Distance"
            },
            "geometry": {
              "type": "string",
              "title": "Geometry"
            },
            "join_style": {
              "type": "integer",
              "title": "Join Style",
              "default": 1
            },
            "resolution": {
              "type": "integer",
              "title": "Resolution",
              "default": 16
            },
            "mitre_limit": {
              "type": "number",
              "title": "Mitre Limit",
              "default": 5
            },
            "single_sided": {
              "type": "boolean",
              "title": "Single Sided",
              "default": false
            }
          },
          "required": [
            "geometry",
            "distance"
          ]
        }
      },
      {
        "name": "intersection",
        "description": "Find intersection of two geometries.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry1": {
              "type": "string",
              "title": "Geometry1"
            },
            "geometry2": {
              "type": "string",
              "title": "Geometry2"
            }
          },
          "required": [
            "geometry1",
            "geometry2"
          ]
        }
      },
      {
        "name": "union",
        "description": "Combine two geometries.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry1": {
              "type": "string",
              "title": "Geometry1"
            },
            "geometry2": {
              "type": "string",
              "title": "Geometry2"
            }
          },
          "required": [
            "geometry1",
            "geometry2"
          ]
        }
      },
      {
        "name": "difference",
        "description": "Find difference between geometries.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry1": {
              "type": "string",
              "title": "Geometry1"
            },
            "geometry2": {
              "type": "string",
              "title": "Geometry2"
            }
          },
          "required": [
            "geometry1",
            "geometry2"
          ]
        }
      },
      {
        "name": "symmetric_difference",
        "description": "Find symmetric difference between geometries.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry1": {
              "type": "string",
              "title": "Geometry1"
            },
            "geometry2": {
              "type": "string",
              "title": "Geometry2"
            }
          },
          "required": [
            "geometry1",
            "geometry2"
          ]
        }
      },
      {
        "name": "convex_hull",
        "description": "Calculate convex hull of a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "envelope",
        "description": "Get bounding box of a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "minimum_rotated_rectangle",
        "description": "Get minimum rotated rectangle of a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "rotate_geometry",
        "description": "Rotate a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "angle": {
              "type": "number",
              "title": "Angle"
            },
            "origin": {
              "type": "string",
              "title": "Origin",
              "default": "center"
            },
            "geometry": {
              "type": "string",
              "title": "Geometry"
            },
            "use_radians": {
              "type": "boolean",
              "title": "Use Radians",
              "default": false
            }
          },
          "required": [
            "geometry",
            "angle"
          ]
        }
      },
      {
        "name": "scale_geometry",
        "description": "Scale a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "xfact": {
              "type": "number",
              "title": "Xfact"
            },
            "yfact": {
              "type": "number",
              "title": "Yfact"
            },
            "origin": {
              "type": "string",
              "title": "Origin",
              "default": "center"
            },
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry",
            "xfact",
            "yfact"
          ]
        }
      },
      {
        "name": "translate_geometry",
        "description": "Translate a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "xoff": {
              "type": "number",
              "title": "Xoff"
            },
            "yoff": {
              "type": "number",
              "title": "Yoff"
            },
            "zoff": {
              "type": "number",
              "title": "Zoff",
              "default": 0
            },
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry",
            "xoff",
            "yoff"
          ]
        }
      },
      {
        "name": "triangulate_geometry",
        "description": "Create a triangulation of a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "voronoi",
        "description": "Create a Voronoi diagram from points.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "unary_union_geometries",
        "description": "Create a union of multiple geometries.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometries": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "Geometries"
            }
          },
          "required": [
            "geometries"
          ]
        }
      },
      {
        "name": "get_centroid",
        "description": "Get the centroid of a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "get_length",
        "description": "Get the length of a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "get_area",
        "description": "Get the area of a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "get_bounds",
        "description": "Get the bounds of a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "get_coordinates",
        "description": "Get the coordinates of a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "get_geometry_type",
        "description": "Get the type of a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "is_valid",
        "description": "Check if a geometry is valid.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "make_valid",
        "description": "Make a geometry valid.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "simplify",
        "description": "Simplify a geometry.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            },
            "tolerance": {
              "type": "number",
              "title": "Tolerance"
            },
            "preserve_topology": {
              "type": "boolean",
              "title": "Preserve Topology",
              "default": true
            }
          },
          "required": [
            "geometry",
            "tolerance"
          ]
        }
      },
      {
        "name": "transform_coordinates",
        "description": "Transform coordinates between CRS.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "source_crs": {
              "type": "string",
              "title": "Source Crs"
            },
            "target_crs": {
              "type": "string",
              "title": "Target Crs"
            },
            "coordinates": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "title": "Coordinates"
            }
          },
          "required": [
            "coordinates",
            "source_crs",
            "target_crs"
          ]
        }
      },
      {
        "name": "project_geometry",
        "description": "Project a geometry between CRS.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "geometry": {
              "type": "string",
              "title": "Geometry"
            },
            "source_crs": {
              "type": "string",
              "title": "Source Crs"
            },
            "target_crs": {
              "type": "string",
              "title": "Target Crs"
            }
          },
          "required": [
            "geometry",
            "source_crs",
            "target_crs"
          ]
        }
      },
      {
        "name": "get_crs_info",
        "description": "Get information about a CRS.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "crs": {
              "type": "string",
              "title": "Crs"
            }
          },
          "required": [
            "crs"
          ]
        }
      },
      {
        "name": "get_available_crs",
        "description": "Get list of available CRS.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_geod_info",
        "description": "Get information about a geodetic calculation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "a": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "title": "A",
              "default": null
            },
            "b": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "title": "B",
              "default": null
            },
            "f": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ],
              "title": "F",
              "default": null
            },
            "ellps": {
              "type": "string",
              "title": "Ellps",
              "default": "WGS84"
            }
          }
        }
      },
      {
        "name": "calculate_geodetic_distance",
        "description": "Calculate geodetic distance between points.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ellps": {
              "type": "string",
              "title": "Ellps",
              "default": "WGS84"
            },
            "point1": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "title": "Point1"
            },
            "point2": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "title": "Point2"
            }
          },
          "required": [
            "point1",
            "point2"
          ]
        }
      },
      {
        "name": "calculate_geodetic_point",
        "description": "Calculate point at given distance and azimuth.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ellps": {
              "type": "string",
              "title": "Ellps",
              "default": "WGS84"
            },
            "azimuth": {
              "type": "number",
              "title": "Azimuth"
            },
            "distance": {
              "type": "number",
              "title": "Distance"
            },
            "start_point": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "title": "Start Point"
            }
          },
          "required": [
            "start_point",
            "azimuth",
            "distance"
          ]
        }
      },
      {
        "name": "calculate_geodetic_area",
        "description": "Calculate area of a polygon using geodetic calculations.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ellps": {
              "type": "string",
              "title": "Ellps",
              "default": "WGS84"
            },
            "geometry": {
              "type": "string",
              "title": "Geometry"
            }
          },
          "required": [
            "geometry"
          ]
        }
      },
      {
        "name": "get_utm_zone",
        "description": "Get UTM zone for given coordinates.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "coordinates": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "title": "Coordinates"
            }
          },
          "required": [
            "coordinates"
          ]
        }
      },
      {
        "name": "get_utm_crs",
        "description": "Get UTM CRS for given coordinates.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "coordinates": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "title": "Coordinates"
            }
          },
          "required": [
            "coordinates"
          ]
        }
      },
      {
        "name": "get_geocentric_crs",
        "description": "Get geocentric CRS for given coordinates.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "coordinates": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "title": "Coordinates"
            }
          },
          "required": [
            "coordinates"
          ]
        }
      }
    ]
  },
  {
    "name": "makeplane-plane-mcp-server",
    "title": "Plane MCP Server",
    "description": "A Model Context Protocol server that enables AI interfaces to seamlessly interact with Plane's project management system, allowing management of projects, issues, states, and other work items through a standardized API.",
    "icon": "https://avatars.githubusercontent.com/makeplane",
    "isOfficial": true,
    "homepage": "https://github.com/makeplane/plane-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@makeplane/plane-mcp-server"
      ],
      "env": {
        "PLANE_API_KEY": "<plane-api-key>",
        "PLANE_API_HOST_URL": "<plane-api-host-url>",
        "PLANE_WORKSPACE_SLUG": "<plane-workspace-slug>"
      }
    },
    "parameters": [
      {
        "name": "PLANE_API_KEY",
        "description": "The user's API token. This can be obtained from the /settings/api-tokens/ page in the UI.",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "PLANE_API_HOST_URL",
        "description": "The host URL of the Plane API Server. Defaults to https://api.plane.so/",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "PLANE_WORKSPACE_SLUG",
        "description": "The workspace slug for your Plane instance.",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "list_issue_types",
        "description": "Get all issue types for a specific project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to get issue types for"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "get_issue_type",
        "description": "Get details of a specific issue type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type_id": {
              "type": "string",
              "description": "The uuid identifier of the issue type to get"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the issue type"
            }
          },
          "required": [
            "project_id",
            "type_id"
          ]
        }
      },
      {
        "name": "create_issue_type",
        "description": "Create a new issue type in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to create the issue type in"
            },
            "issue_type_data": {
              "type": "object",
              "required": [
                "description",
                "name"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "level": {
                  "type": "integer"
                },
                "is_active": {
                  "type": "boolean"
                },
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "is_default": {
                  "type": "boolean"
                },
                "logo_props": {},
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": {
                  "type": "string"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "project_ids": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "project_id",
            "issue_type_data"
          ]
        }
      },
      {
        "name": "update_issue_type",
        "description": "Update an existing issue type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type_id": {
              "type": "string",
              "description": "The uuid identifier of the issue type to update"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the issue type"
            },
            "issue_type_data": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "level": {
                  "type": "integer"
                },
                "is_active": {
                  "type": "boolean"
                },
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "is_default": {
                  "type": "boolean"
                },
                "logo_props": {},
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": {
                  "type": "string"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "project_ids": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                }
              },
              "description": "The fields to update on the issue type",
              "additionalProperties": false
            }
          },
          "required": [
            "project_id",
            "type_id",
            "issue_type_data"
          ]
        }
      },
      {
        "name": "delete_issue_type",
        "description": "Delete an issue type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type_id": {
              "type": "string",
              "description": "The uuid identifier of the issue type to delete"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the issue type"
            }
          },
          "required": [
            "project_id",
            "type_id"
          ]
        }
      },
      {
        "name": "list_states",
        "description": "Get all states for a specific project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to get states for"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "get_state",
        "description": "Get details of a specific state",
        "inputSchema": {
          "type": "object",
          "properties": {
            "state_id": {
              "type": "string",
              "description": "The uuid identifier of the state to get"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the state"
            }
          },
          "required": [
            "project_id",
            "state_id"
          ]
        }
      },
      {
        "name": "create_state",
        "description": "Create a new state in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to create the state in"
            },
            "state_data": {
              "type": "object",
              "required": [
                "color",
                "name"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "slug": {
                  "type": "string",
                  "pattern": "^[-a-zA-Z0-9_]+$",
                  "maxLength": 100
                },
                "color": {
                  "type": "string",
                  "maxLength": 255
                },
                "group": {},
                "default": {
                  "type": "boolean"
                },
                "project": {
                  "type": "string",
                  "format": "uuid"
                },
                "sequence": {
                  "type": "number"
                },
                "is_triage": {
                  "type": "boolean"
                },
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": {
                  "type": "string"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "project_id",
            "state_data"
          ]
        }
      },
      {
        "name": "update_state",
        "description": "Update an existing state",
        "inputSchema": {
          "type": "object",
          "properties": {
            "state_id": {
              "type": "string",
              "description": "The uuid identifier of the state to update"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the state"
            },
            "state_data": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "slug": {
                  "type": "string",
                  "pattern": "^[-a-zA-Z0-9_]+$",
                  "maxLength": 100
                },
                "color": {
                  "type": "string",
                  "maxLength": 255
                },
                "group": {},
                "default": {
                  "type": "boolean"
                },
                "project": {
                  "type": "string",
                  "format": "uuid"
                },
                "sequence": {
                  "type": "number"
                },
                "is_triage": {
                  "type": "boolean"
                },
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": {
                  "type": "string"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                }
              },
              "description": "The fields to update on the state",
              "additionalProperties": false
            }
          },
          "required": [
            "project_id",
            "state_id",
            "state_data"
          ]
        }
      },
      {
        "name": "delete_state",
        "description": "Delete a state",
        "inputSchema": {
          "type": "object",
          "properties": {
            "state_id": {
              "type": "string",
              "description": "The uuid identifier of the state to delete"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the state"
            }
          },
          "required": [
            "project_id",
            "state_id"
          ]
        }
      },
      {
        "name": "list_labels",
        "description": "Get all labels for a specific project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to get labels for"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "get_label",
        "description": "Get details of a specific label",
        "inputSchema": {
          "type": "object",
          "properties": {
            "label_id": {
              "type": "string",
              "description": "The uuid identifier of the label to get"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the label"
            }
          },
          "required": [
            "project_id",
            "label_id"
          ]
        }
      },
      {
        "name": "create_label",
        "description": "Create a new label in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "label_data": {
              "type": "object",
              "required": [
                "color",
                "name"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "color": {
                  "type": "string",
                  "maxLength": 255
                },
                "parent": {
                  "type": "string",
                  "format": "uuid"
                },
                "project": {
                  "type": "string",
                  "format": "uuid"
                },
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "sort_order": {
                  "type": "number"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": {
                  "type": "string"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                }
              },
              "additionalProperties": false
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to create the label in"
            }
          },
          "required": [
            "project_id",
            "label_data"
          ]
        }
      },
      {
        "name": "update_label",
        "description": "Update an existing label",
        "inputSchema": {
          "type": "object",
          "properties": {
            "label_id": {
              "type": "string",
              "description": "The uuid identifier of the label to update"
            },
            "label_data": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "color": {
                  "type": "string",
                  "maxLength": 255
                },
                "parent": {
                  "type": "string",
                  "format": "uuid"
                },
                "project": {
                  "type": "string",
                  "format": "uuid"
                },
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "sort_order": {
                  "type": "number"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": {
                  "type": "string"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                }
              },
              "description": "The fields to update on the label",
              "additionalProperties": false
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the label"
            }
          },
          "required": [
            "project_id",
            "label_id",
            "label_data"
          ]
        }
      },
      {
        "name": "delete_label",
        "description": "Delete a label",
        "inputSchema": {
          "type": "object",
          "properties": {
            "label_id": {
              "type": "string",
              "description": "The uuid identifier of the label to delete"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the label"
            }
          },
          "required": [
            "project_id",
            "label_id"
          ]
        }
      },
      {
        "name": "get_user",
        "description": "Get the current user's information",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_workspace_members",
        "description": "Get all members in the current workspace",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_projects",
        "description": "Get all projects for the current user",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_project",
        "description": "Create a new project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The name of the project"
            },
            "identifier": {
              "type": "string",
              "maxLength": 7,
              "description": "The identifier of the project. This is typically a word of around 5 characters derived from the name of the project in uppercase."
            }
          },
          "required": [
            "name",
            "identifier"
          ]
        }
      },
      {
        "name": "list_modules",
        "description": "Get all modules for a specific project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to get modules for"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "get_module",
        "description": "Get details of a specific module",
        "inputSchema": {
          "type": "object",
          "properties": {
            "module_id": {
              "type": "string",
              "description": "The uuid identifier of the module to get"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the module"
            }
          },
          "required": [
            "project_id",
            "module_id"
          ]
        }
      },
      {
        "name": "create_module",
        "description": "Create a new module in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to create the module in"
            },
            "module_data": {
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "lead": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "status": {},
                "members": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                },
                "project": {
                  "type": "string",
                  "format": "uuid"
                },
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "logo_props": {},
                "sort_order": {
                  "type": "number"
                },
                "start_date": {
                  "type": "string",
                  "format": "date"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "view_props": {},
                "archived_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "description": {
                  "type": "string"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "target_date": {
                  "type": "string",
                  "format": "date"
                },
                "total_issues": {
                  "type": "integer"
                },
                "backlog_issues": {
                  "type": "integer"
                },
                "started_issues": {
                  "type": "integer"
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                },
                "cancelled_issues": {
                  "type": "integer"
                },
                "completed_issues": {
                  "type": "integer"
                },
                "description_html": {},
                "description_text": {},
                "unstarted_issues": {
                  "type": "integer"
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "project_id",
            "module_data"
          ]
        }
      },
      {
        "name": "update_module",
        "description": "Update an existing module",
        "inputSchema": {
          "type": "object",
          "properties": {
            "module_id": {
              "type": "string",
              "description": "The uuid identifier of the module to update"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the module"
            },
            "module_data": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "lead": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "status": {},
                "members": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                },
                "project": {
                  "type": "string",
                  "format": "uuid"
                },
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "logo_props": {},
                "sort_order": {
                  "type": "number"
                },
                "start_date": {
                  "type": "string",
                  "format": "date"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "view_props": {},
                "archived_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "description": {
                  "type": "string"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "target_date": {
                  "type": "string",
                  "format": "date"
                },
                "total_issues": {
                  "type": "integer"
                },
                "backlog_issues": {
                  "type": "integer"
                },
                "started_issues": {
                  "type": "integer"
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                },
                "cancelled_issues": {
                  "type": "integer"
                },
                "completed_issues": {
                  "type": "integer"
                },
                "description_html": {},
                "description_text": {},
                "unstarted_issues": {
                  "type": "integer"
                }
              },
              "description": "The fields to update on the module",
              "additionalProperties": false
            }
          },
          "required": [
            "project_id",
            "module_id",
            "module_data"
          ]
        }
      },
      {
        "name": "delete_module",
        "description": "Delete a module",
        "inputSchema": {
          "type": "object",
          "properties": {
            "module_id": {
              "type": "string",
              "description": "The uuid identifier of the module to delete"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the module"
            }
          },
          "required": [
            "project_id",
            "module_id"
          ]
        }
      },
      {
        "name": "list_module_issues",
        "description": "Get all issues for a specific module",
        "inputSchema": {
          "type": "object",
          "properties": {
            "module_id": {
              "type": "string",
              "description": "The uuid identifier of the module to get issues for"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the module"
            }
          },
          "required": [
            "project_id",
            "module_id"
          ]
        }
      },
      {
        "name": "add_module_issues",
        "description": "Add issues to a module. Assign module to issues.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issues": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of issue UUIDs to add to the module"
            },
            "module_id": {
              "type": "string",
              "description": "The uuid identifier of the module to add issues to"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the module"
            }
          },
          "required": [
            "project_id",
            "module_id",
            "issues"
          ]
        }
      },
      {
        "name": "delete_module_issue",
        "description": "Remove an issue from a module. Unassign module from issue.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_id": {
              "type": "string",
              "description": "The uuid identifier of the issue to remove from the module"
            },
            "module_id": {
              "type": "string",
              "description": "The uuid identifier of the module containing the issue"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the module"
            }
          },
          "required": [
            "project_id",
            "module_id",
            "issue_id"
          ]
        }
      },
      {
        "name": "get_issue_using_readable_identifier",
        "description": "Get all issues for a specific project. When issue identifier is provided something like FIRST-123, ABC-123, etc. For FIRST-123, project_identifier is FIRST and issue_identifier is 123",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_identifier": {
              "type": "string",
              "description": "The identifier of the issue to get"
            },
            "project_identifier": {
              "type": "string",
              "description": "The readable identifier of the project to get issues for"
            }
          },
          "required": [
            "project_identifier",
            "issue_identifier"
          ]
        }
      },
      {
        "name": "get_issue_comments",
        "description": "Get all comments for a specific issue. This requests project_id and issue_id as uuid parameters. If you have a readable identifier, you can use the get_issue_using_readable_identifier tool to get the issue_id and project_id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_id": {
              "type": "string",
              "description": "The uuid identifier of the issue to get"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to get issues for"
            }
          },
          "required": [
            "project_id",
            "issue_id"
          ]
        }
      },
      {
        "name": "add_issue_comment",
        "description": "Add a comment to a specific issue. This requests project_id and issue_id as uuid parameters. If you have a readable identifier, you can use the get_issue_using_readable_identifier tool to get the issue_id and project_id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_id": {
              "type": "string",
              "description": "The uuid identifier of the issue to get"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to get issues for"
            },
            "comment_html": {
              "type": "string",
              "description": "The html content of the comment to add"
            }
          },
          "required": [
            "project_id",
            "issue_id",
            "comment_html"
          ]
        }
      },
      {
        "name": "create_issue",
        "description": "Create an issue. This requests project_id as uuid parameter. If you have a readable identifier for project, you can use the get_projects tool to get the project_id from it",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_data": {
              "type": "object",
              "required": [
                "description_html",
                "name"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "type": {
                  "type": "string",
                  "format": "uuid"
                },
                "point": {
                  "type": "integer",
                  "maximum": 12,
                  "minimum": 0
                },
                "state": {
                  "type": "string",
                  "format": "uuid"
                },
                "labels": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                },
                "parent": {
                  "type": "string",
                  "format": "uuid"
                },
                "project": {
                  "type": "string",
                  "format": "uuid"
                },
                "type_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "is_draft": {
                  "type": "boolean"
                },
                "priority": {},
                "assignees": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                },
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "sort_order": {
                  "type": "number"
                },
                "start_date": {
                  "type": "string",
                  "format": "date"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "archived_at": {
                  "type": "string",
                  "format": "date"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "sequence_id": {
                  "type": "integer",
                  "maximum": 2147483647,
                  "minimum": -2147483648
                },
                "target_date": {
                  "type": "string",
                  "format": "date"
                },
                "completed_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "estimate_point": {
                  "type": "string",
                  "format": "uuid"
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                },
                "description_html": {
                  "type": "string"
                },
                "description_binary": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to create the issue for"
            }
          },
          "required": [
            "project_id",
            "issue_data"
          ]
        }
      },
      {
        "name": "update_issue",
        "description": "Update an issue. This requests project_id and issue_id as uuid parameters. If you have a readable identifier, you can use the get_issue_using_readable_identifier tool to get the issue_id and project_id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_id": {
              "type": "string",
              "description": "The uuid identifier of the issue to update"
            },
            "issue_data": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "type": {
                  "type": "string",
                  "format": "uuid"
                },
                "point": {
                  "type": "integer",
                  "maximum": 12,
                  "minimum": 0
                },
                "state": {
                  "type": "string",
                  "format": "uuid"
                },
                "labels": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                },
                "parent": {
                  "type": "string",
                  "format": "uuid"
                },
                "project": {
                  "type": "string",
                  "format": "uuid"
                },
                "type_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "is_draft": {
                  "type": "boolean"
                },
                "priority": {},
                "assignees": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                },
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "sort_order": {
                  "type": "number"
                },
                "start_date": {
                  "type": "string",
                  "format": "date"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "archived_at": {
                  "type": "string",
                  "format": "date"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "sequence_id": {
                  "type": "integer",
                  "maximum": 2147483647,
                  "minimum": -2147483648
                },
                "target_date": {
                  "type": "string",
                  "format": "date"
                },
                "completed_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "estimate_point": {
                  "type": "string",
                  "format": "uuid"
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                },
                "description_html": {
                  "type": "string"
                },
                "description_binary": {
                  "type": "string"
                }
              },
              "description": "The fields to update on the issue",
              "additionalProperties": false
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the issue"
            }
          },
          "required": [
            "project_id",
            "issue_id",
            "issue_data"
          ]
        }
      },
      {
        "name": "list_cycles",
        "description": "Get all cycles for a specific project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to get cycles for"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "get_cycle",
        "description": "Get details of a specific cycle",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cycle_id": {
              "type": "string",
              "description": "The uuid identifier of the cycle to get"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the cycle"
            }
          },
          "required": [
            "project_id",
            "cycle_id"
          ]
        }
      },
      {
        "name": "create_cycle",
        "description": "Create a new cycle in a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cycle_data": {
              "type": "object",
              "required": [
                "name",
                "project_id"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "version": {
                  "type": "integer",
                  "maximum": 2147483647,
                  "minimum": -2147483648
                },
                "end_date": {
                  "type": "string",
                  "format": "date",
                  "description": "The end date of the cycle of format YYYY-MM-DD"
                },
                "owned_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "timezone": {},
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "logo_props": {},
                "project_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "sort_order": {
                  "type": "number"
                },
                "start_date": {
                  "type": "string",
                  "format": "date",
                  "description": "The start date of the cycle of format YYYY-MM-DD"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "view_props": {},
                "archived_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "description": {
                  "type": "string"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "total_issues": {
                  "type": "integer"
                },
                "backlog_issues": {
                  "type": "integer"
                },
                "started_issues": {
                  "type": "integer"
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                },
                "total_estimates": {
                  "type": "number"
                },
                "cancelled_issues": {
                  "type": "integer"
                },
                "completed_issues": {
                  "type": "integer"
                },
                "unstarted_issues": {
                  "type": "integer"
                },
                "progress_snapshot": {},
                "started_estimates": {
                  "type": "number"
                },
                "completed_estimates": {
                  "type": "number"
                }
              },
              "description": "The data for creating the cycle",
              "additionalProperties": false
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to create the cycle in"
            }
          },
          "required": [
            "project_id",
            "cycle_data"
          ]
        }
      },
      {
        "name": "update_cycle",
        "description": "Update an existing cycle",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cycle_id": {
              "type": "string",
              "description": "The uuid identifier of the cycle to update"
            },
            "cycle_data": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "format": "uuid"
                },
                "name": {
                  "type": "string",
                  "maxLength": 255
                },
                "version": {
                  "type": "integer",
                  "maximum": 2147483647,
                  "minimum": -2147483648
                },
                "end_date": {
                  "type": "string",
                  "format": "date",
                  "description": "The end date of the cycle of format YYYY-MM-DD"
                },
                "owned_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "timezone": {},
                "workspace": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "created_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "deleted_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "logo_props": {},
                "project_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "sort_order": {
                  "type": "number"
                },
                "start_date": {
                  "type": "string",
                  "format": "date",
                  "description": "The start date of the cycle of format YYYY-MM-DD"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "updated_by": {
                  "type": "string",
                  "format": "uuid"
                },
                "view_props": {},
                "archived_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "description": {
                  "type": "string"
                },
                "external_id": {
                  "type": "string",
                  "maxLength": 255
                },
                "total_issues": {
                  "type": "integer"
                },
                "backlog_issues": {
                  "type": "integer"
                },
                "started_issues": {
                  "type": "integer"
                },
                "external_source": {
                  "type": "string",
                  "maxLength": 255
                },
                "total_estimates": {
                  "type": "number"
                },
                "cancelled_issues": {
                  "type": "integer"
                },
                "completed_issues": {
                  "type": "integer"
                },
                "unstarted_issues": {
                  "type": "integer"
                },
                "progress_snapshot": {},
                "started_estimates": {
                  "type": "number"
                },
                "completed_estimates": {
                  "type": "number"
                }
              },
              "description": "The fields to update on the cycle",
              "additionalProperties": false
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the cycle"
            }
          },
          "required": [
            "project_id",
            "cycle_id",
            "cycle_data"
          ]
        }
      },
      {
        "name": "delete_cycle",
        "description": "Delete a cycle",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cycle_id": {
              "type": "string",
              "description": "The uuid identifier of the cycle to delete"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the cycle"
            }
          },
          "required": [
            "project_id",
            "cycle_id"
          ]
        }
      },
      {
        "name": "transfer_cycle_issues",
        "description": "Transfer issues from one cycle to another",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cycle_id": {
              "type": "string",
              "description": "The uuid identifier of the source cycle"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the cycle"
            },
            "new_cycle_id": {
              "type": "string",
              "description": "The uuid identifier of the target cycle"
            }
          },
          "required": [
            "project_id",
            "cycle_id",
            "new_cycle_id"
          ]
        }
      },
      {
        "name": "list_cycle_issues",
        "description": "Get all issues for a specific cycle",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cycle_id": {
              "type": "string",
              "description": "The uuid identifier of the cycle to get issues for"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the cycle"
            }
          },
          "required": [
            "project_id",
            "cycle_id"
          ]
        }
      },
      {
        "name": "add_cycle_issues",
        "description": "Add issues to a cycle",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issues": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of issue UUIDs to add to the cycle"
            },
            "cycle_id": {
              "type": "string",
              "description": "The uuid identifier of the cycle to add issues to"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the cycle"
            }
          },
          "required": [
            "project_id",
            "cycle_id",
            "issues"
          ]
        }
      },
      {
        "name": "delete_cycle_issue",
        "description": "Remove an issue from a cycle",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cycle_id": {
              "type": "string",
              "description": "The uuid identifier of the cycle containing the issue"
            },
            "issue_id": {
              "type": "string",
              "description": "The uuid identifier of the issue to remove from the cycle"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the cycle"
            }
          },
          "required": [
            "project_id",
            "cycle_id",
            "issue_id"
          ]
        }
      },
      {
        "name": "get_issue_worklogs",
        "description": "Get all worklogs for a specific issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_id": {
              "type": "string",
              "description": "The uuid identifier of the issue to get worklogs for"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the issue"
            }
          },
          "required": [
            "project_id",
            "issue_id"
          ]
        }
      },
      {
        "name": "get_total_worklogs",
        "description": "Get total logged time for a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project to get total worklogs for"
            }
          },
          "required": [
            "project_id"
          ]
        }
      },
      {
        "name": "create_worklog",
        "description": "Create a new worklog for an issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_id": {
              "type": "string",
              "description": "The uuid identifier of the issue to create worklog for"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the issue"
            },
            "worklog_data": {
              "type": "object",
              "required": [
                "description",
                "duration"
              ],
              "properties": {
                "duration": {
                  "type": "integer",
                  "minimum": 0,
                  "description": "The duration of the worklog in minutes"
                },
                "issue_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "project_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "description": {
                  "type": "string"
                },
                "logged_by_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "workspace_id": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "description": "The data for creating the worklog",
              "additionalProperties": false
            }
          },
          "required": [
            "project_id",
            "issue_id",
            "worklog_data"
          ]
        }
      },
      {
        "name": "update_worklog",
        "description": "Update an existing worklog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_id": {
              "type": "string",
              "description": "The uuid identifier of the issue containing the worklog"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the issue"
            },
            "worklog_id": {
              "type": "string",
              "description": "The uuid identifier of the worklog to update"
            },
            "worklog_data": {
              "type": "object",
              "properties": {
                "duration": {
                  "type": "integer",
                  "minimum": 0,
                  "description": "The duration of the worklog in minutes"
                },
                "issue_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "project_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time"
                },
                "description": {
                  "type": "string"
                },
                "logged_by_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "workspace_id": {
                  "type": "string",
                  "format": "uuid"
                }
              },
              "description": "The fields to update on the worklog",
              "additionalProperties": false
            }
          },
          "required": [
            "project_id",
            "issue_id",
            "worklog_id",
            "worklog_data"
          ]
        }
      },
      {
        "name": "delete_worklog",
        "description": "Delete a worklog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_id": {
              "type": "string",
              "description": "The uuid identifier of the issue containing the worklog"
            },
            "project_id": {
              "type": "string",
              "description": "The uuid identifier of the project containing the issue"
            },
            "worklog_id": {
              "type": "string",
              "description": "The uuid identifier of the worklog to delete"
            }
          },
          "required": [
            "project_id",
            "issue_id",
            "worklog_id"
          ]
        }
      }
    ]
  },
  {
    "name": "mamertofabian-mcp-everything-search",
    "title": "mcp-everything-search",
    "description": "This server provides:\n\n* Fast file search capabilities using Everything SDK\n* Windows-specific implementation\n* Complements existing filesystem servers with specialized search functionality",
    "icon": "https://avatars.githubusercontent.com/mamertofabian",
    "isOfficial": false,
    "homepage": "https://github.com/mamertofabian/mcp-everything-search",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-everything-search"
      ],
      "env": {
        "EVERYTHING_SDK_PATH": "<everything-sdk-path>"
      }
    },
    "parameters": [
      {
        "name": "EVERYTHING_SDK_PATH",
        "description": "Path to the Everything SDK DLL (Everything64.dll).",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "marcoeg-mcp-server-ntopng",
    "title": "mcp-ntopng",
    "description": "MCP Server for networl monitoring software ntopng.",
    "icon": "https://avatars.githubusercontent.com/marcoeg",
    "isOfficial": false,
    "homepage": "https://github.com/marcoeg/mcp-server-ntopng",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-ntopng"
      ],
      "env": {
        "NTOPNG_HOST": "<ntopng-host>",
        "NTOPNG_DBPORT": "<ntopng-dbport>",
        "NTOPNG_DBUSER": "<ntopng-dbuser>",
        "NTOPNG_SECURE": "<ntopng-secure>",
        "NTOPNG_VERIFY": "<ntopng-verify>",
        "NTOPNG_API_KEY": "<ntopng-api-key>",
        "NTOPNG_DBPASSWORD": "<ntopng-dbpassword>",
        "NTOPNG_CONNECT_TIMEOUT": "<ntopng-connect-timeout>",
        "SELECT_QUERY_TIMEOUT_SECS": "<select-query-timeout-secs>",
        "NTOPNG_SEND_RECEIVE_TIMEOUT": "<ntopng-send-receive-timeout>"
      }
    },
    "parameters": [
      {
        "name": "NTOPNG_HOST",
        "description": "The hostname of the ntopng server",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "NTOPNG_DBPORT",
        "description": "The port number of the Clickhouse DB in the ntopng server (Default: 9000 if HTTPS is enabled, 8123 if disabled)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NTOPNG_DBUSER",
        "description": "The username for Clickhouse DB authentication",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "NTOPNG_SECURE",
        "description": "Enable/disable a TLS connection",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NTOPNG_VERIFY",
        "description": "Enable/disable SSL certificate verification",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NTOPNG_API_KEY",
        "description": "NTOPNG API key token",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NTOPNG_DBPASSWORD",
        "description": "The password for Clickhouse DB authentication",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "NTOPNG_CONNECT_TIMEOUT",
        "description": "Connection timeout in seconds",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "SELECT_QUERY_TIMEOUT_SECS",
        "description": "Timeout for select queries in seconds",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NTOPNG_SEND_RECEIVE_TIMEOUT",
        "description": "Send/receive timeout in seconds",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "list_tables_ntopng_database",
        "description": "List tables structure of the ntopng database",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "query_ntopng_database",
        "description": "Query the ntopng Clickhouse database.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "fetch_ntopng_all_ifids",
        "description": "Retrieve all available interface IDs from ntopng.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_ntopng_hosts_location",
        "description": "Fetch geographical location and additional info for hosts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            }
          },
          "required": [
            "ifid"
          ]
        }
      },
      {
        "name": "fetch_ntopng_top_local_talkers",
        "description": "Retrieve the top 10 local talkers for a specified interface.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            }
          },
          "required": [
            "ifid"
          ]
        }
      },
      {
        "name": "fetch_ntopng_top_remote_talkers",
        "description": "Retrieve the top 10 remote talkers for a specified interface.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            }
          },
          "required": [
            "ifid"
          ]
        }
      },
      {
        "name": "get_ntopng_all_alert_stats",
        "description": "Retrieve statistics for all alerts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "epoch_end": {
              "type": "integer",
              "title": "Epoch End"
            },
            "epoch_begin": {
              "type": "integer",
              "title": "Epoch Begin"
            }
          },
          "required": [
            "ifid",
            "epoch_begin",
            "epoch_end"
          ]
        }
      },
      {
        "name": "get_ntopng_flow_alert_stats",
        "description": "Retrieve statistics for flow alerts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ip": {
              "type": "string",
              "title": "Ip"
            },
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "score": {
              "type": "string",
              "title": "Score"
            },
            "cli_ip": {
              "type": "string",
              "title": "Cli Ip"
            },
            "format": {
              "type": "string",
              "title": "Format"
            },
            "srv_ip": {
              "type": "string",
              "title": "Srv Ip"
            },
            "l7proto": {
              "type": "string",
              "title": "L7Proto"
            },
            "vlan_id": {
              "type": "string",
              "title": "Vlan Id"
            },
            "alert_id": {
              "type": "string",
              "title": "Alert Id"
            },
            "cli_name": {
              "type": "string",
              "title": "Cli Name"
            },
            "cli_port": {
              "type": "string",
              "title": "Cli Port"
            },
            "probe_ip": {
              "type": "string",
              "title": "Probe Ip"
            },
            "severity": {
              "type": "string",
              "title": "Severity"
            },
            "srv_name": {
              "type": "string",
              "title": "Srv Name"
            },
            "srv_port": {
              "type": "string",
              "title": "Srv Port"
            },
            "epoch_end": {
              "type": "integer",
              "title": "Epoch End"
            },
            "input_snmp": {
              "type": "string",
              "title": "Input Snmp"
            },
            "ip_version": {
              "type": "string",
              "title": "Ip Version"
            },
            "cli_country": {
              "type": "string",
              "title": "Cli Country"
            },
            "cli_network": {
              "type": "string",
              "title": "Cli Network"
            },
            "epoch_begin": {
              "type": "integer",
              "title": "Epoch Begin"
            },
            "l7_error_id": {
              "type": "string",
              "title": "L7 Error Id"
            },
            "output_snmp": {
              "type": "string",
              "title": "Output Snmp"
            },
            "srv_country": {
              "type": "string",
              "title": "Srv Country"
            },
            "srv_network": {
              "type": "string",
              "title": "Srv Network"
            },
            "snmp_interface": {
              "type": "string",
              "title": "Snmp Interface"
            },
            "cli_host_pool_id": {
              "type": "string",
              "title": "Cli Host Pool Id"
            },
            "srv_host_pool_id": {
              "type": "string",
              "title": "Srv Host Pool Id"
            },
            "traffic_direction": {
              "type": "string",
              "title": "Traffic Direction"
            }
          },
          "required": [
            "ifid",
            "epoch_begin",
            "epoch_end",
            "alert_id",
            "severity",
            "score",
            "ip_version",
            "ip",
            "cli_ip",
            "srv_ip",
            "cli_name",
            "srv_name",
            "cli_port",
            "srv_port",
            "vlan_id",
            "l7proto",
            "cli_country",
            "srv_country",
            "probe_ip",
            "input_snmp",
            "output_snmp",
            "snmp_interface",
            "cli_host_pool_id",
            "srv_host_pool_id",
            "cli_network",
            "srv_network",
            "l7_error_id",
            "traffic_direction",
            "format"
          ]
        }
      },
      {
        "name": "get_ntopng_host_alert_stats",
        "description": "Retrieve statistics for host alerts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ip": {
              "type": "string",
              "title": "Ip"
            },
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "name": {
              "type": "string",
              "title": "Name"
            },
            "score": {
              "type": "string",
              "title": "Score"
            },
            "network": {
              "type": "string",
              "title": "Network"
            },
            "vlan_id": {
              "type": "string",
              "title": "Vlan Id"
            },
            "alert_id": {
              "type": "string",
              "title": "Alert Id"
            },
            "severity": {
              "type": "string",
              "title": "Severity"
            },
            "epoch_end": {
              "type": "integer",
              "title": "Epoch End"
            },
            "ip_version": {
              "type": "string",
              "title": "Ip Version"
            },
            "epoch_begin": {
              "type": "integer",
              "title": "Epoch Begin"
            },
            "host_pool_id": {
              "type": "string",
              "title": "Host Pool Id"
            }
          },
          "required": [
            "ifid",
            "epoch_begin",
            "epoch_end",
            "alert_id",
            "severity",
            "score",
            "vlan_id",
            "ip_version",
            "ip",
            "name",
            "host_pool_id",
            "network"
          ]
        }
      },
      {
        "name": "get_ntopng_interface_alert_stats",
        "description": "Retrieve statistics for interface alerts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "score": {
              "type": "string",
              "title": "Score"
            },
            "subtype": {
              "type": "string",
              "title": "Subtype"
            },
            "alert_id": {
              "type": "string",
              "title": "Alert Id"
            },
            "severity": {
              "type": "string",
              "title": "Severity"
            },
            "epoch_end": {
              "type": "integer",
              "title": "Epoch End"
            },
            "epoch_begin": {
              "type": "integer",
              "title": "Epoch Begin"
            }
          },
          "required": [
            "ifid",
            "epoch_begin",
            "epoch_end",
            "alert_id",
            "severity",
            "score",
            "subtype"
          ]
        }
      },
      {
        "name": "get_ntopng_mac_alert_stats",
        "description": "Retrieve statistics for MAC alerts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "score": {
              "type": "string",
              "title": "Score"
            },
            "alert_id": {
              "type": "string",
              "title": "Alert Id"
            },
            "severity": {
              "type": "string",
              "title": "Severity"
            },
            "epoch_end": {
              "type": "integer",
              "title": "Epoch End"
            },
            "epoch_begin": {
              "type": "integer",
              "title": "Epoch Begin"
            }
          },
          "required": [
            "ifid",
            "epoch_begin",
            "epoch_end",
            "alert_id",
            "severity",
            "score"
          ]
        }
      },
      {
        "name": "get_ntopng_network_alert_stats",
        "description": "Retrieve statistics for network alerts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "score": {
              "type": "string",
              "title": "Score"
            },
            "alert_id": {
              "type": "string",
              "title": "Alert Id"
            },
            "severity": {
              "type": "string",
              "title": "Severity"
            },
            "epoch_end": {
              "type": "integer",
              "title": "Epoch End"
            },
            "epoch_begin": {
              "type": "integer",
              "title": "Epoch Begin"
            },
            "network_name": {
              "type": "string",
              "title": "Network Name"
            }
          },
          "required": [
            "ifid",
            "epoch_begin",
            "epoch_end",
            "alert_id",
            "severity",
            "score",
            "network_name"
          ]
        }
      },
      {
        "name": "get_ntopng_snmp_device_alert_list",
        "description": "Retrieve a list of SNMP device alerts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ip": {
              "type": "string",
              "title": "Ip"
            },
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "score": {
              "type": "string",
              "title": "Score"
            },
            "start": {
              "type": "integer",
              "title": "Start"
            },
            "format": {
              "type": "string",
              "title": "Format"
            },
            "length": {
              "type": "integer",
              "title": "Length"
            },
            "alert_id": {
              "type": "string",
              "title": "Alert Id"
            },
            "severity": {
              "type": "string",
              "title": "Severity"
            },
            "epoch_end": {
              "type": "integer",
              "title": "Epoch End"
            },
            "epoch_begin": {
              "type": "integer",
              "title": "Epoch Begin"
            },
            "snmp_interface": {
              "type": "string",
              "title": "Snmp Interface"
            }
          },
          "required": [
            "ifid",
            "start",
            "length",
            "epoch_begin",
            "epoch_end",
            "alert_id",
            "severity",
            "score",
            "ip",
            "snmp_interface",
            "format"
          ]
        }
      },
      {
        "name": "get_ntopng_snmp_device_alert_stats",
        "description": "Retrieve statistics for SNMP device alerts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ip": {
              "type": "string",
              "title": "Ip"
            },
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "score": {
              "type": "string",
              "title": "Score"
            },
            "alert_id": {
              "type": "string",
              "title": "Alert Id"
            },
            "severity": {
              "type": "string",
              "title": "Severity"
            },
            "epoch_end": {
              "type": "integer",
              "title": "Epoch End"
            },
            "epoch_begin": {
              "type": "integer",
              "title": "Epoch Begin"
            },
            "snmp_interface": {
              "type": "string",
              "title": "Snmp Interface"
            }
          },
          "required": [
            "ifid",
            "epoch_begin",
            "epoch_end",
            "alert_id",
            "severity",
            "score",
            "ip",
            "snmp_interface"
          ]
        }
      },
      {
        "name": "get_ntopng_system_alert_stats",
        "description": "Retrieve statistics for system alerts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "score": {
              "type": "string",
              "title": "Score"
            },
            "alert_id": {
              "type": "string",
              "title": "Alert Id"
            },
            "severity": {
              "type": "string",
              "title": "Severity"
            },
            "epoch_end": {
              "type": "integer",
              "title": "Epoch End"
            },
            "epoch_begin": {
              "type": "integer",
              "title": "Epoch Begin"
            }
          },
          "required": [
            "ifid",
            "epoch_begin",
            "epoch_end",
            "alert_id",
            "severity",
            "score"
          ]
        }
      },
      {
        "name": "query_ntopng_flows_data",
        "description": "Retrieve detailed flows data from the ntopng flows database.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "where_clause": {
              "type": "string",
              "title": "Where Clause",
              "default": ""
            },
            "select_clause": {
              "type": "string",
              "title": "Select Clause",
              "default": "*"
            },
            "maxhits_clause": {
              "type": "integer",
              "title": "Maxhits Clause",
              "default": 10
            },
            "end_time_clause": {
              "type": "integer",
              "title": "End Time Clause"
            },
            "group_by_clause": {
              "type": "string",
              "title": "Group By Clause",
              "default": ""
            },
            "order_by_clause": {
              "type": "string",
              "title": "Order By Clause",
              "default": ""
            },
            "begin_time_clause": {
              "type": "integer",
              "title": "Begin Time Clause"
            }
          },
          "required": [
            "ifid",
            "begin_time_clause",
            "end_time_clause"
          ]
        }
      },
      {
        "name": "get_ntopng_top-k_flows",
        "description": "Retrieve top-k flows data from the ntopng flows database.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "topk_clause": {
              "type": "string",
              "title": "Topk Clause",
              "default": "SUM"
            },
            "where_clause": {
              "type": "string",
              "title": "Where Clause",
              "default": ""
            },
            "approx_search": {
              "type": "string",
              "title": "Approx Search",
              "default": "true"
            },
            "maxhits_clause": {
              "type": "integer",
              "title": "Maxhits Clause",
              "default": 10
            },
            "end_time_clause": {
              "type": "integer",
              "title": "End Time Clause"
            },
            "begin_time_clause": {
              "type": "integer",
              "title": "Begin Time Clause"
            },
            "select_keys_clause": {
              "type": "string",
              "title": "Select Keys Clause",
              "default": "IPV4_SRC_ADDR,IPV4_DST_ADDR,L7_PROTO"
            },
            "select_values_clause": {
              "type": "string",
              "title": "Select Values Clause",
              "default": "BYTES"
            }
          },
          "required": [
            "ifid",
            "begin_time_clause",
            "end_time_clause"
          ]
        }
      },
      {
        "name": "get_ntopng_user_alert_stats",
        "description": "Retrieve statistics for user alerts.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            },
            "score": {
              "type": "string",
              "title": "Score"
            },
            "alert_id": {
              "type": "string",
              "title": "Alert Id"
            },
            "severity": {
              "type": "string",
              "title": "Severity"
            },
            "epoch_end": {
              "type": "integer",
              "title": "Epoch End"
            },
            "epoch_begin": {
              "type": "integer",
              "title": "Epoch Begin"
            }
          },
          "required": [
            "ifid",
            "epoch_begin",
            "epoch_end",
            "alert_id",
            "severity",
            "score"
          ]
        }
      },
      {
        "name": "get_ntopng_flow_devices_stats",
        "description": "Retrieve statistics for all flow devices.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            }
          },
          "required": [
            "ifid"
          ]
        }
      },
      {
        "name": "get_ntopng_sflow_devices_stats",
        "description": "Retrieve statistics for all sFlow devices.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ifid": {
              "type": "integer",
              "title": "Ifid"
            }
          },
          "required": [
            "ifid"
          ]
        }
      }
    ]
  },
  {
    "name": "marcopesani-mcp-server-serper",
    "title": "serper-search-scrape-mcp-server",
    "description": "This Serper MCP Server supports search and webpage scraping, and all the most recent parameters introduced by the Serper API, like location.",
    "icon": "https://avatars.githubusercontent.com/marcopesani",
    "isOfficial": false,
    "homepage": "https://github.com/marcopesani/mcp-server-serper",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "serper-search-scrape-mcp-server"
      ],
      "env": {
        "SERPER_API_KEY": "<serper-api-key>"
      }
    },
    "parameters": [
      {
        "name": "SERPER_API_KEY",
        "description": "Your Serper API key for web search and content extraction",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "google_search",
        "description": "Tool to perform web searches via Serper API and retrieve rich results. It is able to retrieve organic search results, people also ask, related searches, and knowledge graph.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "description": "Search query string (e.g., 'artificial intelligence', 'climate change solutions')"
            },
            "gl": {
              "type": "string",
              "description": "Optional region code for search results in ISO 3166-1 alpha-2 format (e.g., 'us', 'gb', 'de')"
            },
            "hl": {
              "type": "string",
              "description": "Optional language code for search results in ISO 639-1 format (e.g., 'en', 'es', 'fr')"
            },
            "or": {
              "type": "string",
              "description": "Alternative terms as comma-separated string (e.g., 'tutorial,guide,course', 'documentation,manual')"
            },
            "num": {
              "type": "number",
              "description": "Number of results to return (default: 10)"
            },
            "tbs": {
              "type": "string",
              "description": "Time-based search filter ('qdr:h' for past hour, 'qdr:d' for past day, 'qdr:w' for past week, 'qdr:m' for past month, 'qdr:y' for past year)"
            },
            "page": {
              "type": "number",
              "description": "Page number of results to return (default: 1)"
            },
            "site": {
              "type": "string",
              "description": "Limit results to specific domain (e.g., 'github.com', 'wikipedia.org')"
            },
            "after": {
              "type": "string",
              "description": "Date after in YYYY-MM-DD format (e.g., '2023-01-01')"
            },
            "cache": {
              "type": "string",
              "description": "View Google's cached version of a specific URL (e.g., 'example.com/page')"
            },
            "exact": {
              "type": "string",
              "description": "Exact phrase match (e.g., 'machine learning', 'quantum computing')"
            },
            "inurl": {
              "type": "string",
              "description": "Search for pages with word in URL (e.g., 'download', 'tutorial')"
            },
            "before": {
              "type": "string",
              "description": "Date before in YYYY-MM-DD format (e.g., '2024-01-01')"
            },
            "exclude": {
              "type": "string",
              "description": "Terms to exclude from search results as comma-separated string (e.g., 'spam,ads', 'beginner,basic')"
            },
            "intitle": {
              "type": "string",
              "description": "Search for pages with word in title (e.g., 'review', 'how to')"
            },
            "related": {
              "type": "string",
              "description": "Find similar websites (e.g., 'github.com', 'stackoverflow.com')"
            },
            "filetype": {
              "type": "string",
              "description": "Limit to specific file types (e.g., 'pdf', 'doc', 'xls')"
            },
            "location": {
              "type": "string",
              "description": "Optional location for search results (e.g., 'SoHo, New York, United States', 'California, United States')"
            },
            "autocorrect": {
              "type": "boolean",
              "description": "Whether to autocorrect spelling in query"
            }
          },
          "required": [
            "q",
            "gl",
            "hl"
          ]
        }
      },
      {
        "name": "scrape",
        "description": "Tool to scrape a webpage and retrieve the text and, optionally, the markdown content. It will retrieve also the JSON-LD metadata and the head metadata.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL of the webpage to scrape."
            },
            "includeMarkdown": {
              "type": "boolean",
              "default": false,
              "description": "Whether to include markdown content."
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "marcopesani-think-mcp-server",
    "title": "think-mcp-server",
    "description": "A minimal MCP Server that provides Claude AI models with the 'think' tool capability, enabling better performance on complex reasoning tasks by allowing the model to pause during response generation for additional thinking steps.",
    "icon": "https://avatars.githubusercontent.com/marcopesani",
    "isOfficial": false,
    "homepage": "https://github.com/marcopesani/think-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "think-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "think",
        "description": "Use the tool to think about something. It will not obtain new information or change the database, but just append the thought to the log. Use it when complex reasoning or some cache memory is needed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "thought": {
              "type": "string",
              "description": "A thought to think about."
            }
          },
          "required": [
            "thought"
          ]
        }
      }
    ]
  },
  {
    "name": "marcusbai-caiyun-weather-mcp",
    "title": "Caiyun Weather MCP Server",
    "description": "A Model Context Protocol server that provides comprehensive weather data querying capabilities based on the Caiyun Weather API, supporting real-time weather, forecasts, and alerts with multi-language support.",
    "icon": "https://avatars.githubusercontent.com/marcusbai",
    "isOfficial": false,
    "homepage": "https://github.com/marcusbai/caiyun-weather-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "caiyun-weather-mcp"
      ],
      "env": {
        "AMAP_API_KEY": "<amap-api-key>",
        "CAIYUN_API_KEY": "<caiyun-api-key>"
      }
    },
    "parameters": [
      {
        "name": "AMAP_API_KEY",
        "description": "Your Amap (Gaode Maps) API key (optional for address lookup functionality)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CAIYUN_API_KEY",
        "description": "Your Caiyun Weather API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_weather_by_location",
        "description": "根据经纬度获取天气信息",
        "inputSchema": {
          "type": "object",
          "properties": {
            "unit": {
              "enum": [
                "metric",
                "imperial"
              ],
              "type": "string",
              "default": "metric",
              "description": "单位制 (metric: 公制, imperial: 英制)"
            },
            "language": {
              "enum": [
                "zh_CN",
                "en_US"
              ],
              "type": "string",
              "default": "zh_CN",
              "description": "语言"
            },
            "latitude": {
              "type": "number",
              "description": "纬度"
            },
            "longitude": {
              "type": "number",
              "description": "经度"
            },
            "daily_steps": {
              "type": "number",
              "default": 5,
              "maximum": 15,
              "minimum": 1,
              "description": "每日预报天数 (1-15)"
            },
            "hourly_steps": {
              "type": "number",
              "default": 24,
              "maximum": 360,
              "minimum": 1,
              "description": "小时预报数量 (1-360)"
            }
          },
          "required": [
            "longitude",
            "latitude"
          ]
        }
      },
      {
        "name": "get_weather_by_address",
        "description": "根据地址获取天气信息",
        "inputSchema": {
          "type": "object",
          "properties": {
            "unit": {
              "enum": [
                "metric",
                "imperial"
              ],
              "type": "string",
              "default": "metric",
              "description": "单位制 (metric: 公制, imperial: 英制)"
            },
            "address": {
              "type": "string",
              "description": "地址，如\"北京市海淀区\""
            },
            "language": {
              "enum": [
                "zh_CN",
                "en_US"
              ],
              "type": "string",
              "default": "zh_CN",
              "description": "语言"
            },
            "daily_steps": {
              "type": "number",
              "default": 5,
              "maximum": 15,
              "minimum": 1,
              "description": "每日预报天数 (1-15)"
            },
            "hourly_steps": {
              "type": "number",
              "default": 24,
              "maximum": 360,
              "minimum": 1,
              "description": "小时预报数量 (1-360)"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "get_realtime_weather",
        "description": "获取实时天气数据",
        "inputSchema": {
          "type": "object",
          "properties": {
            "unit": {
              "enum": [
                "metric",
                "imperial"
              ],
              "type": "string",
              "default": "metric",
              "description": "单位制 (metric: 公制, imperial: 英制)"
            },
            "language": {
              "enum": [
                "zh_CN",
                "en_US"
              ],
              "type": "string",
              "default": "zh_CN",
              "description": "语言"
            },
            "latitude": {
              "type": "number",
              "description": "纬度"
            },
            "longitude": {
              "type": "number",
              "description": "经度"
            }
          },
          "required": [
            "longitude",
            "latitude"
          ]
        }
      },
      {
        "name": "get_minutely_forecast",
        "description": "获取分钟级降水预报",
        "inputSchema": {
          "type": "object",
          "properties": {
            "unit": {
              "enum": [
                "metric",
                "imperial"
              ],
              "type": "string",
              "default": "metric",
              "description": "单位制 (metric: 公制, imperial: 英制)"
            },
            "language": {
              "enum": [
                "zh_CN",
                "en_US"
              ],
              "type": "string",
              "default": "zh_CN",
              "description": "语言"
            },
            "latitude": {
              "type": "number",
              "description": "纬度"
            },
            "longitude": {
              "type": "number",
              "description": "经度"
            }
          },
          "required": [
            "longitude",
            "latitude"
          ]
        }
      },
      {
        "name": "get_hourly_forecast",
        "description": "获取小时级天气预报",
        "inputSchema": {
          "type": "object",
          "properties": {
            "unit": {
              "enum": [
                "metric",
                "imperial"
              ],
              "type": "string",
              "default": "metric",
              "description": "单位制 (metric: 公制, imperial: 英制)"
            },
            "language": {
              "enum": [
                "zh_CN",
                "en_US"
              ],
              "type": "string",
              "default": "zh_CN",
              "description": "语言"
            },
            "latitude": {
              "type": "number",
              "description": "纬度"
            },
            "longitude": {
              "type": "number",
              "description": "经度"
            },
            "hourly_steps": {
              "type": "number",
              "default": 24,
              "maximum": 360,
              "minimum": 1,
              "description": "小时预报数量 (1-360)"
            }
          },
          "required": [
            "longitude",
            "latitude"
          ]
        }
      },
      {
        "name": "get_daily_forecast",
        "description": "获取天级天气预报",
        "inputSchema": {
          "type": "object",
          "properties": {
            "unit": {
              "enum": [
                "metric",
                "imperial"
              ],
              "type": "string",
              "default": "metric",
              "description": "单位制 (metric: 公制, imperial: 英制)"
            },
            "language": {
              "enum": [
                "zh_CN",
                "en_US"
              ],
              "type": "string",
              "default": "zh_CN",
              "description": "语言"
            },
            "latitude": {
              "type": "number",
              "description": "纬度"
            },
            "longitude": {
              "type": "number",
              "description": "经度"
            },
            "daily_steps": {
              "type": "number",
              "default": 5,
              "maximum": 15,
              "minimum": 1,
              "description": "每日预报天数 (1-15)"
            }
          },
          "required": [
            "longitude",
            "latitude"
          ]
        }
      },
      {
        "name": "get_weather_alert",
        "description": "获取天气预警信息",
        "inputSchema": {
          "type": "object",
          "properties": {
            "unit": {
              "enum": [
                "metric",
                "imperial"
              ],
              "type": "string",
              "default": "metric",
              "description": "单位制 (metric: 公制, imperial: 英制)"
            },
            "language": {
              "enum": [
                "zh_CN",
                "en_US"
              ],
              "type": "string",
              "default": "zh_CN",
              "description": "语言"
            },
            "latitude": {
              "type": "number",
              "description": "纬度"
            },
            "longitude": {
              "type": "number",
              "description": "经度"
            }
          },
          "required": [
            "longitude",
            "latitude"
          ]
        }
      }
    ]
  },
  {
    "name": "mastergo-design-mastergo-magic-mcp",
    "title": "MasterGo Magic MCP",
    "description": "A standalone Model Context Protocol service that connects MasterGo design tools with AI models, enabling AI models to directly retrieve DSL data from MasterGo design files.",
    "icon": "https://avatars.githubusercontent.com/mastergo-design",
    "isOfficial": true,
    "homepage": "https://github.com/mastergo-design/mastergo-magic-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@mastergo/magic-mcp"
      ],
      "env": {
        "url": "<url>",
        "MG_MCP_TOKEN": "<mg-mcp-token>"
      }
    },
    "parameters": [
      {
        "name": "url",
        "description": "MasterGo URL",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MG_MCP_TOKEN",
        "description": "MasterGo personal access token obtained from personal settings in Security Settings tab",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "version_0.0.4-beta.11",
        "description": "the current version is 0.0.4-beta.11",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "mcp__getDsl",
        "description": "\n\"Use this tool to retrieve the DSL (Domain Specific Language) data from MasterGo design files and the rules you must follow when generating code.\nThis tool is useful when you need to analyze the structure of a design, understand component hierarchy, or extract design properties.\nYou must provide a fileId and layerId to identify the specific design element.\nThis tool returns the raw DSL data in JSON format that you can then parse and analyze.\nThis tool also returns the rules you must follow when generating code.\nThe DSL data can also be used to transform and generate code for different frameworks.\"\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileId": {
              "type": "string",
              "description": "MasterGo design file ID (format: file/<fileId> in MasterGo URL)"
            },
            "layerId": {
              "type": "string",
              "description": "Layer ID of the specific component or element to retrieve (format: ?layer_id=<layerId> / file=<fileId> in MasterGo URL)"
            }
          },
          "required": [
            "fileId",
            "layerId"
          ]
        }
      },
      {
        "name": "mcp__getComponentLink",
        "description": "When the data returned by mcp__getDsl contains a non-empty componentDocumentLinks array, this tool is used to sequentially retrieve URLs from the componentDocumentLinks array and then obtain component documentation data. The returned document data is used for you to generate frontend code based on components.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "Component documentation link URL, from the componentDocumentLinks property, please ensure the URL is valid"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "mcp__getMeta",
        "description": "\nUse this tool when the user intends to build a complete website or needs to obtain high-level site\nconfiguration information. You must provide a fileld and layerld to identify the specific design element.\nThis tool returns the rules and results of the site and page. The rules is a markdown file, you must\nfollow the rules and use the results to analyze the site and page.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileId": {
              "type": "string",
              "description": "MasterGo design file ID (format: file/<fileId> in MasterGo URL)"
            },
            "layerId": {
              "type": "string",
              "description": "Layer ID of the specific component or element to retrieve (format: ?layer_id=<layerId> / file=<fileId> in MasterGo URL)"
            }
          },
          "required": [
            "fileId",
            "layerId"
          ]
        }
      },
      {
        "name": "mcp__getComponentGenerator",
        "description": "\nUsers need to actively call this tool to get the component development workflow. When Generator is mentioned, please actively call this tool.\nThis tool provides a structured workflow for component development following best practices.\nYou must provide an absolute rootPath of workspace to save workflow files.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileId": {
              "type": "string",
              "description": "MasterGo design file ID (format: file/<fileId> in MasterGo URL)"
            },
            "layerId": {
              "type": "string",
              "description": "Layer ID of the specific component or element to retrieve (format: ?layer_id=<layerId> / file=<fileId> in MasterGo URL)"
            },
            "rootPath": {
              "type": "string",
              "description": "The root path of the project, if the user does not provide, you can use the current directory as the root path"
            }
          },
          "required": [
            "rootPath",
            "fileId",
            "layerId"
          ]
        }
      }
    ]
  },
  {
    "name": "mcollina-mcp-node-fetch",
    "title": "MCP Node Fetch",
    "description": "An MCP server that enables fetching web content using the Node.js undici library, supporting various HTTP methods, content formats, and request configurations.",
    "icon": "https://avatars.githubusercontent.com/mcollina",
    "isOfficial": false,
    "homepage": "https://github.com/mcollina/mcp-node-fetch",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-node-fetch"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "extract-html-fragment",
        "description": "Extract a specific HTML fragment from a webpage using CSS selectors",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to fetch"
            },
            "body": {
              "type": "string",
              "description": "Request body for POST requests"
            },
            "method": {
              "enum": [
                "GET",
                "POST"
              ],
              "type": "string",
              "default": "GET",
              "description": "HTTP method"
            },
            "headers": {
              "type": "object",
              "description": "HTTP headers",
              "additionalProperties": {
                "type": "string"
              }
            },
            "timeout": {
              "type": "number",
              "description": "Request timeout in milliseconds"
            },
            "anchorId": {
              "type": "string",
              "description": "Optional anchor ID to locate a specific fragment"
            },
            "selector": {
              "type": "string",
              "description": "CSS selector for the HTML fragment to extract"
            },
            "followRedirects": {
              "type": "boolean",
              "default": true,
              "description": "Whether to follow redirects"
            },
            "fragmentSelector": {
              "type": "string",
              "description": "CSS selector for the HTML fragment to extract (when responseType is html-fragment)"
            }
          },
          "required": [
            "url",
            "selector"
          ]
        }
      },
      {
        "name": "fetch-url",
        "description": "Fetch content from a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to fetch"
            },
            "body": {
              "type": "string",
              "description": "Request body for POST/PUT/PATCH requests"
            },
            "method": {
              "enum": [
                "GET",
                "POST",
                "PUT",
                "DELETE",
                "HEAD",
                "OPTIONS",
                "PATCH"
              ],
              "type": "string",
              "default": "GET",
              "description": "HTTP method"
            },
            "headers": {
              "type": "object",
              "description": "HTTP headers",
              "additionalProperties": {
                "type": "string"
              }
            },
            "timeout": {
              "type": "number",
              "description": "Request timeout in milliseconds"
            },
            "responseType": {
              "enum": [
                "text",
                "json",
                "binary",
                "html-fragment"
              ],
              "type": "string",
              "default": "text",
              "description": "How to parse the response"
            },
            "followRedirects": {
              "type": "boolean",
              "default": true,
              "description": "Whether to follow redirects"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "check-status",
        "description": "Check if a URL is accessible (HEAD request)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL to check"
            },
            "timeout": {
              "type": "number",
              "description": "Request timeout in milliseconds"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "mcollina-perm-shell-mcp",
    "title": "PermShell MCP",
    "description": "A Model Context Protocol server that allows LLMs to execute shell commands with explicit user permission through desktop notifications.",
    "icon": "https://avatars.githubusercontent.com/mcollina",
    "isOfficial": false,
    "homepage": "https://github.com/mcollina/perm-shell-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "perm-shell-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "execute-command",
        "description": "Execute a shell command",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cwd": {
              "type": "string",
              "description": "Directory to run the command in (defaults to system temp directory)"
            },
            "stdin": {
              "type": "string",
              "description": "Optional input to provide to the command's standard input"
            },
            "command": {
              "type": "string",
              "description": "The shell command to execute"
            },
            "timeout": {
              "type": "number",
              "description": "Timeout in milliseconds after which the process is killed"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "system-info",
        "description": "Get system information",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "mcollina-mcp-ripgrep",
    "title": "MCP Ripgrep Server",
    "description": "Provides ripgrep search capabilities to MCP clients like Claude, allowing high-performance text searches across files on your system.",
    "icon": "https://avatars.githubusercontent.com/mcollina",
    "isOfficial": false,
    "homepage": "https://github.com/mcollina/mcp-ripgrep",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-ripgrep"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "search",
        "description": "Search files for patterns using ripgrep (rg)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Directory or file(s) to search."
            },
            "context": {
              "type": "number",
              "description": "Show N lines before and after each match"
            },
            "pattern": {
              "type": "string",
              "description": "The search pattern (regex by default)"
            },
            "useColors": {
              "type": "boolean",
              "description": "Use colors in output (default: false)"
            },
            "maxResults": {
              "type": "number",
              "description": "Limit the number of matching lines"
            },
            "filePattern": {
              "type": "string",
              "description": "Filter by file type or glob"
            },
            "caseSensitive": {
              "type": "boolean",
              "description": "Use case sensitive search (default: auto)"
            }
          },
          "required": [
            "pattern",
            "path"
          ]
        }
      },
      {
        "name": "advanced-search",
        "description": "Advanced search with ripgrep with more options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Directory or file(s) to search."
            },
            "context": {
              "type": "number",
              "description": "Show N lines before and after each match"
            },
            "pattern": {
              "type": "string",
              "description": "The search pattern (regex by default)"
            },
            "fileType": {
              "type": "string",
              "description": "Filter by file type (e.g., js, py)"
            },
            "useColors": {
              "type": "boolean",
              "description": "Use colors in output (default: false)"
            },
            "wordMatch": {
              "type": "boolean",
              "description": "Only show matches surrounded by word boundaries"
            },
            "maxResults": {
              "type": "number",
              "description": "Limit the number of matching lines"
            },
            "filePattern": {
              "type": "string",
              "description": "Filter by file type or glob"
            },
            "invertMatch": {
              "type": "boolean",
              "description": "Show lines that don't match the pattern"
            },
            "fixedStrings": {
              "type": "boolean",
              "description": "Treat pattern as a literal string, not a regex"
            },
            "caseSensitive": {
              "type": "boolean",
              "description": "Use case sensitive search (default: auto)"
            },
            "includeHidden": {
              "type": "boolean",
              "description": "Search in hidden files and directories"
            },
            "followSymlinks": {
              "type": "boolean",
              "description": "Follow symbolic links"
            },
            "showLineNumbers": {
              "type": "boolean",
              "description": "Show line numbers"
            },
            "showFilenamesOnly": {
              "type": "boolean",
              "description": "Only show filenames of matches, not content"
            }
          },
          "required": [
            "pattern",
            "path"
          ]
        }
      },
      {
        "name": "count-matches",
        "description": "Count matches in files using ripgrep",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Directory or file(s) to search."
            },
            "pattern": {
              "type": "string",
              "description": "The search pattern (regex by default)"
            },
            "useColors": {
              "type": "boolean",
              "description": "Use colors in output (default: false)"
            },
            "countLines": {
              "type": "boolean",
              "description": "Count matching lines instead of total matches"
            },
            "filePattern": {
              "type": "string",
              "description": "Filter by file type or glob"
            },
            "caseSensitive": {
              "type": "boolean",
              "description": "Use case sensitive search (default: auto)"
            }
          },
          "required": [
            "pattern",
            "path"
          ]
        }
      },
      {
        "name": "list-files",
        "description": "List files that would be searched by ripgrep without actually searching them",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Directory or file(s) to search."
            },
            "fileType": {
              "type": "string",
              "description": "Filter by file type (e.g., js, py)"
            },
            "filePattern": {
              "type": "string",
              "description": "Filter by file type or glob"
            },
            "includeHidden": {
              "type": "boolean",
              "description": "Include hidden files and directories"
            }
          },
          "required": [
            "path"
          ]
        }
      },
      {
        "name": "list-file-types",
        "description": "List all supported file types in ripgrep",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "mcp2everything-mcp2serial",
    "title": "MCP2Serial",
    "description": "A bridge that connects physical hardware devices with AI large language models via serial communication, allowing users to control hardware using natural language commands.",
    "icon": "https://avatars.githubusercontent.com/mcp2everything",
    "isOfficial": false,
    "homepage": "https://github.com/mcp2everything/mcp2serial",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp2serial"
      ],
      "env": {
        "config": "<config>"
      }
    },
    "parameters": [
      {
        "name": "config",
        "description": "Specifies the configuration file name to use (without the _config.yaml suffix)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "set_pwm",
        "description": "Execute set_pwm command",
        "inputSchema": {
          "type": "object",
          "properties": {
            "frequency": {
              "type": "string"
            }
          },
          "required": [
            "frequency"
          ]
        }
      },
      {
        "name": "get_pico_info",
        "description": "Execute get_pico_info command",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "led_control",
        "description": "Execute led_control command",
        "inputSchema": {
          "type": "object",
          "properties": {
            "state": {
              "type": "string"
            }
          },
          "required": [
            "state"
          ]
        }
      }
    ]
  },
  {
    "name": "mcpdotdirect-starknet-mcp-server",
    "title": "Starknet MCP Server",
    "description": "A comprehensive Model Context Protocol server that enables AI agents to interact with Starknet blockchain, query data, manage wallets, and work with smart contracts.",
    "icon": "https://avatars.githubusercontent.com/mcpdotdirect",
    "isOfficial": false,
    "homepage": "https://github.com/mcpdotdirect/starknet-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@mcpdotdirect/starknet-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_starknet_chain_info",
        "description": "Get information about a Starknet network",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            }
          }
        }
      },
      {
        "name": "get_supported_starknet_networks",
        "description": "Get a list of supported Starknet networks",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_starknet_eth_balance",
        "description": "Get the ETH balance for a Starknet address or Starknet ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "Starknet address or Starknet ID (with or without .stark)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "get_starknet_token_balance",
        "description": "Get the token balance for a Starknet address or Starknet ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "ownerAddress": {
              "type": "string",
              "description": "Owner's Starknet address or Starknet ID"
            },
            "tokenAddress": {
              "type": "string",
              "description": "Token contract address or Starknet ID"
            }
          },
          "required": [
            "tokenAddress",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_starknet_strk_balance",
        "description": "Get the STRK token balance for a Starknet address or Starknet ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "Starknet address or Starknet ID (with or without .stark)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "get_starknet_native_balances",
        "description": "Get all native token balances (ETH and STRK) for a Starknet address or Starknet ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "Starknet address or Starknet ID (with or without .stark)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "resolve_starknet_name",
        "description": "Get the Starknet ID for an address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "Starknet address to lookup (must be a valid address, not a name)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "resolve_starknet_address",
        "description": "Get the address for a Starknet ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Starknet ID to lookup (with or without .stark)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "get_starknet_profile",
        "description": "Get the full Starknet ID profile for an address or Starknet ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "Starknet address or Starknet ID to lookup"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "validate_starknet_domain",
        "description": "Check if a string is a valid Starknet ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "domain": {
              "type": "string",
              "description": "Starknet ID to validate (with or without .stark)"
            }
          },
          "required": [
            "domain"
          ]
        }
      },
      {
        "name": "get_starknet_block",
        "description": "Get information about a specific block",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "blockIdentifier": {
              "type": "string",
              "description": "Block number, hash, or 'latest'/'pending'. Defaults to 'latest'."
            }
          }
        }
      },
      {
        "name": "get_starknet_block_transactions",
        "description": "Get transactions in a specific block",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "blockIdentifier": {
              "type": "string",
              "description": "Block number, hash, or 'latest'/'pending'. Defaults to 'latest'."
            }
          }
        }
      },
      {
        "name": "get_starknet_transaction",
        "description": "Get details about a transaction",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txHash": {
              "type": "string",
              "description": "Transaction hash"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            }
          },
          "required": [
            "txHash"
          ]
        }
      },
      {
        "name": "get_starknet_transaction_receipt",
        "description": "Get transaction receipt",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txHash": {
              "type": "string",
              "description": "Transaction hash"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            }
          },
          "required": [
            "txHash"
          ]
        }
      },
      {
        "name": "call_starknet_contract",
        "description": "Call a read-only function on a contract",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "calldata": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Call data array (optional)"
            },
            "entrypoint": {
              "type": "string",
              "description": "Function name to call"
            },
            "resultTypes": {
              "type": "array",
              "items": {
                "enum": [
                  "felt",
                  "uint256",
                  "address",
                  "string"
                ],
                "type": "string"
              },
              "description": "Expected return types for each result value (e.g., ['felt', 'uint256', 'address'])"
            },
            "contractAddress": {
              "type": "string",
              "description": "Contract address or Starknet ID"
            }
          },
          "required": [
            "contractAddress",
            "entrypoint"
          ]
        }
      },
      {
        "name": "get_starknet_contract_class",
        "description": "Get the class (ABI and other information) of a contract",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "contractAddress": {
              "type": "string",
              "description": "Contract address or Starknet ID"
            }
          },
          "required": [
            "contractAddress"
          ]
        }
      },
      {
        "name": "get_starknet_token_info",
        "description": "Get information about a token",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "tokenAddress": {
              "type": "string",
              "description": "Token contract address or Starknet ID"
            }
          },
          "required": [
            "tokenAddress"
          ]
        }
      },
      {
        "name": "check_starknet_nft_ownership",
        "description": "Check if an address owns a specific NFT",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "tokenId": {
              "type": "string",
              "description": "Token ID to check"
            },
            "ownerAddress": {
              "type": "string",
              "description": "Owner's Starknet address or Starknet ID to check against"
            },
            "tokenAddress": {
              "type": "string",
              "description": "NFT contract address or Starknet ID"
            }
          },
          "required": [
            "tokenAddress",
            "tokenId",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_starknet_nft_balance",
        "description": "Get the number of NFTs owned by an address for a specific collection",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "ownerAddress": {
              "type": "string",
              "description": "Owner's Starknet address or Starknet ID"
            },
            "tokenAddress": {
              "type": "string",
              "description": "NFT contract address or Starknet ID"
            }
          },
          "required": [
            "tokenAddress",
            "ownerAddress"
          ]
        }
      },
      {
        "name": "get_starknet_token_supply",
        "description": "Get the total supply of a token",
        "inputSchema": {
          "type": "object",
          "properties": {
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "tokenAddress": {
              "type": "string",
              "description": "Token contract address or Starknet ID"
            }
          },
          "required": [
            "tokenAddress"
          ]
        }
      },
      {
        "name": "check_starknet_transaction_status",
        "description": "Check if a transaction is confirmed (finalized)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txHash": {
              "type": "string",
              "description": "Transaction hash"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            }
          },
          "required": [
            "txHash"
          ]
        }
      },
      {
        "name": "transfer_starknet_eth",
        "description": "Transfer ETH from one account to another",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "string",
              "description": "Recipient's Starknet address or Starknet ID"
            },
            "from": {
              "type": "string",
              "description": "Sender's Starknet address"
            },
            "amount": {
              "type": "string",
              "description": "Amount to transfer in ETH (human readable format, not wei)"
            },
            "maxFee": {
              "type": "string",
              "description": "Maximum fee to pay (optional)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "privateKey": {
              "type": "string",
              "description": "Private key of the sender account (not stored, only used to sign the transaction)"
            }
          },
          "required": [
            "privateKey",
            "from",
            "to",
            "amount"
          ]
        }
      },
      {
        "name": "transfer_starknet_strk",
        "description": "Transfer STRK from one account to another",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "string",
              "description": "Recipient's Starknet address or Starknet ID"
            },
            "from": {
              "type": "string",
              "description": "Sender's Starknet address"
            },
            "amount": {
              "type": "string",
              "description": "Amount to transfer in STRK (human readable format, not wei)"
            },
            "maxFee": {
              "type": "string",
              "description": "Maximum fee to pay (optional)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "privateKey": {
              "type": "string",
              "description": "Private key of the sender account (not stored, only used to sign the transaction)"
            }
          },
          "required": [
            "privateKey",
            "from",
            "to",
            "amount"
          ]
        }
      },
      {
        "name": "transfer_starknet_token",
        "description": "Transfer ERC20 tokens from one account to another",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "string",
              "description": "Recipient's Starknet address or Starknet ID"
            },
            "from": {
              "type": "string",
              "description": "Sender's Starknet address"
            },
            "amount": {
              "type": "string",
              "description": "Amount to transfer in token's standard units (human readable format, not in smallest unit)"
            },
            "maxFee": {
              "type": "string",
              "description": "Maximum fee to pay (optional)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "privateKey": {
              "type": "string",
              "description": "Private key of the sender account (not stored, only used to sign the transaction)"
            },
            "tokenAddress": {
              "type": "string",
              "description": "Token contract address or Starknet ID"
            }
          },
          "required": [
            "privateKey",
            "from",
            "to",
            "tokenAddress",
            "amount"
          ]
        }
      },
      {
        "name": "execute_starknet_contract",
        "description": "Execute a contract call (write operation)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "maxFee": {
              "type": "string",
              "description": "Maximum fee to pay (optional)"
            },
            "network": {
              "type": "string",
              "description": "Network name (e.g., 'mainnet', 'sepolia'). Defaults to Mainnet."
            },
            "calldata": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Call data array (optional)"
            },
            "entrypoint": {
              "type": "string",
              "description": "Function name to call"
            },
            "privateKey": {
              "type": "string",
              "description": "Private key of the sender account (not stored, only used to sign the transaction)"
            },
            "accountAddress": {
              "type": "string",
              "description": "Sender's Starknet address"
            },
            "contractAddress": {
              "type": "string",
              "description": "Contract address or Starknet ID"
            }
          },
          "required": [
            "privateKey",
            "accountAddress",
            "contractAddress",
            "entrypoint"
          ]
        }
      }
    ]
  },
  {
    "name": "mektigboy-server-hyperliquid",
    "title": "Hyperliquid MCP Server",
    "description": "An MCP server implementation that integrates with Hyperliquid exchange, providing access to crypto market data including mid prices, historical candles, and L2 order books.",
    "icon": "https://avatars.githubusercontent.com/mektigboy",
    "isOfficial": false,
    "homepage": "https://github.com/mektigboy/server-hyperliquid",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@mektigboy/server-hyperliquid"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_all_mids",
        "description": "Get mid prices for all coins on Hyperliquid",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "get_candle_snapshot",
        "description": "Get candlestick data for a token on Hyperliquid",
        "inputSchema": {
          "type": "object",
          "properties": {
            "coin": {
              "type": "string",
              "description": "The symbol of the token to get candlestick data for"
            },
            "endTime": {
              "type": "number",
              "description": "End time in milliseconds since epoch (optional)"
            },
            "interval": {
              "type": "string",
              "description": "Time interval (e.g., '15m', '1h')"
            },
            "startTime": {
              "type": "number",
              "description": "Start time in milliseconds since epoch"
            }
          },
          "required": [
            "coin",
            "interval",
            "startTime"
          ]
        }
      },
      {
        "name": "get_l2_book",
        "description": "Get the L2 book of a token on Hyperliquid",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "description": "The symbol of the token to get the price of"
            },
            "required": [
              "symbol"
            ]
          }
        }
      }
    ]
  },
  {
    "name": "melaodoidao-datagov-mcp-server",
    "title": "Data.gov MCP Server",
    "description": "An MCP server that provides access to government datasets from Data.gov, enabling users to search packages, view dataset details, list groups and tags, and access resources by URL.",
    "icon": "https://avatars.githubusercontent.com/melaodoidao",
    "isOfficial": false,
    "homepage": "https://github.com/melaodoidao/datagov-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@melaodoidao/datagov-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "package_search",
        "description": "Search for packages (datasets) on Data.gov",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "description": "Search query"
            },
            "rows": {
              "type": "number",
              "description": "Number of results per page"
            },
            "sort": {
              "type": "string",
              "description": "Sort order (e.g., \"score desc, name asc\")"
            },
            "start": {
              "type": "number",
              "description": "Starting offset for results"
            }
          }
        }
      },
      {
        "name": "package_show",
        "description": "Get details for a specific package (dataset)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "Package ID or name"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "group_list",
        "description": "List groups on Data.gov",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of results"
            },
            "offset": {
              "type": "number",
              "description": "Offset for results"
            },
            "order_by": {
              "type": "string",
              "description": "Field to order by"
            },
            "all_fields": {
              "type": "boolean",
              "description": "Return all fields"
            }
          }
        }
      },
      {
        "name": "tag_list",
        "description": "List tags on Data.gov",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query for tags"
            },
            "all_fields": {
              "type": "boolean",
              "description": "Return all fields"
            }
          }
        }
      }
    ]
  },
  {
    "name": "metatool-ai-mcp-server-metamcp",
    "title": "MetaMCP MCP Server",
    "description": "A proxy server that unifies multiple MCP servers, enabling seamless tool, prompt, and resource management via the MetaMCP App.",
    "icon": "https://avatars.githubusercontent.com/metatool-ai",
    "isOfficial": false,
    "homepage": "https://github.com/metatool-ai/mcp-server-metamcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@metamcp/mcp-server-metamcp"
      ],
      "env": {
        "METAMCP_API_KEY": "<metamcp-api-key>",
        "METAMCP_API_BASE_URL": "<metamcp-api-base-url>"
      }
    },
    "parameters": [
      {
        "name": "METAMCP_API_KEY",
        "description": "Required. Obtained from MetaMCP App's \"API Keys\" page (https://metamcp.com/api-keys).",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "METAMCP_API_BASE_URL",
        "description": "Optional override for MetaMCP App URL (e.g. http://localhost:12005).",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "mfukushim-map-traveler-mcp",
    "title": "Map Traveler MCP",
    "description": "An MCP server that creates a virtual traveling environment on Google Maps, allowing users to guide an avatar on journeys with photo reports and SNS integration.",
    "icon": "https://avatars.githubusercontent.com/mfukushim",
    "isOfficial": false,
    "homepage": "https://github.com/mfukushim/map-traveler-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@mfukushim/map-traveler-mcp"
      ],
      "env": {
        "MT_BS_ID": "<mt-bs-id>",
        "MT_SD_KEY": "<mt-sd-key>",
        "MT_BS_PASS": "<mt-bs-pass>",
        "MT_NO_IMAGE": "<mt-no-image>",
        "MT_BS_HANDLE": "<mt-bs-handle>",
        "MT_COMFY_URL": "<mt-comfy-url>",
        "MT_MOVE_MODE": "<mt-move-mode>",
        "MT_PIXAI_KEY": "<mt-pixai-key>",
        "MT_REMBG_URL": "<mt-rembg-url>",
        "MT_REMBG_PATH": "<mt-rembg-path>",
        "MT_TIME_SCALE": "<mt-time-scale>",
        "MT_IMAGE_WIDTH": "<mt-image-width>",
        "MT_MAP_API_URL": "<mt-map-api-url>",
        "MT_SQLITE_PATH": "<mt-sqlite-path>",
        "MT_COMFY_PARAMS": "<mt-comfy-params>",
        "MT_FILTER_TOOLS": "<mt-filter-tools>",
        "MT_BODY_HW_RATIO": "<mt-body-hw-ratio>",
        "MT_GOOGLE_MAP_KEY": "<mt-google-map-key>",
        "MT_PIXAI_MODEL_ID": "<mt-pixai-model-id>",
        "MT_BODY_AREA_RATIO": "<mt-body-area-ratio>",
        "MT_COMFY_WORKFLOW_I2I": "<mt-comfy-workflow-i2i>",
        "MT_COMFY_WORKFLOW_T2I": "<mt-comfy-workflow-t2i>",
        "MT_FIXED_MODEL_PROMPT": "<mt-fixed-model-prompt>",
        "MT_BODY_WINDOW_RATIO_H": "<mt-body-window-ratio-h>",
        "MT_BODY_WINDOW_RATIO_W": "<mt-body-window-ratio-w>"
      }
    },
    "parameters": [
      {
        "name": "MT_BS_ID",
        "description": "Bluesky SNS registration address",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_SD_KEY",
        "description": "Stability.ai image generation API key",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_BS_PASS",
        "description": "Bluesky SNS password",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_NO_IMAGE",
        "description": "Optional: true = do not output image, not specified = output image if possible",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_BS_HANDLE",
        "description": "Bluesky SNS handle name: e.g. xxxxxxxx.bsky.social",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_COMFY_URL",
        "description": "Optional: Generate image using ComfyUI API at specified URL. Example: http://192.168.1.100:8188",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_MOVE_MODE",
        "description": "Optional: Specify whether the movement mode is realtime or skip. Default realtime",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_PIXAI_KEY",
        "description": "pixAi API key",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_REMBG_URL",
        "description": "rembg API URL",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_REMBG_PATH",
        "description": "Absolute path of the installed rembg cli",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_TIME_SCALE",
        "description": "Optional: Scale of travel time on real roads duration. Default is 4",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_IMAGE_WIDTH",
        "description": "Optional: Output image width (pixels). Default is 512",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_MAP_API_URL",
        "description": "Optional: Map API custom endpoint. Example: direction=https://xxxx,places=https://yyyy",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_SQLITE_PATH",
        "description": "db save path: e.g. %USERPROFILE%/Desktop/traveler.sqlite, $HOME/traveler.sqlite",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_COMFY_PARAMS",
        "description": "Optional: Variable values to send to the workflow via comfyUI API",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_FILTER_TOOLS",
        "description": "Optional: Directly filter the tools to be used. All are available if not specified. e.g. tips,set_traveler_location",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_BODY_HW_RATIO",
        "description": "Optional: Acceptable avatar image aspect ratios. Default 1.5~2.3",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_GOOGLE_MAP_KEY",
        "description": "Google Map API key with permissions for Street View Static API, Places API, Time Zone API, and Directions API",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_PIXAI_MODEL_ID",
        "description": "Optional: pixAi ModelId, if not set use default model 1648918127446573124",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_BODY_AREA_RATIO",
        "description": "Optional: Acceptable avatar image area ratio. Default 0.042",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_COMFY_WORKFLOW_I2I",
        "description": "Optional: Path of API workflow file when image to image in ComfyUI. If not specified: assets/comfy/i2i_sample.json",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_COMFY_WORKFLOW_T2I",
        "description": "Optional: Path to API workflow file when using text to image with ComfyUI. If not specified: assets/comfy/t2i_sample.json",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_FIXED_MODEL_PROMPT",
        "description": "Optional: Fixed avatar generation prompt. You will no longer be able to change your avatar during conversations.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_BODY_WINDOW_RATIO_H",
        "description": "Optional: Avatar composite window aspect ratio. Default 0.75",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MT_BODY_WINDOW_RATIO_W",
        "description": "Optional: Avatar composite window horizontal ratio. Default 0.5",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get_traveler_view_info",
        "description": "Get the address of the current traveler's location and information on nearby facilities,view snapshot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "includePhoto": {
              "type": "boolean",
              "description": "Get scenery photos of current location"
            },
            "includeNearbyFacilities": {
              "type": "boolean",
              "description": "Get information on nearby facilities"
            }
          }
        }
      },
      {
        "name": "get_traveler_location",
        "description": "Get the address of the current traveler's location",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "tips",
        "description": "Inform you of recommended actions for your device",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_setting",
        "description": "Get current setting",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_traveler_info",
        "description": "get a traveler's setting.For example, traveler's name, the language traveler speak, Personality and speaking habits, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "settings": {}
          }
        }
      },
      {
        "name": "set_traveler_info",
        "description": "set a traveler's setting.For example, traveler's name, the language traveler speak, Personality and speaking habits, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "settings": {
              "type": "string",
              "description": "traveler's setting. traveler's name, the language traveler speak, etc."
            }
          },
          "required": [
            "settings"
          ]
        }
      },
      {
        "name": "start_traveler_journey",
        "description": "Start the traveler's journey to destination",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "stop_traveler_journey",
        "description": "Stop the traveler's journey",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "microsoft-clarity-mcp-server",
    "title": "Clarity Data Export MCP Server",
    "description": "A Model Context Protocol server that lets you fetch Microsoft Clarity analytics data through Claude for Desktop or other MCP-compatible clients, with support for filtering by dimensions and retrieving various metrics.",
    "icon": "https://avatars.githubusercontent.com/microsoft",
    "isOfficial": true,
    "homepage": "https://github.com/microsoft/clarity-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@microsoft/clarity-mcp-server"
      ],
      "env": {
        "clarity_api_token": "<clarity-api-token>"
      }
    },
    "parameters": [
      {
        "name": "clarity_api_token",
        "description": "Your Microsoft Clarity API token used for authentication with the Clarity data export API",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get-clarity-data",
        "description": "Fetch Microsoft Clarity analytics data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "token": {
              "type": "string",
              "description": "Your Clarity API token (optional if provided via environment or command line)"
            },
            "metrics": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Metrics to retrieve (Scroll Depth, Engagement Time, Traffic, Popular Pages, Browser, Device, OS, Country/Region, etc.)"
            },
            "numOfDays": {
              "type": "number",
              "maximum": 3,
              "minimum": 1,
              "description": "Number of days to retrieve data for (1-3)"
            },
            "dimensions": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Up to 3 dimensions to filter by (Browser, Device, Country/Region, OS, Source, Medium, Campaign, Channel, URL)"
            }
          },
          "required": [
            "numOfDays"
          ]
        }
      }
    ]
  },
  {
    "name": "microsoft-playwright-mcp",
    "title": "Playwright MCP Server",
    "description": "A Model Context Protocol server that enables LLMs to interact with web pages through structured accessibility snapshots without requiring vision models or screenshots.",
    "icon": "https://avatars.githubusercontent.com/microsoft",
    "isOfficial": true,
    "homepage": "https://github.com/microsoft/playwright-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@playwright/mcp"
      ],
      "env": {
        "CAPS": "<caps>",
        "PORT": "<port>",
        "VISION": "<vision>",
        "BROWSER": "<browser>",
        "HEADLESS": "<headless>",
        "CDP_ENDPOINT": "<cdp-endpoint>",
        "USER_DATA_DIR": "<user-data-dir>",
        "EXECUTABLE_PATH": "<executable-path>"
      }
    },
    "parameters": [
      {
        "name": "CAPS",
        "description": "Comma-separated list of capabilities to enable, possible values: tabs, pdf, history, wait, files, install",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "PORT",
        "description": "Port to listen on for SSE transport",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "VISION",
        "description": "Run server that uses screenshots (Aria snapshots are used by default)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "BROWSER",
        "description": "Browser or chrome channel to use. Possible values: chrome, firefox, webkit, msedge, chrome-beta, chrome-canary, chrome-dev, msedge-beta, msedge-canary, msedge-dev",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "HEADLESS",
        "description": "Run browser in headless mode (headed by default)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CDP_ENDPOINT",
        "description": "CDP endpoint to connect to",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "USER_DATA_DIR",
        "description": "Path to the user data directory",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "EXECUTABLE_PATH",
        "description": "Path to the browser executable",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "mikechao-brave-search-mcp",
    "title": "Brave Search MCP",
    "description": "Brave Search MCP",
    "icon": "https://avatars.githubusercontent.com/mikechao",
    "isOfficial": false,
    "homepage": "https://github.com/mikechao/brave-search-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "brave-search-mcp"
      ],
      "env": {
        "BRAVE_API_KEY": "<brave-api-key>"
      }
    },
    "parameters": [
      {
        "name": "BRAVE_API_KEY",
        "description": "Your Brave Search API key generated from the developer dashboard",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "misanthropic-ai-ddg-mcp",
    "title": "DuckDuckGo MCP Server",
    "description": "A server that provides DuckDuckGo search capabilities (text, image, news, video search and AI chat) through the Model Context Protocol.",
    "icon": "https://avatars.githubusercontent.com/misanthropic-ai",
    "isOfficial": false,
    "homepage": "https://github.com/misanthropic-ai/ddg-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "ddg-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "ddg-text-search",
        "description": "Search the web for text results using DuckDuckGo",
        "inputSchema": {
          "type": "object",
          "properties": {
            "region": {
              "type": "string",
              "default": "wt-wt",
              "description": "Region code (e.g., wt-wt, us-en, uk-en)"
            },
            "keywords": {
              "type": "string",
              "description": "Search query keywords"
            },
            "timelimit": {
              "enum": [
                "d",
                "w",
                "m",
                "y"
              ],
              "type": "string",
              "description": "Time limit (d=day, w=week, m=month, y=year)"
            },
            "safesearch": {
              "enum": [
                "on",
                "moderate",
                "off"
              ],
              "type": "string",
              "default": "moderate",
              "description": "Safe search level"
            },
            "max_results": {
              "type": "integer",
              "default": 10,
              "description": "Maximum number of results to return"
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "ddg-image-search",
        "description": "Search the web for images using DuckDuckGo",
        "inputSchema": {
          "type": "object",
          "properties": {
            "size": {
              "enum": [
                "Small",
                "Medium",
                "Large",
                "Wallpaper"
              ],
              "type": "string",
              "description": "Image size"
            },
            "color": {
              "enum": [
                "color",
                "Monochrome",
                "Red",
                "Orange",
                "Yellow",
                "Green",
                "Blue",
                "Purple",
                "Pink",
                "Brown",
                "Black",
                "Gray",
                "Teal",
                "White"
              ],
              "type": "string",
              "description": "Image color"
            },
            "layout": {
              "enum": [
                "Square",
                "Tall",
                "Wide"
              ],
              "type": "string",
              "description": "Image layout"
            },
            "region": {
              "type": "string",
              "default": "wt-wt",
              "description": "Region code (e.g., wt-wt, us-en, uk-en)"
            },
            "keywords": {
              "type": "string",
              "description": "Search query keywords"
            },
            "timelimit": {
              "enum": [
                "d",
                "w",
                "m",
                "y"
              ],
              "type": "string",
              "description": "Time limit (d=day, w=week, m=month, y=year)"
            },
            "safesearch": {
              "enum": [
                "on",
                "moderate",
                "off"
              ],
              "type": "string",
              "default": "moderate",
              "description": "Safe search level"
            },
            "type_image": {
              "enum": [
                "photo",
                "clipart",
                "gif",
                "transparent",
                "line"
              ],
              "type": "string",
              "description": "Image type"
            },
            "max_results": {
              "type": "integer",
              "default": 10,
              "description": "Maximum number of results to return"
            },
            "license_image": {
              "enum": [
                "any",
                "Public",
                "Share",
                "ShareCommercially",
                "Modify",
                "ModifyCommercially"
              ],
              "type": "string",
              "description": "Image license type"
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "ddg-news-search",
        "description": "Search for news articles using DuckDuckGo",
        "inputSchema": {
          "type": "object",
          "properties": {
            "region": {
              "type": "string",
              "default": "wt-wt",
              "description": "Region code (e.g., wt-wt, us-en, uk-en)"
            },
            "keywords": {
              "type": "string",
              "description": "Search query keywords"
            },
            "timelimit": {
              "enum": [
                "d",
                "w",
                "m"
              ],
              "type": "string",
              "description": "Time limit (d=day, w=week, m=month)"
            },
            "safesearch": {
              "enum": [
                "on",
                "moderate",
                "off"
              ],
              "type": "string",
              "default": "moderate",
              "description": "Safe search level"
            },
            "max_results": {
              "type": "integer",
              "default": 10,
              "description": "Maximum number of results to return"
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "ddg-video-search",
        "description": "Search for videos using DuckDuckGo",
        "inputSchema": {
          "type": "object",
          "properties": {
            "region": {
              "type": "string",
              "default": "wt-wt",
              "description": "Region code (e.g., wt-wt, us-en, uk-en)"
            },
            "duration": {
              "enum": [
                "short",
                "medium",
                "long"
              ],
              "type": "string",
              "description": "Video duration"
            },
            "keywords": {
              "type": "string",
              "description": "Search query keywords"
            },
            "timelimit": {
              "enum": [
                "d",
                "w",
                "m"
              ],
              "type": "string",
              "description": "Time limit (d=day, w=week, m=month)"
            },
            "resolution": {
              "enum": [
                "high",
                "standard"
              ],
              "type": "string",
              "description": "Video resolution"
            },
            "safesearch": {
              "enum": [
                "on",
                "moderate",
                "off"
              ],
              "type": "string",
              "default": "moderate",
              "description": "Safe search level"
            },
            "max_results": {
              "type": "integer",
              "default": 10,
              "description": "Maximum number of results to return"
            },
            "license_videos": {
              "enum": [
                "creativeCommon",
                "youtube"
              ],
              "type": "string",
              "description": "Video license type"
            }
          },
          "required": [
            "keywords"
          ]
        }
      },
      {
        "name": "ddg-ai-chat",
        "description": "Chat with DuckDuckGo AI",
        "inputSchema": {
          "type": "object",
          "properties": {
            "model": {
              "enum": [
                "gpt-4o-mini",
                "llama-3.3-70b",
                "claude-3-haiku",
                "o3-mini",
                "mistral-small-3"
              ],
              "type": "string",
              "default": "gpt-4o-mini",
              "description": "AI model to use"
            },
            "keywords": {
              "type": "string",
              "description": "Message or question to send to the AI"
            }
          },
          "required": [
            "keywords"
          ]
        }
      }
    ]
  },
  {
    "name": "misanthropic-ai-playwrite-mcp",
    "title": "Playwright MCP",
    "description": "Playwright wrapper for MCP that enables LLM-powered clients to control a browser for automation tasks.",
    "icon": "https://avatars.githubusercontent.com/misanthropic-ai",
    "isOfficial": false,
    "homepage": "https://github.com/misanthropic-ai/playwrite-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "playwright-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "navigate",
        "description": "Navigate to a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            },
            "page_id": {
              "type": "string"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "click",
        "description": "Click on an element by selector",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string"
            },
            "selector": {
              "type": "string"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "type",
        "description": "Type text into an input element",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string"
            },
            "page_id": {
              "type": "string"
            },
            "selector": {
              "type": "string"
            }
          },
          "required": [
            "selector",
            "text"
          ]
        }
      },
      {
        "name": "get_text",
        "description": "Get text content from an element",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string"
            },
            "selector": {
              "type": "string"
            }
          },
          "required": [
            "selector"
          ]
        }
      },
      {
        "name": "get_page_content",
        "description": "Get the current page HTML content",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "take_screenshot",
        "description": "Take a screenshot of the current page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string"
            },
            "selector": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "new_page",
        "description": "Create a new browser page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string"
            }
          },
          "required": [
            "page_id"
          ]
        }
      },
      {
        "name": "switch_page",
        "description": "Switch to a different browser page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string"
            }
          },
          "required": [
            "page_id"
          ]
        }
      },
      {
        "name": "get_pages",
        "description": "List all available browser pages",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "wait_for_selector",
        "description": "Wait for an element to be visible on the page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string"
            },
            "timeout": {
              "type": "number"
            },
            "selector": {
              "type": "string"
            }
          },
          "required": [
            "selector"
          ]
        }
      }
    ]
  },
  {
    "name": "mk965-asset-price-mcp",
    "title": "Asset Price MCP Server",
    "description": "A server that provides tools for retrieving real-time price information for various assets including precious metals and cryptocurrencies, allowing language models to access and display current asset price data.",
    "icon": "https://avatars.githubusercontent.com/mk965",
    "isOfficial": false,
    "homepage": "https://github.com/mk965/asset-price-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "asset-price-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_asset_price",
        "description": "Retrieves current pricing information for various assets including precious metals and cryptocurrencies",
        "inputSchema": {
          "type": "object",
          "properties": {
            "random_string": {
              "type": "string",
              "description": "Dummy parameter for no-parameter tools"
            }
          }
        }
      }
    ]
  },
  {
    "name": "mobile-next-mobile-mcp",
    "title": "Mobile Next MCP Server",
    "description": "A Model Context Protocol server that enables scalable mobile automation through a platform-agnostic interface for iOS and Android devices, allowing agents and LLMs to interact with mobile applications using accessibility snapshots or coordinate-based interactions.",
    "icon": "https://avatars.githubusercontent.com/mobile-next",
    "isOfficial": true,
    "homepage": "https://github.com/mobile-next/mobile-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@mobilenext/mobile-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "mobile_list_available_devices",
        "description": "List all available devices. This includes both physical devices and simulators. If there is more than one device returned, you need to let the user select one of them.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "mobile_use_device",
        "description": "Select a device to use. This can be a simulator or an Android device. Use the list_available_devices tool to get a list of available devices.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "device": {
              "type": "string",
              "description": "The name of the device to select"
            },
            "deviceType": {
              "enum": [
                "simulator",
                "ios",
                "android"
              ],
              "type": "string",
              "description": "The type of device to select"
            }
          },
          "required": [
            "device",
            "deviceType"
          ]
        }
      },
      {
        "name": "mobile_list_apps",
        "description": "List all the installed apps on the device",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "mobile_launch_app",
        "description": "Launch an app on mobile device. Use this to open a specific app. You can find the package name of the app by calling list_apps_on_device.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "packageName": {
              "type": "string",
              "description": "The package name of the app to launch"
            }
          },
          "required": [
            "packageName"
          ]
        }
      },
      {
        "name": "mobile_terminate_app",
        "description": "Stop and terminate an app on mobile device",
        "inputSchema": {
          "type": "object",
          "properties": {
            "packageName": {
              "type": "string",
              "description": "The package name of the app to terminate"
            }
          },
          "required": [
            "packageName"
          ]
        }
      },
      {
        "name": "mobile_get_screen_size",
        "description": "Get the screen size of the mobile device in pixels",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "mobile_click_on_screen_at_coordinates",
        "description": "Click on the screen at given x,y coordinates",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "description": "The x coordinate to click on the screen, in pixels"
            },
            "y": {
              "type": "number",
              "description": "The y coordinate to click on the screen, in pixels"
            }
          },
          "required": [
            "x",
            "y"
          ]
        }
      },
      {
        "name": "mobile_list_elements_on_screen",
        "description": "List elements on screen and their coordinates, with display text or accessibility label. Do not cache this result.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "mobile_press_button",
        "description": "Press a button on device",
        "inputSchema": {
          "type": "object",
          "properties": {
            "button": {
              "type": "string",
              "description": "The button to press. Supported buttons: BACK (android only), HOME, VOLUME_UP, VOLUME_DOWN, ENTER, DPAD_CENTER (android tv only), DPAD_UP (android tv only), DPAD_DOWN (android tv only), DPAD_LEFT (android tv only), DPAD_RIGHT (android tv only)"
            }
          },
          "required": [
            "button"
          ]
        }
      },
      {
        "name": "mobile_open_url",
        "description": "Open a URL in browser on device",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to open"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "swipe_on_screen",
        "description": "Swipe on the screen",
        "inputSchema": {
          "type": "object",
          "properties": {
            "direction": {
              "enum": [
                "up",
                "down"
              ],
              "type": "string",
              "description": "The direction to swipe"
            }
          },
          "required": [
            "direction"
          ]
        }
      },
      {
        "name": "mobile_type_keys",
        "description": "Type text into the focused element",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "description": "The text to type"
            },
            "submit": {
              "type": "boolean",
              "description": "Whether to submit the text. If true, the text will be submitted as if the user pressed the enter key."
            }
          },
          "required": [
            "text",
            "submit"
          ]
        }
      },
      {
        "name": "mobile_take_screenshot",
        "description": "Take a screenshot of the mobile device. Use this to understand what's on screen, if you need to press an element that is available through view hierarchy then you must list elements on screen instead. Do not cache this result.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "mobile_set_orientation",
        "description": "Change the screen orientation of the device",
        "inputSchema": {
          "type": "object",
          "properties": {
            "orientation": {
              "enum": [
                "portrait",
                "landscape"
              ],
              "type": "string",
              "description": "The desired orientation"
            }
          },
          "required": [
            "orientation"
          ]
        }
      },
      {
        "name": "mobile_get_orientation",
        "description": "Get the current screen orientation of the device",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "motherduckdb-mcp-server-motherduck",
    "title": "mcp-server-motherduck",
    "description": "An MCP server for MotherDuck and local DuckDB.",
    "icon": "https://avatars.githubusercontent.com/motherduckdb",
    "isOfficial": true,
    "homepage": "https://github.com/motherduckdb/mcp-server-motherduck",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-motherduck"
      ],
      "env": {
        "HOME": "<home>",
        "motherduck_token": "<motherduck-token>"
      }
    },
    "parameters": [
      {
        "name": "HOME",
        "description": "Your home folder path (needed by DuckDB)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "motherduck_token",
        "description": "Your MotherDuck access token for authenticating to MotherDuck",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "initialize-connection",
        "description": "Create a connection to either a local DuckDB or MotherDuck and retrieve available databases",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "description": "Type of the database, either 'DuckDB' or 'MotherDuck'"
            }
          },
          "required": [
            "type"
          ]
        }
      },
      {
        "name": "read-schemas",
        "description": "Get table schemas from a specific DuckDB/MotherDuck database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "description": "name of the database",
              "database_name": "string"
            }
          },
          "required": [
            "database_name"
          ]
        }
      },
      {
        "name": "execute-query",
        "description": "Execute a query on the MotherDuck (DuckDB) database",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "SQL query to execute"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "mzxrai-mcp-openai",
    "title": "MCP OpenAI Server",
    "description": "A Model Context Protocol (MCP) server that lets you seamlessly use OpenAI's models right from Claude.",
    "icon": "https://avatars.githubusercontent.com/mzxrai",
    "isOfficial": false,
    "homepage": "https://github.com/mzxrai/mcp-openai",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@mzxrai/mcp-openai"
      ],
      "env": {
        "OPENAI_API_KEY": "<openai-api-key>"
      }
    },
    "parameters": [
      {
        "name": "OPENAI_API_KEY",
        "description": "Your OpenAI API key (get one from https://platform.openai.com/api-keys)",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "openai_chat",
        "description": "Use this tool when a user specifically requests to use one of OpenAI's models (gpt-4o, gpt-4o-mini, o1-preview, o1-mini). This tool sends messages to OpenAI's chat completion API using the specified model.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "model": {
              "enum": [
                "gpt-4o",
                "gpt-4o-mini",
                "o1-preview",
                "o1-mini"
              ],
              "type": "string",
              "default": "gpt-4o",
              "description": "Model to use for completion (gpt-4o, gpt-4o-mini, o1-preview, o1-mini)"
            },
            "messages": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "role",
                  "content"
                ],
                "properties": {
                  "role": {
                    "enum": [
                      "system",
                      "user",
                      "assistant"
                    ],
                    "type": "string",
                    "description": "Role of the message sender"
                  },
                  "content": {
                    "type": "string",
                    "description": "Content of the message"
                  }
                }
              },
              "description": "Array of messages to send to the API"
            }
          },
          "required": [
            "messages"
          ]
        }
      }
    ]
  },
  {
    "name": "mzxrai-mcp-webresearch",
    "title": "MCP Web Research Server",
    "description": "A Model Context Protocol (MCP) server for web research. Bring real-time info into Claude and easily research any topic.",
    "icon": "https://avatars.githubusercontent.com/mzxrai",
    "isOfficial": false,
    "homepage": "https://github.com/mzxrai/mcp-webresearch",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@mzxrai/mcp-webresearch"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "nacal-mcp-minecraft-remote",
    "title": "MCP Minecraft Remote",
    "description": "Allows AI assistants to connect to and control Minecraft players on remote servers, enabling navigation, building, mining, inventory management, entity interaction, and chat communication through natural language commands.",
    "icon": "https://avatars.githubusercontent.com/nacal",
    "isOfficial": false,
    "homepage": "https://github.com/nacal/mcp-minecraft-remote",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-minecraft-remote"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "connectToServer",
        "description": "Connect to a Minecraft server with the specified credentials",
        "inputSchema": {
          "type": "object",
          "properties": {
            "host": {
              "type": "string",
              "description": "Minecraft server host address"
            },
            "port": {
              "type": "number",
              "default": 25565,
              "description": "Minecraft server port"
            },
            "version": {
              "type": "string",
              "description": "Minecraft version"
            },
            "password": {
              "type": "string",
              "description": "Minecraft password (if using premium account)"
            },
            "username": {
              "type": "string",
              "description": "Minecraft username"
            }
          },
          "required": [
            "host",
            "username"
          ]
        }
      },
      {
        "name": "disconnectFromServer",
        "description": "Disconnect from the Minecraft server",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "sendChat",
        "description": "Send a chat message to the Minecraft server",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "Message to send to the server"
            }
          },
          "required": [
            "message"
          ]
        }
      },
      {
        "name": "getPosition",
        "description": "Get the current position of the player in the Minecraft world",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "moveTo",
        "description": "Move the player to a specific location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "description": "X coordinate"
            },
            "y": {
              "type": "number",
              "description": "Y coordinate"
            },
            "z": {
              "type": "number",
              "description": "Z coordinate"
            }
          },
          "required": [
            "x",
            "y",
            "z"
          ]
        }
      },
      {
        "name": "moveControl",
        "description": "Control the player with basic movement commands",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "enum": [
                "forward",
                "back",
                "left",
                "right",
                "jump",
                "sprint",
                "sneak",
                "stop"
              ],
              "type": "string",
              "description": "Movement action to perform"
            },
            "duration": {
              "type": "number",
              "default": 1,
              "description": "Duration to perform the action in seconds"
            }
          },
          "required": [
            "action"
          ]
        }
      },
      {
        "name": "lookAt",
        "description": "Make the player look in a specific direction or at coordinates",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "description": "X coordinate to look at"
            },
            "y": {
              "type": "number",
              "description": "Y coordinate to look at"
            },
            "z": {
              "type": "number",
              "description": "Z coordinate to look at"
            }
          },
          "required": [
            "x",
            "y",
            "z"
          ]
        }
      },
      {
        "name": "digBlock",
        "description": "Dig a block at the specified coordinates",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "description": "X coordinate"
            },
            "y": {
              "type": "number",
              "description": "Y coordinate"
            },
            "z": {
              "type": "number",
              "description": "Z coordinate"
            }
          },
          "required": [
            "x",
            "y",
            "z"
          ]
        }
      },
      {
        "name": "placeBlock",
        "description": "Place a block at the specified location",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "description": "X coordinate"
            },
            "y": {
              "type": "number",
              "description": "Y coordinate"
            },
            "z": {
              "type": "number",
              "description": "Z coordinate"
            },
            "itemName": {
              "type": "string",
              "description": "Name of the item to place"
            }
          },
          "required": [
            "x",
            "y",
            "z",
            "itemName"
          ]
        }
      },
      {
        "name": "getNearbyPlayers",
        "description": "Get a list of players nearby",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getServerInfo",
        "description": "Get information about the currently connected server",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "checkInventory",
        "description": "Check the items in the player inventory",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "equipItem",
        "description": "Equip an item from inventory to hand or armor slot",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemName": {
              "type": "string",
              "description": "Name of the item to equip"
            },
            "destination": {
              "enum": [
                "hand",
                "head",
                "torso",
                "legs",
                "feet"
              ],
              "type": "string",
              "default": "hand",
              "description": "Slot to equip the item to"
            }
          },
          "required": [
            "itemName"
          ]
        }
      },
      {
        "name": "inventoryDetails",
        "description": "Get detailed information about inventory items",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "tossItem",
        "description": "Throw items from inventory",
        "inputSchema": {
          "type": "object",
          "properties": {
            "amount": {
              "type": "number",
              "default": 1,
              "description": "Amount of items to throw"
            },
            "itemName": {
              "type": "string",
              "description": "Name of the item to throw"
            }
          },
          "required": [
            "itemName"
          ]
        }
      },
      {
        "name": "getNearbyEntities",
        "description": "Get a list of all entities nearby",
        "inputSchema": {
          "type": "object",
          "properties": {
            "range": {
              "type": "number",
              "default": 10,
              "description": "Range in blocks to search for entities"
            }
          }
        }
      },
      {
        "name": "attackEntity",
        "description": "Attack a specific entity",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entityId": {
              "type": "number",
              "description": "ID of the entity to attack"
            }
          },
          "required": [
            "entityId"
          ]
        }
      },
      {
        "name": "useOnEntity",
        "description": "Use held item on a specific entity",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entityId": {
              "type": "number",
              "description": "ID of the entity to use item on"
            }
          },
          "required": [
            "entityId"
          ]
        }
      },
      {
        "name": "followEntity",
        "description": "Follow a specific entity",
        "inputSchema": {
          "type": "object",
          "properties": {
            "distance": {
              "type": "number",
              "default": 2,
              "description": "Distance to maintain while following"
            },
            "entityId": {
              "type": "number",
              "description": "ID of the entity to follow"
            }
          },
          "required": [
            "entityId"
          ]
        }
      },
      {
        "name": "openContainer",
        "description": "Open a container (chest, furnace, etc.) at specific coordinates",
        "inputSchema": {
          "type": "object",
          "properties": {
            "x": {
              "type": "number",
              "description": "X coordinate of the container"
            },
            "y": {
              "type": "number",
              "description": "Y coordinate of the container"
            },
            "z": {
              "type": "number",
              "description": "Z coordinate of the container"
            }
          },
          "required": [
            "x",
            "y",
            "z"
          ]
        }
      },
      {
        "name": "withdrawItem",
        "description": "Take items from an open container",
        "inputSchema": {
          "type": "object",
          "properties": {
            "amount": {
              "type": "number",
              "default": 1,
              "description": "Amount of items to withdraw"
            },
            "itemName": {
              "type": "string",
              "description": "Name of the item to withdraw"
            }
          },
          "required": [
            "itemName"
          ]
        }
      },
      {
        "name": "depositItem",
        "description": "Put items into an open container",
        "inputSchema": {
          "type": "object",
          "properties": {
            "amount": {
              "type": "number",
              "default": 1,
              "description": "Amount of items to deposit"
            },
            "itemName": {
              "type": "string",
              "description": "Name of the item to deposit"
            }
          },
          "required": [
            "itemName"
          ]
        }
      },
      {
        "name": "closeContainer",
        "description": "Close the currently open container",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getRecipes",
        "description": "Get a list of available crafting recipes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filter": {
              "type": "string",
              "description": "Filter recipes by item name"
            }
          }
        }
      },
      {
        "name": "craftItem",
        "description": "Craft an item using available materials",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "default": 1,
              "description": "Number of items to craft"
            },
            "itemName": {
              "type": "string",
              "description": "Name of the item to craft"
            }
          },
          "required": [
            "itemName"
          ]
        }
      },
      {
        "name": "listTrades",
        "description": "List available trades from a nearby villager",
        "inputSchema": {
          "type": "object",
          "properties": {
            "range": {
              "type": "number",
              "default": 4,
              "description": "Range to search for villagers"
            },
            "villagerName": {
              "type": "string",
              "description": "Name or identifier of the villager (optional)"
            }
          }
        }
      },
      {
        "name": "tradeWithVillager",
        "description": "Trade with a nearby villager",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "type": "number",
              "default": 1,
              "description": "Number of times to perform the trade"
            },
            "tradeIndex": {
              "type": "number",
              "description": "Index of the trade from listTrades (1-based)"
            },
            "villagerName": {
              "type": "string",
              "description": "Name or identifier of the villager (optional)"
            }
          },
          "required": [
            "tradeIndex"
          ]
        }
      }
    ]
  },
  {
    "name": "ndchikin-reference-mcp",
    "title": "cite-mcp",
    "description": "Retrieve citation data effortlessly from CiteAs and Google Scholar. Get BibTeX-formatted citations for your resources with just a few commands. Enhance your research workflow by integrating citation retrieval directly into your applications.",
    "icon": "https://avatars.githubusercontent.com/ndchikin",
    "isOfficial": false,
    "homepage": "https://github.com/ndchikin/reference-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "reference-mcp"
      ],
      "env": {
        "UV_PUBLISH_TOKEN": "<uv-publish-token>",
        "UV_PUBLISH_PASSWORD": "<uv-publish-password>",
        "UV_PUBLISH_USERNAME": "<uv-publish-username>"
      }
    },
    "parameters": [
      {
        "name": "UV_PUBLISH_TOKEN",
        "description": "Your PyPI token for publishing",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "UV_PUBLISH_PASSWORD",
        "description": "Your PyPI password for publishing",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "UV_PUBLISH_USERNAME",
        "description": "Your PyPI username for publishing",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get_citeas_data",
        "description": "Retrieve BibTeX-formatted citation for the specified `resource` (e.g., DOI, URL, keyword) from the CiteAs",
        "inputSchema": {
          "type": "object",
          "properties": {
            "resource": {
              "type": "string",
              "title": "Resource"
            }
          },
          "required": [
            "resource"
          ]
        }
      },
      {
        "name": "get_scholar_data",
        "description": "Retrieve `results` BibTeX-formatted citations for publications matching the `query` from the Google Scholar",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            },
            "results": {
              "type": "integer",
              "title": "Results",
              "default": 2
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "nickclyde-duckduckgo-mcp-server",
    "title": "DuckDuckGo MCP Server",
    "description": "A Model Context Protocol (MCP) server that provides web search capabilities through DuckDuckGo, with additional features for content fetching and parsing.",
    "icon": "https://avatars.githubusercontent.com/nickclyde",
    "isOfficial": false,
    "homepage": "https://github.com/nickclyde/duckduckgo-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "duckduckgo-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "search",
        "description": "\n    Search DuckDuckGo and return formatted results.\n\n    Args:\n        query: The search query string\n        max_results: Maximum number of results to return (default: 10)\n        ctx: MCP context for logging\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            },
            "max_results": {
              "type": "integer",
              "title": "Max Results",
              "default": 10
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "fetch_content",
        "description": "\n    Fetch and parse content from a webpage URL.\n\n    Args:\n        url: The webpage URL to fetch content from\n        ctx: MCP context for logging\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "title": "Url"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "pipeboard-co-meta-ads-mcp",
    "title": "Meta Ads MCP",
    "description": "A Model Context Protocol server that allows AI models to access, analyze, and manage Meta advertising campaigns, enabling LLMs to retrieve performance data, visualize ad creatives, and provide strategic insights for Facebook and Instagram platforms.",
    "icon": "https://avatars.githubusercontent.com/pipeboard-co",
    "isOfficial": false,
    "homepage": "https://github.com/pipeboard-co/meta-ads-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "meta-ads-mcp"
      ],
      "env": {
        "META_APP_ID": "<meta-app-id>",
        "PIPEBOARD_API_TOKEN": "<pipeboard-api-token>"
      }
    },
    "parameters": [
      {
        "name": "META_APP_ID",
        "description": "Your Meta App ID (Client ID) - for direct OAuth method",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "PIPEBOARD_API_TOKEN",
        "description": "Your Pipeboard API token for Meta Ads authentication. Token obtainable via https://pipeboard.co",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "nloui-paperless-mcp",
    "title": "Paperless-NGX MCP Server",
    "description": "Enables interaction with Paperless-NGX API servers, supporting document management, tagging, and metadata operations through a natural language interface.",
    "icon": "https://avatars.githubusercontent.com/nloui",
    "isOfficial": false,
    "homepage": "https://github.com/nloui/paperless-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@nloui/paperless-mcp"
      ],
      "env": {
        "PAPERLESS_URL": "<paperless-url>",
        "PAPERLESS_API_TOKEN": "<paperless-api-token>"
      }
    },
    "parameters": [
      {
        "name": "PAPERLESS_URL",
        "description": "URL to your Paperless-NGX instance (e.g., http://your-paperless-instance:8000)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "PAPERLESS_API_TOKEN",
        "description": "Your Paperless-NGX API token generated from the user profile",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "noahlozevski-mcp-idb",
    "title": "MCP-IDB",
    "description": "Integration between Model Context Protocol (MCP) and Facebook's iOS Development Bridge (idb), enabling automated iOS device management and test execution through natural language.",
    "icon": "https://avatars.githubusercontent.com/noahlozevski",
    "isOfficial": false,
    "homepage": "https://github.com/noahlozevski/mcp-idb",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@noahlozevski/mcp-idb"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "idb",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "The IDB command to execute (e.g., list-apps, screenshot, etc.).\n- For a full list of commands, run 'idb help'.\n- For help with a specific command, run 'idb <command> --help'.\n\nTo interact with the device (simulator):\nIMPORTANT: Always try using the 'idb ui describe-all' command to identify buttons before dispatching UI actions.\nIf that doesn't work, try using the following commands:\n  \n- **Tap**  \n  - **Command:** 'idb ui tap X Y [--duration DURATION]'\n  - **Description:** Simulates a tap at the given screen coordinates. Optionally, you can set the tap's duration.\n  \n- **Swipe**  \n  - **Command:** 'idb ui swipe X_START Y_START X_END Y_END [--delta STEP_SIZE]'\n  - **Description:** Simulates a swipe gesture from the start point to the end point. By default, the swipe moves in steps of 10 points; use '--delta' to change the step size.\n  \n- **Press a Button**  \n  - **Command:** 'idb ui button {APPLE_PAY, HOME, LOCK, SIDE_BUTTON, SIRI} [--duration DURATION]'\n  - **Description:** Simulates pressing a specified hardware button. The press duration can be adjusted with the '--duration' flag.\n  \n- **Inputting Text**  \n  - **Command:** 'idb ui text \"some text\"'\n  - **Description:** Types the provided text string into the target device.\n  \n- **Key Events**  \n  - **Single Key:** 'idb ui key KEYCODE [--duration DURATION]'\n  - **Key Sequence:** 'idb ui key-sequence KEYCODE1 KEYCODE2 ...'\n  - **Description:** Simulates key press events. Use the single key command for one key press (with an optional duration) or the key sequence command for multiple sequential key events.\n\n**Frame and Coordinates in idb ui describe-all:**\nThe output from 'idb ui describe-all' provides detailed layout information for each UI element. Each element includes a 'frame' object with:\n- **x and y:** The coordinates of the element's top-left corner relative to the device screen.\n- **width and height:** The dimensions of the element.\nAdditionally, an 'AXFrame' string presents this data in a human-readable format like '{{x, y}, {width, height}}'.\nThese values allow you to determine an element's position—commonly by calculating its center (x + width/2, y + height/2) for precise interactions. For instance, in the sample output, the \"More, tab, 4 of 4\" button has a frame starting at x=330, y=876.33 with a width of 110 and height of 45.67. A tap command such as 'idb ui tap 375 880' (which targets near the element's center) successfully triggers the button.\n"
            },
            "options": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional arguments for the IDB command"
            }
          },
          "required": [
            "command"
          ]
        }
      }
    ]
  },
  {
    "name": "normal-coder-gitee-mcp-server",
    "title": "Gitee",
    "description": "MCP Tool Server for Gitee, supporting the management of repository files/branches, Issues, and Pull Requests.",
    "icon": "https://avatars.githubusercontent.com/normal-coder",
    "isOfficial": false,
    "homepage": "https://github.com/normal-coder/gitee-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "gitee-mcp-server"
      ],
      "env": {
        "GITEE_API_BASE_URL": "<gitee-api-base-url>",
        "GITEE_PERSONAL_ACCESS_TOKEN": "<gitee-personal-access-token>"
      }
    },
    "parameters": [
      {
        "name": "GITEE_API_BASE_URL",
        "description": "Gitee OpenAPI Endpoint",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GITEE_PERSONAL_ACCESS_TOKEN",
        "description": "Gitee account personal access token (PAT), can be obtained from Gitee account settings Personal Access Tokens",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "create_repository",
        "description": "创建 Gitee 仓库",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Repository name"
            },
            "path": {
              "type": "string",
              "description": "Repository path"
            },
            "private": {
              "type": "boolean",
              "default": false,
              "description": "Whether the repository is private"
            },
            "has_wiki": {
              "type": "boolean",
              "default": true,
              "description": "Whether to enable Wiki functionality"
            },
            "homepage": {
              "type": "string",
              "description": "Homepage URL"
            },
            "auto_init": {
              "type": "boolean",
              "default": false,
              "description": "Whether to automatically initialize the repository"
            },
            "has_issues": {
              "type": "boolean",
              "default": true,
              "description": "Whether to enable Issue functionality"
            },
            "description": {
              "type": "string",
              "description": "Repository description"
            },
            "license_template": {
              "type": "string",
              "description": "License template"
            },
            "gitignore_template": {
              "type": "string",
              "description": "Git Ignore template"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "fork_repository",
        "description": "Fork Gitee 仓库",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "organization": {
              "type": "string",
              "description": "Organization path, defaults to personal account if not provided"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "create_branch",
        "description": "在 Gitee 仓库中创建一个新分支",
        "inputSchema": {
          "type": "object",
          "properties": {
            "refs": {
              "type": "string",
              "default": "master",
              "description": "Source reference for the branch, default: master"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "branch_name": {
              "type": "string",
              "description": "Name for the new branch"
            }
          },
          "required": [
            "owner",
            "repo",
            "branch_name"
          ]
        }
      },
      {
        "name": "list_branches",
        "description": "列出 Gitee 仓库中的分支",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "default": 1,
              "description": "Page number"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "sort": {
              "enum": [
                "name",
                "updated"
              ],
              "type": "string",
              "default": "name",
              "description": "Sort field"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Number of items per page, maximum 100"
            },
            "direction": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "default": "asc",
              "description": "Sort direction"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "get_branch",
        "description": "获取 Gitee 仓库中的特定分支信息",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "branch": {
              "type": "string",
              "description": "Branch name"
            }
          },
          "required": [
            "owner",
            "repo",
            "branch"
          ]
        }
      },
      {
        "name": "get_file_contents",
        "description": "获取 Gitee 仓库中文件或目录的内容",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "File path"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "branch": {
              "type": "string",
              "description": "Branch name, defaults to the repository's default branch"
            }
          },
          "required": [
            "owner",
            "repo",
            "path"
          ]
        }
      },
      {
        "name": "create_or_update_file",
        "description": "在 Gitee 仓库中创建或更新文件",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sha": {
              "type": "string",
              "description": "File SHA, required when updating an existing file"
            },
            "path": {
              "type": "string",
              "description": "File path"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "branch": {
              "type": "string",
              "description": "Branch name, defaults to the repository's default branch"
            },
            "content": {
              "type": "string",
              "description": "File content"
            },
            "message": {
              "type": "string",
              "description": "Commit message"
            }
          },
          "required": [
            "owner",
            "repo",
            "path",
            "content",
            "message"
          ]
        }
      },
      {
        "name": "push_files",
        "description": "向 Gitee 仓库提交多个文件",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "files": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "path",
                  "content"
                ],
                "properties": {
                  "path": {
                    "type": "string",
                    "description": "File path"
                  },
                  "content": {
                    "type": "string",
                    "description": "File content"
                  }
                },
                "additionalProperties": false
              },
              "description": "List of files to commit"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "branch": {
              "type": "string",
              "description": "Branch name, defaults to the repository's default branch"
            },
            "message": {
              "type": "string",
              "description": "Commit message"
            }
          },
          "required": [
            "owner",
            "repo",
            "message",
            "files"
          ]
        }
      },
      {
        "name": "create_issue",
        "description": "在 Gitee 仓库中创建 Issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "description": "Issue content"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "title": {
              "type": "string",
              "description": "Issue title"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Labels"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Users assigned to the issue"
            },
            "milestone": {
              "type": "number",
              "description": "Milestone ID"
            },
            "security_hole": {
              "type": "boolean",
              "description": "Whether the issue is private, default is false"
            }
          },
          "required": [
            "owner",
            "repo",
            "title"
          ]
        }
      },
      {
        "name": "list_issues",
        "description": "列出 Gitee 仓库中的 Issues",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "default": 1,
              "description": "Page number"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "sort": {
              "enum": [
                "created",
                "updated",
                "comments"
              ],
              "type": "string",
              "default": "created",
              "description": "Sort field"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "state": {
              "enum": [
                "open",
                "closed",
                "all"
              ],
              "type": "string",
              "default": "open",
              "description": "Issue state"
            },
            "labels": {
              "type": "string",
              "description": "Labels, multiple labels separated by commas"
            },
            "creator": {
              "type": "string",
              "description": "Filter issues created by a specific user"
            },
            "program": {
              "type": "string",
              "description": "Filter issues for a specific program"
            },
            "assignee": {
              "type": "string",
              "description": "Filter issues assigned to a specific user"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Number of items per page, maximum 100"
            },
            "direction": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "default": "desc",
              "description": "Sort direction"
            },
            "milestone": {
              "type": "number",
              "description": "Milestone ID"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "get_issue",
        "description": "获取 Gitee 仓库中的特定 Issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "issue_number": {
              "type": [
                "number",
                "string"
              ],
              "description": "Issue number"
            }
          },
          "required": [
            "owner",
            "repo",
            "issue_number"
          ]
        }
      },
      {
        "name": "update_issue",
        "description": "更新 Gitee 仓库中的 Issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "description": "Issue content"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "state": {
              "enum": [
                "open",
                "closed",
                "progressing"
              ],
              "type": "string",
              "description": "Issue state"
            },
            "title": {
              "type": "string",
              "description": "Issue title"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Labels"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Users assigned to the issue"
            },
            "milestone": {
              "type": "number",
              "description": "Milestone ID"
            },
            "issue_number": {
              "type": [
                "number",
                "string"
              ],
              "description": "Issue number"
            }
          },
          "required": [
            "owner",
            "repo",
            "issue_number"
          ]
        }
      },
      {
        "name": "add_issue_comment",
        "description": "向 Gitee 仓库中的 Issue 添加评论",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "description": "Comment content"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "issue_number": {
              "type": [
                "number",
                "string"
              ],
              "description": "Issue number"
            }
          },
          "required": [
            "owner",
            "repo",
            "issue_number",
            "body"
          ]
        }
      },
      {
        "name": "create_pull_request",
        "description": "在 Gitee 仓库中创建 Pull Request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "base": {
              "type": "string",
              "description": "Target branch name"
            },
            "body": {
              "type": "string",
              "description": "Pull Request content"
            },
            "head": {
              "type": "string",
              "description": "Source branch name"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "issue": {
              "type": "string",
              "description": "Related issue, format: #xxx"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "title": {
              "type": "string",
              "description": "Pull Request title"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Labels"
            },
            "testers": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Testers"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Reviewers"
            },
            "milestone_number": {
              "type": "number",
              "description": "Milestone number"
            },
            "prune_source_branch": {
              "type": "boolean",
              "description": "Whether to delete the source branch after merging"
            }
          },
          "required": [
            "owner",
            "repo",
            "title",
            "head",
            "base"
          ]
        }
      },
      {
        "name": "list_pull_requests",
        "description": "列出 Gitee 仓库中的 Pull Requests",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "default": 1,
              "description": "Page number"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "sort": {
              "enum": [
                "created",
                "updated",
                "popularity",
                "long-running"
              ],
              "type": "string",
              "default": "created",
              "description": "Sort field"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "state": {
              "enum": [
                "open",
                "closed",
                "merged",
                "all"
              ],
              "type": "string",
              "default": "open",
              "description": "Pull Request state"
            },
            "labels": {
              "type": "string",
              "description": "Labels, multiple labels separated by commas"
            },
            "per_page": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Number of items per page, maximum 100"
            },
            "direction": {
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string",
              "default": "desc",
              "description": "Sort direction"
            },
            "milestone": {
              "type": "number",
              "description": "Milestone ID"
            }
          },
          "required": [
            "owner",
            "repo"
          ]
        }
      },
      {
        "name": "get_pull_request",
        "description": "获取 Gitee 仓库中的特定 Pull Request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull Request number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "update_pull_request",
        "description": "更新 Gitee 仓库中的 Pull Request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "description": "Pull Request content"
            },
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "state": {
              "enum": [
                "open",
                "closed"
              ],
              "type": "string",
              "description": "Pull Request state"
            },
            "title": {
              "type": "string",
              "description": "Pull Request title"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Labels"
            },
            "testers": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Testers"
            },
            "assignees": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Reviewers"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull Request number"
            },
            "milestone_number": {
              "type": "number",
              "description": "Milestone number"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "merge_pull_request",
        "description": "合并 Gitee 仓库中的 Pull Request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "string",
              "description": "Repository path"
            },
            "owner": {
              "type": "string",
              "description": "Repository owner path (enterprise, organization, or personal path)"
            },
            "pull_number": {
              "type": "number",
              "description": "Pull Request number"
            },
            "merge_method": {
              "enum": [
                "merge",
                "squash",
                "rebase"
              ],
              "type": "string",
              "default": "merge",
              "description": "Merge method"
            },
            "prune_source_branch": {
              "type": "boolean",
              "description": "Whether to delete the source branch after merging"
            }
          },
          "required": [
            "owner",
            "repo",
            "pull_number"
          ]
        }
      },
      {
        "name": "get_user",
        "description": "获取 Gitee 用户信息",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "description": "Username"
            }
          },
          "required": [
            "username"
          ]
        }
      },
      {
        "name": "get_current_user",
        "description": "获取当前认证的 Gitee 用户信息",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "novitalabs-novita-mcp-server",
    "title": "Novita MCP Server",
    "description": "An MCP server that enables seamless management of Novita AI platform resources, currently supporting GPU instance operations (list, create, start, stop, etc.) through compatible clients like Claude Desktop and Cursor.",
    "icon": "https://avatars.githubusercontent.com/novitalabs",
    "isOfficial": true,
    "homepage": "https://github.com/novitalabs/novita-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@novitalabs/novita-mcp-server"
      ],
      "env": {
        "NOVITA_API_KEY": "<novita-api-key>"
      }
    },
    "parameters": [
      {
        "name": "NOVITA_API_KEY",
        "description": "Your Novita API key from the Novita AI Key Management",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "list-clusters",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list-products",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clusterId": {
              "type": "string",
              "description": "ID of the cluster to list products from. You can use the `list-clusters` tool to get the cluster ID."
            },
            "productName": {
              "type": "string",
              "description": "Name of the product to filter by."
            }
          }
        }
      },
      {
        "name": "list-gpu-instances",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "maxLength": 1024,
              "description": "Filter by the instance name"
            },
            "status": {
              "enum": [
                "running",
                "pulling",
                "exited",
                "resetting",
                "removed",
                "migrating",
                "freezing"
              ],
              "type": "string",
              "description": "Filter by the instance status"
            },
            "pageSize": {
              "type": "number",
              "default": 10,
              "minimum": 0,
              "description": "Number of instances to return, "
            },
            "pageNumber": {
              "type": "number",
              "default": 1,
              "minimum": 0,
              "description": "Page number to return, start from "
            },
            "productName": {
              "type": "string",
              "description": "Filter by the product name"
            }
          }
        }
      },
      {
        "name": "get-gpu-instance",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instanceId": {
              "type": "string",
              "description": "ID of the instance to retrieve"
            }
          },
          "required": [
            "instanceId"
          ]
        }
      },
      {
        "name": "create-gpu-instance",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "env": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "key",
                  "value"
                ],
                "properties": {
                  "key": {
                    "type": "string",
                    "maxLength": 2048,
                    "minLength": 1,
                    "description": "Environment variable key"
                  },
                  "value": {
                    "type": "string",
                    "maxLength": 2048,
                    "description": "Environment variable value"
                  }
                },
                "additionalProperties": false
              },
              "description": "Environment variables"
            },
            "kind": {
              "enum": [
                "gpu"
              ],
              "type": "string",
              "default": "gpu",
              "description": "Type of the instance"
            },
            "name": {
              "type": "string",
              "maxLength": 255,
              "description": "Name for the instance. Must contain only numbers, letters, and hyphens"
            },
            "ports": {
              "type": "string",
              "description": "Ports to expose (e.g., '8888/http', '22/tcp'), separated by commas if multiple. Maximum of 10 ports."
            },
            "gpuNum": {
              "type": "number",
              "minimum": 1,
              "description": "Number of GPUs allocated to the instance. The availableGpuNumber of the product must be greater than or equal to the gpuNum."
            },
            "command": {
              "type": "string",
              "maxLength": 2048,
              "description": "Container start command to run when the instance starts"
            },
            "imageUrl": {
              "type": "string",
              "maxLength": 500,
              "minLength": 1,
              "description": "Docker image URL to initialize the instance"
            },
            "productId": {
              "type": "string",
              "minLength": 1,
              "description": "ID of the product used to deploy the instance. The availableGpuNumber of the product must be greater than 0. You can use the `list-products` tool to get or check the product ID if needed. Before calling the MCP tool, MUST show me the details of the product to help me identify it, including name, price, etc."
            },
            "rootfsSize": {
              "type": "number",
              "minimum": 10,
              "description": "Root filesystem size (container disk size) in GB. Free tier includes 60GB."
            },
            "imageAuthId": {
              "type": "string",
              "description": "ID of the container registry auth. Required only when the imageUrl is private. You can use the `list-container-registry-auths` tool to check the ID if you're not sure."
            },
            "networkStorages": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "Id",
                  "mountPoint"
                ],
                "properties": {
                  "Id": {
                    "type": "string",
                    "minLength": 1,
                    "description": "ID of the network storage to mount. You can use the `list-network-storage` tool to get or check the ID if needed. The network storage's cluster must match the product's cluster."
                  },
                  "mountPoint": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Path to mount the network storage"
                  }
                },
                "additionalProperties": false
              },
              "description": "Network storages to mount"
            }
          },
          "required": [
            "name",
            "productId",
            "gpuNum",
            "rootfsSize",
            "imageUrl"
          ]
        }
      },
      {
        "name": "start-gpu-instance",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instanceId": {
              "type": "string",
              "description": "ID of the instance to start"
            }
          },
          "required": [
            "instanceId"
          ]
        }
      },
      {
        "name": "stop-gpu-instance",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instanceId": {
              "type": "string",
              "description": "ID of the instance to stop. Before calling the MCP tool to stop the instance, MUST show me the details of the instance to help me identify it, including id, name, etc."
            }
          },
          "required": [
            "instanceId"
          ]
        }
      },
      {
        "name": "delete-gpu-instance",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instanceId": {
              "type": "string",
              "description": "ID of the instance to delete. Before calling the MCP tool to delete the instance, MUST show me the details of the instance to help me identify it, including id, name, etc."
            }
          },
          "required": [
            "instanceId"
          ]
        }
      },
      {
        "name": "restart-gpu-instance",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "instanceId": {
              "type": "string",
              "description": "ID of the instance to restart. Before calling the MCP tool to restart the instance, MUST show me the details of the instance to help me identify it, including id, name, etc."
            }
          },
          "required": [
            "instanceId"
          ]
        }
      },
      {
        "name": "create-network-storage",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clusterId": {
              "type": "string",
              "description": "The ID of the cluster to create network storage. Must be from the `list-clusters` tool result, and the cluster must have supportNetworkStorage set to true"
            },
            "storageName": {
              "type": "string",
              "minLength": 1,
              "description": "Name for the network storage. Use only letters, numbers, and hyphens"
            },
            "storageSize": {
              "type": "number",
              "minimum": 10,
              "description": "Size of the network storage in GB"
            }
          },
          "required": [
            "clusterId",
            "storageName",
            "storageSize"
          ]
        }
      },
      {
        "name": "list-network-storage",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pageNo": {
              "type": "number",
              "default": 1,
              "minimum": 0,
              "description": "Page number"
            },
            "pageSize": {
              "type": "number",
              "default": 10,
              "minimum": 0,
              "description": "Page size"
            },
            "storageId": {
              "type": "string",
              "description": "ID for the network storage"
            },
            "storageName": {
              "type": "string",
              "description": "Name for the network storage"
            }
          }
        }
      },
      {
        "name": "update-network-storage",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "storageId": {
              "type": "string",
              "minLength": 1,
              "description": "The unique ID of the network storage to update. Please ensure it exists before updating."
            },
            "storageName": {
              "type": "string",
              "description": "New name for the network storage. This is optional, if not provided, the name will not be changed. Use only letters, numbers, and hyphens"
            },
            "storageSize": {
              "type": "number",
              "minimum": 10,
              "description": "New size in GB (must be larger than current size). You can use the `list-network-storage` tool to get the current size if you don't know it."
            }
          },
          "required": [
            "storageId",
            "storageSize"
          ]
        }
      },
      {
        "name": "delete-network-storage",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "storageId": {
              "type": "string",
              "minLength": 1,
              "description": "The unique ID of the network storage to delete. Please ensure it exists before updating."
            }
          },
          "required": [
            "storageId"
          ]
        }
      },
      {
        "name": "list-container-registry-auths",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create-container-registry-auth",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "maxLength": 255,
              "minLength": 1,
              "description": "Name for the container registry auth."
            },
            "password": {
              "type": "string",
              "maxLength": 1024,
              "minLength": 1,
              "description": "Registry password."
            },
            "username": {
              "type": "string",
              "maxLength": 511,
              "minLength": 1,
              "description": "Registry username."
            }
          },
          "required": [
            "name",
            "username",
            "password"
          ]
        }
      },
      {
        "name": "delete-container-registry-auth",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "minLength": 1,
              "description": "ID of the container registry auth to delete. Please ensure it exists before deleting. Before calling the MCP tool, please show me the name to help identify it. You can use the `list-container-registry-auths` tool to check the ID if needed."
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list-templates",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "instance",
                "serverless"
              ],
              "type": "string",
              "description": "Type of template to return"
            },
            "channel": {
              "type": "array",
              "items": {
                "enum": [
                  "private",
                  "community",
                  "official"
                ],
                "type": "string"
              },
              "description": "Channels of template to return"
            },
            "pageNum": {
              "type": "number",
              "default": 1,
              "minimum": 0,
              "description": "Page number to return, start from 1"
            },
            "pageSize": {
              "type": "number",
              "default": 20,
              "minimum": 0,
              "description": "Number of templates to return in each page"
            }
          }
        }
      },
      {
        "name": "get-template",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "templateId": {
              "type": "string",
              "description": "ID of the template to retrieve"
            }
          },
          "required": [
            "templateId"
          ]
        }
      },
      {
        "name": "create-template",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "template": {
              "type": "object",
              "required": [
                "name",
                "image",
                "rootfsSize",
                "ports"
              ],
              "properties": {
                "env": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "key",
                      "value"
                    ],
                    "properties": {
                      "key": {
                        "type": "string",
                        "maxLength": 2048,
                        "minLength": 1,
                        "description": "Environment variable key"
                      },
                      "value": {
                        "type": "string",
                        "maxLength": 2048,
                        "description": "Environment variable value"
                      }
                    },
                    "additionalProperties": false
                  },
                  "description": "Environment variables"
                },
                "name": {
                  "type": "string",
                  "minLength": 2,
                  "description": "Name for the template, must be unique."
                },
                "type": {
                  "enum": [
                    "instance",
                    "serverless"
                  ],
                  "type": "string",
                  "default": "instance",
                  "description": "Type of template"
                },
                "image": {
                  "type": "string",
                  "maxLength": 500,
                  "minLength": 1,
                  "description": "Docker image address for instance startup"
                },
                "ports": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "type",
                      "ports"
                    ],
                    "properties": {
                      "type": {
                        "enum": [
                          "http",
                          "udp",
                          "tcp"
                        ],
                        "type": "string",
                        "description": "Type of exposed port"
                      },
                      "ports": {
                        "type": "array",
                        "items": {
                          "type": "number",
                          "maximum": 65535,
                          "minimum": 1,
                          "description": "Exposed port numbers, maximum of 10"
                        },
                        "maxItems": 10,
                        "description": "Exposed port numbers, maximum of 10"
                      }
                    },
                    "additionalProperties": false
                  },
                  "description": "Ports to expose"
                },
                "readme": {
                  "type": "string",
                  "maxLength": 20480,
                  "description": "Template README content (in Markdown format)"
                },
                "channel": {
                  "enum": [
                    "private",
                    "community"
                  ],
                  "type": "string",
                  "default": "private",
                  "description": "Channel for the template"
                },
                "imageAuth": {
                  "type": "string",
                  "description": "ID of the container registry auth. Required only when the channel is private, or else keep it empty. You can use the `list-container-registry-auths` tool to check the ID if you're not sure."
                },
                "rootfsSize": {
                  "type": "number",
                  "minimum": 10,
                  "description": "Root filesystem size (/Container disk size) in GB"
                },
                "startCommand": {
                  "type": "string",
                  "maxLength": 2047,
                  "description": "Command to run when the instance starts"
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "template"
          ]
        }
      },
      {
        "name": "delete-template",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "templateId": {
              "type": "string",
              "minLength": 1,
              "description": "ID of the template to delete. Please ensure it exists before deleting. Before calling the MCP tool, please show me the name to help identify it. You can use the `get-template` tool to check the ID if needed."
            }
          },
          "required": [
            "templateId"
          ]
        }
      }
    ]
  },
  {
    "name": "oxylabs-oxylabs-mcp",
    "title": "Oxylabs MCP Server",
    "description": "A scraper tool that leverages the Oxylabs Web Scraper API to fetch and process web content with flexible options for parsing and rendering pages, enabling efficient content extraction from complex websites.",
    "icon": "https://avatars.githubusercontent.com/oxylabs",
    "isOfficial": true,
    "homepage": "https://github.com/oxylabs/oxylabs-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "oxylabs-mcp"
      ],
      "env": {
        "OXYLABS_PASSWORD": "<oxylabs-password>",
        "OXYLABS_USERNAME": "<oxylabs-username>"
      }
    },
    "parameters": [
      {
        "name": "OXYLABS_PASSWORD",
        "description": "Your Oxylabs account password",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "OXYLABS_USERNAME",
        "description": "Your Oxylabs account username",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "universal_scraper",
        "description": "Get a content of any webpage.\n\n    Supports browser rendering, parsing of certain webpages\n    and different output formats.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "title": "Url",
              "description": "Website url to scrape."
            },
            "render": {
              "enum": [
                "",
                "html"
              ],
              "type": "string",
              "title": "Render",
              "default": "",
              "examples": [
                "",
                "html"
              ],
              "description": "\n        Whether a headless browser should be used to render the page.\n        For example:\n            - 'html' when browser is required to render the page.\n        "
            },
            "geo_location": {
              "type": "string",
              "title": "Geo Location",
              "default": "",
              "examples": [
                "US",
                "DE",
                "FR"
              ],
              "description": "\n        The geographical location that the result should be adapted for.\n        Use ISO-3166 country codes.\n        Examples:\n            - 'California, United States'\n            - 'Mexico'\n            - 'US' for United States\n            - 'DE' for Germany\n            - 'FR' for France\n        "
            },
            "output_format": {
              "enum": [
                "",
                "links",
                "md",
                "html"
              ],
              "type": "string",
              "title": "Output Format",
              "default": "",
              "description": "\n        The format of the output. Works only when parse parameter is false.\n            - links - Most efficient when the goal is navigation or finding specific URLs. Use this first when you need to locate a specific page within a website.\n            - md - Best for extracting and reading visible content once you've found the right page. Use this to get structured content that's easy to read and process.\n            - html - Should be used sparingly only when you need the raw HTML structure, JavaScript code, or styling information.\n        "
            },
            "user_agent_type": {
              "enum": [
                "",
                "desktop",
                "desktop_chrome",
                "desktop_firefox",
                "desktop_safari",
                "desktop_edge",
                "desktop_opera",
                "mobile",
                "mobile_ios",
                "mobile_android",
                "tablet"
              ],
              "type": "string",
              "title": "User Agent Type",
              "default": "",
              "description": "Device type and browser that will be used to determine User-Agent header value."
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "google_search_scraper",
        "description": "Scrape Google Search results.\n\n    Supports content parsing, different user agent types, pagination,\n    domain, geolocation, locale parameters and different output formats.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 0,
              "description": "Number of results to retrieve in each page."
            },
            "pages": {
              "type": "integer",
              "title": "Pages",
              "default": 0,
              "description": "Number of pages to retrieve."
            },
            "parse": {
              "type": "boolean",
              "title": "Parse",
              "default": true,
              "description": "Should result be parsed. If the result is not parsed, the output_format parameter is applied."
            },
            "query": {
              "type": "string",
              "title": "Query",
              "description": "URL-encoded keyword to search for."
            },
            "domain": {
              "type": "string",
              "title": "Domain",
              "default": "",
              "examples": [
                "uk",
                "us",
                "fr"
              ],
              "description": "\n        Domain localization for Google.\n        Use country top level domains.\n        For example:\n            - 'co.uk' for United Kingdom\n            - 'us' for United States\n            - 'fr' for France\n        "
            },
            "locale": {
              "type": "string",
              "title": "Locale",
              "default": "",
              "examples": [
                "en-US",
                "de-AT",
                "fr-FR"
              ],
              "description": "\n        Set 'Accept-Language' header value which changes your Google search page web interface language.\n        Examples:\n            - 'en-US' for English, United States\n            - 'de-AT' for German, Austria\n            - 'fr-FR' for French, France\n        "
            },
            "render": {
              "enum": [
                "",
                "html"
              ],
              "type": "string",
              "title": "Render",
              "default": "",
              "examples": [
                "",
                "html"
              ],
              "description": "\n        Whether a headless browser should be used to render the page.\n        For example:\n            - 'html' when browser is required to render the page.\n        "
            },
            "ad_mode": {
              "type": "boolean",
              "title": "Ad Mode",
              "default": false,
              "description": "If true will use the Google Ads source optimized for the paid ads."
            },
            "start_page": {
              "type": "integer",
              "title": "Start Page",
              "default": 0,
              "description": "Starting page number."
            },
            "geo_location": {
              "type": "string",
              "title": "Geo Location",
              "default": "",
              "examples": [
                "US",
                "DE",
                "FR"
              ],
              "description": "\n        The geographical location that the result should be adapted for.\n        Use ISO-3166 country codes.\n        Examples:\n            - 'California, United States'\n            - 'Mexico'\n            - 'US' for United States\n            - 'DE' for Germany\n            - 'FR' for France\n        "
            },
            "output_format": {
              "enum": [
                "",
                "links",
                "md",
                "html"
              ],
              "type": "string",
              "title": "Output Format",
              "default": "",
              "description": "\n        The format of the output. Works only when parse parameter is false.\n            - links - Most efficient when the goal is navigation or finding specific URLs. Use this first when you need to locate a specific page within a website.\n            - md - Best for extracting and reading visible content once you've found the right page. Use this to get structured content that's easy to read and process.\n            - html - Should be used sparingly only when you need the raw HTML structure, JavaScript code, or styling information.\n        "
            },
            "user_agent_type": {
              "enum": [
                "",
                "desktop",
                "desktop_chrome",
                "desktop_firefox",
                "desktop_safari",
                "desktop_edge",
                "desktop_opera",
                "mobile",
                "mobile_ios",
                "mobile_android",
                "tablet"
              ],
              "type": "string",
              "title": "User Agent Type",
              "default": "",
              "description": "Device type and browser that will be used to determine User-Agent header value."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "amazon_search_scraper",
        "description": "Scrape Amazon search results.\n\n    Supports content parsing, different user agent types, pagination,\n    domain, geolocation, locale parameters and different output formats.\n    Supports Amazon specific parameters such as category id, merchant id, currency.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pages": {
              "type": "integer",
              "title": "Pages",
              "default": 0,
              "description": "Number of pages to retrieve."
            },
            "parse": {
              "type": "boolean",
              "title": "Parse",
              "default": true,
              "description": "Should result be parsed. If the result is not parsed, the output_format parameter is applied."
            },
            "query": {
              "type": "string",
              "title": "Query",
              "description": "Keyword to search for."
            },
            "domain": {
              "type": "string",
              "title": "Domain",
              "default": "",
              "examples": [
                "uk",
                "us",
                "fr"
              ],
              "description": "\n        Domain localization for Google.\n        Use country top level domains.\n        For example:\n            - 'co.uk' for United Kingdom\n            - 'us' for United States\n            - 'fr' for France\n        "
            },
            "locale": {
              "type": "string",
              "title": "Locale",
              "default": "",
              "examples": [
                "en-US",
                "de-AT",
                "fr-FR"
              ],
              "description": "\n        Set 'Accept-Language' header value which changes your Google search page web interface language.\n        Examples:\n            - 'en-US' for English, United States\n            - 'de-AT' for German, Austria\n            - 'fr-FR' for French, France\n        "
            },
            "render": {
              "enum": [
                "",
                "html"
              ],
              "type": "string",
              "title": "Render",
              "default": "",
              "examples": [
                "",
                "html"
              ],
              "description": "\n        Whether a headless browser should be used to render the page.\n        For example:\n            - 'html' when browser is required to render the page.\n        "
            },
            "currency": {
              "type": "string",
              "title": "Currency",
              "default": "",
              "examples": [
                "USD",
                "EUR",
                "AUD"
              ],
              "description": "Currency that will be used to display the prices."
            },
            "start_page": {
              "type": "integer",
              "title": "Start Page",
              "default": 0,
              "description": "Starting page number."
            },
            "category_id": {
              "type": "string",
              "title": "Category Id",
              "default": "",
              "description": "Search for items in a particular browse node (product category)."
            },
            "merchant_id": {
              "type": "string",
              "title": "Merchant Id",
              "default": "",
              "description": "Search for items sold by a particular seller."
            },
            "geo_location": {
              "type": "string",
              "title": "Geo Location",
              "default": "",
              "examples": [
                "US",
                "DE",
                "FR"
              ],
              "description": "\n        The geographical location that the result should be adapted for.\n        Use ISO-3166 country codes.\n        Examples:\n            - 'California, United States'\n            - 'Mexico'\n            - 'US' for United States\n            - 'DE' for Germany\n            - 'FR' for France\n        "
            },
            "output_format": {
              "enum": [
                "",
                "links",
                "md",
                "html"
              ],
              "type": "string",
              "title": "Output Format",
              "default": "",
              "description": "\n        The format of the output. Works only when parse parameter is false.\n            - links - Most efficient when the goal is navigation or finding specific URLs. Use this first when you need to locate a specific page within a website.\n            - md - Best for extracting and reading visible content once you've found the right page. Use this to get structured content that's easy to read and process.\n            - html - Should be used sparingly only when you need the raw HTML structure, JavaScript code, or styling information.\n        "
            },
            "user_agent_type": {
              "enum": [
                "",
                "desktop",
                "desktop_chrome",
                "desktop_firefox",
                "desktop_safari",
                "desktop_edge",
                "desktop_opera",
                "mobile",
                "mobile_ios",
                "mobile_android",
                "tablet"
              ],
              "type": "string",
              "title": "User Agent Type",
              "default": "",
              "description": "Device type and browser that will be used to determine User-Agent header value."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "amazon_product_scraper",
        "description": "Scrape Amazon products.\n\n    Supports content parsing, different user agent types, domain,\n    geolocation, locale parameters and different output formats.\n    Supports Amazon specific parameters such as currency and getting\n    more accurate pricing data with auto select variant.\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "parse": {
              "type": "boolean",
              "title": "Parse",
              "default": true,
              "description": "Should result be parsed. If the result is not parsed, the output_format parameter is applied."
            },
            "query": {
              "type": "string",
              "title": "Query",
              "description": "Keyword to search for."
            },
            "domain": {
              "type": "string",
              "title": "Domain",
              "default": "",
              "examples": [
                "uk",
                "us",
                "fr"
              ],
              "description": "\n        Domain localization for Google.\n        Use country top level domains.\n        For example:\n            - 'co.uk' for United Kingdom\n            - 'us' for United States\n            - 'fr' for France\n        "
            },
            "locale": {
              "type": "string",
              "title": "Locale",
              "default": "",
              "examples": [
                "en-US",
                "de-AT",
                "fr-FR"
              ],
              "description": "\n        Set 'Accept-Language' header value which changes your Google search page web interface language.\n        Examples:\n            - 'en-US' for English, United States\n            - 'de-AT' for German, Austria\n            - 'fr-FR' for French, France\n        "
            },
            "render": {
              "enum": [
                "",
                "html"
              ],
              "type": "string",
              "title": "Render",
              "default": "",
              "examples": [
                "",
                "html"
              ],
              "description": "\n        Whether a headless browser should be used to render the page.\n        For example:\n            - 'html' when browser is required to render the page.\n        "
            },
            "currency": {
              "type": "string",
              "title": "Currency",
              "default": "",
              "examples": [
                "USD",
                "EUR",
                "AUD"
              ],
              "description": "Currency that will be used to display the prices."
            },
            "geo_location": {
              "type": "string",
              "title": "Geo Location",
              "default": "",
              "examples": [
                "US",
                "DE",
                "FR"
              ],
              "description": "\n        The geographical location that the result should be adapted for.\n        Use ISO-3166 country codes.\n        Examples:\n            - 'California, United States'\n            - 'Mexico'\n            - 'US' for United States\n            - 'DE' for Germany\n            - 'FR' for France\n        "
            },
            "output_format": {
              "enum": [
                "",
                "links",
                "md",
                "html"
              ],
              "type": "string",
              "title": "Output Format",
              "default": "",
              "description": "\n        The format of the output. Works only when parse parameter is false.\n            - links - Most efficient when the goal is navigation or finding specific URLs. Use this first when you need to locate a specific page within a website.\n            - md - Best for extracting and reading visible content once you've found the right page. Use this to get structured content that's easy to read and process.\n            - html - Should be used sparingly only when you need the raw HTML structure, JavaScript code, or styling information.\n        "
            },
            "user_agent_type": {
              "enum": [
                "",
                "desktop",
                "desktop_chrome",
                "desktop_firefox",
                "desktop_safari",
                "desktop_edge",
                "desktop_opera",
                "mobile",
                "mobile_ios",
                "mobile_android",
                "tablet"
              ],
              "type": "string",
              "title": "User Agent Type",
              "default": "",
              "description": "Device type and browser that will be used to determine User-Agent header value."
            },
            "autoselect_variant": {
              "type": "boolean",
              "title": "Autoselect Variant",
              "default": false,
              "description": "To get accurate pricing/buybox data, set this parameter to true."
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "pebbletek-cribl-mcp",
    "title": "cribl-mcp",
    "description": "This server acts as a MCP bridge to interact with the Cribl REST API. It allows AI models or other MCP clients to query and manage Cribl configurations.",
    "icon": "https://avatars.githubusercontent.com/pebbletek",
    "isOfficial": false,
    "homepage": "https://github.com/pebbletek/cribl-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@pebbletek/cribl-mcp"
      ],
      "env": {
        "CRIBL_BASE_URL": "<cribl-base-url>",
        "CRIBL_AUTH_TYPE": "<cribl-auth-type>",
        "CRIBL_CLIENT_ID": "<cribl-client-id>",
        "CRIBL_CLIENT_SECRET": "<cribl-client-secret>"
      }
    },
    "parameters": [
      {
        "name": "CRIBL_BASE_URL",
        "description": "The base URL of your Cribl cloud instance",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "CRIBL_AUTH_TYPE",
        "description": "The authentication type to use (e.g., cloud)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "CRIBL_CLIENT_ID",
        "description": "The client ID for authentication",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "CRIBL_CLIENT_SECRET",
        "description": "The client secret for authentication",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "cribl_listWorkerGroups",
        "description": "Lists available worker groups in the Cribl deployment, optionally filtered by product type (stream, edge, search, or all).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "productType": {
              "enum": [
                "stream",
                "edge",
                "search",
                "all"
              ],
              "type": "string",
              "default": "stream",
              "description": "Filter groups by product type (stream, edge, search, all). Defaults to stream."
            }
          }
        }
      },
      {
        "name": "cribl_getPipelines",
        "description": "Fetches pipeline definitions in a specified worker group.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "groupName": {
              "type": "string",
              "description": "Optional: The name of the Worker Group/Fleet. If omitted, defaults to attempting to use Cribl Stream and if only one group exists for Stream, it will use that sole group."
            }
          }
        }
      },
      {
        "name": "cribl_getSources",
        "description": "Fetches source configurations in a specified worker group.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "groupName": {
              "type": "string",
              "description": "Optional: The name of the Worker Group/Fleet. If omitted, defaults to attempting to use Cribl Stream and if only one group exists for Stream, it will use that sole group."
            }
          }
        }
      },
      {
        "name": "cribl_getPipelineConfig",
        "description": "Retrieves full configuration JSON for a specified pipeline in a worker group.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "groupName": {
              "type": "string",
              "description": "Optional: The name of the Worker Group/Fleet. If omitted, defaults to attempting to use Cribl Stream and if only one group exists for Stream, it will use that sole group."
            },
            "pipelineId": {
              "type": "string",
              "description": "The ID of the pipeline to retrieve configuration for."
            }
          },
          "required": [
            "pipelineId"
          ]
        }
      },
      {
        "name": "cribl_setPipelineConfig",
        "description": "Applies a new configuration payload to a specified pipeline in a worker group.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "config": {
              "type": "object",
              "properties": {},
              "description": "The pipeline configuration payload expected by the API, typically structured as { id: 'pipeline-id', conf: { ... actual config ... } }. Note: 'pipelineId' argument is used for URL, but API might require it in body too.",
              "additionalProperties": true
            },
            "groupName": {
              "type": "string",
              "description": "Optional: The name of the Worker Group/Fleet. If omitted, defaults to attempting to use Cribl Stream and if only one group exists for Stream, it will use that sole group."
            },
            "pipelineId": {
              "type": "string",
              "description": "The ID of the pipeline to configure."
            }
          },
          "required": [
            "pipelineId",
            "config"
          ]
        }
      },
      {
        "name": "cribl_restartWorkerGroup",
        "description": "Restarts all workers within the default or specified worker group.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "cribl_getSystemMetrics",
        "description": "Retrieves system metrics from the Cribl deployment. \nIMPORTANT: To avoid excessively large responses, please use the optional parameters (filterExpr, metricNameFilter, earliest, latest, numBuckets, wp) to narrow down your query whenever possible. \nIf no parameters are provided, the server will default to fetching only the most recent data bucket (numBuckets=1) to prevent performance issues.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "wp": {
              "anyOf": [
                {
                  "anyOf": [
                    {
                      "not": {}
                    },
                    {
                      "type": "string"
                    }
                  ]
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional: Worker process filter."
            },
            "latest": {
              "anyOf": [
                {
                  "anyOf": [
                    {
                      "not": {}
                    },
                    {
                      "type": "string"
                    }
                  ]
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional: End time for the query (e.g., 'now', '2023-10-26T10:15:00Z')."
            },
            "earliest": {
              "anyOf": [
                {
                  "anyOf": [
                    {
                      "not": {}
                    },
                    {
                      "type": "string"
                    }
                  ]
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional: Start time for the query (e.g., '-15m', '2023-10-26T10:00:00Z')."
            },
            "filterExpr": {
              "anyOf": [
                {
                  "anyOf": [
                    {
                      "not": {}
                    },
                    {
                      "type": "string"
                    }
                  ]
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional: A JS expression to filter metrics (e.g., \"model.pipeline === 'test'\" or \"host == 'myhost'\")."
            },
            "numBuckets": {
              "anyOf": [
                {
                  "anyOf": [
                    {
                      "not": {}
                    },
                    {
                      "type": "integer"
                    }
                  ]
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional: The number of time buckets for aggregation."
            },
            "metricNameFilter": {
              "anyOf": [
                {
                  "anyOf": [
                    {
                      "not": {}
                    },
                    {
                      "type": "string"
                    }
                  ]
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional: Regex or array of metric names (e.g.,limit to \"pipe.*\" , \"total.in_bytes\", or \"os.cpu.perc,os.mem.*\")."
            }
          }
        }
      }
    ]
  },
  {
    "name": "peng-shawn-mermaid-mcp-server",
    "title": "mermaid-mcp-server",
    "description": "A Model Context Protocol (MCP) server that converts Mermaid diagrams to PNG images.",
    "icon": "https://avatars.githubusercontent.com/peng-shawn",
    "isOfficial": false,
    "homepage": "https://github.com/peng-shawn/mermaid-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@peng-shawn/mermaid-mcp-server"
      ],
      "env": {
        "CONTENT_IMAGE_SUPPORTED": "<content-image-supported>"
      }
    },
    "parameters": [
      {
        "name": "CONTENT_IMAGE_SUPPORTED",
        "description": "Controls whether images are returned directly in the response or saved to disk. If true (default), images are returned directly in the response. If false, images are saved to disk, requiring name and folder parameters.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "generate",
        "description": "Generate PNG image from mermaid markdown",
        "inputSchema": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "The mermaid markdown to generate an image from"
            },
            "name": {
              "type": "string",
              "description": "Name of the diagram (optional)"
            },
            "theme": {
              "enum": [
                "default",
                "forest",
                "dark",
                "neutral"
              ],
              "type": "string",
              "description": "Theme for the diagram (optional)"
            },
            "folder": {
              "type": "string",
              "description": "Absolute path to save the image to (optional)"
            },
            "backgroundColor": {
              "type": "string",
              "description": "Background color for the diagram, e.g. 'white', 'transparent', '#F0F0F0' (optional)"
            }
          },
          "required": [
            "code"
          ]
        }
      }
    ]
  },
  {
    "name": "pinkpixel-dev-blabber-mcp",
    "title": "Blabber-MCP",
    "description": "An MCP server that enables LLMs to generate spoken audio from text using OpenAI's Text-to-Speech API, supporting various voices, models, and audio formats.",
    "icon": "https://avatars.githubusercontent.com/pinkpixel-dev",
    "isOfficial": false,
    "homepage": "https://github.com/pinkpixel-dev/blabber-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@pinkpixel/blabber-mcp"
      ],
      "env": {
        "OPENAI_API_KEY": "<openai-api-key>",
        "DEFAULT_TTS_VOICE": "<default-tts-voice>",
        "AUDIO_PLAYER_COMMAND": "<audio-player-command>"
      }
    },
    "parameters": [
      {
        "name": "OPENAI_API_KEY",
        "description": "Your API key from OpenAI",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "DEFAULT_TTS_VOICE",
        "description": "Set default voice (alloy, echo, fable, onyx, nova, shimmer)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "AUDIO_PLAYER_COMMAND",
        "description": "Command to play audio (e.g., \"cvlc\", \"vlc\", \"mpv\", \"ffplay\", \"afplay\", \"xdg-open\")",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "text_to_speech",
        "description": "Converts text into spoken audio using OpenAI TTS (default voice: nova), saves it to a file, and optionally plays it.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "play": {
              "type": "boolean",
              "default": false,
              "description": "Whether to automatically play the generated audio file."
            },
            "input": {
              "type": "string",
              "description": "The text to synthesize into speech."
            },
            "model": {
              "enum": [
                "tts-1",
                "tts-1-hd"
              ],
              "type": "string",
              "default": "tts-1",
              "description": "The TTS model to use."
            },
            "voice": {
              "enum": [
                "alloy",
                "echo",
                "fable",
                "onyx",
                "nova",
                "shimmer"
              ],
              "type": "string",
              "description": "Optional: The voice to use. Overrides the configured default (nova)."
            },
            "response_format": {
              "enum": [
                "mp3",
                "opus",
                "aac",
                "flac"
              ],
              "type": "string",
              "default": "mp3",
              "description": "The format of the audio response."
            }
          },
          "required": [
            "input"
          ]
        }
      }
    ]
  },
  {
    "name": "pinkpixel-dev-deep-research-mcp",
    "title": "Deep Research MCP Server",
    "description": "A Model Context Protocol server that performs comprehensive web research by combining Tavily Search and Crawl APIs to gather extensive information and provide structured JSON output tailored for LLMs to create detailed markdown documents.",
    "icon": "https://avatars.githubusercontent.com/pinkpixel-dev",
    "isOfficial": false,
    "homepage": "https://github.com/pinkpixel-dev/deep-research-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@pinkpixel/deep-research-mcp"
      ],
      "env": {
        "CRAWL_LIMIT": "<crawl-limit>",
        "CRAWL_TIMEOUT": "<crawl-timeout>",
        "SEARCH_TIMEOUT": "<search-timeout>",
        "TAVILY_API_KEY": "<tavily-api-key>",
        "CRAWL_MAX_DEPTH": "<crawl-max-depth>",
        "FILE_WRITE_ENABLED": "<file-write-enabled>",
        "MAX_SEARCH_RESULTS": "<max-search-results>",
        "ALLOWED_WRITE_PATHS": "<allowed-write-paths>",
        "DOCUMENTATION_PROMPT": "<documentation-prompt>",
        "RESEARCH_OUTPUT_PATH": "<research-output-path>",
        "FILE_WRITE_LINE_LIMIT": "<file-write-line-limit>"
      }
    },
    "parameters": [
      {
        "name": "CRAWL_LIMIT",
        "description": "Maximum number of URLs to crawl per source",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CRAWL_TIMEOUT",
        "description": "Timeout in seconds for Tavily crawl requests",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "SEARCH_TIMEOUT",
        "description": "Timeout in seconds for Tavily search requests",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TAVILY_API_KEY",
        "description": "Your Tavily API key",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "CRAWL_MAX_DEPTH",
        "description": "Maximum crawl depth from base URL",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "FILE_WRITE_ENABLED",
        "description": "Enable file writing capability",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MAX_SEARCH_RESULTS",
        "description": "Maximum number of search results to retrieve",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ALLOWED_WRITE_PATHS",
        "description": "Comma-separated allowed directories for file writing",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DOCUMENTATION_PROMPT",
        "description": "Custom prompt for LLM documentation generation",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "RESEARCH_OUTPUT_PATH",
        "description": "Path where research documents and images should be saved",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "FILE_WRITE_LINE_LIMIT",
        "description": "Maximum lines per file write operation",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "deep-research-tool",
        "description": "Performs extensive web research using Tavily Search and Crawl. Returns aggregated JSON data including the query, search summary (if any), detailed research findings, and documentation instructions. The documentation instructions will guide you on how the user wants the research data to be formatted into markdown.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "days": {
              "type": "number",
              "description": "For 'news' topic: number of days back from current date to include results."
            },
            "query": {
              "type": "string",
              "description": "The main research topic or question."
            },
            "topic": {
              "enum": [
                "general",
                "news"
              ],
              "type": "string",
              "default": "general",
              "description": "Category for the Tavily search ('general' or 'news')."
            },
            "time_range": {
              "type": "string",
              "description": "Time range for search results (e.g., 'd' for day, 'w' for week, 'm' for month, 'y' for year)."
            },
            "crawl_limit": {
              "type": "number",
              "default": 10,
              "description": "Total links crawler will process per root URL (1-20). Can be set via CRAWL_LIMIT environment variable."
            },
            "search_depth": {
              "enum": [
                "basic",
                "advanced"
              ],
              "type": "string",
              "default": "advanced",
              "description": "Depth of the initial Tavily search ('basic' or 'advanced')."
            },
            "crawl_timeout": {
              "type": "number",
              "default": 180,
              "description": "Timeout in seconds for Tavily crawl requests. Can be set via CRAWL_TIMEOUT environment variable."
            },
            "include_answer": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "enum": [
                    "basic",
                    "advanced"
                  ],
                  "type": "string"
                }
              ],
              "default": false,
              "description": "Include an LLM-generated answer from Tavily search (true implies 'basic')."
            },
            "search_timeout": {
              "type": "number",
              "default": 60,
              "description": "Timeout in seconds for Tavily search requests. Can be set via SEARCH_TIMEOUT environment variable."
            },
            "crawl_max_depth": {
              "type": "number",
              "default": 1,
              "description": "Max crawl depth from base URL (1-2). Higher values increase processing time significantly. Can be set via CRAWL_MAX_DEPTH environment variable."
            },
            "crawl_categories": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Filter crawl URLs by categories (e.g., 'Blog', 'Documentation')."
            },
            "chunks_per_source": {
              "type": "number",
              "default": 3,
              "maximum": 3,
              "minimum": 1,
              "description": "For 'advanced' search: number of content chunks from each source (1-3)."
            },
            "crawl_max_breadth": {
              "type": "number",
              "default": 10,
              "description": "Max links to follow per page level during crawl (1-10)."
            },
            "crawl_instructions": {
              "type": "string",
              "description": "Natural language instructions for the crawler."
            },
            "crawl_select_paths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Regex for URLs paths to crawl (e.g., '/docs/.*')."
            },
            "max_search_results": {
              "type": "number",
              "default": 7,
              "maximum": 20,
              "minimum": 1,
              "description": "Max search results to retrieve for crawling (1-20). Can be set via MAX_SEARCH_RESULTS environment variable."
            },
            "crawl_exclude_paths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Regex for URL paths to exclude."
            },
            "crawl_extract_depth": {
              "enum": [
                "basic",
                "advanced"
              ],
              "type": "string",
              "default": "basic",
              "description": "Extraction depth for crawl ('basic' or 'advanced')."
            },
            "crawl_allow_external": {
              "type": "boolean",
              "default": false,
              "description": "Allow crawler to follow links to external domains."
            },
            "crawl_include_images": {
              "type": "boolean",
              "default": false,
              "description": "Extract image URLs from crawled pages."
            },
            "crawl_select_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Regex for domains/subdomains to crawl (e.g., '^docs\\.example\\.com$'). Overrides auto-domain focus."
            },
            "documentation_prompt": {
              "type": "string",
              "description": "Optional. Custom prompt for LLM documentation generation. Overrides 'DOCUMENTATION_PROMPT' env var and default. If none set, a comprehensive default is used."
            },
            "crawl_exclude_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Regex for domains/subdomains to exclude."
            },
            "hardware_acceleration": {
              "type": "boolean",
              "default": false,
              "description": "Try to use hardware acceleration (WebGPU) if available."
            },
            "include_search_images": {
              "type": "boolean",
              "default": false,
              "description": "Include image URLs from initial search results."
            },
            "exclude_domains_search": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "List of domains to specifically exclude from search."
            },
            "include_domains_search": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "List of domains to specifically include in search."
            },
            "include_raw_content_search": {
              "type": "boolean",
              "default": false,
              "description": "Include cleaned HTML from initial search results."
            },
            "include_search_image_descriptions": {
              "type": "boolean",
              "default": false,
              "description": "Include image descriptions from initial search results."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "write-research-file",
        "description": "Write research content to a file. This tool allows you to save research findings, documentation, or any text content to a specified file path.\n\n                    SECURITY: File writing is controlled by environment variables:\n                    - FILE_WRITE_ENABLED must be set to 'true' to enable file writing\n                    - ALLOWED_WRITE_PATHS can specify allowed directories (comma-separated)\n                    - If no ALLOWED_WRITE_PATHS specified, defaults to user's home directory\n                    - FILE_WRITE_LINE_LIMIT controls maximum lines per write operation (default: 200)\n\n                    Use this tool to save research reports, documentation, or any content generated from the deep-research-tool results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "mode": {
              "enum": [
                "rewrite",
                "append"
              ],
              "type": "string",
              "default": "rewrite",
              "description": "Write mode: 'rewrite' to overwrite file, 'append' to add to existing content."
            },
            "content": {
              "type": "string",
              "description": "Content to write to the file."
            },
            "file_path": {
              "type": "string",
              "description": "Path where the file should be written. Must be within allowed directories."
            }
          },
          "required": [
            "file_path",
            "content"
          ]
        }
      }
    ]
  },
  {
    "name": "pinkpixel-dev-mindbridge-mcp",
    "title": "MindBridge MCP Server",
    "description": "An AI router that connects applications to multiple LLM providers (OpenAI, Anthropic, Google, DeepSeek, Ollama, etc.) with smart model orchestration capabilities, enabling dynamic switching between models for different reasoning tasks.",
    "icon": "https://avatars.githubusercontent.com/pinkpixel-dev",
    "isOfficial": false,
    "homepage": "https://github.com/pinkpixel-dev/mindbridge-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@pinkpixel/mindbridge"
      ],
      "env": {
        "GOOGLE_API_KEY": "<google-api-key>",
        "OPENAI_API_KEY": "<openai-api-key>",
        "OLLAMA_BASE_URL": "<ollama-base-url>",
        "DEEPSEEK_API_KEY": "<deepseek-api-key>",
        "ANTHROPIC_API_KEY": "<anthropic-api-key>",
        "OPENROUTER_API_KEY": "<openrouter-api-key>",
        "OPENAI_COMPATIBLE_API_KEY": "<openai-compatible-api-key>",
        "OPENAI_COMPATIBLE_API_MODELS": "<openai-compatible-api-models>",
        "OPENAI_COMPATIBLE_API_BASE_URL": "<openai-compatible-api-base-url>"
      }
    },
    "parameters": [
      {
        "name": "GOOGLE_API_KEY",
        "description": "Your Google AI API key",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OPENAI_API_KEY",
        "description": "Your OpenAI API key",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OLLAMA_BASE_URL",
        "description": "Ollama instance URL",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DEEPSEEK_API_KEY",
        "description": "Your DeepSeek API key",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ANTHROPIC_API_KEY",
        "description": "Your Anthropic API key",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OPENROUTER_API_KEY",
        "description": "Your OpenRouter API key",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OPENAI_COMPATIBLE_API_KEY",
        "description": "API key for OpenAI-compatible services",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OPENAI_COMPATIBLE_API_MODELS",
        "description": "Comma-separated list of available models for OpenAI-compatible services",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OPENAI_COMPATIBLE_API_BASE_URL",
        "description": "Base URL for OpenAI-compatible services",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "getSecondOpinion",
        "description": "Get responses from various LLM providers",
        "inputSchema": {
          "type": "object",
          "properties": {
            "model": {
              "type": "string",
              "minLength": 1
            },
            "top_k": {
              "type": "number",
              "exclusiveMinimum": 0
            },
            "top_p": {
              "type": "number",
              "maximum": 1,
              "minimum": 0
            },
            "prompt": {
              "type": "string",
              "minLength": 1
            },
            "stream": {
              "type": "boolean"
            },
            "provider": {
              "enum": [
                "openai",
                "anthropic",
                "deepseek",
                "google",
                "openrouter",
                "ollama",
                "openaiCompatible"
              ],
              "type": "string"
            },
            "maxTokens": {
              "type": "number",
              "default": 1024,
              "exclusiveMinimum": 0
            },
            "temperature": {
              "type": "number",
              "maximum": 1,
              "minimum": 0
            },
            "systemPrompt": {
              "anyOf": [
                {
                  "anyOf": [
                    {
                      "not": {}
                    },
                    {
                      "type": "string"
                    }
                  ]
                },
                {
                  "type": "null"
                }
              ]
            },
            "stop_sequences": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "presence_penalty": {
              "type": "number",
              "maximum": 2,
              "minimum": -2
            },
            "reasoning_effort": {
              "anyOf": [
                {
                  "anyOf": [
                    {
                      "not": {}
                    },
                    {
                      "enum": [
                        "low",
                        "medium",
                        "high"
                      ],
                      "type": "string"
                    }
                  ]
                },
                {
                  "type": "null"
                }
              ]
            },
            "frequency_penalty": {
              "type": "number",
              "maximum": 2,
              "minimum": -2
            }
          },
          "required": [
            "prompt",
            "provider",
            "model"
          ]
        }
      },
      {
        "name": "listProviders",
        "description": "List all configured LLM providers and their available models",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "listReasoningModels",
        "description": "List all available models that support reasoning capabilities",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "pinkpixel-dev-notification-mcp",
    "title": "Notifications MCP Server",
    "description": "A Model Context Protocol server that allows AI agents to play notification sounds when tasks are completed.",
    "icon": "https://avatars.githubusercontent.com/pinkpixel-dev",
    "isOfficial": false,
    "homepage": "https://github.com/pinkpixel-dev/notification-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@pinkpixel/notification-mcp"
      ],
      "env": {
        "MCP_NOTIFICATION_SOUND_PATH": "<mcp-notification-sound-path>"
      }
    },
    "parameters": [
      {
        "name": "MCP_NOTIFICATION_SOUND_PATH",
        "description": "The full absolute path to your notification sound MP3 file",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "play_notification",
        "description": "Play a notification sound to indicate task completion",
        "inputSchema": {
          "type": "object",
          "properties": {
            "message": {
              "type": "string",
              "description": "Optional message to display with notification"
            }
          }
        }
      }
    ]
  },
  {
    "name": "puchunjie-doc-tools-mcp",
    "title": "doc-tools-mcp",
    "description": "Word document reading and writing MCP implemented in Node.js",
    "icon": "https://avatars.githubusercontent.com/puchunjie",
    "isOfficial": false,
    "homepage": "https://github.com/puchunjie/doc-tools-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@puchunjie/doc-tools-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "create_document",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string"
            },
            "author": {
              "type": "string"
            },
            "filePath": {
              "type": "string"
            }
          },
          "required": [
            "filePath"
          ]
        }
      },
      {
        "name": "open_document",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string"
            }
          },
          "required": [
            "filePath"
          ]
        }
      },
      {
        "name": "add_paragraph",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string"
            },
            "style": {
              "type": "string"
            },
            "filePath": {
              "type": "string"
            },
            "alignment": {
              "enum": [
                "left",
                "center",
                "right",
                "start",
                "end",
                "both",
                "mediumKashida",
                "distribute",
                "numTab",
                "highKashida",
                "lowKashida",
                "thaiDistribute"
              ],
              "type": "string"
            }
          },
          "required": [
            "filePath",
            "text"
          ]
        }
      },
      {
        "name": "add_table",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cols": {
              "type": "number"
            },
            "data": {
              "type": "array",
              "items": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "rows": {
              "type": "number"
            },
            "headers": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filePath": {
              "type": "string"
            }
          },
          "required": [
            "filePath",
            "rows",
            "cols"
          ]
        }
      },
      {
        "name": "search_and_replace",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string"
            },
            "matchCase": {
              "type": "boolean"
            },
            "searchText": {
              "type": "string"
            },
            "replaceText": {
              "type": "string"
            }
          },
          "required": [
            "filePath",
            "searchText",
            "replaceText"
          ]
        }
      },
      {
        "name": "set_page_margins",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "top": {
              "type": "number"
            },
            "left": {
              "type": "number"
            },
            "right": {
              "type": "number"
            },
            "bottom": {
              "type": "number"
            },
            "filePath": {
              "type": "string"
            }
          },
          "required": [
            "filePath"
          ]
        }
      },
      {
        "name": "get_document_info",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string"
            }
          },
          "required": [
            "filePath"
          ]
        }
      }
    ]
  },
  {
    "name": "puremd-puremd-mcp",
    "title": "pure.md MCP server",
    "description": "An MCP server that enables AI clients like Cursor, Windsurf, and Claude Desktop to access web content in markdown format, providing web unblocking and searching capabilities.",
    "icon": "https://avatars.githubusercontent.com/puremd",
    "isOfficial": true,
    "homepage": "https://github.com/puremd/puremd-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "puremd-mcp"
      ],
      "env": {
        "PUREMD_API_KEY": "<puremd-api-key>"
      }
    },
    "parameters": [
      {
        "name": "PUREMD_API_KEY",
        "description": "Your pure.md API token for higher rate limits. Can be set to an empty string for anonymous usage.",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "unblock-url",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "search-web",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "qdrant-mcp-server-qdrant",
    "title": "mcp-server-qdrant",
    "description": "This repository is an example of how to create a MCP server for Qdrant, a vector search engine.",
    "icon": "https://avatars.githubusercontent.com/qdrant",
    "isOfficial": true,
    "homepage": "https://github.com/qdrant/mcp-server-qdrant",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-qdrant"
      ],
      "env": {
        "QDRANT_URL": "<qdrant-url>",
        "QDRANT_API_KEY": "<qdrant-api-key>",
        "COLLECTION_NAME": "<collection-name>",
        "QDRANT_LOCAL_PATH": "<qdrant-local-path>",
        "FASTEMBED_MODEL_NAME": "<fastembed-model-name>"
      }
    },
    "parameters": [
      {
        "name": "QDRANT_URL",
        "description": "URL of the Qdrant server, e.g. http://localhost:6333",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "QDRANT_API_KEY",
        "description": "API key for the Qdrant server",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "COLLECTION_NAME",
        "description": "Name of the collection to use",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "QDRANT_LOCAL_PATH",
        "description": "Path to the local Qdrant database",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "FASTEMBED_MODEL_NAME",
        "description": "Name of the FastEmbed model to use",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "qdrant-store",
        "description": "Keep the memory for later use, when you are asked to remember something.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "metadata": {
              "type": "object",
              "title": "Metadata",
              "default": null,
              "additionalProperties": true
            },
            "information": {
              "type": "string",
              "title": "Information"
            }
          },
          "required": [
            "information"
          ]
        }
      },
      {
        "name": "qdrant-find",
        "description": "Look up memories in Qdrant. Use this tool when you need to: \n - Find memories by their content \n - Access memories for further analysis \n - Get some personal information about the user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      }
    ]
  },
  {
    "name": "qpd-v-mcp-delete",
    "title": "MCP-Delete",
    "description": "A Model Context Protocol (MCP) server that provides file deletion capabilities. This server allows AI assistants to safely delete files when needed, with support for both relative and absolute paths.",
    "icon": "https://avatars.githubusercontent.com/qpd-v",
    "isOfficial": false,
    "homepage": "https://github.com/qpd-v/mcp-delete",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@qpd-v/mcp-delete"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "qpd-v-mcp-communicator-telegram",
    "title": "MCP-Communicator-Telegram",
    "description": "An MCP server that enables communication with users through Telegram. This server provides a tool to ask questions to users and receive their responses via a Telegram bot.",
    "icon": "https://avatars.githubusercontent.com/qpd-v",
    "isOfficial": false,
    "homepage": "https://github.com/qpd-v/mcp-communicator-telegram",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-communicator-telegram"
      ],
      "env": {
        "CHAT_ID": "<chat-id>",
        "TELEGRAM_TOKEN": "<telegram-token>"
      }
    },
    "parameters": [
      {
        "name": "CHAT_ID",
        "description": "Your Telegram chat ID",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "TELEGRAM_TOKEN",
        "description": "The Telegram bot token obtained from @BotFather",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "qpd-v-mcp-wordcounter",
    "title": "MCP Word Counter",
    "description": "A Model Context Protocol server that provides tools for analyzing text documents, including counting words and characters. This server helps LLMs perform text analysis tasks by exposing simple document statistics functionality.",
    "icon": "https://avatars.githubusercontent.com/qpd-v",
    "isOfficial": false,
    "homepage": "https://github.com/qpd-v/mcp-wordcounter",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-wordcounter"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "qwang07-duck-duck-mcp",
    "title": "Duck Duck MCP",
    "description": "This MCP server utilizes DuckDuckGo for web searches, providing structured search results with metadata and features like smart content classification and language detection, facilitating easy integration with AI clients supporting the MCP protocol.",
    "icon": "https://avatars.githubusercontent.com/qwang07",
    "isOfficial": false,
    "homepage": "https://github.com/qwang07/duck-duck-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "duck-duck-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "rafaljanicki-x-twitter-mcp-server",
    "title": "X (Twitter) MCP server",
    "description": "X (Twitter) MCP server",
    "icon": "https://avatars.githubusercontent.com/rafaljanicki",
    "isOfficial": false,
    "homepage": "https://github.com/rafaljanicki/x-twitter-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "x-twitter-mcp"
      ],
      "env": {
        "TWITTER_API_KEY": "<twitter-api-key>",
        "PYTHONUNBUFFERED": "<pythonunbuffered>",
        "TWITTER_API_SECRET": "<twitter-api-secret>",
        "TWITTER_ACCESS_TOKEN": "<twitter-access-token>",
        "TWITTER_BEARER_TOKEN": "<twitter-bearer-token>",
        "TWITTER_ACCESS_TOKEN_SECRET": "<twitter-access-token-secret>"
      }
    },
    "parameters": [
      {
        "name": "TWITTER_API_KEY",
        "description": "Your Twitter API key from the Twitter Developer Portal",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "PYTHONUNBUFFERED",
        "description": "Ensures output is unbuffered for better logging in Claude",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TWITTER_API_SECRET",
        "description": "Your Twitter API secret from the Twitter Developer Portal",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "TWITTER_ACCESS_TOKEN",
        "description": "Your Twitter access token from the Twitter Developer Portal",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "TWITTER_BEARER_TOKEN",
        "description": "Your Twitter bearer token from the Twitter Developer Portal",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "TWITTER_ACCESS_TOKEN_SECRET",
        "description": "Your Twitter access token secret from the Twitter Developer Portal",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_user_profile",
        "description": "Get detailed profile information for a user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user_id": {
              "type": "string",
              "title": "User Id"
            }
          },
          "required": [
            "user_id"
          ]
        }
      },
      {
        "name": "get_user_by_screen_name",
        "description": "Fetches a user by screen name",
        "inputSchema": {
          "type": "object",
          "properties": {
            "screen_name": {
              "type": "string",
              "title": "Screen Name"
            }
          },
          "required": [
            "screen_name"
          ]
        }
      },
      {
        "name": "get_user_by_id",
        "description": "Fetches a user by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user_id": {
              "type": "string",
              "title": "User Id"
            }
          },
          "required": [
            "user_id"
          ]
        }
      },
      {
        "name": "get_user_followers",
        "description": "Retrieves a list of followers for a given user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Count",
              "default": 100
            },
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "user_id": {
              "type": "string",
              "title": "User Id"
            }
          },
          "required": [
            "user_id"
          ]
        }
      },
      {
        "name": "get_user_following",
        "description": "Retrieves users the given user is following",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Count",
              "default": 100
            },
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "user_id": {
              "type": "string",
              "title": "User Id"
            }
          },
          "required": [
            "user_id"
          ]
        }
      },
      {
        "name": "get_user_followers_you_know",
        "description": "Retrieves a list of common followers",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Count",
              "default": 100
            },
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "user_id": {
              "type": "string",
              "title": "User Id"
            }
          },
          "required": [
            "user_id"
          ]
        }
      },
      {
        "name": "get_user_subscriptions",
        "description": "Retrieves a list of users to which the specified user is subscribed",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Count",
              "default": 100
            },
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "user_id": {
              "type": "string",
              "title": "User Id"
            }
          },
          "required": [
            "user_id"
          ]
        }
      },
      {
        "name": "post_tweet",
        "description": "Post a tweet with optional media, reply, and tags",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags",
              "default": null
            },
            "text": {
              "type": "string",
              "title": "Text"
            },
            "reply_to": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Reply To",
              "default": null
            },
            "media_paths": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Media Paths",
              "default": null
            }
          },
          "required": [
            "text"
          ]
        }
      },
      {
        "name": "delete_tweet",
        "description": "Delete a tweet by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tweet_id": {
              "type": "string",
              "title": "Tweet Id"
            }
          },
          "required": [
            "tweet_id"
          ]
        }
      },
      {
        "name": "get_tweet_details",
        "description": "Get detailed information about a specific tweet",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tweet_id": {
              "type": "string",
              "title": "Tweet Id"
            }
          },
          "required": [
            "tweet_id"
          ]
        }
      },
      {
        "name": "create_poll_tweet",
        "description": "Create a tweet with a poll",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "type": "string",
              "title": "Text"
            },
            "choices": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "Choices"
            },
            "duration_minutes": {
              "type": "integer",
              "title": "Duration Minutes"
            }
          },
          "required": [
            "text",
            "choices",
            "duration_minutes"
          ]
        }
      },
      {
        "name": "vote_on_poll",
        "description": "Vote on a poll",
        "inputSchema": {
          "type": "object",
          "properties": {
            "choice": {
              "type": "string",
              "title": "Choice"
            },
            "tweet_id": {
              "type": "string",
              "title": "Tweet Id"
            }
          },
          "required": [
            "tweet_id",
            "choice"
          ]
        }
      },
      {
        "name": "favorite_tweet",
        "description": "Favorites a tweet",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tweet_id": {
              "type": "string",
              "title": "Tweet Id"
            }
          },
          "required": [
            "tweet_id"
          ]
        }
      },
      {
        "name": "unfavorite_tweet",
        "description": "Unfavorites a tweet",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tweet_id": {
              "type": "string",
              "title": "Tweet Id"
            }
          },
          "required": [
            "tweet_id"
          ]
        }
      },
      {
        "name": "bookmark_tweet",
        "description": "Adds the tweet to bookmarks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tweet_id": {
              "type": "string",
              "title": "Tweet Id"
            },
            "folder_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Folder Id",
              "default": null
            }
          },
          "required": [
            "tweet_id"
          ]
        }
      },
      {
        "name": "delete_bookmark",
        "description": "Removes the tweet from bookmarks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tweet_id": {
              "type": "string",
              "title": "Tweet Id"
            }
          },
          "required": [
            "tweet_id"
          ]
        }
      },
      {
        "name": "delete_all_bookmarks",
        "description": "Deletes all bookmarks",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_timeline",
        "description": "Get tweets from your home timeline (For You)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Count",
              "default": 100
            },
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "seen_tweet_ids": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Seen Tweet Ids",
              "default": null
            }
          }
        }
      },
      {
        "name": "get_latest_timeline",
        "description": "Get tweets from your home timeline (Following)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Count",
              "default": 100
            }
          }
        }
      },
      {
        "name": "search_twitter",
        "description": "Search Twitter with a query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Count",
              "default": 100
            },
            "query": {
              "type": "string",
              "title": "Query"
            },
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "product": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Product",
              "default": "Top"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_trends",
        "description": "Retrieves trending topics on Twitter",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Count",
              "default": 50
            },
            "category": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Category",
              "default": null
            }
          }
        }
      },
      {
        "name": "get_highlights_tweets",
        "description": "Retrieves highlighted tweets from a user’s timeline",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Count",
              "default": 100
            },
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "user_id": {
              "type": "string",
              "title": "User Id"
            }
          },
          "required": [
            "user_id"
          ]
        }
      },
      {
        "name": "get_user_mentions",
        "description": "Get tweets mentioning a specific user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "count": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Count",
              "default": 100
            },
            "cursor": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor",
              "default": null
            },
            "user_id": {
              "type": "string",
              "title": "User Id"
            }
          },
          "required": [
            "user_id"
          ]
        }
      }
    ]
  },
  {
    "name": "rahgadda-openapi_mcp_server",
    "title": "OpenAPI MCP Server",
    "description": "A Model Context Protocol Server that enables LLMs to interact with and execute REST API calls through natural language prompts, supporting GET/PUT/POST/PATCH operations on configured APIs.",
    "icon": "https://avatars.githubusercontent.com/rahgadda",
    "isOfficial": false,
    "homepage": "https://github.com/rahgadda/openapi_mcp_server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "openapi_mcp_server"
      ],
      "env": {
        "DEBUG": "<debug>",
        "NO_PROXY": "<no-proxy>",
        "HTTP_PROXY": "<http-proxy>",
        "API_HEADERS": "<api-headers>",
        "HTTPS_PROXY": "<https-proxy>",
        "API_BASE_URL": "<api-base-url>",
        "API_BLACK_LIST": "<api-black-list>",
        "API_WHITE_LIST": "<api-white-list>",
        "OPENAPI_SPEC_PATH": "<openapi-spec-path>"
      }
    },
    "parameters": [
      {
        "name": "DEBUG",
        "description": "Enable debug logging",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "NO_PROXY",
        "description": "No Proxy details",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "HTTP_PROXY",
        "description": "HTTP Proxy details",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "API_HEADERS",
        "description": "Headers to include in the API requests",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "HTTPS_PROXY",
        "description": "HTTPS Proxy details",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "API_BASE_URL",
        "description": "Base URL for the API requests",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "API_BLACK_LIST",
        "description": "Black Listed operationId in list format [\"operationId3\", \"operationId4\"]",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "API_WHITE_LIST",
        "description": "White Listed operationId in list format [\"operationId1\", \"operationId2\"]",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OPENAPI_SPEC_PATH",
        "description": "Path to the OpenAPI document",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "rahgadda-oracledb_mcp_server",
    "title": "OracleDB MCP Server",
    "description": "A Model Context Protocol Server that enables LLMs to interact with Oracle Database by providing database tables/columns as context, allowing users to generate SQL statements and retrieve results using natural language prompts.",
    "icon": "https://avatars.githubusercontent.com/rahgadda",
    "isOfficial": false,
    "homepage": "https://github.com/rahgadda/oracledb_mcp_server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "oracledb-mcp-server"
      ],
      "env": {
        "DEBUG": "<debug>",
        "QUERY_LIMIT_SIZE": "<query-limit-size>",
        "TABLE_WHITE_LIST": "<table-white-list>",
        "COLUMN_WHITE_LIST": "<column-white-list>",
        "DB_CONNECTION_STRING": "<db-connection-string>",
        "COMMENT_DB_CONNECTION_STRING": "<comment-db-connection-string>"
      }
    },
    "parameters": [
      {
        "name": "DEBUG",
        "description": "Enable debug logging",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "QUERY_LIMIT_SIZE",
        "description": "Default value is 10 records if not provided",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TABLE_WHITE_LIST",
        "description": "White Listed table names in list format [\"table1\", \"table2\"]",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "COLUMN_WHITE_LIST",
        "description": "White Listed table-column names in list format [\"table.column1\", \"table.column2\"]",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "DB_CONNECTION_STRING",
        "description": "Oracle DB connection String for execution of queries",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "COMMENT_DB_CONNECTION_STRING",
        "description": "Oracle DB connection String for comments",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "recraft-ai-mcp-recraft-server",
    "title": "Recraft AI MCP Server",
    "description": "An MCP server that integrates with Recraft AI to enable generation and manipulation of high-quality raster and vector images through tools like image generation, editing, vectorization, background removal, and upscaling.",
    "icon": "https://avatars.githubusercontent.com/recraft-ai",
    "isOfficial": true,
    "homepage": "https://github.com/recraft-ai/mcp-recraft-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@recraft-ai/mcp-recraft-server"
      ],
      "env": {
        "RECRAFT_API_KEY": "<recraft-api-key>",
        "IMAGE_STORAGE_DIRECTORY": "<image-storage-directory>"
      }
    },
    "parameters": [
      {
        "name": "RECRAFT_API_KEY",
        "description": "Your Recraft AI API key from https://www.recraft.ai/profile/api",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "IMAGE_STORAGE_DIRECTORY",
        "description": "Optional, absolute path to directory where generated images will be stored. Default is $HOME_DIR/.mcp-recraft-server",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "generate_image",
        "description": "Generate an image using Recraft from a text prompt.\nYou can specify the image size, style, model, and number of images to generate.\nYou don't need to change default parameters if you don't have any specific requirements.\nYou can use styles to refine the image generation, and also to generate raster or vector images.\nLocal paths or URLs to generated images and their previews will be returned in the response.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "size": {
              "enum": [
                "1024x1024",
                "1365x1024",
                "1024x1365",
                "1536x1024",
                "1024x1536",
                "1820x1024",
                "1024x1820",
                "1024x2048",
                "2048x1024",
                "1434x1024",
                "1024x1434",
                "1024x1280",
                "1280x1024",
                "1024x1707",
                "1707x1024"
              ],
              "type": "string",
              "description": "Image dimensions. Default is 1024x1024."
            },
            "model": {
              "enum": [
                "recraftv3",
                "recraftv2"
              ],
              "type": "string",
              "description": "Model version to use. Default is recraftv3.\n- recraftv3 is the latest model and should be used in most cases.\n- recraftv2 is the previous state model, it has a bit cheaper generation.\nBe accurate with compatibility of model with style if it is specified, otherwise generation will fail."
            },
            "style": {
              "enum": [
                "digital_illustration",
                "icon",
                "realistic_image",
                "vector_illustration",
                "logo_raster"
              ],
              "type": "string",
              "description": "Visual style to apply. Default is realistic_image.\nUse this parameter only if you want to refine the image generation.\nMutually exclusive with styleID, you can't specify both of them.\nrealistic_image, digital_illustration, vector_illustration are available in both models, but icon is available only for recraftv2, and logo_raster is available only for recraftv3.\nIf you will provide a style that is not available for the specified model, generation will fail.\nStyles use-cases:\n- realistic_image: for realistic images, photos, portraits, landscapes, etc. Raster is generated.\n- digital_illustration: for digital illustrations, concept art, fantasy art, etc. Raster is generated.\n- vector_illustration: for vector illustrations, logos, icons, etc. Vector is generated.\n- icon: for icons, small graphics (only in recraftv2). Vector is generated\n- logo_raster: for graphic design, raster logos, posters, emblems, and badges (only in recraftv3). Raster is generated."
            },
            "prompt": {
              "type": "string",
              "description": "Text prompt of the image you want to generate.\nIts length should be from 1 to 1024 characters."
            },
            "styleID": {
              "type": "string",
              "description": "ID of the style to apply. Mutually exclusive with style, you can't specify both of them.\nThis ID can be the style ID from recraft.ai or some previously created custom style."
            },
            "substyle": {
              "enum": [
                "2d_art_poster",
                "3d",
                "80s",
                "glow",
                "grain",
                "hand_drawn",
                "infantile_sketch",
                "kawaii",
                "pixel_art",
                "psychedelic",
                "seamless",
                "voxel",
                "watercolor",
                "broken_line",
                "colored_outline",
                "colored_shapes",
                "colored_shapes_gradient",
                "doodle_fill",
                "doodle_offset_fill",
                "offset_fill",
                "outline",
                "outline_gradient",
                "cartoon",
                "doodle_line_art",
                "engraving",
                "flat_2",
                "line_art",
                "linocut",
                "b_and_w",
                "enterprise",
                "hard_flash",
                "hdr",
                "motion_blur",
                "natural_light",
                "studio_portrait",
                "line_circuit",
                "2d_art_poster_2",
                "engraving_color",
                "hand_drawn_outline",
                "handmade_3d",
                "plastic",
                "pictogram",
                "antiquarian",
                "bold_fantasy",
                "child_book",
                "cover",
                "crosshatch",
                "digital_engraving",
                "expressionism",
                "freehand_details",
                "grain_20",
                "graphic_intensity",
                "hard_comics",
                "long_shadow",
                "modern_folk",
                "multicolor",
                "neon_calm",
                "noir",
                "nostalgic_pastel",
                "outline_details",
                "pastel_gradient",
                "pastel_sketch",
                "pop_art",
                "pop_renaissance",
                "street_art",
                "tablet_sketch",
                "urban_glow",
                "urban_sketching",
                "young_adult_book",
                "young_adult_book_2",
                "evening_light",
                "faded_nostalgia",
                "forest_life",
                "mystic_naturalism",
                "natural_tones",
                "organic_calm",
                "real_life_glow",
                "retro_realism",
                "retro_snapshot",
                "urban_drama",
                "village_realism",
                "warm_folk",
                "bold_stroke",
                "chemistry",
                "colored_stencil",
                "cosmics",
                "cutout",
                "depressive",
                "editorial",
                "emotional_flat",
                "marker_outline",
                "mosaic",
                "naivector",
                "roundish_flat",
                "segmented_colors",
                "sharp_contrast",
                "thin",
                "vector_photo",
                "vivid_shapes",
                "emblem_graffiti",
                "emblem_pop_art",
                "emblem_punk",
                "emblem_stamp",
                "emblem_vintage"
              ],
              "type": "string",
              "description": "Visual substyle to apply. Can be specified only with style to refine more specifically.\nIf this parameter is not specified, model will decide on the final style. Use this parameter only if you want to refine the image generation more. No need to specify if you don't have any specific requirements.\nNote that each combination of model and style has their own list of available substyles:\n- recraftv3 with style realistic_image: b_and_w, enterprise, evening_light, faded_nostalgia, forest_life, hard_flash, hdr, motion_blur, mystic_naturalism, natural_light, natural_tones, organic_calm, real_life_glow, retro_realism, retro_snapshot, studio_portrait, urban_drama, village_realism, warm_folk\n- recraftv2 with style realistic_image: b_and_w, enterprise, hard_flash, hdr, motion_blur, natural_light, studio_portrait\n- recraftv3 with style digital_illustration: 2d_art_poster, 2d_art_poster_2, antiquarian, bold_fantasy, child_book, cover, crosshatch, digital_engraving, engraving_color, expressionism, freehand_details, grain, grain_20, graphic_intensity, hand_drawn, hand_drawn_outline, handmade_3d, hard_comics, infantile_sketch, long_shadow, modern_folk, multicolor, neon_calm, noir, nostalgic_pastel, outline_details, pastel_gradient, pastel_sketch, pixel_art, plastic, pop_art, pop_renaissance, seamless, street_art, tablet_sketch, urban_glow, urban_sketching, young_adult_book, young_adult_book_2\n- recraftv2 with style digital_illustration: 2d_art_poster, 2d_art_poster_2, 3d, 80s, engraving_color, glow, grain, hand_drawn, hand_drawn_outline, handmade_3d, infantile_sketch, kawaii, pixel_art, plastic, psychedelic, seamless, voxel, watercolor\n- recraftv3 with style vector_illustration: bold_stroke, chemistry, colored_stencil, cosmics, cutout, depressive, editorial, emotional_flat, engraving, line_art, line_circuit, linocut, marker_outline, mosaic, naivector, roundish_flat, seamless, segmented_colors, sharp_contrast, thin, vector_photo, vivid_shapes\n- recraftv2 with style vector_illustration: cartoon, doodle_line_art, engraving, flat_2, kawaii, line_art, line_circuit, linocut, seamless\n- recraftv2 with style icon: broken_line, colored_outline, colored_shapes, colored_shapes_gradient, doodle_fill, doodle_offset_fill, offset_fill, outline, outline_gradient, pictogram\n- recraftv3 with style logo_raster: emblem_graffiti, emblem_pop_art, emblem_punk, emblem_stamp, emblem_vintage\nIf you will provide a substyle that is not available for the specified model and style, generation will fail."
            },
            "numberOfImages": {
              "type": "integer",
              "maximum": 6,
              "minimum": 1,
              "description": "Number of images to generate. Should be from 1 to 6. Default is 1."
            }
          },
          "required": [
            "prompt"
          ]
        }
      },
      {
        "name": "create_style",
        "description": "Create a style in Recraft from the set of style reference images.\nA style is extracted from the provided images and can be used in image generation tools.\nID of the created style will be returned in the response.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "style": {
              "enum": [
                "realistic_image",
                "digital_illustration",
                "vector_illustration",
                "icon"
              ],
              "type": "string",
              "description": "Basic visual style in which the style will be created."
            },
            "imageURIs": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of images to use as a style references. Each item can be a URL (starting with http:// or https://) or a file path (starting with file://). The length should be from 1 to 5."
            }
          },
          "required": [
            "style",
            "imageURIs"
          ]
        }
      },
      {
        "name": "vectorize_image",
        "description": "Vectorize an input image using Recraft.\nThis operation takes an input image and returns a vector SVG image, close to it.\nLocal path or URL to resulting image and its preview will be returned in the response.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "imageURI": {
              "type": "string",
              "description": "Image to use as an input. This can be a URL (starting with http:// or https://) or an absolute file path (starting with file://)."
            }
          },
          "required": [
            "imageURI"
          ]
        }
      },
      {
        "name": "image_to_image",
        "description": "Generate an image using Recraft from an input image and a text prompt.\nYou can specify the reference input image, style, model, and number of images to generate.\nYou should provide the same style/substyle/styleID settings as were used for input image generation (if exists) if there are no specific requirements to change the style.\nOther parameters are recommended to keep default if you don't have any specific requirements on them.\nYou can use styles to refine the image generation, and also to generate raster or vector images.\nLocal paths or URLs to generated images and their previews will be returned in the response.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "model": {
              "enum": [
                "recraftv3",
                "recraftv2"
              ],
              "type": "string",
              "description": "Model version to use. Default is recraftv3.\n- recraftv3 is the latest model and should be used in most cases.\n- recraftv2 is the previous state model, it has a bit cheaper generation.\nBe accurate with compatibility of model with style if it is specified, otherwise generation will fail."
            },
            "style": {
              "enum": [
                "digital_illustration",
                "icon",
                "realistic_image",
                "vector_illustration",
                "logo_raster"
              ],
              "type": "string",
              "description": "Visual style to apply. Default is realistic_image.\nUse this parameter only if you want to refine the image generation.\nMutually exclusive with styleID, you can't specify both of them.\nrealistic_image, digital_illustration, vector_illustration are available in both models, but icon is available only for recraftv2, and logo_raster is available only for recraftv3.\nIf you will provide a style that is not available for the specified model, generation will fail.\nStyles use-cases:\n- realistic_image: for realistic images, photos, portraits, landscapes, etc. Raster is generated.\n- digital_illustration: for digital illustrations, concept art, fantasy art, etc. Raster is generated.\n- vector_illustration: for vector illustrations, logos, icons, etc. Vector is generated.\n- icon: for icons, small graphics (only in recraftv2). Vector is generated\n- logo_raster: for graphic design, raster logos, posters, emblems, and badges (only in recraftv3). Raster is generated.\nYou should provide the same style/substyle/styleID settings as were used for input image generation (if they exist) if there are no specific requirements to change the style in the resulting image."
            },
            "prompt": {
              "type": "string",
              "description": "Text prompt of the image you want to generate.\nIts length should be from 1 to 1024 characters."
            },
            "styleID": {
              "type": "string",
              "description": "ID of the style to apply. Mutually exclusive with style, you can't specify both of them.\nThis ID can be the style ID from recraft.ai or some previously created custom style.\nYou should provide the same style/substyle/styleID settings as were used for input image generation (if they exist) if there are no specific requirements to change the style in the resulting image."
            },
            "imageURI": {
              "type": "string",
              "description": "Image to use as an input. This can be a URL (starting with http:// or https://) or an absolute file path (starting with file://)."
            },
            "strength": {
              "type": "number",
              "maximum": 1,
              "minimum": 0,
              "description": "Strength of the image to image transformation, where 0 means almost similar to reference input image, 1 means almost no reference."
            },
            "substyle": {
              "enum": [
                "2d_art_poster",
                "3d",
                "80s",
                "glow",
                "grain",
                "hand_drawn",
                "infantile_sketch",
                "kawaii",
                "pixel_art",
                "psychedelic",
                "seamless",
                "voxel",
                "watercolor",
                "broken_line",
                "colored_outline",
                "colored_shapes",
                "colored_shapes_gradient",
                "doodle_fill",
                "doodle_offset_fill",
                "offset_fill",
                "outline",
                "outline_gradient",
                "cartoon",
                "doodle_line_art",
                "engraving",
                "flat_2",
                "line_art",
                "linocut",
                "b_and_w",
                "enterprise",
                "hard_flash",
                "hdr",
                "motion_blur",
                "natural_light",
                "studio_portrait",
                "line_circuit",
                "2d_art_poster_2",
                "engraving_color",
                "hand_drawn_outline",
                "handmade_3d",
                "plastic",
                "pictogram",
                "antiquarian",
                "bold_fantasy",
                "child_book",
                "cover",
                "crosshatch",
                "digital_engraving",
                "expressionism",
                "freehand_details",
                "grain_20",
                "graphic_intensity",
                "hard_comics",
                "long_shadow",
                "modern_folk",
                "multicolor",
                "neon_calm",
                "noir",
                "nostalgic_pastel",
                "outline_details",
                "pastel_gradient",
                "pastel_sketch",
                "pop_art",
                "pop_renaissance",
                "street_art",
                "tablet_sketch",
                "urban_glow",
                "urban_sketching",
                "young_adult_book",
                "young_adult_book_2",
                "evening_light",
                "faded_nostalgia",
                "forest_life",
                "mystic_naturalism",
                "natural_tones",
                "organic_calm",
                "real_life_glow",
                "retro_realism",
                "retro_snapshot",
                "urban_drama",
                "village_realism",
                "warm_folk",
                "bold_stroke",
                "chemistry",
                "colored_stencil",
                "cosmics",
                "cutout",
                "depressive",
                "editorial",
                "emotional_flat",
                "marker_outline",
                "mosaic",
                "naivector",
                "roundish_flat",
                "segmented_colors",
                "sharp_contrast",
                "thin",
                "vector_photo",
                "vivid_shapes",
                "emblem_graffiti",
                "emblem_pop_art",
                "emblem_punk",
                "emblem_stamp",
                "emblem_vintage"
              ],
              "type": "string",
              "description": "Visual substyle to apply. Can be specified only with style to refine more specifically.\nIf this parameter is not specified, model will decide on the final style. Use this parameter only if you want to refine the image generation more. No need to specify if you don't have any specific requirements.\nNote that each combination of model and style has their own list of available substyles:\n- recraftv3 with style realistic_image: b_and_w, enterprise, evening_light, faded_nostalgia, forest_life, hard_flash, hdr, motion_blur, mystic_naturalism, natural_light, natural_tones, organic_calm, real_life_glow, retro_realism, retro_snapshot, studio_portrait, urban_drama, village_realism, warm_folk\n- recraftv2 with style realistic_image: b_and_w, enterprise, hard_flash, hdr, motion_blur, natural_light, studio_portrait\n- recraftv3 with style digital_illustration: 2d_art_poster, 2d_art_poster_2, antiquarian, bold_fantasy, child_book, cover, crosshatch, digital_engraving, engraving_color, expressionism, freehand_details, grain, grain_20, graphic_intensity, hand_drawn, hand_drawn_outline, handmade_3d, hard_comics, infantile_sketch, long_shadow, modern_folk, multicolor, neon_calm, noir, nostalgic_pastel, outline_details, pastel_gradient, pastel_sketch, pixel_art, plastic, pop_art, pop_renaissance, seamless, street_art, tablet_sketch, urban_glow, urban_sketching, young_adult_book, young_adult_book_2\n- recraftv2 with style digital_illustration: 2d_art_poster, 2d_art_poster_2, 3d, 80s, engraving_color, glow, grain, hand_drawn, hand_drawn_outline, handmade_3d, infantile_sketch, kawaii, pixel_art, plastic, psychedelic, seamless, voxel, watercolor\n- recraftv3 with style vector_illustration: bold_stroke, chemistry, colored_stencil, cosmics, cutout, depressive, editorial, emotional_flat, engraving, line_art, line_circuit, linocut, marker_outline, mosaic, naivector, roundish_flat, seamless, segmented_colors, sharp_contrast, thin, vector_photo, vivid_shapes\n- recraftv2 with style vector_illustration: cartoon, doodle_line_art, engraving, flat_2, kawaii, line_art, line_circuit, linocut, seamless\n- recraftv2 with style icon: broken_line, colored_outline, colored_shapes, colored_shapes_gradient, doodle_fill, doodle_offset_fill, offset_fill, outline, outline_gradient, pictogram\n- recraftv3 with style logo_raster: emblem_graffiti, emblem_pop_art, emblem_punk, emblem_stamp, emblem_vintage\nIf you will provide a substyle that is not available for the specified model and style, generation will fail.\nYou should provide the same style/substyle/styleID settings as were used for input image generation (if they exist) if there are no specific requirements to change the style in the resulting image."
            },
            "numberOfImages": {
              "type": "integer",
              "maximum": 6,
              "minimum": 1,
              "description": "Number of images to generate. Should be from 1 to 6. Default is 1."
            }
          },
          "required": [
            "imageURI",
            "prompt",
            "strength"
          ]
        }
      },
      {
        "name": "remove_background",
        "description": "Remove background in the input image using Recraft.\nThis operation takes an input image and returns the same image with detected background removed. Raster image will be always returned.\nLocal path or URL to resulting image and its preview will be returned in the response.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "imageURI": {
              "type": "string",
              "description": "Image to use as an input. This can be a URL (starting with http:// or https://) or an absolute file path (starting with file://)."
            }
          },
          "required": [
            "imageURI"
          ]
        }
      },
      {
        "name": "replace_background",
        "description": "Generate an image using Recraft from an input image with its detected background replaced based on the prompt.\nYou can specify the input image, style, model, and number of images to generate.\nYou should provide the same style/substyle/styleID settings as were used for input image generation (if exists) if there are no specific requirements to change the style.\nOther parameters are recommended to keep default if you don't have any specific requirements on them.\nYou can use styles to refine the image background generation, and also to generate raster or vector images.\nLocal paths or URLs to generated images and their previews will be returned in the response.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "style": {
              "enum": [
                "digital_illustration",
                "icon",
                "realistic_image",
                "vector_illustration",
                "logo_raster"
              ],
              "type": "string",
              "description": "Visual style to apply. Default is realistic_image.\nUse this parameter only if you want to refine the image generation.\nMutually exclusive with styleID, you can't specify both of them.\nrealistic_image, digital_illustration, vector_illustration are available in both models, but icon is available only for recraftv2, and logo_raster is available only for recraftv3.\nIf you will provide a style that is not available for the specified model, generation will fail.\nStyles use-cases:\n- realistic_image: for realistic images, photos, portraits, landscapes, etc. Raster is generated.\n- digital_illustration: for digital illustrations, concept art, fantasy art, etc. Raster is generated.\n- vector_illustration: for vector illustrations, logos, icons, etc. Vector is generated.\n- icon: for icons, small graphics (only in recraftv2). Vector is generated\n- logo_raster: for graphic design, raster logos, posters, emblems, and badges (only in recraftv3). Raster is generated.\nYou should provide the same style/substyle/styleID settings as were used for input image generation (if they exist) if there are no specific requirements to change the style in the resulting image."
            },
            "prompt": {
              "type": "string",
              "description": "Text prompt of the background areas that will be changed.\nIts length should be from 1 to 1024 characters."
            },
            "styleID": {
              "type": "string",
              "description": "ID of the style to apply. Mutually exclusive with style, you can't specify both of them.\nThis ID can be the style ID from recraft.ai or some previously created custom style.\nYou should provide the same style/substyle/styleID settings as were used for input image generation (if they exist) if there are no specific requirements to change the style in the resulting image."
            },
            "imageURI": {
              "type": "string",
              "description": "Image to use as an input. This can be a URL (starting with http:// or https://) or an absolute file path (starting with file://)."
            },
            "substyle": {
              "enum": [
                "2d_art_poster",
                "3d",
                "80s",
                "glow",
                "grain",
                "hand_drawn",
                "infantile_sketch",
                "kawaii",
                "pixel_art",
                "psychedelic",
                "seamless",
                "voxel",
                "watercolor",
                "broken_line",
                "colored_outline",
                "colored_shapes",
                "colored_shapes_gradient",
                "doodle_fill",
                "doodle_offset_fill",
                "offset_fill",
                "outline",
                "outline_gradient",
                "cartoon",
                "doodle_line_art",
                "engraving",
                "flat_2",
                "line_art",
                "linocut",
                "b_and_w",
                "enterprise",
                "hard_flash",
                "hdr",
                "motion_blur",
                "natural_light",
                "studio_portrait",
                "line_circuit",
                "2d_art_poster_2",
                "engraving_color",
                "hand_drawn_outline",
                "handmade_3d",
                "plastic",
                "pictogram",
                "antiquarian",
                "bold_fantasy",
                "child_book",
                "cover",
                "crosshatch",
                "digital_engraving",
                "expressionism",
                "freehand_details",
                "grain_20",
                "graphic_intensity",
                "hard_comics",
                "long_shadow",
                "modern_folk",
                "multicolor",
                "neon_calm",
                "noir",
                "nostalgic_pastel",
                "outline_details",
                "pastel_gradient",
                "pastel_sketch",
                "pop_art",
                "pop_renaissance",
                "street_art",
                "tablet_sketch",
                "urban_glow",
                "urban_sketching",
                "young_adult_book",
                "young_adult_book_2",
                "evening_light",
                "faded_nostalgia",
                "forest_life",
                "mystic_naturalism",
                "natural_tones",
                "organic_calm",
                "real_life_glow",
                "retro_realism",
                "retro_snapshot",
                "urban_drama",
                "village_realism",
                "warm_folk",
                "bold_stroke",
                "chemistry",
                "colored_stencil",
                "cosmics",
                "cutout",
                "depressive",
                "editorial",
                "emotional_flat",
                "marker_outline",
                "mosaic",
                "naivector",
                "roundish_flat",
                "segmented_colors",
                "sharp_contrast",
                "thin",
                "vector_photo",
                "vivid_shapes",
                "emblem_graffiti",
                "emblem_pop_art",
                "emblem_punk",
                "emblem_stamp",
                "emblem_vintage"
              ],
              "type": "string",
              "description": "Visual substyle to apply. Can be specified only with style to refine more specifically.\nIf this parameter is not specified, model will decide on the final style. Use this parameter only if you want to refine the image generation more. No need to specify if you don't have any specific requirements.\nNote that each combination of model and style has their own list of available substyles:\n- recraftv3 with style realistic_image: b_and_w, enterprise, evening_light, faded_nostalgia, forest_life, hard_flash, hdr, motion_blur, mystic_naturalism, natural_light, natural_tones, organic_calm, real_life_glow, retro_realism, retro_snapshot, studio_portrait, urban_drama, village_realism, warm_folk\n- recraftv2 with style realistic_image: b_and_w, enterprise, hard_flash, hdr, motion_blur, natural_light, studio_portrait\n- recraftv3 with style digital_illustration: 2d_art_poster, 2d_art_poster_2, antiquarian, bold_fantasy, child_book, cover, crosshatch, digital_engraving, engraving_color, expressionism, freehand_details, grain, grain_20, graphic_intensity, hand_drawn, hand_drawn_outline, handmade_3d, hard_comics, infantile_sketch, long_shadow, modern_folk, multicolor, neon_calm, noir, nostalgic_pastel, outline_details, pastel_gradient, pastel_sketch, pixel_art, plastic, pop_art, pop_renaissance, seamless, street_art, tablet_sketch, urban_glow, urban_sketching, young_adult_book, young_adult_book_2\n- recraftv2 with style digital_illustration: 2d_art_poster, 2d_art_poster_2, 3d, 80s, engraving_color, glow, grain, hand_drawn, hand_drawn_outline, handmade_3d, infantile_sketch, kawaii, pixel_art, plastic, psychedelic, seamless, voxel, watercolor\n- recraftv3 with style vector_illustration: bold_stroke, chemistry, colored_stencil, cosmics, cutout, depressive, editorial, emotional_flat, engraving, line_art, line_circuit, linocut, marker_outline, mosaic, naivector, roundish_flat, seamless, segmented_colors, sharp_contrast, thin, vector_photo, vivid_shapes\n- recraftv2 with style vector_illustration: cartoon, doodle_line_art, engraving, flat_2, kawaii, line_art, line_circuit, linocut, seamless\n- recraftv2 with style icon: broken_line, colored_outline, colored_shapes, colored_shapes_gradient, doodle_fill, doodle_offset_fill, offset_fill, outline, outline_gradient, pictogram\n- recraftv3 with style logo_raster: emblem_graffiti, emblem_pop_art, emblem_punk, emblem_stamp, emblem_vintage\nIf you will provide a substyle that is not available for the specified model and style, generation will fail.\nYou should provide the same style/substyle/styleID settings as were used for input image generation (if they exist) if there are no specific requirements to change the style in the resulting image."
            },
            "numberOfImages": {
              "type": "integer",
              "maximum": 6,
              "minimum": 1,
              "description": "Number of images to generate. Should be from 1 to 6. Default is 1."
            }
          },
          "required": [
            "imageURI",
            "prompt"
          ]
        }
      },
      {
        "name": "crisp_upscale",
        "description": "Crisp upscale of the input image using Recraft.\nThis operation takes an input image and returns an upscaled image, making the image sharper and cleaner.\nThis version of upscale is much cheaper and faster than creative upscale.\nLocal path or URL to resulting image and its preview will be returned in the response.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "imageURI": {
              "type": "string",
              "description": "Image to use as an input. This can be a URL (starting with http:// or https://) or an absolute file path (starting with file://)."
            }
          },
          "required": [
            "imageURI"
          ]
        }
      },
      {
        "name": "creative_upscale",
        "description": "Creative upscale of the input image using Recraft.\nThis operation takes an input image and returns an upscaled image, boosting resolution with a focus on refining small details and faces.\nThis version of upscale is expensive and slower than crisp upscale.\nLocal path or URL to resulting image and its preview will be returned in the response.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "imageURI": {
              "type": "string",
              "description": "Image to use as an input. This can be a URL (starting with http:// or https://) or an absolute file path (starting with file://)."
            }
          },
          "required": [
            "imageURI"
          ]
        }
      },
      {
        "name": "get_user",
        "description": "Get information about the current Recraft API user (their email, name, and credit balance).",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      }
    ]
  },
  {
    "name": "reeeeemo-ancestry-mcp",
    "title": "Ancestry MCP",
    "description": "Allows the AI to read .ged files and genetic data.",
    "icon": "https://avatars.githubusercontent.com/reeeeemo",
    "isOfficial": false,
    "homepage": "https://github.com/reeeeemo/ancestry-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-ancestry"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "erithwik-mcp-hn",
    "title": "mcp-hn",
    "description": "A Model Context Protocol (MCP) server that provides tools for searching and fetching information from Hacker News.",
    "icon": "https://avatars.githubusercontent.com/erithwik",
    "isOfficial": false,
    "homepage": "https://github.com/erithwik/mcp-hn",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-hn"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_stories",
        "description": "Get stories from Hacker News. The options are `top`, `new`, `ask_hn`, `show_hn` for types of stories. This doesn't include the comments. Use `get_story_info` to get the comments.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "story_type": {
              "type": "string",
              "description": "Type of stories to get, one of: `top`, `new`, `ask_hn`, `show_hn`"
            },
            "num_stories": {
              "type": "integer",
              "description": "Number of stories to get"
            }
          }
        }
      },
      {
        "name": "get_user_info",
        "description": "Get user info from Hacker News, including the stories they've submitted",
        "inputSchema": {
          "type": "object",
          "properties": {
            "user_name": {
              "type": "string",
              "description": "Username of the user"
            },
            "num_stories": {
              "type": "integer",
              "description": "Number of stories to get, defaults to 10"
            }
          },
          "required": [
            "user_name"
          ]
        }
      },
      {
        "name": "search_stories",
        "description": "Search stories from Hacker News. It is generally recommended to use simpler queries to get a broader set of results (less than 5 words). Very targetted queries may not return any results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "num_results": {
              "type": "integer",
              "description": "Number of results to get, defaults to 10"
            },
            "search_by_date": {
              "type": "boolean",
              "description": "Search by date, defaults to False. If this is False, then we search by relevance, then points, then number of comments."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "get_story_info",
        "description": "Get detailed story info from Hacker News, including the comments",
        "inputSchema": {
          "type": "object",
          "properties": {
            "story_id": {
              "type": "integer",
              "description": "Story ID"
            }
          }
        }
      }
    ]
  },
  {
    "name": "ruixingshi-deepseek-thinker-mcp",
    "title": "Deepseek Thinker MCP Server",
    "description": "Provides reasoning content to MCP-enabled AI clients by interfacing with Deepseek's API or a local Ollama server, enabling focused reasoning and thought process visualization.",
    "icon": "https://avatars.githubusercontent.com/ruixingshi",
    "isOfficial": false,
    "homepage": "https://github.com/ruixingshi/deepseek-thinker-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "deepseek-thinker-mcp"
      ],
      "env": {
        "API_KEY": "<api-key>",
        "BASE_URL": "<base-url>",
        "USE_OLLAMA": "<use-ollama>"
      }
    },
    "parameters": [
      {
        "name": "API_KEY",
        "description": "Your OpenAI API Key for accessing Deepseek API",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "BASE_URL",
        "description": "API Base URL for the Deepseek API service",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "USE_OLLAMA",
        "description": "Enable Ollama local mode instead of OpenAI API mode",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get-deepseek-thinker",
        "description": "think with deepseek",
        "inputSchema": {
          "type": "object",
          "properties": {
            "originPrompt": {
              "type": "string",
              "description": "user's original prompt"
            }
          },
          "required": [
            "originPrompt"
          ]
        }
      }
    ]
  },
  {
    "name": "sakce-mcp-server-monday",
    "title": "Monday.com MCP Server",
    "description": "Enables MCP clients to interact with Monday.com boards, allowing creation and management of items, sub-items, comments, and retrieval of board information.",
    "icon": "https://avatars.githubusercontent.com/sakce",
    "isOfficial": false,
    "homepage": "https://github.com/sakce/mcp-server-monday",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-monday"
      ],
      "env": {
        "MONDAY_API_KEY": "<monday-api-key>",
        "MONDAY_WORKSPACE_NAME": "<monday-workspace-name>"
      }
    },
    "parameters": [
      {
        "name": "MONDAY_API_KEY",
        "description": "Your personal API token from Monday.com",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MONDAY_WORKSPACE_NAME",
        "description": "The name of your Monday.com workspace (from the URL, e.g., 'myworkspace' from 'https://myworkspace.monday.com/')",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "monday-create-item",
        "description": "Create a new item in a Monday.com Board. Optionally, specify the parent Item ID to create a Sub-item.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string"
            },
            "groupId": {
              "type": "string"
            },
            "itemTitle": {
              "type": "string"
            },
            "parentItemId": {
              "type": "string"
            }
          },
          "required": [
            "boardId",
            "itemTitle"
          ]
        }
      },
      {
        "name": "monday-get-board-groups",
        "description": "Get the Groups of a Monday.com Board.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string"
            }
          },
          "required": [
            "boardId"
          ]
        }
      },
      {
        "name": "monday-create-update",
        "description": "Create an update (comment) on a Monday.com item",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemId": {
              "type": "string"
            },
            "updateText": {
              "type": "string"
            }
          },
          "required": [
            "itemId",
            "updateText"
          ]
        }
      },
      {
        "name": "monday-list-boards",
        "description": "Get all boards from Monday.com",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "description": "Maximum number of boards to return"
            }
          }
        }
      },
      {
        "name": "monday-list-items-in-groups",
        "description": "List all items in the specified groups of a Monday.com board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer"
            },
            "cursor": {
              "type": "string"
            },
            "boardId": {
              "type": "string"
            },
            "groupIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "boardId",
            "groupIds"
          ]
        }
      },
      {
        "name": "monday-list-subitems-in-items",
        "description": "List all Sub-items of a list of Monday Items",
        "inputSchema": {
          "type": "object",
          "properties": {
            "itemIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "itemIds"
          ]
        }
      }
    ]
  },
  {
    "name": "sammcj-mcp-github-issue",
    "title": "MCP GitHub Issue Server",
    "description": "Enables LLMs to interact with GitHub issues by providing details as tasks, allowing for seamless integration and task management through GitHub's platform.",
    "icon": "https://avatars.githubusercontent.com/sammcj",
    "isOfficial": false,
    "homepage": "https://github.com/sammcj/mcp-github-issue",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-github-issue"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "sanderkooger-mcp-server-ragdocs",
    "title": "@sanderkooger/mcp-server-ragdocs",
    "description": "An MCP server implementation that provides tools for retrieving and processing documentation through vector search, enabling AI assistants to augment their responses with relevant documentation context.\n\nUses Ollama or OpenAI to generate embeddings.\n\nDocker files included",
    "icon": "https://avatars.githubusercontent.com/sanderkooger",
    "isOfficial": false,
    "homepage": "https://github.com/sanderkooger/mcp-server-ragdocs",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@sanderkooger/mcp-server-ragdocs"
      ],
      "env": {
        "QDRANT_URL": "<qdrant-url>",
        "OPENAI_API_KEY": "<openai-api-key>",
        "QDRANT_API_KEY": "<qdrant-api-key>",
        "OLLAMA_BASE_URL": "<ollama-base-url>",
        "EMBEDDINGS_PROVIDER": "<embeddings-provider>"
      }
    },
    "parameters": [
      {
        "name": "QDRANT_URL",
        "description": "URL of your Qdrant vector database instance",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "OPENAI_API_KEY",
        "description": "API key for OpenAI (required when EMBEDDINGS_PROVIDER is 'openai')",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "QDRANT_API_KEY",
        "description": "API key for authenticating with Qdrant (if applicable)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OLLAMA_BASE_URL",
        "description": "Base URL for Ollama service (used when EMBEDDINGS_PROVIDER is 'ollama')",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "EMBEDDINGS_PROVIDER",
        "description": "Provider to use for generating embeddings",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "sapientpants-deepsource-mcp-server",
    "title": "DeepSource MCP Server",
    "description": "A Model Context Protocol server that integrates with DeepSource to provide AI assistants with access to code quality metrics, issues, and analysis results.",
    "icon": "https://avatars.githubusercontent.com/sapientpants",
    "isOfficial": false,
    "homepage": "https://github.com/sapientpants/deepsource-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "deepsource-mcp-server"
      ],
      "env": {
        "DEEPSOURCE_API_KEY": "<deepsource-api-key>"
      }
    },
    "parameters": [
      {
        "name": "DEEPSOURCE_API_KEY",
        "description": "Your DeepSource API key for authentication with the DeepSource API",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "deepsource_projects",
        "description": "List all available DeepSource projects. Returns a list of project objects with \"key\" and \"name\" properties.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "deepsource_project_issues",
        "description": "Get issues from a DeepSource project with support for Relay-style cursor-based pagination and filtering.\nFor forward pagination, use `first` (defaults to 10) with optional `after` cursor.\nFor backward pagination, use `last` (defaults to 10) with optional `before` cursor.\nThe response includes `pageInfo` with `hasNextPage`, `hasPreviousPage`, `startCursor`, and `endCursor`\nto help navigate through pages.\n\nFiltering options:\n- `path`: Filter issues by specific file path\n- `analyzerIn`: Filter issues by specific analyzers\n- `tags`: Filter issues by tags",
        "inputSchema": {
          "type": "object",
          "properties": {
            "last": {
              "type": "number",
              "description": "Number of items to return before the \"before\" cursor (default: 10)"
            },
            "path": {
              "type": "string",
              "description": "Filter issues by specific file path"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter issues by tags"
            },
            "after": {
              "type": "string",
              "description": "Cursor to fetch records after this position"
            },
            "first": {
              "type": "number",
              "description": "Number of items to return after the \"after\" cursor (default: 10)"
            },
            "before": {
              "type": "string",
              "description": "Cursor to fetch records before this position"
            },
            "offset": {
              "type": "number",
              "description": "Legacy pagination: Number of items to skip"
            },
            "analyzerIn": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter issues by specific analyzers (e.g. [\"python\", \"javascript\"])"
            },
            "projectKey": {
              "type": "string",
              "description": "The unique identifier for the DeepSource project"
            }
          },
          "required": [
            "projectKey"
          ]
        }
      },
      {
        "name": "deepsource_project_runs",
        "description": "List analysis runs for a DeepSource project with support for Relay-style cursor-based pagination and filtering.\nFor forward pagination, use `first` (defaults to 10) with optional `after` cursor.\nFor backward pagination, use `last` (defaults to 10) with optional `before` cursor.\nThe response includes `pageInfo` with `hasNextPage`, `hasPreviousPage`, `startCursor`, and `endCursor`\nto help navigate through pages.\n\nFiltering options:\n- `analyzerIn`: Filter runs by specific analyzers",
        "inputSchema": {
          "type": "object",
          "properties": {
            "last": {
              "type": "number",
              "description": "Number of items to return before the \"before\" cursor (default: 10)"
            },
            "after": {
              "type": "string",
              "description": "Cursor to fetch records after this position"
            },
            "first": {
              "type": "number",
              "description": "Number of items to return after the \"after\" cursor (default: 10)"
            },
            "before": {
              "type": "string",
              "description": "Cursor to fetch records before this position"
            },
            "offset": {
              "type": "number",
              "description": "Legacy pagination: Number of items to skip"
            },
            "analyzerIn": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter runs by specific analyzers (e.g. [\"python\", \"javascript\"])"
            },
            "projectKey": {
              "type": "string",
              "description": "The unique identifier for the DeepSource project"
            }
          },
          "required": [
            "projectKey"
          ]
        }
      },
      {
        "name": "deepsource_run",
        "description": "Get a specific analysis run by its runUid (UUID) or commitOid (commit hash).",
        "inputSchema": {
          "type": "object",
          "properties": {
            "runIdentifier": {
              "type": "string",
              "description": "The runUid (UUID) or commitOid (commit hash) to identify the run"
            }
          },
          "required": [
            "runIdentifier"
          ]
        }
      },
      {
        "name": "deepsource_dependency_vulnerabilities",
        "description": "Get dependency vulnerabilities from a DeepSource project with support for Relay-style cursor-based pagination.\nFor forward pagination, use `first` (defaults to 10) with optional `after` cursor.\nFor backward pagination, use `last` (defaults to 10) with optional `before` cursor.\nThe response includes `pageInfo` with `hasNextPage`, `hasPreviousPage`, `startCursor`, and `endCursor`\nto help navigate through pages.\n\nThe response provides detailed information about each vulnerability, including:\n- Package information (name, ecosystem, purl)\n- Package version details\n- Vulnerability details (identifiers, severity, CVSS scores)\n- Reachability status (whether the vulnerability is reachable in the code)\n- Fixability information (whether and how the vulnerability can be fixed)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "last": {
              "type": "integer",
              "description": "Number of items to return before the \"before\" cursor (default: 10)",
              "exclusiveMinimum": 0
            },
            "after": {
              "type": "string",
              "description": "Cursor to fetch records after this position"
            },
            "first": {
              "type": "integer",
              "description": "Number of items to return after the \"after\" cursor (default: 10)",
              "exclusiveMinimum": 0
            },
            "before": {
              "type": "string",
              "description": "Cursor to fetch records before this position"
            },
            "offset": {
              "type": "integer",
              "minimum": 0,
              "description": "Legacy pagination: Number of items to skip"
            },
            "projectKey": {
              "type": "string",
              "minLength": 1,
              "description": "The unique identifier for the DeepSource project"
            }
          },
          "required": [
            "projectKey"
          ]
        }
      },
      {
        "name": "deepsource_quality_metrics",
        "description": "Get quality metrics from a DeepSource project with optional filtering by metric type.\n  \n  Metrics include code coverage, duplicate code percentage, and more, along with their:\n  - Current values\n  - Threshold settings\n  - Pass/fail status\n  - Configuration status (reporting and enforcement)\n\n  For each metric, detailed information is provided for different programming languages\n  and the aggregated metrics for the entire repository.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectKey": {
              "type": "string",
              "description": "The unique identifier for the DeepSource project"
            },
            "shortcodeIn": {
              "type": "array",
              "items": {
                "enum": [
                  "LCV",
                  "BCV",
                  "DCV",
                  "DDP",
                  "SCV",
                  "TCV",
                  "CMP"
                ],
                "type": "string"
              },
              "description": "Filter metrics by specific shortcodes (e.g., [\"LCV\", \"BCV\"])"
            }
          },
          "required": [
            "projectKey"
          ]
        }
      },
      {
        "name": "deepsource_update_metric_threshold",
        "description": "Update the threshold for a specific quality metric in a DeepSource project.\n  \n  This allows setting or removing threshold values that determine if a metric passes or fails.\n  Thresholds can be set per language or for the entire repository (AGGREGATE).\n\n  Examples:\n  - Set a 80% line coverage threshold: metricShortcode=\"LCV\", metricKey=\"AGGREGATE\", thresholdValue=80\n  - Remove a threshold: metricShortcode=\"LCV\", metricKey=\"AGGREGATE\", thresholdValue=null",
        "inputSchema": {
          "type": "object",
          "properties": {
            "metricKey": {
              "enum": [
                "AGGREGATE",
                "PYTHON",
                "JAVASCRIPT",
                "TYPESCRIPT",
                "GO",
                "JAVA",
                "RUBY",
                "RUST"
              ],
              "type": "string",
              "description": "The language or context key for the metric"
            },
            "projectKey": {
              "type": "string",
              "description": "The unique identifier for the DeepSource project"
            },
            "repositoryId": {
              "type": "string",
              "description": "The GraphQL repository ID (get this from deepsource_quality_metrics response)"
            },
            "thresholdValue": {
              "type": [
                "number",
                "null"
              ],
              "description": "The new threshold value (null to remove the threshold)"
            },
            "metricShortcode": {
              "enum": [
                "LCV",
                "BCV",
                "DCV",
                "DDP",
                "SCV",
                "TCV",
                "CMP"
              ],
              "type": "string",
              "description": "The shortcode of the metric to update"
            }
          },
          "required": [
            "projectKey",
            "repositoryId",
            "metricShortcode",
            "metricKey"
          ]
        }
      },
      {
        "name": "deepsource_update_metric_setting",
        "description": "Update the settings for a quality metric in a DeepSource project.\n  \n  This allows configuring how metrics are used in the project:\n  - Enable/disable reporting the metric in the UI and API\n  - Enable/disable enforcing thresholds (failing checks when thresholds aren't met)\n  \n  Example:\n  - Enable reporting and enforce thresholds: isReported=true, isThresholdEnforced=true\n  - Only report but don't enforce: isReported=true, isThresholdEnforced=false\n  - Disable completely: isReported=false, isThresholdEnforced=false",
        "inputSchema": {
          "type": "object",
          "properties": {
            "isReported": {
              "type": "boolean",
              "description": "Whether the metric should be reported"
            },
            "projectKey": {
              "type": "string",
              "description": "The unique identifier for the DeepSource project"
            },
            "repositoryId": {
              "type": "string",
              "description": "The GraphQL repository ID (get this from deepsource_quality_metrics response)"
            },
            "metricShortcode": {
              "enum": [
                "LCV",
                "BCV",
                "DCV",
                "DDP",
                "SCV",
                "TCV",
                "CMP"
              ],
              "type": "string",
              "description": "The shortcode of the metric to update"
            },
            "isThresholdEnforced": {
              "type": "boolean",
              "description": "Whether the threshold should be enforced (can fail checks)"
            }
          },
          "required": [
            "projectKey",
            "repositoryId",
            "metricShortcode",
            "isReported",
            "isThresholdEnforced"
          ]
        }
      },
      {
        "name": "deepsource_compliance_report",
        "description": "Get security compliance reports from a DeepSource project.\n\n  This tool provides access to industry-standard security compliance reports including:\n  - OWASP Top 10: Common web application security vulnerabilities\n  - SANS Top 25: Most dangerous software errors\n  - MISRA-C: Guidelines for safety-critical software in C\n\n  The response includes:\n  - Comprehensive statistics about security issues by category and severity\n  - Compliance status (passing/failing)\n  - Recommendations for improving security posture\n  - Trend data showing changes over time",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectKey": {
              "type": "string",
              "description": "The unique identifier for the DeepSource project"
            },
            "reportType": {
              "enum": [
                "OWASP_TOP_10",
                "SANS_TOP_25",
                "MISRA_C",
                "CODE_COVERAGE",
                "CODE_HEALTH_TREND",
                "ISSUE_DISTRIBUTION",
                "ISSUES_PREVENTED",
                "ISSUES_AUTOFIXED"
              ],
              "type": "string",
              "description": "The type of compliance report to fetch (OWASP_TOP_10, SANS_TOP_25, or MISRA_C)"
            }
          },
          "required": [
            "projectKey",
            "reportType"
          ]
        }
      }
    ]
  },
  {
    "name": "mcp2everything-mcp2tcp",
    "title": "mcp2tcp",
    "description": "A bridge connecting physical hardware with AI large language models through the Model Context Protocol (MCP), enabling natural language control of TCP devices.",
    "icon": "https://avatars.githubusercontent.com/mcp2everything",
    "isOfficial": false,
    "homepage": "https://github.com/mcp2everything/mcp2tcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp2tcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "pwm",
        "description": "把PWM调到最大 (frequency=100)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "frequency": {
              "type": "string",
              "examples": [
                "请将PWM设置为value (0-100的整数)"
              ],
              "description": "Parameter frequency for the pwm command"
            }
          },
          "required": [
            "frequency"
          ]
        }
      },
      {
        "name": "pico_info",
        "description": "查询Pico板信息",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "led",
        "description": "打开LED (state=on)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "state": {
              "type": "string",
              "examples": [
                "设置LED状态为value (on或off)"
              ],
              "description": "Parameter state for the led command"
            }
          },
          "required": [
            "state"
          ]
        }
      }
    ]
  },
  {
    "name": "shannonlal-mcp-postman",
    "title": "Postman MCP Server",
    "description": "Enables running Postman collections using Newman for conducting API tests and obtaining detailed result analysis via a standardized interface.",
    "icon": "https://avatars.githubusercontent.com/shannonlal",
    "isOfficial": false,
    "homepage": "https://github.com/shannonlal/mcp-postman",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-postman"
      ],
      "env": {
        "globals": "<globals>",
        "collection": "<collection>",
        "environment": "<environment>",
        "iterationCount": "<iterationcount>"
      }
    },
    "parameters": [
      {
        "name": "globals",
        "description": "Path or URL to globals file",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "collection",
        "description": "Path or URL to the Postman collection",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "environment",
        "description": "Path or URL to environment file",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "iterationCount",
        "description": "Number of iterations to run",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "shinzo-labs-gmail-mcp",
    "title": "Gmail MCP",
    "description": "Manage your emails effortlessly with a standardized interface for drafting, sending, retrieving, and organizing messages. Streamline your email workflow with complete Gmail API coverage, including label and thread management.",
    "icon": "https://avatars.githubusercontent.com/shinzo-labs",
    "isOfficial": false,
    "homepage": "https://github.com/shinzo-labs/gmail-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@shinzolabs/gmail-mcp"
      ],
      "env": {
        "CLIENT_ID": "<client-id>",
        "CLIENT_SECRET": "<client-secret>",
        "REFRESH_TOKEN": "<refresh-token>",
        "MCP_CONFIG_DIR": "<mcp-config-dir>",
        "AUTH_SERVER_PORT": "<auth-server-port>"
      }
    },
    "parameters": [
      {
        "name": "CLIENT_ID",
        "description": "Google OAuth2 client ID, only required if running without credentials JSON file",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CLIENT_SECRET",
        "description": "Google OAuth2 client secret, only required if running without credentials JSON file",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "REFRESH_TOKEN",
        "description": "Google OAuth2 initial refresh token, only required if running without credentials JSON file",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_CONFIG_DIR",
        "description": "Path for MCP credentials config, defaults to $HOME, only required if CLIENT_ID, CLIENT_SECRET, and REFRESH_TOKEN are not specified",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "AUTH_SERVER_PORT",
        "description": "Port for auth server to listen on when authenticating locally with pnpm run auth, defaults to 3000",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "create_draft",
        "description": "Create a draft email in Gmail. Note the mechanics of the raw parameter.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cc": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of CC recipient email addresses"
            },
            "to": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of recipient email addresses"
            },
            "bcc": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of BCC recipient email addresses"
            },
            "raw": {
              "type": "string",
              "description": "The entire email message in base64url encoded RFC 2822 format, ignores params.to, cc, bcc, subject, body, includeBodyHtml if provided"
            },
            "body": {
              "type": "string",
              "description": "The body of the email"
            },
            "subject": {
              "type": "string",
              "description": "The subject of the email"
            },
            "threadId": {
              "type": "string",
              "description": "The thread ID to associate this draft with"
            },
            "includeBodyHtml": {
              "type": "boolean",
              "description": "Whether to include the parsed HTML in the return for each body, excluded by default because they can be excessively large"
            }
          }
        }
      },
      {
        "name": "delete_draft",
        "description": "Delete a draft",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the draft to delete"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_draft",
        "description": "Get a specific draft by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the draft to retrieve"
            },
            "includeBodyHtml": {
              "type": "boolean",
              "description": "Whether to include the parsed HTML in the return for each body, excluded by default because they can be excessively large"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_drafts",
        "description": "List drafts in the user's mailbox",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "description": "Only return drafts matching the specified query. Supports the same query format as the Gmail search box"
            },
            "maxResults": {
              "type": "number",
              "description": "Maximum number of drafts to return. Accepts values between 1-500"
            },
            "includeBodyHtml": {
              "type": "boolean",
              "description": "Whether to include the parsed HTML in the return for each body, excluded by default because they can be excessively large"
            },
            "includeSpamTrash": {
              "type": "boolean",
              "description": "Include drafts from SPAM and TRASH in the results"
            }
          }
        }
      },
      {
        "name": "send_draft",
        "description": "Send an existing draft",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the draft to send"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "create_label",
        "description": "Create a new label",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "The display name of the label"
            },
            "color": {
              "type": "object",
              "required": [
                "textColor",
                "backgroundColor"
              ],
              "properties": {
                "textColor": {
                  "type": "string",
                  "description": "The text color of the label as hex string"
                },
                "backgroundColor": {
                  "type": "string",
                  "description": "The background color of the label as hex string"
                }
              },
              "description": "The color settings for the label",
              "additionalProperties": false
            },
            "labelListVisibility": {
              "enum": [
                "labelShow",
                "labelShowIfUnread",
                "labelHide"
              ],
              "type": "string",
              "description": "The visibility of the label in the label list"
            },
            "messageListVisibility": {
              "enum": [
                "show",
                "hide"
              ],
              "type": "string",
              "description": "The visibility of messages with this label in the message list"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "delete_label",
        "description": "Delete a label",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the label to delete"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_label",
        "description": "Get a specific label by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the label to retrieve"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_labels",
        "description": "List all labels in the user's mailbox",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "patch_label",
        "description": "Patch an existing label (partial update)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the label to patch"
            },
            "name": {
              "type": "string",
              "description": "The display name of the label"
            },
            "color": {
              "type": "object",
              "required": [
                "textColor",
                "backgroundColor"
              ],
              "properties": {
                "textColor": {
                  "type": "string",
                  "description": "The text color of the label as hex string"
                },
                "backgroundColor": {
                  "type": "string",
                  "description": "The background color of the label as hex string"
                }
              },
              "description": "The color settings for the label",
              "additionalProperties": false
            },
            "labelListVisibility": {
              "enum": [
                "labelShow",
                "labelShowIfUnread",
                "labelHide"
              ],
              "type": "string",
              "description": "The visibility of the label in the label list"
            },
            "messageListVisibility": {
              "enum": [
                "show",
                "hide"
              ],
              "type": "string",
              "description": "The visibility of messages with this label in the message list"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "update_label",
        "description": "Update an existing label",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the label to update"
            },
            "name": {
              "type": "string",
              "description": "The display name of the label"
            },
            "color": {
              "type": "object",
              "required": [
                "textColor",
                "backgroundColor"
              ],
              "properties": {
                "textColor": {
                  "type": "string",
                  "description": "The text color of the label as hex string"
                },
                "backgroundColor": {
                  "type": "string",
                  "description": "The background color of the label as hex string"
                }
              },
              "description": "The color settings for the label",
              "additionalProperties": false
            },
            "labelListVisibility": {
              "enum": [
                "labelShow",
                "labelShowIfUnread",
                "labelHide"
              ],
              "type": "string",
              "description": "The visibility of the label in the label list"
            },
            "messageListVisibility": {
              "enum": [
                "show",
                "hide"
              ],
              "type": "string",
              "description": "The visibility of messages with this label in the message list"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "batch_delete_messages",
        "description": "Delete multiple messages",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The IDs of the messages to delete"
            }
          },
          "required": [
            "ids"
          ]
        }
      },
      {
        "name": "batch_modify_messages",
        "description": "Modify the labels on multiple messages",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The IDs of the messages to modify"
            },
            "addLabelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of label IDs to add to the messages"
            },
            "removeLabelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of label IDs to remove from the messages"
            }
          },
          "required": [
            "ids"
          ]
        }
      },
      {
        "name": "delete_message",
        "description": "Immediately and permanently delete a message",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the message to delete"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_message",
        "description": "Get a specific message by ID with format options",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the message to retrieve"
            },
            "includeBodyHtml": {
              "type": "boolean",
              "description": "Whether to include the parsed HTML in the return for each body, excluded by default because they can be excessively large"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_messages",
        "description": "List messages in the user's mailbox with optional filtering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "description": "Only return messages matching the specified query. Supports the same query format as the Gmail search box"
            },
            "labelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Only return messages with labels that match all of the specified label IDs"
            },
            "pageToken": {
              "type": "string",
              "description": "Page token to retrieve a specific page of results"
            },
            "maxResults": {
              "type": "number",
              "description": "Maximum number of messages to return. Accepts values between 1-500"
            },
            "includeBodyHtml": {
              "type": "boolean",
              "description": "Whether to include the parsed HTML in the return for each body, excluded by default because they can be excessively large"
            },
            "includeSpamTrash": {
              "type": "boolean",
              "description": "Include messages from SPAM and TRASH in the results"
            }
          }
        }
      },
      {
        "name": "modify_message",
        "description": "Modify the labels on a message",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the message to modify"
            },
            "addLabelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of label IDs to add to the message"
            },
            "removeLabelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of label IDs to remove from the message"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "send_message",
        "description": "Send an email message to specified recipients. Note the mechanics of the raw parameter.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cc": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of CC recipient email addresses"
            },
            "to": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of recipient email addresses"
            },
            "bcc": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of BCC recipient email addresses"
            },
            "raw": {
              "type": "string",
              "description": "The entire email message in base64url encoded RFC 2822 format, ignores params.to, cc, bcc, subject, body, includeBodyHtml if provided"
            },
            "body": {
              "type": "string",
              "description": "The body of the email"
            },
            "subject": {
              "type": "string",
              "description": "The subject of the email"
            },
            "threadId": {
              "type": "string",
              "description": "The thread ID to associate this message with"
            },
            "includeBodyHtml": {
              "type": "boolean",
              "description": "Whether to include the parsed HTML in the return for each body, excluded by default because they can be excessively large"
            }
          }
        }
      },
      {
        "name": "trash_message",
        "description": "Move a message to the trash",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the message to move to trash"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "untrash_message",
        "description": "Remove a message from the trash",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the message to remove from trash"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_attachment",
        "description": "Get a message attachment",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the attachment"
            },
            "messageId": {
              "type": "string",
              "description": "ID of the message containing the attachment"
            }
          },
          "required": [
            "messageId",
            "id"
          ]
        }
      },
      {
        "name": "delete_thread",
        "description": "Delete a thread",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the thread to delete"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_thread",
        "description": "Get a specific thread by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the thread to retrieve"
            },
            "includeBodyHtml": {
              "type": "boolean",
              "description": "Whether to include the parsed HTML in the return for each body, excluded by default because they can be excessively large"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_threads",
        "description": "List threads in the user's mailbox",
        "inputSchema": {
          "type": "object",
          "properties": {
            "q": {
              "type": "string",
              "description": "Only return threads matching the specified query"
            },
            "labelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Only return threads with labels that match all of the specified label IDs"
            },
            "pageToken": {
              "type": "string",
              "description": "Page token to retrieve a specific page of results"
            },
            "maxResults": {
              "type": "number",
              "description": "Maximum number of threads to return"
            },
            "includeBodyHtml": {
              "type": "boolean",
              "description": "Whether to include the parsed HTML in the return for each body, excluded by default because they can be excessively large"
            },
            "includeSpamTrash": {
              "type": "boolean",
              "description": "Include threads from SPAM and TRASH in the results"
            }
          }
        }
      },
      {
        "name": "modify_thread",
        "description": "Modify the labels applied to a thread",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the thread to modify"
            },
            "addLabelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of label IDs to add to the thread"
            },
            "removeLabelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "A list of label IDs to remove from the thread"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "trash_thread",
        "description": "Move a thread to the trash",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the thread to move to trash"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "untrash_thread",
        "description": "Remove a thread from the trash",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the thread to remove from trash"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_auto_forwarding",
        "description": "Gets auto-forwarding settings",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_imap",
        "description": "Gets IMAP settings",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_language",
        "description": "Gets language settings",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_pop",
        "description": "Gets POP settings",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_vacation",
        "description": "Get vacation responder settings",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "update_auto_forwarding",
        "description": "Updates automatic forwarding settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Whether all incoming mail is automatically forwarded to another address"
            },
            "disposition": {
              "enum": [
                "leaveInInbox",
                "archive",
                "trash",
                "markRead"
              ],
              "type": "string",
              "description": "The state in which messages should be left after being forwarded"
            },
            "emailAddress": {
              "type": "string",
              "description": "Email address to which messages should be automatically forwarded"
            }
          },
          "required": [
            "enabled",
            "emailAddress",
            "disposition"
          ]
        }
      },
      {
        "name": "update_imap",
        "description": "Updates IMAP settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Whether IMAP is enabled for the account"
            },
            "maxFolderSize": {
              "type": "number",
              "description": "An optional limit on the number of messages that can be accessed through IMAP"
            },
            "expungeBehavior": {
              "enum": [
                "archive",
                "trash",
                "deleteForever"
              ],
              "type": "string",
              "description": "The action that will be executed on a message when it is marked as deleted and expunged from the last visible IMAP folder"
            }
          },
          "required": [
            "enabled"
          ]
        }
      },
      {
        "name": "update_language",
        "description": "Updates language settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "displayLanguage": {
              "type": "string",
              "description": "The language to display Gmail in, formatted as an RFC 3066 Language Tag"
            }
          },
          "required": [
            "displayLanguage"
          ]
        }
      },
      {
        "name": "update_pop",
        "description": "Updates POP settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "disposition": {
              "enum": [
                "archive",
                "trash",
                "leaveInInbox"
              ],
              "type": "string",
              "description": "The action that will be executed on a message after it has been fetched via POP"
            },
            "accessWindow": {
              "enum": [
                "disabled",
                "allMail",
                "fromNowOn"
              ],
              "type": "string",
              "description": "The range of messages which are accessible via POP"
            }
          },
          "required": [
            "accessWindow",
            "disposition"
          ]
        }
      },
      {
        "name": "update_vacation",
        "description": "Update vacation responder settings",
        "inputSchema": {
          "type": "object",
          "properties": {
            "endTime": {
              "type": "string",
              "description": "End time for sending auto-replies (epoch ms)"
            },
            "startTime": {
              "type": "string",
              "description": "Start time for sending auto-replies (epoch ms)"
            },
            "enableAutoReply": {
              "type": "boolean",
              "description": "Whether the vacation responder is enabled"
            },
            "responseSubject": {
              "type": "string",
              "description": "Optional subject line for the vacation responder auto-reply"
            },
            "restrictToDomain": {
              "type": "boolean",
              "description": "Whether responses are only sent to users in the same domain"
            },
            "restrictToContacts": {
              "type": "boolean",
              "description": "Whether responses are only sent to contacts"
            },
            "responseBodyPlainText": {
              "type": "string",
              "description": "Response body in plain text format"
            }
          },
          "required": [
            "enableAutoReply",
            "responseBodyPlainText"
          ]
        }
      },
      {
        "name": "add_delegate",
        "description": "Adds a delegate to the specified account",
        "inputSchema": {
          "type": "object",
          "properties": {
            "delegateEmail": {
              "type": "string",
              "description": "Email address of delegate to add"
            }
          },
          "required": [
            "delegateEmail"
          ]
        }
      },
      {
        "name": "remove_delegate",
        "description": "Removes the specified delegate",
        "inputSchema": {
          "type": "object",
          "properties": {
            "delegateEmail": {
              "type": "string",
              "description": "Email address of delegate to remove"
            }
          },
          "required": [
            "delegateEmail"
          ]
        }
      },
      {
        "name": "get_delegate",
        "description": "Gets the specified delegate",
        "inputSchema": {
          "type": "object",
          "properties": {
            "delegateEmail": {
              "type": "string",
              "description": "The email address of the delegate to retrieve"
            }
          },
          "required": [
            "delegateEmail"
          ]
        }
      },
      {
        "name": "list_delegates",
        "description": "Lists the delegates for the specified account",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_filter",
        "description": "Creates a filter",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "type": "object",
              "properties": {
                "forward": {
                  "type": "string",
                  "description": "Email address that the message should be forwarded to"
                },
                "addLabelIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "List of labels to add to messages"
                },
                "removeLabelIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "List of labels to remove from messages"
                }
              },
              "description": "Actions to perform on messages matching the criteria",
              "additionalProperties": false
            },
            "criteria": {
              "type": "object",
              "properties": {
                "to": {
                  "type": "string",
                  "description": "The recipient's display name or email address"
                },
                "from": {
                  "type": "string",
                  "description": "The sender's display name or email address"
                },
                "size": {
                  "type": "number",
                  "description": "The size of the entire RFC822 message in bytes"
                },
                "query": {
                  "type": "string",
                  "description": "A Gmail search query that specifies the filter's criteria"
                },
                "subject": {
                  "type": "string",
                  "description": "Case-insensitive phrase in the message's subject"
                },
                "excludeChats": {
                  "type": "boolean",
                  "description": "Whether the response should exclude chats"
                },
                "negatedQuery": {
                  "type": "string",
                  "description": "A Gmail search query that specifies criteria the message must not match"
                },
                "hasAttachment": {
                  "type": "boolean",
                  "description": "Whether the message has any attachment"
                },
                "sizeComparison": {
                  "enum": [
                    "smaller",
                    "larger"
                  ],
                  "type": "string",
                  "description": "How the message size in bytes should be in relation to the size field"
                }
              },
              "description": "Filter criteria",
              "additionalProperties": false
            }
          },
          "required": [
            "criteria",
            "action"
          ]
        }
      },
      {
        "name": "delete_filter",
        "description": "Deletes a filter",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the filter to be deleted"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_filter",
        "description": "Gets a filter",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID of the filter to be fetched"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "list_filters",
        "description": "Lists the message filters of a Gmail user",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_forwarding_address",
        "description": "Creates a forwarding address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "forwardingEmail": {
              "type": "string",
              "description": "An email address to which messages can be forwarded"
            }
          },
          "required": [
            "forwardingEmail"
          ]
        }
      },
      {
        "name": "delete_forwarding_address",
        "description": "Deletes the specified forwarding address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "forwardingEmail": {
              "type": "string",
              "description": "The forwarding address to be deleted"
            }
          },
          "required": [
            "forwardingEmail"
          ]
        }
      },
      {
        "name": "get_forwarding_address",
        "description": "Gets the specified forwarding address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "forwardingEmail": {
              "type": "string",
              "description": "The forwarding address to be retrieved"
            }
          },
          "required": [
            "forwardingEmail"
          ]
        }
      },
      {
        "name": "list_forwarding_addresses",
        "description": "Lists the forwarding addresses for the specified account",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "create_send_as",
        "description": "Creates a custom send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "isPrimary": {
              "type": "boolean",
              "description": "Whether this address is the primary address"
            },
            "signature": {
              "type": "string",
              "description": "An optional HTML signature"
            },
            "displayName": {
              "type": "string",
              "description": "A name that appears in the 'From:' header"
            },
            "sendAsEmail": {
              "type": "string",
              "description": "The email address that appears in the 'From:' header"
            },
            "treatAsAlias": {
              "type": "boolean",
              "description": "Whether Gmail should treat this address as an alias"
            },
            "replyToAddress": {
              "type": "string",
              "description": "An optional email address that is included in a 'Reply-To:' header"
            }
          },
          "required": [
            "sendAsEmail"
          ]
        }
      },
      {
        "name": "delete_send_as",
        "description": "Deletes the specified send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sendAsEmail": {
              "type": "string",
              "description": "The send-as alias to be deleted"
            }
          },
          "required": [
            "sendAsEmail"
          ]
        }
      },
      {
        "name": "get_send_as",
        "description": "Gets the specified send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sendAsEmail": {
              "type": "string",
              "description": "The send-as alias to be retrieved"
            }
          },
          "required": [
            "sendAsEmail"
          ]
        }
      },
      {
        "name": "list_send_as",
        "description": "Lists the send-as aliases for the specified account",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "patch_send_as",
        "description": "Patches the specified send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "isPrimary": {
              "type": "boolean",
              "description": "Whether this address is the primary address"
            },
            "signature": {
              "type": "string",
              "description": "An optional HTML signature"
            },
            "displayName": {
              "type": "string",
              "description": "A name that appears in the 'From:' header"
            },
            "sendAsEmail": {
              "type": "string",
              "description": "The send-as alias to be updated"
            },
            "treatAsAlias": {
              "type": "boolean",
              "description": "Whether Gmail should treat this address as an alias"
            },
            "replyToAddress": {
              "type": "string",
              "description": "An optional email address that is included in a 'Reply-To:' header"
            }
          },
          "required": [
            "sendAsEmail"
          ]
        }
      },
      {
        "name": "update_send_as",
        "description": "Updates a send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "isPrimary": {
              "type": "boolean",
              "description": "Whether this address is the primary address"
            },
            "signature": {
              "type": "string",
              "description": "An optional HTML signature"
            },
            "displayName": {
              "type": "string",
              "description": "A name that appears in the 'From:' header"
            },
            "sendAsEmail": {
              "type": "string",
              "description": "The send-as alias to be updated"
            },
            "treatAsAlias": {
              "type": "boolean",
              "description": "Whether Gmail should treat this address as an alias"
            },
            "replyToAddress": {
              "type": "string",
              "description": "An optional email address that is included in a 'Reply-To:' header"
            }
          },
          "required": [
            "sendAsEmail"
          ]
        }
      },
      {
        "name": "verify_send_as",
        "description": "Sends a verification email to the specified send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sendAsEmail": {
              "type": "string",
              "description": "The send-as alias to be verified"
            }
          },
          "required": [
            "sendAsEmail"
          ]
        }
      },
      {
        "name": "delete_smime_info",
        "description": "Deletes the specified S/MIME config for the specified send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The immutable ID for the S/MIME config"
            },
            "sendAsEmail": {
              "type": "string",
              "description": "The email address that appears in the 'From:' header"
            }
          },
          "required": [
            "sendAsEmail",
            "id"
          ]
        }
      },
      {
        "name": "get_smime_info",
        "description": "Gets the specified S/MIME config for the specified send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The immutable ID for the S/MIME config"
            },
            "sendAsEmail": {
              "type": "string",
              "description": "The email address that appears in the 'From:' header"
            }
          },
          "required": [
            "sendAsEmail",
            "id"
          ]
        }
      },
      {
        "name": "insert_smime_info",
        "description": "Insert (upload) the given S/MIME config for the specified send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pkcs12": {
              "type": "string",
              "description": "PKCS#12 format containing a single private/public key pair and certificate chain"
            },
            "sendAsEmail": {
              "type": "string",
              "description": "The email address that appears in the 'From:' header"
            },
            "encryptedKeyPassword": {
              "type": "string",
              "description": "Encrypted key password"
            }
          },
          "required": [
            "sendAsEmail",
            "encryptedKeyPassword",
            "pkcs12"
          ]
        }
      },
      {
        "name": "list_smime_info",
        "description": "Lists S/MIME configs for the specified send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sendAsEmail": {
              "type": "string",
              "description": "The email address that appears in the 'From:' header"
            }
          },
          "required": [
            "sendAsEmail"
          ]
        }
      },
      {
        "name": "set_default_smime_info",
        "description": "Sets the default S/MIME config for the specified send-as alias",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The immutable ID for the S/MIME config"
            },
            "sendAsEmail": {
              "type": "string",
              "description": "The email address that appears in the 'From:' header"
            }
          },
          "required": [
            "sendAsEmail",
            "id"
          ]
        }
      },
      {
        "name": "get_profile",
        "description": "Get the current user's Gmail profile",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "watch_mailbox",
        "description": "Watch for changes to the user's mailbox",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Label IDs to restrict notifications to"
            },
            "topicName": {
              "type": "string",
              "description": "The name of the Cloud Pub/Sub topic to publish notifications to"
            },
            "labelFilterAction": {
              "enum": [
                "include",
                "exclude"
              ],
              "type": "string",
              "description": "Whether to include or exclude the specified labels"
            }
          },
          "required": [
            "topicName"
          ]
        }
      },
      {
        "name": "stop_mail_watch",
        "description": "Stop receiving push notifications for the given user mailbox",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "shinzo-labs-hubspot-mcp",
    "title": "HubSpot MCP",
    "description": "A Model Context Protocol implementation for the HubSpot API that provides a standardized interface for accessing and managing CRM data, including companies, contacts, deals, and other objects with comprehensive CRUD operations and association management.",
    "icon": "https://avatars.githubusercontent.com/shinzo-labs",
    "isOfficial": false,
    "homepage": "https://github.com/shinzo-labs/hubspot-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@shinzolabs/hubspot-mcp"
      ],
      "env": {
        "HUBSPOT_ACCESS_TOKEN": "<hubspot-access-token>"
      }
    },
    "parameters": [
      {
        "name": "HUBSPOT_ACCESS_TOKEN",
        "description": "Your HubSpot API access token",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "crm_create_company",
        "description": "Create a new company with validated properties",
        "inputSchema": {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "properties": {
                "zip": {
                  "type": "string"
                },
                "city": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "type": {
                  "type": "string"
                },
                "phone": {
                  "type": "string"
                },
                "state": {
                  "type": "string"
                },
                "domain": {
                  "type": "string"
                },
                "address": {
                  "type": "string"
                },
                "country": {
                  "type": "string"
                },
                "website": {
                  "type": "string",
                  "format": "uri"
                },
                "address2": {
                  "type": "string"
                },
                "industry": {
                  "type": "string"
                },
                "description": {
                  "type": "string"
                },
                "annualrevenue": {
                  "type": "number"
                },
                "lifecyclestage": {
                  "enum": [
                    "lead",
                    "customer",
                    "opportunity",
                    "subscriber",
                    "other"
                  ],
                  "type": "string"
                },
                "numberofemployees": {
                  "type": "number"
                }
              },
              "additionalProperties": {}
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "to",
                  "types"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "types": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "associationCategory",
                        "associationTypeId"
                      ],
                      "properties": {
                        "associationTypeId": {
                          "type": "number"
                        },
                        "associationCategory": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "properties"
          ]
        }
      },
      {
        "name": "crm_update_company",
        "description": "Update an existing company with validated properties",
        "inputSchema": {
          "type": "object",
          "properties": {
            "companyId": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "properties": {
                "zip": {
                  "type": "string"
                },
                "city": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "type": {
                  "type": "string"
                },
                "phone": {
                  "type": "string"
                },
                "state": {
                  "type": "string"
                },
                "domain": {
                  "type": "string"
                },
                "address": {
                  "type": "string"
                },
                "country": {
                  "type": "string"
                },
                "website": {
                  "type": "string",
                  "format": "uri"
                },
                "address2": {
                  "type": "string"
                },
                "industry": {
                  "type": "string"
                },
                "description": {
                  "type": "string"
                },
                "annualrevenue": {
                  "type": "number"
                },
                "lifecyclestage": {
                  "enum": [
                    "lead",
                    "customer",
                    "opportunity",
                    "subscriber",
                    "other"
                  ],
                  "type": "string"
                },
                "numberofemployees": {
                  "type": "number"
                }
              },
              "additionalProperties": {}
            }
          },
          "required": [
            "companyId",
            "properties"
          ]
        }
      },
      {
        "name": "crm_get_company",
        "description": "Get a single company by ID with specific properties and associations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "companyId": {
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "contacts",
                  "deals",
                  "tickets"
                ],
                "type": "string"
              }
            }
          },
          "required": [
            "companyId"
          ]
        }
      },
      {
        "name": "crm_search_companies",
        "description": "Search companies with company-specific filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "sorts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "propertyName",
                  "direction"
                ],
                "properties": {
                  "direction": {
                    "enum": [
                      "ASCENDING",
                      "DESCENDING"
                    ],
                    "type": "string"
                  },
                  "propertyName": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filterGroups": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "filters"
                ],
                "properties": {
                  "filters": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "propertyName",
                        "operator"
                      ],
                      "properties": {
                        "value": {},
                        "operator": {
                          "enum": [
                            "EQ",
                            "NEQ",
                            "LT",
                            "LTE",
                            "GT",
                            "GTE",
                            "BETWEEN",
                            "IN",
                            "NOT_IN",
                            "HAS_PROPERTY",
                            "NOT_HAS_PROPERTY",
                            "CONTAINS_TOKEN",
                            "NOT_CONTAINS_TOKEN"
                          ],
                          "type": "string"
                        },
                        "propertyName": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "filterGroups"
          ]
        }
      },
      {
        "name": "crm_batch_create_companies",
        "description": "Create multiple companies in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "properties"
                ],
                "properties": {
                  "properties": {
                    "type": "object",
                    "properties": {
                      "zip": {
                        "type": "string"
                      },
                      "city": {
                        "type": "string"
                      },
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string"
                      },
                      "phone": {
                        "type": "string"
                      },
                      "state": {
                        "type": "string"
                      },
                      "domain": {
                        "type": "string"
                      },
                      "address": {
                        "type": "string"
                      },
                      "country": {
                        "type": "string"
                      },
                      "website": {
                        "type": "string",
                        "format": "uri"
                      },
                      "address2": {
                        "type": "string"
                      },
                      "industry": {
                        "type": "string"
                      },
                      "description": {
                        "type": "string"
                      },
                      "annualrevenue": {
                        "type": "number"
                      },
                      "lifecyclestage": {
                        "enum": [
                          "lead",
                          "customer",
                          "opportunity",
                          "subscriber",
                          "other"
                        ],
                        "type": "string"
                      },
                      "numberofemployees": {
                        "type": "number"
                      }
                    },
                    "additionalProperties": {}
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "to",
                        "types"
                      ],
                      "properties": {
                        "to": {
                          "type": "object",
                          "required": [
                            "id"
                          ],
                          "properties": {
                            "id": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "types": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "associationCategory",
                              "associationTypeId"
                            ],
                            "properties": {
                              "associationTypeId": {
                                "type": "number"
                              },
                              "associationCategory": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "crm_batch_update_companies",
        "description": "Update multiple companies in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "properties"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "object",
                    "properties": {
                      "zip": {
                        "type": "string"
                      },
                      "city": {
                        "type": "string"
                      },
                      "name": {
                        "type": "string"
                      },
                      "type": {
                        "type": "string"
                      },
                      "phone": {
                        "type": "string"
                      },
                      "state": {
                        "type": "string"
                      },
                      "domain": {
                        "type": "string"
                      },
                      "address": {
                        "type": "string"
                      },
                      "country": {
                        "type": "string"
                      },
                      "website": {
                        "type": "string",
                        "format": "uri"
                      },
                      "address2": {
                        "type": "string"
                      },
                      "industry": {
                        "type": "string"
                      },
                      "description": {
                        "type": "string"
                      },
                      "annualrevenue": {
                        "type": "number"
                      },
                      "lifecyclestage": {
                        "enum": [
                          "lead",
                          "customer",
                          "opportunity",
                          "subscriber",
                          "other"
                        ],
                        "type": "string"
                      },
                      "numberofemployees": {
                        "type": "number"
                      }
                    },
                    "additionalProperties": {}
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "crm_get_company_properties",
        "description": "Get all properties for companies",
        "inputSchema": {
          "type": "object",
          "properties": {
            "archived": {
              "type": "boolean"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      {
        "name": "crm_create_company_property",
        "description": "Create a new company property",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "type": {
              "enum": [
                "string",
                "number",
                "date",
                "datetime",
                "enumeration",
                "bool"
              ],
              "type": "string"
            },
            "label": {
              "type": "string"
            },
            "hidden": {
              "type": "boolean"
            },
            "options": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "label",
                  "value"
                ],
                "properties": {
                  "label": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  },
                  "hidden": {
                    "type": "boolean"
                  },
                  "description": {
                    "type": "string"
                  },
                  "displayOrder": {
                    "type": "number"
                  }
                },
                "additionalProperties": false
              }
            },
            "fieldType": {
              "enum": [
                "text",
                "textarea",
                "select",
                "radio",
                "checkbox",
                "number",
                "date",
                "file"
              ],
              "type": "string"
            },
            "formField": {
              "type": "boolean"
            },
            "groupName": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "displayOrder": {
              "type": "number"
            },
            "hasUniqueValue": {
              "type": "boolean"
            }
          },
          "required": [
            "name",
            "label",
            "type",
            "fieldType",
            "groupName"
          ]
        }
      },
      {
        "name": "crm_list_objects",
        "description": "List CRM objects of a specific type with optional filtering and pagination",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "archived": {
              "type": "boolean"
            },
            "objectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "objectType"
          ]
        }
      },
      {
        "name": "crm_get_object",
        "description": "Get a single CRM object by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectId": {
              "type": "string"
            },
            "objectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "objectType",
            "objectId"
          ]
        }
      },
      {
        "name": "crm_create_object",
        "description": "Create a new CRM object",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "properties": {
              "type": "object",
              "additionalProperties": {}
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "to",
                  "types"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "types": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "associationCategory",
                        "associationTypeId"
                      ],
                      "properties": {
                        "associationTypeId": {
                          "type": "number"
                        },
                        "associationCategory": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "objectType",
            "properties"
          ]
        }
      },
      {
        "name": "crm_update_object",
        "description": "Update an existing CRM object",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectId": {
              "type": "string"
            },
            "objectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "properties": {
              "type": "object",
              "additionalProperties": {}
            }
          },
          "required": [
            "objectType",
            "objectId",
            "properties"
          ]
        }
      },
      {
        "name": "crm_archive_object",
        "description": "Archive (delete) a CRM object",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectId": {
              "type": "string"
            },
            "objectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "objectType",
            "objectId"
          ]
        }
      },
      {
        "name": "crm_search_objects",
        "description": "Search CRM objects using filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "sorts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "propertyName",
                  "direction"
                ],
                "properties": {
                  "direction": {
                    "enum": [
                      "ASCENDING",
                      "DESCENDING"
                    ],
                    "type": "string"
                  },
                  "propertyName": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "objectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filterGroups": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "filters"
                ],
                "properties": {
                  "filters": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "propertyName",
                        "operator"
                      ],
                      "properties": {
                        "value": {},
                        "operator": {
                          "enum": [
                            "EQ",
                            "NEQ",
                            "LT",
                            "LTE",
                            "GT",
                            "GTE",
                            "BETWEEN",
                            "IN",
                            "NOT_IN",
                            "HAS_PROPERTY",
                            "NOT_HAS_PROPERTY",
                            "CONTAINS_TOKEN",
                            "NOT_CONTAINS_TOKEN"
                          ],
                          "type": "string"
                        },
                        "propertyName": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "objectType",
            "filterGroups"
          ]
        }
      },
      {
        "name": "crm_batch_create_objects",
        "description": "Create multiple CRM objects in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "properties"
                ],
                "properties": {
                  "properties": {
                    "type": "object",
                    "additionalProperties": {}
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "to",
                        "types"
                      ],
                      "properties": {
                        "to": {
                          "type": "object",
                          "required": [
                            "id"
                          ],
                          "properties": {
                            "id": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "types": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "associationCategory",
                              "associationTypeId"
                            ],
                            "properties": {
                              "associationTypeId": {
                                "type": "number"
                              },
                              "associationCategory": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "objectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "objectType",
            "inputs"
          ]
        }
      },
      {
        "name": "crm_batch_read_objects",
        "description": "Create multiple CRM objects in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "idProperty": {
              "type": "string"
            },
            "objectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "propertiesWithHistory": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "objectType",
            "objectIds"
          ]
        }
      },
      {
        "name": "crm_batch_update_objects",
        "description": "Update multiple CRM objects in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "properties"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "object",
                    "additionalProperties": {}
                  }
                },
                "additionalProperties": false
              }
            },
            "objectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "objectType",
            "inputs"
          ]
        }
      },
      {
        "name": "crm_batch_archive_objects",
        "description": "Archive (delete) multiple CRM objects in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "objectIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "objectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "objectType",
            "objectIds"
          ]
        }
      },
      {
        "name": "crm_list_association_types",
        "description": "List all available association types for a given object type pair",
        "inputSchema": {
          "type": "object",
          "properties": {
            "toObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "fromObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "fromObjectType",
            "toObjectType"
          ]
        }
      },
      {
        "name": "crm_get_associations",
        "description": "Get all associations of a specific type between objects",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 500,
              "minimum": 1
            },
            "fromObjectId": {
              "type": "string"
            },
            "toObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "fromObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "fromObjectType",
            "toObjectType",
            "fromObjectId"
          ]
        }
      },
      {
        "name": "crm_create_association",
        "description": "Create an association between two objects",
        "inputSchema": {
          "type": "object",
          "properties": {
            "toObjectId": {
              "type": "string"
            },
            "fromObjectId": {
              "type": "string"
            },
            "toObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "fromObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "associationTypes": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "associationCategory",
                  "associationTypeId"
                ],
                "properties": {
                  "associationTypeId": {
                    "type": "number"
                  },
                  "associationCategory": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "fromObjectType",
            "toObjectType",
            "fromObjectId",
            "toObjectId",
            "associationTypes"
          ]
        }
      },
      {
        "name": "crm_archive_association",
        "description": "Archive (delete) an association between two objects",
        "inputSchema": {
          "type": "object",
          "properties": {
            "toObjectId": {
              "type": "string"
            },
            "fromObjectId": {
              "type": "string"
            },
            "toObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "fromObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "fromObjectType",
            "toObjectType",
            "fromObjectId",
            "toObjectId"
          ]
        }
      },
      {
        "name": "crm_batch_create_associations",
        "description": "Create multiple associations in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "from",
                  "to",
                  "types"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "from": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "types": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "associationCategory",
                        "associationTypeId"
                      ],
                      "properties": {
                        "associationTypeId": {
                          "type": "number"
                        },
                        "associationCategory": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "toObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "fromObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "fromObjectType",
            "toObjectType",
            "inputs"
          ]
        }
      },
      {
        "name": "crm_batch_archive_associations",
        "description": "Archive (delete) multiple associations in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "from",
                  "to"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "from": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  }
                },
                "additionalProperties": false
              }
            },
            "toObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            },
            "fromObjectType": {
              "enum": [
                "companies",
                "contacts",
                "deals",
                "tickets",
                "products",
                "line_items",
                "quotes",
                "custom"
              ],
              "type": "string"
            }
          },
          "required": [
            "fromObjectType",
            "toObjectType",
            "inputs"
          ]
        }
      },
      {
        "name": "crm_create_contact",
        "description": "Create a new contact with validated properties",
        "inputSchema": {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "properties": {
                "zip": {
                  "type": "string"
                },
                "city": {
                  "type": "string"
                },
                "email": {
                  "type": "string",
                  "format": "email"
                },
                "phone": {
                  "type": "string"
                },
                "state": {
                  "type": "string"
                },
                "address": {
                  "type": "string"
                },
                "company": {
                  "type": "string"
                },
                "country": {
                  "type": "string"
                },
                "website": {
                  "type": "string",
                  "format": "uri"
                },
                "jobtitle": {
                  "type": "string"
                },
                "lastname": {
                  "type": "string"
                },
                "firstname": {
                  "type": "string"
                },
                "leadstatus": {
                  "enum": [
                    "new",
                    "open",
                    "inprogress",
                    "opennotcontacted",
                    "opencontacted",
                    "closedconverted",
                    "closednotconverted"
                  ],
                  "type": "string"
                },
                "linkedinbio": {
                  "type": "string"
                },
                "mobilephone": {
                  "type": "string"
                },
                "twitterhandle": {
                  "type": "string"
                },
                "lifecyclestage": {
                  "enum": [
                    "subscriber",
                    "lead",
                    "marketingqualifiedlead",
                    "salesqualifiedlead",
                    "opportunity",
                    "customer",
                    "evangelist",
                    "other"
                  ],
                  "type": "string"
                },
                "facebookfanpage": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "to",
                  "types"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "types": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "associationCategory",
                        "associationTypeId"
                      ],
                      "properties": {
                        "associationTypeId": {
                          "type": "number"
                        },
                        "associationCategory": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "properties"
          ]
        }
      },
      {
        "name": "crm_update_contact",
        "description": "Update an existing contact with validated properties",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactId": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "properties": {
                "zip": {
                  "type": "string"
                },
                "city": {
                  "type": "string"
                },
                "email": {
                  "type": "string",
                  "format": "email"
                },
                "phone": {
                  "type": "string"
                },
                "state": {
                  "type": "string"
                },
                "address": {
                  "type": "string"
                },
                "company": {
                  "type": "string"
                },
                "country": {
                  "type": "string"
                },
                "website": {
                  "type": "string",
                  "format": "uri"
                },
                "jobtitle": {
                  "type": "string"
                },
                "lastname": {
                  "type": "string"
                },
                "firstname": {
                  "type": "string"
                },
                "leadstatus": {
                  "enum": [
                    "new",
                    "open",
                    "inprogress",
                    "opennotcontacted",
                    "opencontacted",
                    "closedconverted",
                    "closednotconverted"
                  ],
                  "type": "string"
                },
                "linkedinbio": {
                  "type": "string"
                },
                "mobilephone": {
                  "type": "string"
                },
                "twitterhandle": {
                  "type": "string"
                },
                "lifecyclestage": {
                  "enum": [
                    "subscriber",
                    "lead",
                    "marketingqualifiedlead",
                    "salesqualifiedlead",
                    "opportunity",
                    "customer",
                    "evangelist",
                    "other"
                  ],
                  "type": "string"
                },
                "facebookfanpage": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            }
          },
          "required": [
            "contactId",
            "properties"
          ]
        }
      },
      {
        "name": "crm_get_contact",
        "description": "Get a single contact by ID with specific properties and associations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactId": {
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "companies",
                  "deals",
                  "tickets",
                  "calls",
                  "emails",
                  "meetings",
                  "notes"
                ],
                "type": "string"
              }
            }
          },
          "required": [
            "contactId"
          ]
        }
      },
      {
        "name": "crm_search_contacts",
        "description": "Search contacts with contact-specific filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "sorts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "propertyName",
                  "direction"
                ],
                "properties": {
                  "direction": {
                    "enum": [
                      "ASCENDING",
                      "DESCENDING"
                    ],
                    "type": "string"
                  },
                  "propertyName": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filterGroups": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "filters"
                ],
                "properties": {
                  "filters": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "propertyName",
                        "operator"
                      ],
                      "properties": {
                        "value": {},
                        "operator": {
                          "enum": [
                            "EQ",
                            "NEQ",
                            "LT",
                            "LTE",
                            "GT",
                            "GTE",
                            "BETWEEN",
                            "IN",
                            "NOT_IN",
                            "HAS_PROPERTY",
                            "NOT_HAS_PROPERTY",
                            "CONTAINS_TOKEN",
                            "NOT_CONTAINS_TOKEN"
                          ],
                          "type": "string"
                        },
                        "propertyName": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "filterGroups"
          ]
        }
      },
      {
        "name": "crm_batch_create_contacts",
        "description": "Create multiple contacts in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "properties"
                ],
                "properties": {
                  "properties": {
                    "type": "object",
                    "properties": {
                      "zip": {
                        "type": "string"
                      },
                      "city": {
                        "type": "string"
                      },
                      "email": {
                        "type": "string",
                        "format": "email"
                      },
                      "phone": {
                        "type": "string"
                      },
                      "state": {
                        "type": "string"
                      },
                      "address": {
                        "type": "string"
                      },
                      "company": {
                        "type": "string"
                      },
                      "country": {
                        "type": "string"
                      },
                      "website": {
                        "type": "string",
                        "format": "uri"
                      },
                      "jobtitle": {
                        "type": "string"
                      },
                      "lastname": {
                        "type": "string"
                      },
                      "firstname": {
                        "type": "string"
                      },
                      "leadstatus": {
                        "enum": [
                          "new",
                          "open",
                          "inprogress",
                          "opennotcontacted",
                          "opencontacted",
                          "closedconverted",
                          "closednotconverted"
                        ],
                        "type": "string"
                      },
                      "linkedinbio": {
                        "type": "string"
                      },
                      "mobilephone": {
                        "type": "string"
                      },
                      "twitterhandle": {
                        "type": "string"
                      },
                      "lifecyclestage": {
                        "enum": [
                          "subscriber",
                          "lead",
                          "marketingqualifiedlead",
                          "salesqualifiedlead",
                          "opportunity",
                          "customer",
                          "evangelist",
                          "other"
                        ],
                        "type": "string"
                      },
                      "facebookfanpage": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": {}
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "to",
                        "types"
                      ],
                      "properties": {
                        "to": {
                          "type": "object",
                          "required": [
                            "id"
                          ],
                          "properties": {
                            "id": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "types": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "associationCategory",
                              "associationTypeId"
                            ],
                            "properties": {
                              "associationTypeId": {
                                "type": "number"
                              },
                              "associationCategory": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "crm_batch_update_contacts",
        "description": "Update multiple contacts in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "properties"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "object",
                    "properties": {
                      "zip": {
                        "type": "string"
                      },
                      "city": {
                        "type": "string"
                      },
                      "email": {
                        "type": "string",
                        "format": "email"
                      },
                      "phone": {
                        "type": "string"
                      },
                      "state": {
                        "type": "string"
                      },
                      "address": {
                        "type": "string"
                      },
                      "company": {
                        "type": "string"
                      },
                      "country": {
                        "type": "string"
                      },
                      "website": {
                        "type": "string",
                        "format": "uri"
                      },
                      "jobtitle": {
                        "type": "string"
                      },
                      "lastname": {
                        "type": "string"
                      },
                      "firstname": {
                        "type": "string"
                      },
                      "leadstatus": {
                        "enum": [
                          "new",
                          "open",
                          "inprogress",
                          "opennotcontacted",
                          "opencontacted",
                          "closedconverted",
                          "closednotconverted"
                        ],
                        "type": "string"
                      },
                      "linkedinbio": {
                        "type": "string"
                      },
                      "mobilephone": {
                        "type": "string"
                      },
                      "twitterhandle": {
                        "type": "string"
                      },
                      "lifecyclestage": {
                        "enum": [
                          "subscriber",
                          "lead",
                          "marketingqualifiedlead",
                          "salesqualifiedlead",
                          "opportunity",
                          "customer",
                          "evangelist",
                          "other"
                        ],
                        "type": "string"
                      },
                      "facebookfanpage": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": {}
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "crm_get_contact_properties",
        "description": "Get all properties for contacts",
        "inputSchema": {
          "type": "object",
          "properties": {
            "archived": {
              "type": "boolean"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      {
        "name": "crm_create_contact_property",
        "description": "Create a new contact property",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "type": {
              "enum": [
                "string",
                "number",
                "date",
                "datetime",
                "enumeration",
                "bool"
              ],
              "type": "string"
            },
            "label": {
              "type": "string"
            },
            "hidden": {
              "type": "boolean"
            },
            "options": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "label",
                  "value"
                ],
                "properties": {
                  "label": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  },
                  "hidden": {
                    "type": "boolean"
                  },
                  "description": {
                    "type": "string"
                  },
                  "displayOrder": {
                    "type": "number"
                  }
                },
                "additionalProperties": false
              }
            },
            "fieldType": {
              "enum": [
                "text",
                "textarea",
                "select",
                "radio",
                "checkbox",
                "number",
                "date",
                "file"
              ],
              "type": "string"
            },
            "formField": {
              "type": "boolean"
            },
            "groupName": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "displayOrder": {
              "type": "number"
            },
            "hasUniqueValue": {
              "type": "boolean"
            }
          },
          "required": [
            "name",
            "label",
            "type",
            "fieldType",
            "groupName"
          ]
        }
      },
      {
        "name": "crm_create_lead",
        "description": "Create a new lead with validated properties",
        "inputSchema": {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "properties": {
                "zip": {
                  "type": "string"
                },
                "city": {
                  "type": "string"
                },
                "email": {
                  "type": "string",
                  "format": "email"
                },
                "notes": {
                  "type": "string"
                },
                "phone": {
                  "type": "string"
                },
                "state": {
                  "type": "string"
                },
                "rating": {
                  "enum": [
                    "hot",
                    "warm",
                    "cold"
                  ],
                  "type": "string"
                },
                "address": {
                  "type": "string"
                },
                "company": {
                  "type": "string"
                },
                "country": {
                  "type": "string"
                },
                "website": {
                  "type": "string",
                  "format": "uri"
                },
                "industry": {
                  "type": "string"
                },
                "jobtitle": {
                  "type": "string"
                },
                "lastname": {
                  "type": "string"
                },
                "firstname": {
                  "type": "string"
                },
                "leadsource": {
                  "type": "string"
                },
                "leadstatus": {
                  "enum": [
                    "new",
                    "open",
                    "in_progress",
                    "qualified",
                    "unqualified",
                    "converted",
                    "lost"
                  ],
                  "type": "string"
                },
                "annualrevenue": {
                  "type": "number"
                },
                "numberofemployees": {
                  "type": "number"
                }
              },
              "additionalProperties": {}
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "to",
                  "types"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "types": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "associationCategory",
                        "associationTypeId"
                      ],
                      "properties": {
                        "associationTypeId": {
                          "type": "number"
                        },
                        "associationCategory": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "properties"
          ]
        }
      },
      {
        "name": "crm_update_lead",
        "description": "Update an existing lead with validated properties",
        "inputSchema": {
          "type": "object",
          "properties": {
            "leadId": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "properties": {
                "zip": {
                  "type": "string"
                },
                "city": {
                  "type": "string"
                },
                "email": {
                  "type": "string",
                  "format": "email"
                },
                "notes": {
                  "type": "string"
                },
                "phone": {
                  "type": "string"
                },
                "state": {
                  "type": "string"
                },
                "rating": {
                  "enum": [
                    "hot",
                    "warm",
                    "cold"
                  ],
                  "type": "string"
                },
                "address": {
                  "type": "string"
                },
                "company": {
                  "type": "string"
                },
                "country": {
                  "type": "string"
                },
                "website": {
                  "type": "string",
                  "format": "uri"
                },
                "industry": {
                  "type": "string"
                },
                "jobtitle": {
                  "type": "string"
                },
                "lastname": {
                  "type": "string"
                },
                "firstname": {
                  "type": "string"
                },
                "leadsource": {
                  "type": "string"
                },
                "leadstatus": {
                  "enum": [
                    "new",
                    "open",
                    "in_progress",
                    "qualified",
                    "unqualified",
                    "converted",
                    "lost"
                  ],
                  "type": "string"
                },
                "annualrevenue": {
                  "type": "number"
                },
                "numberofemployees": {
                  "type": "number"
                }
              },
              "additionalProperties": {}
            }
          },
          "required": [
            "leadId",
            "properties"
          ]
        }
      },
      {
        "name": "crm_get_lead",
        "description": "Get a single lead by ID with specific properties and associations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "leadId": {
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "companies",
                  "contacts",
                  "deals",
                  "notes",
                  "tasks"
                ],
                "type": "string"
              }
            }
          },
          "required": [
            "leadId"
          ]
        }
      },
      {
        "name": "crm_search_leads",
        "description": "Search leads with lead-specific filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "sorts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "propertyName",
                  "direction"
                ],
                "properties": {
                  "direction": {
                    "enum": [
                      "ASCENDING",
                      "DESCENDING"
                    ],
                    "type": "string"
                  },
                  "propertyName": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filterGroups": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "filters"
                ],
                "properties": {
                  "filters": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "propertyName",
                        "operator"
                      ],
                      "properties": {
                        "value": {},
                        "operator": {
                          "enum": [
                            "EQ",
                            "NEQ",
                            "LT",
                            "LTE",
                            "GT",
                            "GTE",
                            "BETWEEN",
                            "IN",
                            "NOT_IN",
                            "HAS_PROPERTY",
                            "NOT_HAS_PROPERTY",
                            "CONTAINS_TOKEN",
                            "NOT_CONTAINS_TOKEN"
                          ],
                          "type": "string"
                        },
                        "propertyName": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "filterGroups"
          ]
        }
      },
      {
        "name": "crm_batch_create_leads",
        "description": "Create multiple leads in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "properties"
                ],
                "properties": {
                  "properties": {
                    "type": "object",
                    "properties": {
                      "zip": {
                        "type": "string"
                      },
                      "city": {
                        "type": "string"
                      },
                      "email": {
                        "type": "string",
                        "format": "email"
                      },
                      "notes": {
                        "type": "string"
                      },
                      "phone": {
                        "type": "string"
                      },
                      "state": {
                        "type": "string"
                      },
                      "rating": {
                        "enum": [
                          "hot",
                          "warm",
                          "cold"
                        ],
                        "type": "string"
                      },
                      "address": {
                        "type": "string"
                      },
                      "company": {
                        "type": "string"
                      },
                      "country": {
                        "type": "string"
                      },
                      "website": {
                        "type": "string",
                        "format": "uri"
                      },
                      "industry": {
                        "type": "string"
                      },
                      "jobtitle": {
                        "type": "string"
                      },
                      "lastname": {
                        "type": "string"
                      },
                      "firstname": {
                        "type": "string"
                      },
                      "leadsource": {
                        "type": "string"
                      },
                      "leadstatus": {
                        "enum": [
                          "new",
                          "open",
                          "in_progress",
                          "qualified",
                          "unqualified",
                          "converted",
                          "lost"
                        ],
                        "type": "string"
                      },
                      "annualrevenue": {
                        "type": "number"
                      },
                      "numberofemployees": {
                        "type": "number"
                      }
                    },
                    "additionalProperties": {}
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "to",
                        "types"
                      ],
                      "properties": {
                        "to": {
                          "type": "object",
                          "required": [
                            "id"
                          ],
                          "properties": {
                            "id": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "types": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "associationCategory",
                              "associationTypeId"
                            ],
                            "properties": {
                              "associationTypeId": {
                                "type": "number"
                              },
                              "associationCategory": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "crm_batch_update_leads",
        "description": "Update multiple leads in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "properties"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "object",
                    "properties": {
                      "zip": {
                        "type": "string"
                      },
                      "city": {
                        "type": "string"
                      },
                      "email": {
                        "type": "string",
                        "format": "email"
                      },
                      "notes": {
                        "type": "string"
                      },
                      "phone": {
                        "type": "string"
                      },
                      "state": {
                        "type": "string"
                      },
                      "rating": {
                        "enum": [
                          "hot",
                          "warm",
                          "cold"
                        ],
                        "type": "string"
                      },
                      "address": {
                        "type": "string"
                      },
                      "company": {
                        "type": "string"
                      },
                      "country": {
                        "type": "string"
                      },
                      "website": {
                        "type": "string",
                        "format": "uri"
                      },
                      "industry": {
                        "type": "string"
                      },
                      "jobtitle": {
                        "type": "string"
                      },
                      "lastname": {
                        "type": "string"
                      },
                      "firstname": {
                        "type": "string"
                      },
                      "leadsource": {
                        "type": "string"
                      },
                      "leadstatus": {
                        "enum": [
                          "new",
                          "open",
                          "in_progress",
                          "qualified",
                          "unqualified",
                          "converted",
                          "lost"
                        ],
                        "type": "string"
                      },
                      "annualrevenue": {
                        "type": "number"
                      },
                      "numberofemployees": {
                        "type": "number"
                      }
                    },
                    "additionalProperties": {}
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "crm_get_lead_properties",
        "description": "Get all properties for leads",
        "inputSchema": {
          "type": "object",
          "properties": {
            "archived": {
              "type": "boolean"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      {
        "name": "crm_create_lead_property",
        "description": "Create a new lead property",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "type": {
              "enum": [
                "string",
                "number",
                "date",
                "datetime",
                "enumeration",
                "bool"
              ],
              "type": "string"
            },
            "label": {
              "type": "string"
            },
            "hidden": {
              "type": "boolean"
            },
            "options": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "label",
                  "value"
                ],
                "properties": {
                  "label": {
                    "type": "string"
                  },
                  "value": {
                    "type": "string"
                  },
                  "hidden": {
                    "type": "boolean"
                  },
                  "description": {
                    "type": "string"
                  },
                  "displayOrder": {
                    "type": "number"
                  }
                },
                "additionalProperties": false
              }
            },
            "fieldType": {
              "enum": [
                "text",
                "textarea",
                "select",
                "radio",
                "checkbox",
                "number",
                "date",
                "file"
              ],
              "type": "string"
            },
            "formField": {
              "type": "boolean"
            },
            "groupName": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "displayOrder": {
              "type": "number"
            },
            "hasUniqueValue": {
              "type": "boolean"
            }
          },
          "required": [
            "name",
            "label",
            "type",
            "fieldType",
            "groupName"
          ]
        }
      },
      {
        "name": "meetings_list",
        "description": "List all meetings with optional filtering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "createdAfter": {
              "type": "string"
            },
            "createdBefore": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "meetings_get",
        "description": "Get details of a specific meeting",
        "inputSchema": {
          "type": "object",
          "properties": {
            "meetingId": {
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "contacts",
                  "companies",
                  "deals"
                ],
                "type": "string"
              }
            }
          },
          "required": [
            "meetingId"
          ]
        }
      },
      {
        "name": "meetings_create",
        "description": "Create a new meeting",
        "inputSchema": {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "required": [
                "hs_timestamp",
                "hs_meeting_title",
                "hs_meeting_start_time",
                "hs_meeting_end_time"
              ],
              "properties": {
                "hs_timestamp": {
                  "type": "string"
                },
                "hs_meeting_body": {
                  "type": "string"
                },
                "hs_meeting_title": {
                  "type": "string"
                },
                "hubspot_owner_id": {
                  "type": "string"
                },
                "hs_meeting_outcome": {
                  "enum": [
                    "SCHEDULED",
                    "COMPLETED",
                    "CANCELED"
                  ],
                  "type": "string"
                },
                "hs_meeting_end_time": {
                  "type": "string"
                },
                "hs_meeting_location": {
                  "type": "string"
                },
                "hs_meeting_start_time": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "to",
                  "types"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "types": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "associationCategory",
                        "associationTypeId"
                      ],
                      "properties": {
                        "associationTypeId": {
                          "type": "number"
                        },
                        "associationCategory": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "properties"
          ]
        }
      },
      {
        "name": "meetings_update",
        "description": "Update an existing meeting",
        "inputSchema": {
          "type": "object",
          "properties": {
            "meetingId": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "properties": {
                "hs_meeting_body": {
                  "type": "string"
                },
                "hs_meeting_title": {
                  "type": "string"
                },
                "hubspot_owner_id": {
                  "type": "string"
                },
                "hs_meeting_outcome": {
                  "enum": [
                    "SCHEDULED",
                    "COMPLETED",
                    "CANCELED"
                  ],
                  "type": "string"
                },
                "hs_meeting_end_time": {
                  "type": "string"
                },
                "hs_meeting_location": {
                  "type": "string"
                },
                "hs_meeting_start_time": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "meetingId",
            "properties"
          ]
        }
      },
      {
        "name": "meetings_archive",
        "description": "Archive (delete) a meeting",
        "inputSchema": {
          "type": "object",
          "properties": {
            "meetingId": {
              "type": "string"
            }
          },
          "required": [
            "meetingId"
          ]
        }
      },
      {
        "name": "meetings_search",
        "description": "Search meetings with specific filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "sorts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "propertyName",
                  "direction"
                ],
                "properties": {
                  "direction": {
                    "enum": [
                      "ASCENDING",
                      "DESCENDING"
                    ],
                    "type": "string"
                  },
                  "propertyName": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filterGroups": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "filters"
                ],
                "properties": {
                  "filters": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "propertyName",
                        "operator"
                      ],
                      "properties": {
                        "value": {},
                        "operator": {
                          "enum": [
                            "EQ",
                            "NEQ",
                            "LT",
                            "LTE",
                            "GT",
                            "GTE",
                            "BETWEEN",
                            "IN",
                            "NOT_IN",
                            "HAS_PROPERTY",
                            "NOT_HAS_PROPERTY",
                            "CONTAINS_TOKEN",
                            "NOT_CONTAINS_TOKEN"
                          ],
                          "type": "string"
                        },
                        "propertyName": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "filterGroups"
          ]
        }
      },
      {
        "name": "meetings_batch_create",
        "description": "Create multiple meetings in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "properties"
                ],
                "properties": {
                  "properties": {
                    "type": "object",
                    "required": [
                      "hs_timestamp",
                      "hs_meeting_title",
                      "hs_meeting_start_time",
                      "hs_meeting_end_time"
                    ],
                    "properties": {
                      "hs_timestamp": {
                        "type": "string"
                      },
                      "hs_meeting_body": {
                        "type": "string"
                      },
                      "hs_meeting_title": {
                        "type": "string"
                      },
                      "hubspot_owner_id": {
                        "type": "string"
                      },
                      "hs_meeting_outcome": {
                        "enum": [
                          "SCHEDULED",
                          "COMPLETED",
                          "CANCELED"
                        ],
                        "type": "string"
                      },
                      "hs_meeting_end_time": {
                        "type": "string"
                      },
                      "hs_meeting_location": {
                        "type": "string"
                      },
                      "hs_meeting_start_time": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "to",
                        "types"
                      ],
                      "properties": {
                        "to": {
                          "type": "object",
                          "required": [
                            "id"
                          ],
                          "properties": {
                            "id": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "types": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "associationCategory",
                              "associationTypeId"
                            ],
                            "properties": {
                              "associationTypeId": {
                                "type": "number"
                              },
                              "associationCategory": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "meetings_batch_update",
        "description": "Update multiple meetings in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "properties"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "object",
                    "properties": {
                      "hs_meeting_body": {
                        "type": "string"
                      },
                      "hs_meeting_title": {
                        "type": "string"
                      },
                      "hubspot_owner_id": {
                        "type": "string"
                      },
                      "hs_meeting_outcome": {
                        "enum": [
                          "SCHEDULED",
                          "COMPLETED",
                          "CANCELED"
                        ],
                        "type": "string"
                      },
                      "hs_meeting_end_time": {
                        "type": "string"
                      },
                      "hs_meeting_location": {
                        "type": "string"
                      },
                      "hs_meeting_start_time": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "meetings_batch_archive",
        "description": "Archive (delete) multiple meetings in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "meetingIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "meetingIds"
          ]
        }
      },
      {
        "name": "notes_create",
        "description": "Create a new note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "required": [
                "hs_note_body"
              ],
              "properties": {
                "hs_note_body": {
                  "type": "string"
                },
                "hs_timestamp": {
                  "type": "string"
                },
                "hubspot_owner_id": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "to",
                  "types"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "types": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "associationCategory",
                        "associationTypeId"
                      ],
                      "properties": {
                        "associationTypeId": {
                          "type": "number"
                        },
                        "associationCategory": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "properties"
          ]
        }
      },
      {
        "name": "notes_get",
        "description": "Get details of a specific note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "contacts",
                  "companies",
                  "deals",
                  "tickets"
                ],
                "type": "string"
              }
            }
          },
          "required": [
            "noteId"
          ]
        }
      },
      {
        "name": "notes_update",
        "description": "Update an existing note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "required": [
                "hs_note_body"
              ],
              "properties": {
                "hs_note_body": {
                  "type": "string"
                },
                "hs_timestamp": {
                  "type": "string"
                },
                "hubspot_owner_id": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            }
          },
          "required": [
            "noteId",
            "properties"
          ]
        }
      },
      {
        "name": "notes_archive",
        "description": "Archive (delete) a note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string"
            }
          },
          "required": [
            "noteId"
          ]
        }
      },
      {
        "name": "notes_list",
        "description": "List all notes with optional filtering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "archived": {
              "type": "boolean"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "contacts",
                  "companies",
                  "deals",
                  "tickets"
                ],
                "type": "string"
              }
            }
          }
        }
      },
      {
        "name": "notes_search",
        "description": "Search notes with specific filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "sorts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "propertyName",
                  "direction"
                ],
                "properties": {
                  "direction": {
                    "enum": [
                      "ASCENDING",
                      "DESCENDING"
                    ],
                    "type": "string"
                  },
                  "propertyName": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filterGroups": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "filters"
                ],
                "properties": {
                  "filters": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "propertyName",
                        "operator"
                      ],
                      "properties": {
                        "value": {},
                        "operator": {
                          "enum": [
                            "EQ",
                            "NEQ",
                            "LT",
                            "LTE",
                            "GT",
                            "GTE",
                            "BETWEEN",
                            "IN",
                            "NOT_IN",
                            "HAS_PROPERTY",
                            "NOT_HAS_PROPERTY",
                            "CONTAINS_TOKEN",
                            "NOT_CONTAINS_TOKEN"
                          ],
                          "type": "string"
                        },
                        "propertyName": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "filterGroups"
          ]
        }
      },
      {
        "name": "notes_batch_create",
        "description": "Create multiple notes in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "properties"
                ],
                "properties": {
                  "properties": {
                    "type": "object",
                    "required": [
                      "hs_note_body"
                    ],
                    "properties": {
                      "hs_note_body": {
                        "type": "string"
                      },
                      "hs_timestamp": {
                        "type": "string"
                      },
                      "hubspot_owner_id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": {}
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "to",
                        "types"
                      ],
                      "properties": {
                        "to": {
                          "type": "object",
                          "required": [
                            "id"
                          ],
                          "properties": {
                            "id": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "types": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "associationCategory",
                              "associationTypeId"
                            ],
                            "properties": {
                              "associationTypeId": {
                                "type": "number"
                              },
                              "associationCategory": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "notes_batch_read",
        "description": "Read multiple notes in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "enum": [
                        "contacts",
                        "companies",
                        "deals",
                        "tickets"
                      ],
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "notes_batch_update",
        "description": "Update multiple notes in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "properties"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "object",
                    "required": [
                      "hs_note_body"
                    ],
                    "properties": {
                      "hs_note_body": {
                        "type": "string"
                      },
                      "hs_timestamp": {
                        "type": "string"
                      },
                      "hubspot_owner_id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": {}
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "notes_batch_archive",
        "description": "Archive (delete) multiple notes in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "noteIds"
          ]
        }
      },
      {
        "name": "tasks_create",
        "description": "Create a new task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "required": [
                "hs_task_body",
                "hs_task_subject"
              ],
              "properties": {
                "hs_task_body": {
                  "type": "string"
                },
                "hs_task_type": {
                  "type": "string"
                },
                "hs_timestamp": {
                  "type": "string"
                },
                "hs_task_status": {
                  "enum": [
                    "NOT_STARTED",
                    "IN_PROGRESS",
                    "WAITING",
                    "COMPLETED",
                    "DEFERRED"
                  ],
                  "type": "string"
                },
                "hs_task_subject": {
                  "type": "string"
                },
                "hs_task_due_date": {
                  "type": "string"
                },
                "hs_task_priority": {
                  "enum": [
                    "HIGH",
                    "MEDIUM",
                    "LOW"
                  ],
                  "type": "string"
                },
                "hubspot_owner_id": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "to",
                  "types"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "types": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "associationCategory",
                        "associationTypeId"
                      ],
                      "properties": {
                        "associationTypeId": {
                          "type": "number"
                        },
                        "associationCategory": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "properties"
          ]
        }
      },
      {
        "name": "tasks_get",
        "description": "Get details of a specific task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "contacts",
                  "companies",
                  "deals",
                  "tickets"
                ],
                "type": "string"
              }
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "tasks_update",
        "description": "Update an existing task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "required": [
                "hs_task_body",
                "hs_task_subject"
              ],
              "properties": {
                "hs_task_body": {
                  "type": "string"
                },
                "hs_task_type": {
                  "type": "string"
                },
                "hs_timestamp": {
                  "type": "string"
                },
                "hs_task_status": {
                  "enum": [
                    "NOT_STARTED",
                    "IN_PROGRESS",
                    "WAITING",
                    "COMPLETED",
                    "DEFERRED"
                  ],
                  "type": "string"
                },
                "hs_task_subject": {
                  "type": "string"
                },
                "hs_task_due_date": {
                  "type": "string"
                },
                "hs_task_priority": {
                  "enum": [
                    "HIGH",
                    "MEDIUM",
                    "LOW"
                  ],
                  "type": "string"
                },
                "hubspot_owner_id": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            }
          },
          "required": [
            "taskId",
            "properties"
          ]
        }
      },
      {
        "name": "tasks_archive",
        "description": "Archive (delete) a task",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "tasks_list",
        "description": "List all tasks with optional filtering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "archived": {
              "type": "boolean"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "contacts",
                  "companies",
                  "deals",
                  "tickets"
                ],
                "type": "string"
              }
            }
          }
        }
      },
      {
        "name": "tasks_search",
        "description": "Search tasks with specific filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "sorts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "propertyName",
                  "direction"
                ],
                "properties": {
                  "direction": {
                    "enum": [
                      "ASCENDING",
                      "DESCENDING"
                    ],
                    "type": "string"
                  },
                  "propertyName": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filterGroups": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "filters"
                ],
                "properties": {
                  "filters": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "propertyName",
                        "operator"
                      ],
                      "properties": {
                        "value": {},
                        "operator": {
                          "enum": [
                            "EQ",
                            "NEQ",
                            "LT",
                            "LTE",
                            "GT",
                            "GTE",
                            "BETWEEN",
                            "IN",
                            "NOT_IN",
                            "HAS_PROPERTY",
                            "NOT_HAS_PROPERTY",
                            "CONTAINS_TOKEN",
                            "NOT_CONTAINS_TOKEN"
                          ],
                          "type": "string"
                        },
                        "propertyName": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "filterGroups"
          ]
        }
      },
      {
        "name": "tasks_batch_create",
        "description": "Create multiple tasks in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "properties"
                ],
                "properties": {
                  "properties": {
                    "type": "object",
                    "required": [
                      "hs_task_body",
                      "hs_task_subject"
                    ],
                    "properties": {
                      "hs_task_body": {
                        "type": "string"
                      },
                      "hs_task_type": {
                        "type": "string"
                      },
                      "hs_timestamp": {
                        "type": "string"
                      },
                      "hs_task_status": {
                        "enum": [
                          "NOT_STARTED",
                          "IN_PROGRESS",
                          "WAITING",
                          "COMPLETED",
                          "DEFERRED"
                        ],
                        "type": "string"
                      },
                      "hs_task_subject": {
                        "type": "string"
                      },
                      "hs_task_due_date": {
                        "type": "string"
                      },
                      "hs_task_priority": {
                        "enum": [
                          "HIGH",
                          "MEDIUM",
                          "LOW"
                        ],
                        "type": "string"
                      },
                      "hubspot_owner_id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": {}
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "to",
                        "types"
                      ],
                      "properties": {
                        "to": {
                          "type": "object",
                          "required": [
                            "id"
                          ],
                          "properties": {
                            "id": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "types": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "associationCategory",
                              "associationTypeId"
                            ],
                            "properties": {
                              "associationTypeId": {
                                "type": "number"
                              },
                              "associationCategory": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "tasks_batch_read",
        "description": "Read multiple tasks in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "enum": [
                        "contacts",
                        "companies",
                        "deals",
                        "tickets"
                      ],
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "tasks_batch_update",
        "description": "Update multiple tasks in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "properties"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "object",
                    "required": [
                      "hs_task_body",
                      "hs_task_subject"
                    ],
                    "properties": {
                      "hs_task_body": {
                        "type": "string"
                      },
                      "hs_task_type": {
                        "type": "string"
                      },
                      "hs_timestamp": {
                        "type": "string"
                      },
                      "hs_task_status": {
                        "enum": [
                          "NOT_STARTED",
                          "IN_PROGRESS",
                          "WAITING",
                          "COMPLETED",
                          "DEFERRED"
                        ],
                        "type": "string"
                      },
                      "hs_task_subject": {
                        "type": "string"
                      },
                      "hs_task_due_date": {
                        "type": "string"
                      },
                      "hs_task_priority": {
                        "enum": [
                          "HIGH",
                          "MEDIUM",
                          "LOW"
                        ],
                        "type": "string"
                      },
                      "hubspot_owner_id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": {}
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "tasks_batch_archive",
        "description": "Archive (delete) multiple tasks in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "taskIds"
          ]
        }
      },
      {
        "name": "engagement_details_get",
        "description": "Get details of a specific engagement",
        "inputSchema": {
          "type": "object",
          "properties": {
            "engagementId": {
              "type": "string"
            }
          },
          "required": [
            "engagementId"
          ]
        }
      },
      {
        "name": "engagement_details_create",
        "description": "Create a new engagement with details",
        "inputSchema": {
          "type": "object",
          "properties": {
            "metadata": {
              "type": "object",
              "additionalProperties": {}
            },
            "engagement": {
              "type": "object",
              "required": [
                "type",
                "title"
              ],
              "properties": {
                "type": {
                  "enum": [
                    "EMAIL",
                    "CALL",
                    "MEETING",
                    "TASK",
                    "NOTE"
                  ],
                  "type": "string"
                },
                "owner": {
                  "type": "object",
                  "required": [
                    "id",
                    "email"
                  ],
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "email": {
                      "type": "string",
                      "format": "email"
                    }
                  },
                  "additionalProperties": false
                },
                "title": {
                  "type": "string"
                },
                "status": {
                  "type": "string"
                },
                "endTime": {
                  "type": "string"
                },
                "loggedAt": {
                  "type": "string"
                },
                "startTime": {
                  "type": "string"
                },
                "description": {
                  "type": "string"
                },
                "activityType": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            },
            "associations": {
              "type": "object",
              "properties": {
                "dealIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "ownerIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "ticketIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "companyIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "contactIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "engagement"
          ]
        }
      },
      {
        "name": "engagement_details_update",
        "description": "Update an existing engagement's details",
        "inputSchema": {
          "type": "object",
          "properties": {
            "metadata": {
              "type": "object",
              "additionalProperties": {}
            },
            "engagement": {
              "type": "object",
              "required": [
                "type",
                "title"
              ],
              "properties": {
                "type": {
                  "enum": [
                    "EMAIL",
                    "CALL",
                    "MEETING",
                    "TASK",
                    "NOTE"
                  ],
                  "type": "string"
                },
                "owner": {
                  "type": "object",
                  "required": [
                    "id",
                    "email"
                  ],
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "email": {
                      "type": "string",
                      "format": "email"
                    }
                  },
                  "additionalProperties": false
                },
                "title": {
                  "type": "string"
                },
                "status": {
                  "type": "string"
                },
                "endTime": {
                  "type": "string"
                },
                "loggedAt": {
                  "type": "string"
                },
                "startTime": {
                  "type": "string"
                },
                "description": {
                  "type": "string"
                },
                "activityType": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            },
            "engagementId": {
              "type": "string"
            }
          },
          "required": [
            "engagementId",
            "engagement"
          ]
        }
      },
      {
        "name": "engagement_details_list",
        "description": "List all engagements with optional filtering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "offset": {
              "type": "number"
            },
            "endTime": {
              "type": "string"
            },
            "startTime": {
              "type": "string"
            },
            "activityTypes": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      {
        "name": "engagement_details_archive",
        "description": "Archive (delete) an engagement",
        "inputSchema": {
          "type": "object",
          "properties": {
            "engagementId": {
              "type": "string"
            }
          },
          "required": [
            "engagementId"
          ]
        }
      },
      {
        "name": "engagement_details_get_associated",
        "description": "Get all engagements associated with an object",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "offset": {
              "type": "number"
            },
            "endTime": {
              "type": "string"
            },
            "objectId": {
              "type": "string"
            },
            "startTime": {
              "type": "string"
            },
            "objectType": {
              "enum": [
                "CONTACT",
                "COMPANY",
                "DEAL",
                "TICKET"
              ],
              "type": "string"
            },
            "activityTypes": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "objectType",
            "objectId"
          ]
        }
      },
      {
        "name": "calls_create",
        "description": "Create a new call record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "required": [
                "hs_call_body",
                "hs_call_title"
              ],
              "properties": {
                "hs_call_body": {
                  "type": "string"
                },
                "hs_timestamp": {
                  "type": "string"
                },
                "hs_call_title": {
                  "type": "string"
                },
                "hs_call_status": {
                  "enum": [
                    "SCHEDULED",
                    "COMPLETED",
                    "CANCELED",
                    "NO_ANSWER"
                  ],
                  "type": "string"
                },
                "hs_call_duration": {
                  "type": "number"
                },
                "hubspot_owner_id": {
                  "type": "string"
                },
                "hs_call_direction": {
                  "enum": [
                    "INBOUND",
                    "OUTBOUND"
                  ],
                  "type": "string"
                },
                "hs_call_disposition": {
                  "type": "string"
                },
                "hs_call_recording_url": {
                  "type": "string",
                  "format": "uri"
                }
              },
              "additionalProperties": {}
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "to",
                  "types"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "types": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "associationCategory",
                        "associationTypeId"
                      ],
                      "properties": {
                        "associationTypeId": {
                          "type": "number"
                        },
                        "associationCategory": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "properties"
          ]
        }
      },
      {
        "name": "calls_get",
        "description": "Get details of a specific call",
        "inputSchema": {
          "type": "object",
          "properties": {
            "callId": {
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "contacts",
                  "companies",
                  "deals",
                  "tickets"
                ],
                "type": "string"
              }
            }
          },
          "required": [
            "callId"
          ]
        }
      },
      {
        "name": "calls_update",
        "description": "Update an existing call record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "callId": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "required": [
                "hs_call_body",
                "hs_call_title"
              ],
              "properties": {
                "hs_call_body": {
                  "type": "string"
                },
                "hs_timestamp": {
                  "type": "string"
                },
                "hs_call_title": {
                  "type": "string"
                },
                "hs_call_status": {
                  "enum": [
                    "SCHEDULED",
                    "COMPLETED",
                    "CANCELED",
                    "NO_ANSWER"
                  ],
                  "type": "string"
                },
                "hs_call_duration": {
                  "type": "number"
                },
                "hubspot_owner_id": {
                  "type": "string"
                },
                "hs_call_direction": {
                  "enum": [
                    "INBOUND",
                    "OUTBOUND"
                  ],
                  "type": "string"
                },
                "hs_call_disposition": {
                  "type": "string"
                },
                "hs_call_recording_url": {
                  "type": "string",
                  "format": "uri"
                }
              },
              "additionalProperties": {}
            }
          },
          "required": [
            "callId",
            "properties"
          ]
        }
      },
      {
        "name": "calls_archive",
        "description": "Archive (delete) a call record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "callId": {
              "type": "string"
            }
          },
          "required": [
            "callId"
          ]
        }
      },
      {
        "name": "calls_list",
        "description": "List all calls with optional filtering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "archived": {
              "type": "boolean"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "contacts",
                  "companies",
                  "deals",
                  "tickets"
                ],
                "type": "string"
              }
            }
          }
        }
      },
      {
        "name": "calls_search",
        "description": "Search calls with specific filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "sorts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "propertyName",
                  "direction"
                ],
                "properties": {
                  "direction": {
                    "enum": [
                      "ASCENDING",
                      "DESCENDING"
                    ],
                    "type": "string"
                  },
                  "propertyName": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filterGroups": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "filters"
                ],
                "properties": {
                  "filters": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "propertyName",
                        "operator"
                      ],
                      "properties": {
                        "value": {},
                        "operator": {
                          "enum": [
                            "EQ",
                            "NEQ",
                            "LT",
                            "LTE",
                            "GT",
                            "GTE",
                            "BETWEEN",
                            "IN",
                            "NOT_IN",
                            "HAS_PROPERTY",
                            "NOT_HAS_PROPERTY",
                            "CONTAINS_TOKEN",
                            "NOT_CONTAINS_TOKEN"
                          ],
                          "type": "string"
                        },
                        "propertyName": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "filterGroups"
          ]
        }
      },
      {
        "name": "calls_batch_create",
        "description": "Create multiple call records in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "properties"
                ],
                "properties": {
                  "properties": {
                    "type": "object",
                    "required": [
                      "hs_call_body",
                      "hs_call_title"
                    ],
                    "properties": {
                      "hs_call_body": {
                        "type": "string"
                      },
                      "hs_timestamp": {
                        "type": "string"
                      },
                      "hs_call_title": {
                        "type": "string"
                      },
                      "hs_call_status": {
                        "enum": [
                          "SCHEDULED",
                          "COMPLETED",
                          "CANCELED",
                          "NO_ANSWER"
                        ],
                        "type": "string"
                      },
                      "hs_call_duration": {
                        "type": "number"
                      },
                      "hubspot_owner_id": {
                        "type": "string"
                      },
                      "hs_call_direction": {
                        "enum": [
                          "INBOUND",
                          "OUTBOUND"
                        ],
                        "type": "string"
                      },
                      "hs_call_disposition": {
                        "type": "string"
                      },
                      "hs_call_recording_url": {
                        "type": "string",
                        "format": "uri"
                      }
                    },
                    "additionalProperties": {}
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "to",
                        "types"
                      ],
                      "properties": {
                        "to": {
                          "type": "object",
                          "required": [
                            "id"
                          ],
                          "properties": {
                            "id": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "types": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "associationCategory",
                              "associationTypeId"
                            ],
                            "properties": {
                              "associationTypeId": {
                                "type": "number"
                              },
                              "associationCategory": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "calls_batch_read",
        "description": "Read multiple call records in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "enum": [
                        "contacts",
                        "companies",
                        "deals",
                        "tickets"
                      ],
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "calls_batch_update",
        "description": "Update multiple call records in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "properties"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "object",
                    "required": [
                      "hs_call_body",
                      "hs_call_title"
                    ],
                    "properties": {
                      "hs_call_body": {
                        "type": "string"
                      },
                      "hs_timestamp": {
                        "type": "string"
                      },
                      "hs_call_title": {
                        "type": "string"
                      },
                      "hs_call_status": {
                        "enum": [
                          "SCHEDULED",
                          "COMPLETED",
                          "CANCELED",
                          "NO_ANSWER"
                        ],
                        "type": "string"
                      },
                      "hs_call_duration": {
                        "type": "number"
                      },
                      "hubspot_owner_id": {
                        "type": "string"
                      },
                      "hs_call_direction": {
                        "enum": [
                          "INBOUND",
                          "OUTBOUND"
                        ],
                        "type": "string"
                      },
                      "hs_call_disposition": {
                        "type": "string"
                      },
                      "hs_call_recording_url": {
                        "type": "string",
                        "format": "uri"
                      }
                    },
                    "additionalProperties": {}
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "calls_batch_archive",
        "description": "Archive (delete) multiple call records in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "callIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "callIds"
          ]
        }
      },
      {
        "name": "emails_create",
        "description": "Create a new email record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "required": [
                "hs_email_subject",
                "hs_email_text",
                "hs_email_from_email",
                "hs_email_to_email"
              ],
              "properties": {
                "hs_email_cc": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "email"
                  }
                },
                "hs_email_bcc": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "email"
                  }
                },
                "hs_timestamp": {
                  "type": "string"
                },
                "hs_email_html": {
                  "type": "string"
                },
                "hs_email_text": {
                  "type": "string"
                },
                "hs_email_status": {
                  "enum": [
                    "SENT",
                    "DRAFT",
                    "SCHEDULED"
                  ],
                  "type": "string"
                },
                "hs_email_headers": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "hs_email_subject": {
                  "type": "string"
                },
                "hubspot_owner_id": {
                  "type": "string"
                },
                "hs_email_to_email": {
                  "type": "string",
                  "format": "email"
                },
                "hs_email_direction": {
                  "enum": [
                    "INBOUND",
                    "OUTBOUND"
                  ],
                  "type": "string"
                },
                "hs_email_from_email": {
                  "type": "string",
                  "format": "email"
                },
                "hs_email_to_lastname": {
                  "type": "string"
                },
                "hs_email_to_firstname": {
                  "type": "string"
                },
                "hs_email_from_lastname": {
                  "type": "string"
                },
                "hs_email_from_firstname": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "to",
                  "types"
                ],
                "properties": {
                  "to": {
                    "type": "object",
                    "required": [
                      "id"
                    ],
                    "properties": {
                      "id": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "types": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "associationCategory",
                        "associationTypeId"
                      ],
                      "properties": {
                        "associationTypeId": {
                          "type": "number"
                        },
                        "associationCategory": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "properties"
          ]
        }
      },
      {
        "name": "emails_get",
        "description": "Get details of a specific email",
        "inputSchema": {
          "type": "object",
          "properties": {
            "emailId": {
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "contacts",
                  "companies",
                  "deals",
                  "tickets"
                ],
                "type": "string"
              }
            }
          },
          "required": [
            "emailId"
          ]
        }
      },
      {
        "name": "emails_update",
        "description": "Update an existing email record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "emailId": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "required": [
                "hs_email_subject",
                "hs_email_text",
                "hs_email_from_email",
                "hs_email_to_email"
              ],
              "properties": {
                "hs_email_cc": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "email"
                  }
                },
                "hs_email_bcc": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "email"
                  }
                },
                "hs_timestamp": {
                  "type": "string"
                },
                "hs_email_html": {
                  "type": "string"
                },
                "hs_email_text": {
                  "type": "string"
                },
                "hs_email_status": {
                  "enum": [
                    "SENT",
                    "DRAFT",
                    "SCHEDULED"
                  ],
                  "type": "string"
                },
                "hs_email_headers": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "hs_email_subject": {
                  "type": "string"
                },
                "hubspot_owner_id": {
                  "type": "string"
                },
                "hs_email_to_email": {
                  "type": "string",
                  "format": "email"
                },
                "hs_email_direction": {
                  "enum": [
                    "INBOUND",
                    "OUTBOUND"
                  ],
                  "type": "string"
                },
                "hs_email_from_email": {
                  "type": "string",
                  "format": "email"
                },
                "hs_email_to_lastname": {
                  "type": "string"
                },
                "hs_email_to_firstname": {
                  "type": "string"
                },
                "hs_email_from_lastname": {
                  "type": "string"
                },
                "hs_email_from_firstname": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            }
          },
          "required": [
            "emailId",
            "properties"
          ]
        }
      },
      {
        "name": "emails_archive",
        "description": "Archive (delete) an email record",
        "inputSchema": {
          "type": "object",
          "properties": {
            "emailId": {
              "type": "string"
            }
          },
          "required": [
            "emailId"
          ]
        }
      },
      {
        "name": "emails_list",
        "description": "List all emails with optional filtering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "archived": {
              "type": "boolean"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "enum": [
                  "contacts",
                  "companies",
                  "deals",
                  "tickets"
                ],
                "type": "string"
              }
            }
          }
        }
      },
      {
        "name": "emails_search",
        "description": "Search emails with specific filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1
            },
            "sorts": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "propertyName",
                  "direction"
                ],
                "properties": {
                  "direction": {
                    "enum": [
                      "ASCENDING",
                      "DESCENDING"
                    ],
                    "type": "string"
                  },
                  "propertyName": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filterGroups": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "filters"
                ],
                "properties": {
                  "filters": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "propertyName",
                        "operator"
                      ],
                      "properties": {
                        "value": {},
                        "operator": {
                          "enum": [
                            "EQ",
                            "NEQ",
                            "LT",
                            "LTE",
                            "GT",
                            "GTE",
                            "BETWEEN",
                            "IN",
                            "NOT_IN",
                            "HAS_PROPERTY",
                            "NOT_HAS_PROPERTY",
                            "CONTAINS_TOKEN",
                            "NOT_CONTAINS_TOKEN"
                          ],
                          "type": "string"
                        },
                        "propertyName": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "filterGroups"
          ]
        }
      },
      {
        "name": "emails_batch_create",
        "description": "Create multiple email records in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "properties"
                ],
                "properties": {
                  "properties": {
                    "type": "object",
                    "required": [
                      "hs_email_subject",
                      "hs_email_text",
                      "hs_email_from_email",
                      "hs_email_to_email"
                    ],
                    "properties": {
                      "hs_email_cc": {
                        "type": "array",
                        "items": {
                          "type": "string",
                          "format": "email"
                        }
                      },
                      "hs_email_bcc": {
                        "type": "array",
                        "items": {
                          "type": "string",
                          "format": "email"
                        }
                      },
                      "hs_timestamp": {
                        "type": "string"
                      },
                      "hs_email_html": {
                        "type": "string"
                      },
                      "hs_email_text": {
                        "type": "string"
                      },
                      "hs_email_status": {
                        "enum": [
                          "SENT",
                          "DRAFT",
                          "SCHEDULED"
                        ],
                        "type": "string"
                      },
                      "hs_email_headers": {
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "hs_email_subject": {
                        "type": "string"
                      },
                      "hubspot_owner_id": {
                        "type": "string"
                      },
                      "hs_email_to_email": {
                        "type": "string",
                        "format": "email"
                      },
                      "hs_email_direction": {
                        "enum": [
                          "INBOUND",
                          "OUTBOUND"
                        ],
                        "type": "string"
                      },
                      "hs_email_from_email": {
                        "type": "string",
                        "format": "email"
                      },
                      "hs_email_to_lastname": {
                        "type": "string"
                      },
                      "hs_email_to_firstname": {
                        "type": "string"
                      },
                      "hs_email_from_lastname": {
                        "type": "string"
                      },
                      "hs_email_from_firstname": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": {}
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "to",
                        "types"
                      ],
                      "properties": {
                        "to": {
                          "type": "object",
                          "required": [
                            "id"
                          ],
                          "properties": {
                            "id": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "types": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "associationCategory",
                              "associationTypeId"
                            ],
                            "properties": {
                              "associationTypeId": {
                                "type": "number"
                              },
                              "associationCategory": {
                                "type": "string"
                              }
                            },
                            "additionalProperties": false
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "emails_batch_read",
        "description": "Read multiple email records in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "associations": {
                    "type": "array",
                    "items": {
                      "enum": [
                        "contacts",
                        "companies",
                        "deals",
                        "tickets"
                      ],
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "emails_batch_update",
        "description": "Update multiple email records in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "properties"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "object",
                    "required": [
                      "hs_email_subject",
                      "hs_email_text",
                      "hs_email_from_email",
                      "hs_email_to_email"
                    ],
                    "properties": {
                      "hs_email_cc": {
                        "type": "array",
                        "items": {
                          "type": "string",
                          "format": "email"
                        }
                      },
                      "hs_email_bcc": {
                        "type": "array",
                        "items": {
                          "type": "string",
                          "format": "email"
                        }
                      },
                      "hs_timestamp": {
                        "type": "string"
                      },
                      "hs_email_html": {
                        "type": "string"
                      },
                      "hs_email_text": {
                        "type": "string"
                      },
                      "hs_email_status": {
                        "enum": [
                          "SENT",
                          "DRAFT",
                          "SCHEDULED"
                        ],
                        "type": "string"
                      },
                      "hs_email_headers": {
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "hs_email_subject": {
                        "type": "string"
                      },
                      "hubspot_owner_id": {
                        "type": "string"
                      },
                      "hs_email_to_email": {
                        "type": "string",
                        "format": "email"
                      },
                      "hs_email_direction": {
                        "enum": [
                          "INBOUND",
                          "OUTBOUND"
                        ],
                        "type": "string"
                      },
                      "hs_email_from_email": {
                        "type": "string",
                        "format": "email"
                      },
                      "hs_email_to_lastname": {
                        "type": "string"
                      },
                      "hs_email_to_firstname": {
                        "type": "string"
                      },
                      "hs_email_from_lastname": {
                        "type": "string"
                      },
                      "hs_email_from_firstname": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": {}
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "emails_batch_archive",
        "description": "Archive (delete) multiple email records in a single request",
        "inputSchema": {
          "type": "object",
          "properties": {
            "emailIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "emailIds"
          ]
        }
      },
      {
        "name": "communications_get_preferences",
        "description": "Get communication preferences for a contact",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactId": {
              "type": "string"
            },
            "subscriptionId": {
              "type": "string"
            }
          },
          "required": [
            "contactId"
          ]
        }
      },
      {
        "name": "communications_update_preferences",
        "description": "Update communication preferences for a contact",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactId": {
              "type": "string"
            },
            "preferences": {
              "type": "object",
              "required": [
                "subscriptionId",
                "status"
              ],
              "properties": {
                "status": {
                  "enum": [
                    "SUBSCRIBED",
                    "UNSUBSCRIBED",
                    "NOT_OPTED"
                  ],
                  "type": "string"
                },
                "legalBasis": {
                  "enum": [
                    "LEGITIMATE_INTEREST_CLIENT",
                    "LEGITIMATE_INTEREST_PUB",
                    "PERFORMANCE_OF_CONTRACT",
                    "CONSENT_WITH_NOTICE",
                    "CONSENT_WITH_NOTICE_AND_OPT_OUT"
                  ],
                  "type": "string"
                },
                "subscriptionId": {
                  "type": "string"
                },
                "legalBasisExplanation": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            },
            "subscriptionId": {
              "type": "string"
            }
          },
          "required": [
            "contactId",
            "subscriptionId",
            "preferences"
          ]
        }
      },
      {
        "name": "communications_unsubscribe_contact",
        "description": "Unsubscribe a contact from all email communications",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactId": {
              "type": "string"
            },
            "portalSubscriptionLegalBasis": {
              "enum": [
                "LEGITIMATE_INTEREST_CLIENT",
                "LEGITIMATE_INTEREST_PUB",
                "PERFORMANCE_OF_CONTRACT",
                "CONSENT_WITH_NOTICE",
                "CONSENT_WITH_NOTICE_AND_OPT_OUT"
              ],
              "type": "string"
            },
            "portalSubscriptionLegalBasisExplanation": {
              "type": "string"
            }
          },
          "required": [
            "contactId"
          ]
        }
      },
      {
        "name": "communications_subscribe_contact",
        "description": "Subscribe a contact to all email communications",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactId": {
              "type": "string"
            },
            "portalSubscriptionLegalBasis": {
              "enum": [
                "LEGITIMATE_INTEREST_CLIENT",
                "LEGITIMATE_INTEREST_PUB",
                "PERFORMANCE_OF_CONTRACT",
                "CONSENT_WITH_NOTICE",
                "CONSENT_WITH_NOTICE_AND_OPT_OUT"
              ],
              "type": "string"
            },
            "portalSubscriptionLegalBasisExplanation": {
              "type": "string"
            }
          },
          "required": [
            "contactId"
          ]
        }
      },
      {
        "name": "communications_get_subscription_definitions",
        "description": "Get all subscription definitions for the portal",
        "inputSchema": {
          "type": "object",
          "properties": {
            "archived": {
              "type": "boolean"
            }
          }
        }
      },
      {
        "name": "communications_get_subscription_status",
        "description": "Get subscription status for multiple contacts",
        "inputSchema": {
          "type": "object",
          "properties": {
            "contactIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "subscriptionId": {
              "type": "string"
            }
          },
          "required": [
            "subscriptionId",
            "contactIds"
          ]
        }
      },
      {
        "name": "communications_update_subscription_status",
        "description": "Update subscription status for multiple contacts",
        "inputSchema": {
          "type": "object",
          "properties": {
            "updates": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "contactId",
                  "status"
                ],
                "properties": {
                  "status": {
                    "enum": [
                      "SUBSCRIBED",
                      "UNSUBSCRIBED",
                      "NOT_OPTED"
                    ],
                    "type": "string"
                  },
                  "contactId": {
                    "type": "string"
                  },
                  "legalBasis": {
                    "enum": [
                      "LEGITIMATE_INTEREST_CLIENT",
                      "LEGITIMATE_INTEREST_PUB",
                      "PERFORMANCE_OF_CONTRACT",
                      "CONSENT_WITH_NOTICE",
                      "CONSENT_WITH_NOTICE_AND_OPT_OUT"
                    ],
                    "type": "string"
                  },
                  "legalBasisExplanation": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "subscriptionId": {
              "type": "string"
            }
          },
          "required": [
            "subscriptionId",
            "updates"
          ]
        }
      },
      {
        "name": "products_list",
        "description": "Read a page of products. Control what is returned via the `properties` query param. `after` is the paging cursor token of the last successfully read resource will be returned as the `paging.next.after` JSON property of a paged response containing more results.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "minimum": 1
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      {
        "name": "products_read",
        "description": "Read an Object identified by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "productId": {
              "type": "string"
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "associations": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "productId"
          ]
        }
      },
      {
        "name": "products_create",
        "description": "Create a product with the given properties and return a copy of the object, including the ID.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "properties": {
              "type": "object",
              "properties": {
                "sku": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "price": {
                  "type": "number"
                },
                "description": {
                  "type": "string"
                },
                "hs_product_type": {
                  "type": "string"
                },
                "hs_recurring_billing_period": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            }
          },
          "required": [
            "properties"
          ]
        }
      },
      {
        "name": "products_update",
        "description": "Perform a partial update of an Object identified by ID. Read-only and non-existent properties will result in an error. Properties values can be cleared by passing an empty string.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "productId": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "properties": {
                "sku": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "price": {
                  "type": "number"
                },
                "description": {
                  "type": "string"
                },
                "hs_product_type": {
                  "type": "string"
                },
                "hs_recurring_billing_period": {
                  "type": "string"
                }
              },
              "additionalProperties": {}
            }
          },
          "required": [
            "productId",
            "properties"
          ]
        }
      },
      {
        "name": "products_archive",
        "description": "Move an Object identified by ID to the recycling bin.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "productId": {
              "type": "string"
            }
          },
          "required": [
            "productId"
          ]
        }
      },
      {
        "name": "products_search",
        "description": "Search products",
        "inputSchema": {
          "type": "object",
          "properties": {
            "after": {
              "type": "string"
            },
            "limit": {
              "type": "number",
              "minimum": 1
            },
            "query": {
              "type": "string"
            },
            "sorts": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "filterGroups": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "filters"
                ],
                "properties": {
                  "filters": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "required": [
                        "propertyName",
                        "operator"
                      ],
                      "properties": {
                        "value": {},
                        "values": {
                          "type": "array"
                        },
                        "operator": {
                          "enum": [
                            "EQ",
                            "NEQ",
                            "LT",
                            "LTE",
                            "GT",
                            "GTE",
                            "BETWEEN",
                            "IN",
                            "NOT_IN",
                            "HAS_PROPERTY",
                            "NOT_HAS_PROPERTY",
                            "CONTAINS_TOKEN",
                            "NOT_CONTAINS_TOKEN"
                          ],
                          "type": "string"
                        },
                        "propertyName": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "filterGroups"
          ]
        }
      },
      {
        "name": "products_batch_archive",
        "description": "Archive (delete) a batch of products by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "productIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "productIds"
          ]
        }
      },
      {
        "name": "products_batch_create",
        "description": "Create a batch of products",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "properties"
                ],
                "properties": {
                  "properties": {
                    "type": "object",
                    "properties": {
                      "sku": {
                        "type": "string"
                      },
                      "name": {
                        "type": "string"
                      },
                      "price": {
                        "type": "number"
                      },
                      "description": {
                        "type": "string"
                      },
                      "hs_product_type": {
                        "type": "string"
                      },
                      "hs_recurring_billing_period": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": {}
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      },
      {
        "name": "products_batch_read",
        "description": "Read a batch of products by internal ID, or unique property values. Retrieve records by the `idProperty` parameter to retrieve records by a custom unique value property.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "idProperty": {
              "type": "string"
            },
            "productIds": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "properties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "propertiesWithHistory": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "propertiesWithHistory",
            "productIds",
            "properties"
          ]
        }
      },
      {
        "name": "products_batch_update",
        "description": "Update a batch of products by internal ID, or unique values specified by the `idProperty` query param.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "id",
                  "properties"
                ],
                "properties": {
                  "id": {
                    "type": "string"
                  },
                  "idProperty": {
                    "type": "string"
                  },
                  "properties": {
                    "type": "object",
                    "properties": {
                      "sku": {
                        "type": "string"
                      },
                      "name": {
                        "type": "string"
                      },
                      "price": {
                        "type": "number"
                      },
                      "description": {
                        "type": "string"
                      },
                      "hs_product_type": {
                        "type": "string"
                      },
                      "hs_recurring_billing_period": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": {}
                  },
                  "objectWriteTraceId": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "inputs"
          ]
        }
      }
    ]
  },
  {
    "name": "sylphxltd-pdf-reader-mcp",
    "title": "PDF Reader MCP Server",
    "description": "Empowers AI agents to securely read and extract information (text, metadata, page count) from PDF files within project contexts using a flexible MCP tool.",
    "icon": "https://avatars.githubusercontent.com/sylphxltd",
    "isOfficial": false,
    "homepage": "https://github.com/sylphxltd/pdf-reader-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@shtse8/pdf-reader-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "read_pdf",
        "description": "Reads content/metadata from one or more PDFs (local/URL). Each source can specify pages to extract.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sources": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "format": "uri",
                    "description": "URL of the PDF file."
                  },
                  "path": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Relative path to the local PDF file."
                  },
                  "pages": {
                    "anyOf": [
                      {
                        "type": "array",
                        "items": {
                          "type": "integer",
                          "minimum": 0,
                          "exclusiveMinimum": true
                        },
                        "minItems": 1
                      },
                      {
                        "type": "string",
                        "minLength": 1
                      }
                    ],
                    "description": "Extract text only from specific pages (1-based) or ranges for *this specific source*. If provided, 'include_full_text' for the entire request is ignored for this source."
                  }
                },
                "additionalProperties": false
              },
              "minItems": 1,
              "description": "An array of PDF sources to process, each can optionally specify pages."
            },
            "include_metadata": {
              "type": "boolean",
              "default": true,
              "description": "Include metadata and info objects for each PDF."
            },
            "include_full_text": {
              "type": "boolean",
              "default": false,
              "description": "Include the full text content of each PDF (only if 'pages' is not specified for that source)."
            },
            "include_page_count": {
              "type": "boolean",
              "default": true,
              "description": "Include the total number of pages for each PDF."
            }
          },
          "required": [
            "sources"
          ]
        }
      }
    ]
  },
  {
    "name": "sinco-lab-mcp-youtube-transcript",
    "title": "mcp-youtube-transcript",
    "description": "A Model Context Protocol server that enables retrieval of transcripts from YouTube videos. This server provides direct access to video transcripts and subtitles through a simple interface, making it ideal for content analysis and processing.",
    "icon": "https://avatars.githubusercontent.com/sinco-lab",
    "isOfficial": false,
    "homepage": "https://github.com/sinco-lab/mcp-youtube-transcript",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@sinco-lab/mcp-youtube-transcript"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_transcripts",
        "description": "Extract and process transcripts from a YouTube video.\n\n**Parameters:**\n- `url` (string, required): YouTube video URL or ID.\n- `lang` (string, optional, default 'en'): Language code for transcripts (e.g. 'en', 'uk', 'ja', 'ru', 'zh').\n- `enableParagraphs` (boolean, optional, default false): Enable automatic paragraph breaks.\n\n**IMPORTANT:** If the user does *not* specify a language *code*, **DO NOT** include the `lang` parameter in the tool call. Do not guess the language or use parts of the user query as the language code.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "YouTube video URL or ID"
            },
            "lang": {
              "type": "string",
              "default": "en",
              "description": "Language code for transcripts, default 'en' (e.g. 'en', 'uk', 'ja', 'ru', 'zh')"
            },
            "enableParagraphs": {
              "type": "boolean",
              "default": false,
              "description": "Enable automatic paragraph breaks, default `false`"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "sirmews-apple-notes-mcp",
    "title": "apple-notes-mcp",
    "description": "Allows the AI to read from your local Apple Notes database (macOS only)",
    "icon": "https://avatars.githubusercontent.com/sirmews",
    "isOfficial": false,
    "homepage": "https://github.com/sirmews/apple-notes-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "apple-notes-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "sirmews-mcp-pinecone",
    "title": "mcp-pinecone",
    "description": "Pinecone integration with vector search capabilities",
    "icon": "https://avatars.githubusercontent.com/sirmews",
    "isOfficial": false,
    "homepage": "https://github.com/sirmews/mcp-pinecone",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-pinecone"
      ],
      "env": {
        "your-index-name": "<your-index-name>",
        "UV_PUBLISH_TOKEN": "<uv-publish-token>",
        "UV_PUBLISH_PASSWORD": "<uv-publish-password>",
        "UV_PUBLISH_USERNAME": "<uv-publish-username>",
        "your-secret-api-key": "<your-secret-api-key>"
      }
    },
    "parameters": [
      {
        "name": "your-index-name",
        "description": "The name of your Pinecone index.",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "UV_PUBLISH_TOKEN",
        "description": "Your token used for publishing to PyPI.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "UV_PUBLISH_PASSWORD",
        "description": "Your password for publishing to PyPI.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "UV_PUBLISH_USERNAME",
        "description": "Your username for publishing to PyPI.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "your-secret-api-key",
        "description": "Your secret API key for accessing the Pinecone index.",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "skydeckai-mcp-server-rememberizer",
    "title": "Rememberizer MCP Server",
    "description": "A Model Context Protocol server enabling LLMs to search, retrieve, and manage documents through Rememberizer's knowledge management API.",
    "icon": "https://avatars.githubusercontent.com/skydeckai",
    "isOfficial": false,
    "homepage": "https://github.com/skydeckai/mcp-server-rememberizer",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-rememberizer"
      ],
      "env": {
        "REMEMBERIZER_API_TOKEN": "<rememberizer-api-token>"
      }
    },
    "parameters": [
      {
        "name": "REMEMBERIZER_API_TOKEN",
        "description": "Your Rememberizer API token, obtained by creating your own Common Knowledge in Rememberizer",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "janwilmake-openapi-mcp-server",
    "title": "OpenAPI",
    "description": "This tool creates a Model Context Protocol (MCP) server that acts as a proxy for any API that has an OpenAPI v3.1 specification. This allows you to use Claude Desktop to easily interact with both local and remote server APIs.",
    "icon": "https://avatars.githubusercontent.com/janwilmake",
    "isOfficial": false,
    "homepage": "https://github.com/janwilmake/openapi-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "openapi-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "getApiOverview",
        "description": "Get an overview of an OpenAPI specification. This should be the first step when working with any API.\n\n- github - GitHub is where one hosts their code in a central location, to collaborate with others\n- socialdata.tools\n- podscan.fm - Search through podcast transcripts, get alerts\n- x - Official Twitter/X API\n- cloudflare - Cloudflare provides content delivery network services, cloud cybersecurity, DDoS mitigation, wide area network services, Domain Name Service, and ICANN-accredited domain registration services\n- npm-registry\n- supabase - Create hosted Postgres Databases with API\n- hackernews - Readonly API for posts, comments, and profiles from news.ycombinator.com\n- stripe - Create a paywall for your app or invoices\n- slack - A very common app used for communication at work\n- vercel - Vercel is a cloud hosting solution for full stack applications\n- val-town - Host serverless APIs\n- openai - OpenAI is a large AI service provider providing state of the art models in various modalities.\n- firecrawl - API for interacting with Firecrawl services to perform web scraping and crawling tasks.\n- playht - The PlayHT's API API allows developers to Realtime Text to Speech streaming Stream audio bytes from text, Convert long form Text to Speech Generate audio from text, and Voice Cloning Instant Cloning.\n- serper - The worlds fastest and cheapest google search api\n- replicate\n- brandwatch - Watch social media about your brand\n- jina-reader - Read webpages in markdown, html, or screenshot\n- upstash-redis - Control a Redis database over API\n- upstash-qstash - Scheduling and batching API calls\n- upstash-vector - Control a Vector database over API\n- digitalocean\n- apisguru - Public API to find OpenAPIs on https://apis.guru\n- groq - Cloud AI Provider with multiple transformer LLMs and other modalities, with very fast inference\n- notion-dbs - Notion Databases API\n- posthog-capture-api - Posthog is a Product analytics platform allowing companies to track and understand their users\n- google-analytics4 - The Google Analytics Admin API allows for programmatic access to the Google Analytics 4 (GA4) configuration data and is only compatible with GA4 properties\n- google-analytics3 - Views and manages your Google Analytics data (GA3)\n- anthropic-message-api\n- probo-nl\n- whatsapp-business - The WhatsApp Business Platform gives medium to large businesses the ability to connect with customers at scale. You can start WhatsApp conversations with your customers in minutes, send them care notifications or purchase updates, offer personalized services, and provide support in the channel that your customers prefer.\n- shopify - Shopify Admin API\n- twilio-messaging\n- huggingface\n- doppio\n- multion\n- browserless - Web browsing API\n- bol-com-retailer - Dutch shopping platform\n- statusbrew - Social media planning API for facebook, instagram, twitter, linkedin, google my business, pinterest, youtube, and tiktok.\n- swagger-validator - Validators for swagger 2.0 and 3.x specifications of OpenAPIs\n- google-mail - Manage GMail\n- youtube-data - The YouTube Data API v3 is an API that provides access to YouTube data, such as videos, playlists, and channels.\n- google-sheets\n- google-drive\n- google-secret-manager\n- flyio\n- vapi\n- klippa\n- uberduck\n- twilio\n- saltedge - Bank integrations\n- google-search-console\n- aws-cloudwatch-insights\n- aws-cloudfront\n- aws-email\n- aws-s3-control\n- aws-s3\n- aws-sagemaker\n- aws-sagemaker-edge\n- aws-sagemaker-featureStore\n- bunq\n- hootsuite\n- robocorp\n- sendgrid\n- google-calendar\n- google-docs",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "API identifier, can be a known ID from openapisearch.com or a URL leading to a raw OpenAPI file"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "getApiOperation",
        "description": "Get details about a specific operation from an OpenAPI specification. Use this after getting an overview.\n\n- github - GitHub is where one hosts their code in a central location, to collaborate with others\n- socialdata.tools\n- podscan.fm - Search through podcast transcripts, get alerts\n- x - Official Twitter/X API\n- cloudflare - Cloudflare provides content delivery network services, cloud cybersecurity, DDoS mitigation, wide area network services, Domain Name Service, and ICANN-accredited domain registration services\n- npm-registry\n- supabase - Create hosted Postgres Databases with API\n- hackernews - Readonly API for posts, comments, and profiles from news.ycombinator.com\n- stripe - Create a paywall for your app or invoices\n- slack - A very common app used for communication at work\n- vercel - Vercel is a cloud hosting solution for full stack applications\n- val-town - Host serverless APIs\n- openai - OpenAI is a large AI service provider providing state of the art models in various modalities.\n- firecrawl - API for interacting with Firecrawl services to perform web scraping and crawling tasks.\n- playht - The PlayHT's API API allows developers to Realtime Text to Speech streaming Stream audio bytes from text, Convert long form Text to Speech Generate audio from text, and Voice Cloning Instant Cloning.\n- serper - The worlds fastest and cheapest google search api\n- replicate\n- brandwatch - Watch social media about your brand\n- jina-reader - Read webpages in markdown, html, or screenshot\n- upstash-redis - Control a Redis database over API\n- upstash-qstash - Scheduling and batching API calls\n- upstash-vector - Control a Vector database over API\n- digitalocean\n- apisguru - Public API to find OpenAPIs on https://apis.guru\n- groq - Cloud AI Provider with multiple transformer LLMs and other modalities, with very fast inference\n- notion-dbs - Notion Databases API\n- posthog-capture-api - Posthog is a Product analytics platform allowing companies to track and understand their users\n- google-analytics4 - The Google Analytics Admin API allows for programmatic access to the Google Analytics 4 (GA4) configuration data and is only compatible with GA4 properties\n- google-analytics3 - Views and manages your Google Analytics data (GA3)\n- anthropic-message-api\n- probo-nl\n- whatsapp-business - The WhatsApp Business Platform gives medium to large businesses the ability to connect with customers at scale. You can start WhatsApp conversations with your customers in minutes, send them care notifications or purchase updates, offer personalized services, and provide support in the channel that your customers prefer.\n- shopify - Shopify Admin API\n- twilio-messaging\n- huggingface\n- doppio\n- multion\n- browserless - Web browsing API\n- bol-com-retailer - Dutch shopping platform\n- statusbrew - Social media planning API for facebook, instagram, twitter, linkedin, google my business, pinterest, youtube, and tiktok.\n- swagger-validator - Validators for swagger 2.0 and 3.x specifications of OpenAPIs\n- google-mail - Manage GMail\n- youtube-data - The YouTube Data API v3 is an API that provides access to YouTube data, such as videos, playlists, and channels.\n- google-sheets\n- google-drive\n- google-secret-manager\n- flyio\n- vapi\n- klippa\n- uberduck\n- twilio\n- saltedge - Bank integrations\n- google-search-console\n- aws-cloudwatch-insights\n- aws-cloudfront\n- aws-email\n- aws-s3-control\n- aws-s3\n- aws-sagemaker\n- aws-sagemaker-edge\n- aws-sagemaker-featureStore\n- bunq\n- hootsuite\n- robocorp\n- sendgrid\n- google-calendar\n- google-docs",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "API identifier, can be a known ID from openapisearch.com or a URL leading to a raw OpenAPI file"
            },
            "operationIdOrRoute": {
              "type": "string",
              "description": "Operation ID or route path to retrieve"
            }
          },
          "required": [
            "id",
            "operationIdOrRoute"
          ]
        }
      }
    ]
  },
  {
    "name": "snjyor-binance-mcp",
    "title": "Binance Cryptocurrency MCP",
    "description": "MCP service that provides real-time access to Binance cryptocurrency market data, allowing AI agents to fetch current prices, order books, candlestick charts, and trading statistics through natural language queries.",
    "icon": "https://avatars.githubusercontent.com/snjyor",
    "isOfficial": false,
    "homepage": "https://github.com/snjyor/binance-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@snjyor/binance-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_order_book",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Order book depth, default 100, max 5000"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_recent_trades",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Number of trades to return, default 500, max 1000"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_historical_trades",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Number of trades to return, default 500, max 1000"
            },
            "fromId": {
              "type": "number",
              "description": "Trade ID to start from, default returns the most recent trades"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_aggregate_trades",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Number of trades to return, default 500, max 1000"
            },
            "fromId": {
              "type": "number",
              "description": "Aggregate trade ID to start from"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            },
            "endTime": {
              "type": "number",
              "description": "End timestamp (milliseconds)"
            },
            "startTime": {
              "type": "number",
              "description": "Start timestamp (milliseconds)"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_klines",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Number of K-lines to return, default 500, max 1000"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            },
            "endTime": {
              "type": "number",
              "description": "End timestamp (milliseconds)"
            },
            "interval": {
              "type": "string",
              "description": "K-line interval, e.g. 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M"
            },
            "timeZone": {
              "type": "string",
              "description": "Time zone, default UTC"
            },
            "startTime": {
              "type": "number",
              "description": "Start timestamp (milliseconds)"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "get_ui_klines",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Number of K-lines to return, default 500, max 1000"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            },
            "endTime": {
              "type": "number",
              "description": "End timestamp (milliseconds)"
            },
            "interval": {
              "type": "string",
              "description": "K-line interval, e.g. 1m, 3m, 5m, 15m, 30m, 1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M"
            },
            "timeZone": {
              "type": "string",
              "description": "Time zone, default UTC"
            },
            "startTime": {
              "type": "number",
              "description": "Start timestamp (milliseconds)"
            }
          },
          "required": [
            "symbol",
            "interval"
          ]
        }
      },
      {
        "name": "get_avg_price",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_24hr_ticker",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            },
            "symbols": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of multiple trading pair symbols"
            }
          }
        }
      },
      {
        "name": "get_trading_day_ticker",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "FULL",
                "MINI"
              ],
              "type": "string",
              "description": "Return data type, FULL or MINI"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            },
            "symbols": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of multiple trading pair symbols"
            },
            "timeZone": {
              "type": "number",
              "description": "Time zone, default 0"
            }
          }
        }
      },
      {
        "name": "get_price",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            },
            "symbols": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of multiple trading pair symbols"
            }
          }
        }
      },
      {
        "name": "get_book_ticker",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            },
            "symbols": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of multiple trading pair symbols"
            }
          }
        }
      },
      {
        "name": "get_rolling_window_ticker",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "FULL",
                "MINI"
              ],
              "type": "string",
              "description": "Return data type, FULL or MINI"
            },
            "symbol": {
              "type": "string",
              "description": "Trading pair symbol, e.g. BTCUSDT"
            },
            "symbols": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of multiple trading pair symbols"
            },
            "windowSize": {
              "type": "string",
              "description": "Window size, e.g. 1m, 4h, 1d"
            }
          }
        }
      }
    ]
  },
  {
    "name": "sooperset-mcp-atlassian",
    "title": "MCP Atlassian",
    "description": "Model Context Protocol (MCP) server for Atlassian Cloud products (Confluence and Jira). This integration is designed specifically for Atlassian Cloud instances and does not support Atlassian Server or Data Center deployments.",
    "icon": "https://avatars.githubusercontent.com/sooperset",
    "isOfficial": false,
    "homepage": "https://github.com/sooperset/mcp-atlassian",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-atlassian"
      ],
      "env": {
        "JIRA_URL": "<jira-url>",
        "JIRA_USERNAME": "<jira-username>",
        "CONFLUENCE_URL": "<confluence-url>",
        "JIRA_API_TOKEN": "<jira-api-token>",
        "CONFLUENCE_USERNAME": "<confluence-username>",
        "CONFLUENCE_API_TOKEN": "<confluence-api-token>"
      }
    },
    "parameters": [
      {
        "name": "JIRA_URL",
        "description": "The URL for your Jira instance",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "JIRA_USERNAME",
        "description": "Your Jira account email",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "CONFLUENCE_URL",
        "description": "The URL for your Confluence instance",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "JIRA_API_TOKEN",
        "description": "Your Jira API token",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "CONFLUENCE_USERNAME",
        "description": "Your Confluence account email",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "CONFLUENCE_API_TOKEN",
        "description": "Your Confluence API token",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "jira_get_issue",
        "description": "Get details of a specific Jira issue including its Epic links and relationship information",
        "inputSchema": {
          "type": "object",
          "properties": {
            "expand": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Expand",
              "default": null,
              "description": "Optional fields to expand. Examples: 'renderedFields' (for rendered content), 'transitions' (for available status transitions), 'changelog' (for history)"
            },
            "fields": {
              "type": "string",
              "title": "Fields",
              "default": "summary,description,status,assignee,reporter,labels,priority,created,updated,issuetype",
              "description": "Fields to return. Can be a comma-separated list (e.g., 'summary,status,customfield_10010'), '*all' for all fields (including custom fields), or omitted for essential fields only"
            },
            "issue_key": {
              "type": "string",
              "title": "Issue Key",
              "description": "Jira issue key (e.g., 'PROJ-123')"
            },
            "properties": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Properties",
              "default": null,
              "description": "A comma-separated list of issue properties to return"
            },
            "comment_limit": {
              "type": "integer",
              "title": "Comment Limit",
              "default": 10,
              "maximum": 100,
              "minimum": 0,
              "description": "Maximum number of comments to include (0 or null for no comments)"
            },
            "update_history": {
              "type": "boolean",
              "title": "Update History",
              "default": true,
              "description": "Whether to update the issue view history for the requesting user"
            }
          },
          "required": [
            "issue_key"
          ]
        }
      },
      {
        "name": "jira_search",
        "description": "Search Jira issues using JQL (Jira Query Language)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "jql": {
              "type": "string",
              "title": "Jql",
              "description": "JQL query string (Jira Query Language). Examples:\n- Find Epics: \"issuetype = Epic AND project = PROJ\"\n- Find issues in Epic: \"parent = PROJ-123\"\n- Find by status: \"status = 'In Progress' AND project = PROJ\"\n- Find by assignee: \"assignee = currentUser()\"\n- Find recently updated: \"updated >= -7d AND project = PROJ\"\n- Find by label: \"labels = frontend AND project = PROJ\"\n- Find by priority: \"priority = High AND project = PROJ\""
            },
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of results (1-50)"
            },
            "fields": {
              "type": "string",
              "title": "Fields",
              "default": "summary,description,status,assignee,reporter,labels,priority,created,updated,issuetype",
              "description": "Comma-separated fields to return in the results. Use '*all' for all fields, or specify individual fields like 'summary,status,assignee,priority'"
            },
            "start_at": {
              "type": "integer",
              "title": "Start At",
              "default": 0,
              "minimum": 0,
              "description": "Starting index for pagination (0-based)"
            },
            "projects_filter": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Projects Filter",
              "default": null,
              "description": "Comma-separated list of project keys to filter results by. Overrides the environment variable JIRA_PROJECTS_FILTER if provided."
            }
          },
          "required": [
            "jql"
          ]
        }
      },
      {
        "name": "jira_get_project_issues",
        "description": "Get all issues for a specific Jira project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of results (1-50)"
            },
            "start_at": {
              "type": "integer",
              "title": "Start At",
              "default": 0,
              "minimum": 0,
              "description": "Starting index for pagination (0-based)"
            },
            "project_key": {
              "type": "string",
              "title": "Project Key",
              "description": "The project key"
            }
          },
          "required": [
            "project_key"
          ]
        }
      },
      {
        "name": "jira_get_epic_issues",
        "description": "Get all issues linked to a specific epic",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of issues to return (1-50)"
            },
            "epic_key": {
              "type": "string",
              "title": "Epic Key",
              "description": "The key of the epic (e.g., 'PROJ-123')"
            },
            "start_at": {
              "type": "integer",
              "title": "Start At",
              "default": 0,
              "minimum": 0,
              "description": "Starting index for pagination (0-based)"
            }
          },
          "required": [
            "epic_key"
          ]
        }
      },
      {
        "name": "jira_get_transitions",
        "description": "Get available status transitions for a Jira issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_key": {
              "type": "string",
              "title": "Issue Key",
              "description": "Jira issue key (e.g., 'PROJ-123')"
            }
          },
          "required": [
            "issue_key"
          ]
        }
      },
      {
        "name": "jira_get_worklog",
        "description": "Get worklog entries for a Jira issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_key": {
              "type": "string",
              "title": "Issue Key",
              "description": "Jira issue key (e.g., 'PROJ-123')"
            }
          },
          "required": [
            "issue_key"
          ]
        }
      },
      {
        "name": "jira_download_attachments",
        "description": "Download attachments from a Jira issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_key": {
              "type": "string",
              "title": "Issue Key",
              "description": "Jira issue key (e.g., 'PROJ-123')"
            },
            "target_dir": {
              "type": "string",
              "title": "Target Dir",
              "description": "Directory where attachments should be saved"
            }
          },
          "required": [
            "issue_key",
            "target_dir"
          ]
        }
      },
      {
        "name": "jira_get_agile_boards",
        "description": "Get jira agile boards by name, project key, or type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of results (1-50)"
            },
            "start_at": {
              "type": "integer",
              "title": "Start At",
              "default": 0,
              "minimum": 0,
              "description": "Starting index for pagination (0-based)"
            },
            "board_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Board Name",
              "default": null,
              "description": "The name of board, support fuzzy search"
            },
            "board_type": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Board Type",
              "default": null,
              "description": "The type of jira board (e.g., 'scrum', 'kanban')"
            },
            "project_key": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Project Key",
              "default": null,
              "description": "Jira project key (e.g., 'PROJ-123')"
            }
          }
        }
      },
      {
        "name": "jira_get_board_issues",
        "description": "Get all issues linked to a specific board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "jql": {
              "type": "string",
              "title": "Jql",
              "description": "JQL query string (Jira Query Language). Examples:\n- Find Epics: \"issuetype = Epic AND project = PROJ\"\n- Find issues in Epic: \"parent = PROJ-123\"\n- Find by status: \"status = 'In Progress' AND project = PROJ\"\n- Find by assignee: \"assignee = currentUser()\"\n- Find recently updated: \"updated >= -7d AND project = PROJ\"\n- Find by label: \"labels = frontend AND project = PROJ\"\n- Find by priority: \"priority = High AND project = PROJ\""
            },
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of results (1-50)"
            },
            "expand": {
              "type": "string",
              "title": "Expand",
              "default": "version",
              "description": "Fields to expand in the response (e.g., 'version', 'body.storage')"
            },
            "fields": {
              "type": "string",
              "title": "Fields",
              "default": "*all",
              "description": "Comma-separated fields to return in the results. Use '*all' for all fields, or specify individual fields like 'summary,status,assignee,priority'"
            },
            "board_id": {
              "type": "string",
              "title": "Board Id",
              "description": "The id of the board (e.g., '1001')"
            },
            "start_at": {
              "type": "integer",
              "title": "Start At",
              "default": 0,
              "minimum": 0,
              "description": "Starting index for pagination (0-based)"
            }
          },
          "required": [
            "board_id",
            "jql"
          ]
        }
      },
      {
        "name": "jira_get_sprints_from_board",
        "description": "Get jira sprints from board by state",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of results (1-50)"
            },
            "state": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "State",
              "default": null,
              "description": "Sprint state (e.g., 'active', 'future', 'closed')"
            },
            "board_id": {
              "type": "string",
              "title": "Board Id",
              "description": "The id of board (e.g., '1000')"
            },
            "start_at": {
              "type": "integer",
              "title": "Start At",
              "default": 0,
              "minimum": 0,
              "description": "Starting index for pagination (0-based)"
            }
          },
          "required": [
            "board_id"
          ]
        }
      },
      {
        "name": "jira_get_sprint_issues",
        "description": "Get jira issues from sprint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of results (1-50)"
            },
            "fields": {
              "type": "string",
              "title": "Fields",
              "default": "*all",
              "description": "Comma-separated fields to return in the results. Use '*all' for all fields, or specify individual fields like 'summary,status,assignee,priority'"
            },
            "start_at": {
              "type": "integer",
              "title": "Start At",
              "default": 0,
              "minimum": 0,
              "description": "Starting index for pagination (0-based)"
            },
            "sprint_id": {
              "type": "string",
              "title": "Sprint Id",
              "description": "The id of sprint (e.g., '10001')"
            }
          },
          "required": [
            "sprint_id"
          ]
        }
      },
      {
        "name": "jira_update_sprint",
        "description": "Update jira sprint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "goal": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Goal",
              "default": null,
              "description": "Optional: New goal for the sprint"
            },
            "state": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "State",
              "default": null,
              "description": "Optional: New state for the sprint (future|active|closed)"
            },
            "end_date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "End Date",
              "default": null,
              "description": "Optional: New end date for the sprint"
            },
            "sprint_id": {
              "type": "string",
              "title": "Sprint Id",
              "description": "The id of sprint (e.g., '10001')"
            },
            "start_date": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Start Date",
              "default": null,
              "description": "Optional: New start date for the sprint"
            },
            "sprint_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Sprint Name",
              "default": null,
              "description": "Optional: New name for the sprint"
            }
          },
          "required": [
            "sprint_id"
          ]
        }
      },
      {
        "name": "jira_create_issue",
        "description": "Create a new Jira issue with optional Epic link or parent for subtasks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "summary": {
              "type": "string",
              "title": "Summary",
              "description": "Summary/title of the issue"
            },
            "assignee": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Assignee",
              "default": null,
              "description": "Assignee of the ticket (accountID, full name or e-mail)"
            },
            "components": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Components",
              "default": null,
              "description": "Comma-separated list of component names to assign (e.g., 'Frontend,API')"
            },
            "issue_type": {
              "type": "string",
              "title": "Issue Type",
              "description": "Issue type (e.g. 'Task', 'Bug', 'Story', 'Epic', 'Subtask'). The available types depend on your project configuration. For subtasks, use 'Subtask' (not 'Sub-task') and include parent in additional_fields."
            },
            "description": {
              "type": "string",
              "title": "Description",
              "default": "",
              "description": "Issue description"
            },
            "project_key": {
              "type": "string",
              "title": "Project Key",
              "description": "The JIRA project key (e.g. 'PROJ', 'DEV', 'SUPPORT'). This is the prefix of issue keys in your project. Never assume what it might be, always ask the user."
            },
            "additional_fields": {
              "type": "string",
              "title": "Additional Fields",
              "default": "{}",
              "description": "Optional JSON string of additional fields to set. Examples:\n- Set priority: {\"priority\": {\"name\": \"High\"}}\n- Add labels: {\"labels\": [\"frontend\", \"urgent\"]}\n- Link to parent (for any issue type): {\"parent\": \"PROJ-123\"}\n- Set Fix Version/s: {\"fixVersions\": [{\"id\": \"10020\"}]}\n- Custom fields: {\"customfield_10010\": \"value\"}"
            }
          },
          "required": [
            "project_key",
            "summary",
            "issue_type"
          ]
        }
      },
      {
        "name": "jira_batch_create_issues",
        "description": "Create multiple Jira issues in a batch",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issues": {
              "type": "string",
              "title": "Issues",
              "description": "JSON array of issue objects. Each object should contain:\n- project_key (required): The project key (e.g., 'PROJ')\n- summary (required): Issue summary/title\n- issue_type (required): Type of issue (e.g., 'Task', 'Bug')\n- description (optional): Issue description\n- assignee (optional): Assignee username or email\n- components (optional): Array of component names\nExample: [\n  {\"project_key\": \"PROJ\", \"summary\": \"Issue 1\", \"issue_type\": \"Task\"},\n  {\"project_key\": \"PROJ\", \"summary\": \"Issue 2\", \"issue_type\": \"Bug\", \"components\": [\"Frontend\"]}\n]"
            },
            "validate_only": {
              "type": "boolean",
              "title": "Validate Only",
              "default": false,
              "description": "If true, only validates the issues without creating them"
            }
          },
          "required": [
            "issues"
          ]
        }
      },
      {
        "name": "jira_update_issue",
        "description": "Update an existing Jira issue including changing status, adding Epic links, updating fields, etc.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fields": {
              "type": "string",
              "title": "Fields",
              "description": "A valid JSON object of fields to update as a string. Example: '{\"summary\": \"New title\", \"description\": \"Updated description\", \"priority\": {\"name\": \"High\"}, \"assignee\": {\"name\": \"john.doe\"}}'"
            },
            "issue_key": {
              "type": "string",
              "title": "Issue Key",
              "description": "Jira issue key (e.g., 'PROJ-123')"
            },
            "attachments": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Attachments",
              "default": null,
              "description": "Optional JSON string or comma-separated list of file paths to attach to the issue. Example: \"/path/to/file1.txt,/path/to/file2.txt\" or \"[\"/path/to/file1.txt\",\"/path/to/file2.txt\"]\""
            },
            "additional_fields": {
              "type": "string",
              "title": "Additional Fields",
              "default": "{}",
              "description": "Optional JSON string of additional fields to update. Use this for custom fields or more complex updates."
            }
          },
          "required": [
            "issue_key",
            "fields"
          ]
        }
      },
      {
        "name": "jira_delete_issue",
        "description": "Delete an existing Jira issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issue_key": {
              "type": "string",
              "title": "Issue Key",
              "description": "Jira issue key (e.g. PROJ-123)"
            }
          },
          "required": [
            "issue_key"
          ]
        }
      },
      {
        "name": "jira_add_comment",
        "description": "Add a comment to a Jira issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "comment": {
              "type": "string",
              "title": "Comment",
              "description": "Comment text in Markdown format"
            },
            "issue_key": {
              "type": "string",
              "title": "Issue Key",
              "description": "Jira issue key (e.g., 'PROJ-123')"
            }
          },
          "required": [
            "issue_key",
            "comment"
          ]
        }
      },
      {
        "name": "jira_add_worklog",
        "description": "Add a worklog entry to a Jira issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "comment": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Comment",
              "default": null,
              "description": "Optional comment for the worklog in Markdown format"
            },
            "started": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Started",
              "default": null,
              "description": "Optional start time in ISO format. If not provided, the current time will be used. Example: '2023-08-01T12:00:00.000+0000'"
            },
            "issue_key": {
              "type": "string",
              "title": "Issue Key",
              "description": "Jira issue key (e.g., 'PROJ-123')"
            },
            "time_spent": {
              "type": "string",
              "title": "Time Spent",
              "description": "Time spent in Jira format. Examples: '1h 30m' (1 hour and 30 minutes), '1d' (1 day), '30m' (30 minutes), '4h' (4 hours)"
            }
          },
          "required": [
            "issue_key",
            "time_spent"
          ]
        }
      },
      {
        "name": "jira_link_to_epic",
        "description": "Link an existing issue to an epic",
        "inputSchema": {
          "type": "object",
          "properties": {
            "epic_key": {
              "type": "string",
              "title": "Epic Key",
              "description": "The key of the epic to link to (e.g., 'PROJ-456')"
            },
            "issue_key": {
              "type": "string",
              "title": "Issue Key",
              "description": "The key of the issue to link (e.g., 'PROJ-123')"
            }
          },
          "required": [
            "issue_key",
            "epic_key"
          ]
        }
      },
      {
        "name": "jira_create_issue_link",
        "description": "Create a link between two Jira issues",
        "inputSchema": {
          "type": "object",
          "properties": {
            "comment": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Comment",
              "default": null,
              "description": "Optional comment to add to the link"
            },
            "link_type": {
              "type": "string",
              "title": "Link Type",
              "description": "The type of link to create (e.g., 'Duplicate', 'Blocks', 'Relates to')"
            },
            "inward_issue_key": {
              "type": "string",
              "title": "Inward Issue Key",
              "description": "The key of the inward issue (e.g., 'PROJ-123')"
            },
            "outward_issue_key": {
              "type": "string",
              "title": "Outward Issue Key",
              "description": "The key of the outward issue (e.g., 'PROJ-456')"
            },
            "comment_visibility": {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Comment Visibility",
              "default": null,
              "description": "Optional visibility settings for the comment"
            }
          },
          "required": [
            "link_type",
            "inward_issue_key",
            "outward_issue_key"
          ]
        }
      },
      {
        "name": "jira_remove_issue_link",
        "description": "Remove a link between two Jira issues",
        "inputSchema": {
          "type": "object",
          "properties": {
            "link_id": {
              "type": "string",
              "title": "Link Id",
              "description": "The ID of the link to remove"
            }
          },
          "required": [
            "link_id"
          ]
        }
      },
      {
        "name": "jira_transition_issue",
        "description": "Transition a Jira issue to a new status",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fields": {
              "type": "string",
              "title": "Fields",
              "default": "{}",
              "description": "JSON string of fields to update during the transition. Some transitions require specific fields to be set. Example: '{\"resolution\": {\"name\": \"Fixed\"}}'"
            },
            "comment": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Comment",
              "default": null,
              "description": "Comment to add during the transition (optional). This will be visible in the issue history."
            },
            "issue_key": {
              "type": "string",
              "title": "Issue Key",
              "description": "Jira issue key (e.g., 'PROJ-123')"
            },
            "transition_id": {
              "type": "string",
              "title": "Transition Id",
              "description": "ID of the transition to perform. Use the jira_get_transitions tool first to get the available transition IDs for the issue. Example values: '11', '21', '31'"
            }
          },
          "required": [
            "issue_key",
            "transition_id"
          ]
        }
      },
      {
        "name": "jira_search_fields",
        "description": "Search Jira fields by keyword with fuzzy match",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10,
              "minimum": 1,
              "description": "Maximum number of results"
            },
            "keyword": {
              "type": "string",
              "title": "Keyword",
              "default": "",
              "description": "Keyword for fuzzy search. If left empty, lists the first 'limit' available fields in their default order."
            },
            "refresh": {
              "type": "boolean",
              "title": "Refresh",
              "default": false,
              "description": "Whether to force refresh the field list"
            }
          }
        }
      },
      {
        "name": "confluence_search",
        "description": "Search Confluence content using simple terms or CQL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of results (1-50)"
            },
            "query": {
              "type": "string",
              "title": "Query",
              "description": "Search query - can be either a simple text (e.g. 'project documentation') or a CQL query string. Simple queries use 'siteSearch' by default, to mimic the WebUI search, with an automatic fallback to 'text' search if not supported. Examples of CQL:\n- Basic search: 'type=page AND space=DEV'\n- Personal space search: 'space=\"~username\"' (note: personal space keys starting with ~ must be quoted)\n- Search by title: 'title~\"Meeting Notes\"'\n- Use siteSearch: 'siteSearch ~ \"important concept\"'\n- Use text search: 'text ~ \"important concept\"'\n- Recent content: 'created >= \"2023-01-01\"'\n- Content with specific label: 'label=documentation'\n- Recently modified content: 'lastModified > startOfMonth(\"-1M\")'\n- Content modified this year: 'creator = currentUser() AND lastModified > startOfYear()'\n- Content you contributed to recently: 'contributor = currentUser() AND lastModified > startOfWeek()'\n- Content watched by user: 'watcher = \"user@domain.com\" AND type = page'\n- Exact phrase in content: 'text ~ \"\\\"Urgent Review Required\\\"\" AND label = \"pending-approval\"'\n- Title wildcards: 'title ~ \"Minutes*\" AND (space = \"HR\" OR space = \"Marketing\")'\nNote: Special identifiers need proper quoting in CQL: personal space keys (e.g., \"~username\"), reserved words, numeric IDs, and identifiers with special characters."
            },
            "spaces_filter": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Spaces Filter",
              "default": null,
              "description": "Comma-separated list of space keys to filter results by. Overrides the environment variable CONFLUENCE_SPACES_FILTER if provided."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "confluence_get_page",
        "description": "Get content of a specific Confluence page by ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string",
              "title": "Page Id",
              "description": "Confluence page ID (numeric ID, can be found in the page URL). For example, in the URL 'https://example.atlassian.net/wiki/spaces/TEAM/pages/123456789/Page+Title', the page ID is '123456789'"
            },
            "include_metadata": {
              "type": "boolean",
              "title": "Include Metadata",
              "default": true,
              "description": "Whether to include page metadata such as creation date, last update, version, and labels"
            },
            "convert_to_markdown": {
              "type": "boolean",
              "title": "Convert To Markdown",
              "default": true,
              "description": "Whether to convert page to markdown (true) or keep it in raw HTML format (false). Raw HTML can reveal macros (like dates) not visible in markdown, but CAUTION: using HTML significantly increases token usage in AI responses."
            }
          },
          "required": [
            "page_id"
          ]
        }
      },
      {
        "name": "confluence_get_page_children",
        "description": "Get child pages of a specific Confluence page.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 25,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of child pages to return (1-50)"
            },
            "expand": {
              "type": "string",
              "title": "Expand",
              "default": "version",
              "description": "Fields to expand in the response (e.g., 'version', 'body.storage')"
            },
            "parent_id": {
              "type": "string",
              "title": "Parent Id",
              "description": "The ID of the parent page whose children you want to retrieve"
            },
            "include_content": {
              "type": "boolean",
              "title": "Include Content",
              "default": false,
              "description": "Whether to include the page content in the response"
            }
          },
          "required": [
            "parent_id"
          ]
        }
      },
      {
        "name": "confluence_get_page_ancestors",
        "description": "Get ancestor (parent) pages of a specific Confluence page.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string",
              "title": "Page Id",
              "description": "The ID of the page whose ancestors you want to retrieve"
            }
          },
          "required": [
            "page_id"
          ]
        }
      },
      {
        "name": "confluence_get_comments",
        "description": "Get comments for a specific Confluence page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string",
              "title": "Page Id",
              "description": "Confluence page ID (numeric ID, can be parsed from URL, e.g. from 'https://example.atlassian.net/wiki/spaces/TEAM/pages/123456789/Page+Title' -> '123456789')"
            }
          },
          "required": [
            "page_id"
          ]
        }
      },
      {
        "name": "confluence_create_page",
        "description": "Create a new Confluence page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "title": "Title",
              "description": "The title of the page"
            },
            "content": {
              "type": "string",
              "title": "Content",
              "description": "The content of the page in Markdown format. Supports headings, lists, tables, code blocks, and other Markdown syntax"
            },
            "parent_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Parent Id",
              "default": null,
              "description": "Optional parent page ID. If provided, this page will be created as a child of the specified page"
            },
            "space_key": {
              "type": "string",
              "title": "Space Key",
              "description": "The key of the space to create the page in (usually a short uppercase code like 'DEV', 'TEAM', or 'DOC')"
            }
          },
          "required": [
            "space_key",
            "title",
            "content"
          ]
        }
      },
      {
        "name": "confluence_update_page",
        "description": "Update an existing Confluence page.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "title": "Title",
              "description": "The new title of the page"
            },
            "content": {
              "type": "string",
              "title": "Content",
              "description": "The new content of the page in Markdown format"
            },
            "page_id": {
              "type": "string",
              "title": "Page Id",
              "description": "The ID of the page to update"
            },
            "parent_id": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Parent Id",
              "default": null,
              "description": "Optional the new parent page ID"
            },
            "is_minor_edit": {
              "type": "boolean",
              "title": "Is Minor Edit",
              "default": false,
              "description": "Whether this is a minor edit"
            },
            "version_comment": {
              "type": "string",
              "title": "Version Comment",
              "default": "",
              "description": "Optional comment for this version"
            }
          },
          "required": [
            "page_id",
            "title",
            "content"
          ]
        }
      },
      {
        "name": "confluence_delete_page",
        "description": "Delete an existing Confluence page.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page_id": {
              "type": "string",
              "title": "Page Id",
              "description": "The ID of the page to delete"
            }
          },
          "required": [
            "page_id"
          ]
        }
      }
    ]
  },
  {
    "name": "spences10-mcp-memory-libsql",
    "title": "mcp-memory-libsql",
    "description": "A high-performance MCP server utilizing libSQL for persistent memory and vector search capabilities, enabling efficient entity management and semantic knowledge storage.",
    "icon": "https://avatars.githubusercontent.com/spences10",
    "isOfficial": false,
    "homepage": "https://github.com/spences10/mcp-memory-libsql",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-memory-libsql"
      ],
      "env": {
        "LIBSQL_URL": "<libsql-url>",
        "LIBSQL_AUTH_TOKEN": "<libsql-auth-token>"
      }
    },
    "parameters": [
      {
        "name": "LIBSQL_URL",
        "description": "URL for the libSQL database. For local SQLite databases use 'file:/path/to/database.db', for remote libSQL databases use 'libsql://your-database.turso.io'",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "LIBSQL_AUTH_TOKEN",
        "description": "Authentication token for remote libSQL databases (e.g., Turso)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "srmorete-adb-mcp",
    "title": "ADB MCP Server",
    "description": "A TypeScript-based bridge between AI models and Android device functionality, enabling interaction with Android devices through ADB commands for tasks like app installation, file transfer, UI analysis, and shell command execution.",
    "icon": "https://avatars.githubusercontent.com/srmorete",
    "isOfficial": false,
    "homepage": "https://github.com/srmorete/adb-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "adb-mcp"
      ],
      "env": {
        "ADB_PATH": "<adb-path>",
        "LOG_LEVEL": "<log-level>"
      }
    },
    "parameters": [
      {
        "name": "ADB_PATH",
        "description": "Custom path to ADB executable",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "LOG_LEVEL",
        "description": "Logging verbosity level (e.g. 3 for detailed logs)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "adb_devices",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "random_string": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "inspect_ui",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "device": {
              "type": "string",
              "description": "Specific device ID (optional)"
            },
            "asBase64": {
              "type": "boolean",
              "default": false,
              "description": "Return XML content as base64 (default: false)"
            },
            "outputPath": {
              "type": "string",
              "description": "Custom output path on device (default: /sdcard/window_dump.xml)"
            }
          }
        }
      },
      {
        "name": "adb_shell",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "device": {
              "type": "string",
              "description": "Specific device ID (optional)"
            },
            "command": {
              "type": "string",
              "description": "Shell command to execute on the device"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "adb_install",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "device": {
              "type": "string",
              "description": "Specific device ID (optional)"
            },
            "apkPath": {
              "type": "string",
              "description": "Local path to the APK file"
            }
          },
          "required": [
            "apkPath"
          ]
        }
      },
      {
        "name": "adb_logcat",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "lines": {
              "type": "number",
              "default": 50,
              "description": "Number of lines to return (default: 50)"
            },
            "device": {
              "type": "string",
              "description": "Specific device ID (optional)"
            },
            "filter": {
              "type": "string",
              "description": "Logcat filter expression (optional)"
            }
          }
        }
      },
      {
        "name": "adb_pull",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "device": {
              "type": "string",
              "description": "Specific device ID (optional)"
            },
            "asBase64": {
              "type": "boolean",
              "default": true,
              "description": "Return file content as base64 (default: true)"
            },
            "remotePath": {
              "type": "string",
              "description": "Remote file path on the device"
            }
          },
          "required": [
            "remotePath"
          ]
        }
      },
      {
        "name": "adb_push",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "device": {
              "type": "string",
              "description": "Specific device ID (optional)"
            },
            "fileBase64": {
              "type": "string",
              "description": "Base64 encoded file content to push"
            },
            "remotePath": {
              "type": "string",
              "description": "Remote file path on the device"
            }
          },
          "required": [
            "fileBase64",
            "remotePath"
          ]
        }
      },
      {
        "name": "dump_image",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "device": {
              "type": "string",
              "description": "Specific device ID (optional)"
            },
            "asBase64": {
              "type": "boolean",
              "default": false,
              "description": "Return image as base64 (default: false)"
            }
          }
        }
      }
    ]
  },
  {
    "name": "stabgan-openrouter-mcp-multimodal",
    "title": "OpenRouter MCP Multimodal Server",
    "description": "Provides chat and image analysis capabilities through OpenRouter.ai's diverse model ecosystem, enabling both text conversations and powerful multimodal image processing with various AI models.",
    "icon": "https://avatars.githubusercontent.com/stabgan",
    "isOfficial": false,
    "homepage": "https://github.com/stabgan/openrouter-mcp-multimodal",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@stabgan/openrouter-mcp-multimodal"
      ],
      "env": {
        "PATH": "<path>",
        "OPENROUTER_API_KEY": "<openrouter-api-key>",
        "OPENROUTER_DEFAULT_MODEL": "<openrouter-default-model>"
      }
    },
    "parameters": [
      {
        "name": "PATH",
        "description": "System PATH environment variable (to resolve 'fetch is not defined' errors)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "OPENROUTER_API_KEY",
        "description": "Your OpenRouter API key from openrouter.ai/keys",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "OPENROUTER_DEFAULT_MODEL",
        "description": "Default model to use (e.g., anthropic/claude-3.5-sonnet)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "steipete-claude-code-mcp",
    "title": "Claude Code MCP Server",
    "description": "A server that allows LLMs to run Claude Code with all permissions bypassed automatically, enabling code execution and file editing without permission interruptions.",
    "icon": "https://avatars.githubusercontent.com/steipete",
    "isOfficial": false,
    "homepage": "https://github.com/steipete/claude-code-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@steipete/claude-code-mcp"
      ],
      "env": {
        "CLAUDE_CLI_PATH": "<claude-cli-path>"
      }
    },
    "parameters": [
      {
        "name": "CLAUDE_CLI_PATH",
        "description": "Set a custom path to the Claude CLI executable",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "claude_code",
        "description": "Claude Code Agent: Your versatile multi-modal assistant for code, file, Git, and terminal operations via Claude CLI. Use `workFolder` for contextual execution.\n\n• File ops: Create, read, (fuzzy) edit, move, copy, delete, list files, analyze/ocr images, file content analysis\n    └─ e.g., \"Create /tmp/log.txt with 'system boot'\", \"Edit main.py to replace 'debug_mode = True' with 'debug_mode = False'\", \"List files in /src\", \"Move a specific section somewhere else\"\n\n• Code: Generate / analyse / refactor / fix\n    └─ e.g. \"Generate Python to parse CSV→JSON\", \"Find bugs in my_script.py\"\n\n• Git: Stage ▸ commit ▸ push ▸ tag (any workflow)\n    └─ \"Commit '/workspace/src/main.java' with 'feat: user auth' to develop.\"\n\n• Terminal: Run any CLI cmd or open URLs\n    └─ \"npm run build\", \"Open https://developer.mozilla.org\"\n\n• Web search + summarise content on-the-fly\n\n• Multi-step workflows  (Version bumps, changelog updates, release tagging, etc.)\n\n• GitHub integration  Create PRs, check CI status\n\n• Confused or stuck on an issue? Ask Claude Code for a second opinion, it might surprise you!\n\n**Prompt tips**\n\n1. Be concise, explicit & step-by-step for complex tasks. No need for niceties, this is a tool to get things done.\n2. For multi-line text, write it to a temporary file in the project root, use that file, then delete it.\n3. If you get a timeout, split the task into smaller steps.\n4. **Seeking a second opinion/analysis**: If you're stuck or want advice, you can ask `claude_code` to analyze a problem and suggest solutions. Clearly state in your prompt that you are looking for analysis only and no actual file modifications should be made.\n5. If workFolder is set to the project path, there is no need to repeat that path in the prompt and you can use relative paths for files.\n6. Claude Code is really good at complex multi-step file operations and refactorings and faster than your native edit features.\n7. Combine file operations, README updates, and Git commands in a sequence.\n8. Claude can do much more, just ask it!\n\n        ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "prompt": {
              "type": "string",
              "description": "The detailed natural language prompt for Claude to execute."
            },
            "workFolder": {
              "type": "string",
              "description": "Mandatory when using file operations or referencing any file. The working directory for the Claude CLI execution. Must be an absolute path."
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  {
    "name": "stevengonsalvez-todoist-mcp",
    "title": "Todoist MCP Server",
    "description": "A Model Context Protocol server that enables advanced task and project management in Todoist via Claude Desktop and other MCP-compatible clients.",
    "icon": "https://avatars.githubusercontent.com/stevengonsalvez",
    "isOfficial": false,
    "homepage": "https://github.com/stevengonsalvez/todoist-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "todoist-mcp-server"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "listTasks",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "label": {
              "type": "string"
            },
            "filter": {
              "type": "string"
            },
            "projectId": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "getTask",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "createTask",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "order": {
              "type": "number"
            },
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "content": {
              "type": "string"
            },
            "dueDate": {
              "type": "string"
            },
            "dueLang": {
              "type": "string"
            },
            "parentId": {
              "type": "string"
            },
            "priority": {
              "type": "number"
            },
            "dueString": {
              "type": "string"
            },
            "projectId": {
              "type": "string"
            },
            "sectionId": {
              "type": "string"
            },
            "assigneeId": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "dueDatetime": {
              "type": "string"
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "updateTask",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labels": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "taskId": {
              "type": "string"
            },
            "content": {
              "type": "string"
            },
            "dueDate": {
              "type": "string"
            },
            "dueLang": {
              "type": "string"
            },
            "priority": {
              "type": "number"
            },
            "dueString": {
              "type": "string"
            },
            "assigneeId": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "dueDatetime": {
              "type": "string"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "completeTask",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "reopenTask",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "deleteTask",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            }
          },
          "required": [
            "taskId"
          ]
        }
      },
      {
        "name": "listProjects",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getProject",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "createProject",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "color": {
              "type": "string"
            },
            "parentId": {
              "type": "string"
            },
            "viewStyle": {
              "enum": [
                "list",
                "board"
              ],
              "type": "string"
            },
            "isFavorite": {
              "type": "boolean"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "updateProject",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "color": {
              "type": "string"
            },
            "projectId": {
              "type": "string"
            },
            "viewStyle": {
              "enum": [
                "list",
                "board"
              ],
              "type": "string"
            },
            "isFavorite": {
              "type": "boolean"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "archiveProject",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "unarchiveProject",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "deleteProject",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "getProjectCollaborators",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "listSections",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectId": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "getSection",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sectionId": {
              "type": "string"
            }
          },
          "required": [
            "sectionId"
          ]
        }
      },
      {
        "name": "createSection",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "order": {
              "type": "number"
            },
            "projectId": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "projectId"
          ]
        }
      },
      {
        "name": "updateSection",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "sectionId": {
              "type": "string"
            }
          },
          "required": [
            "sectionId",
            "name"
          ]
        }
      },
      {
        "name": "deleteSection",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sectionId": {
              "type": "string"
            }
          },
          "required": [
            "sectionId"
          ]
        }
      },
      {
        "name": "listComments",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            },
            "projectId": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "getComment",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "commentId": {
              "type": "string"
            }
          },
          "required": [
            "commentId"
          ]
        }
      },
      {
        "name": "createComment",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "taskId": {
              "type": "string"
            },
            "content": {
              "type": "string"
            },
            "projectId": {
              "type": "string"
            },
            "attachment": {
              "type": "object",
              "required": [
                "fileUrl"
              ],
              "properties": {
                "fileUrl": {
                  "type": "string"
                },
                "fileName": {
                  "type": "string"
                },
                "fileType": {
                  "type": "string"
                },
                "resourceType": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "content"
          ]
        }
      },
      {
        "name": "updateComment",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "content": {
              "type": "string"
            },
            "commentId": {
              "type": "string"
            }
          },
          "required": [
            "commentId",
            "content"
          ]
        }
      },
      {
        "name": "deleteComment",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "commentId": {
              "type": "string"
            }
          },
          "required": [
            "commentId"
          ]
        }
      },
      {
        "name": "listLabels",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "getLabel",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labelId": {
              "type": "string"
            }
          },
          "required": [
            "labelId"
          ]
        }
      },
      {
        "name": "createLabel",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "color": {
              "type": "string"
            },
            "order": {
              "type": "number"
            },
            "isFavorite": {
              "type": "boolean"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "updateLabel",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "color": {
              "type": "string"
            },
            "order": {
              "type": "number"
            },
            "labelId": {
              "type": "string"
            },
            "isFavorite": {
              "type": "boolean"
            }
          },
          "required": [
            "labelId"
          ]
        }
      },
      {
        "name": "deleteLabel",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "labelId": {
              "type": "string"
            }
          },
          "required": [
            "labelId"
          ]
        }
      },
      {
        "name": "getSharedLabels",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "omitPersonal": {
              "type": "boolean"
            }
          }
        }
      },
      {
        "name": "renameSharedLabel",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "newName": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "newName"
          ]
        }
      },
      {
        "name": "removeSharedLabel",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name"
          ]
        }
      }
    ]
  },
  {
    "name": "cfdude-super-shell-mcp",
    "title": "Super Shell MCP Server",
    "description": "An MCP server that enables secure execution of shell commands across Windows, macOS, and Linux with built-in whitelisting and approval mechanisms for enhanced security.",
    "icon": "https://avatars.githubusercontent.com/cfdude",
    "isOfficial": false,
    "homepage": "https://github.com/cfdude/super-shell-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "super-shell-mcp"
      ],
      "env": {
        "shell": "<shell>"
      }
    },
    "parameters": [
      {
        "name": "shell",
        "description": "Path to the shell executable to use (e.g. /bin/bash, C:\\Windows\\System32\\cmd.exe)",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get_platform_info",
        "description": "Get information about the current platform and shell",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "execute_command",
        "description": "Execute a shell command on the current platform",
        "inputSchema": {
          "type": "object",
          "properties": {
            "args": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Command arguments"
            },
            "command": {
              "type": "string",
              "description": "The command to execute"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "get_whitelist",
        "description": "Get the list of whitelisted commands",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "add_to_whitelist",
        "description": "Add a command to the whitelist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "The command to whitelist"
            },
            "description": {
              "type": "string",
              "description": "Description of the command"
            },
            "securityLevel": {
              "enum": [
                "safe",
                "requires_approval",
                "forbidden"
              ],
              "type": "string",
              "description": "Security level for the command"
            }
          },
          "required": [
            "command",
            "securityLevel"
          ]
        }
      },
      {
        "name": "update_security_level",
        "description": "Update the security level of a whitelisted command",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "The command to update"
            },
            "securityLevel": {
              "enum": [
                "safe",
                "requires_approval",
                "forbidden"
              ],
              "type": "string",
              "description": "New security level for the command"
            }
          },
          "required": [
            "command",
            "securityLevel"
          ]
        }
      },
      {
        "name": "remove_from_whitelist",
        "description": "Remove a command from the whitelist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "The command to remove from whitelist"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      {
        "name": "get_pending_commands",
        "description": "Get the list of commands pending approval",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "approve_command",
        "description": "Approve a pending command",
        "inputSchema": {
          "type": "object",
          "properties": {
            "commandId": {
              "type": "string",
              "description": "ID of the command to approve"
            }
          },
          "required": [
            "commandId"
          ]
        }
      },
      {
        "name": "deny_command",
        "description": "Deny a pending command",
        "inputSchema": {
          "type": "object",
          "properties": {
            "reason": {
              "type": "string",
              "description": "Reason for denial"
            },
            "commandId": {
              "type": "string",
              "description": "ID of the command to deny"
            }
          },
          "required": [
            "commandId"
          ]
        }
      }
    ]
  },
  {
    "name": "maverickg59-sushimcp",
    "title": "SushiMCP",
    "description": "sushimcp",
    "icon": "https://avatars.githubusercontent.com/maverickg59",
    "isOfficial": false,
    "homepage": "https://github.com/maverickg59/sushimcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@chriswhiterocks/sushimcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "list_llms_txt_sources",
        "description": "This tool lists all available source urls where an llms.txt can be fetched. After reading the listed sources, use fetch_llms_txt to fetch any source that matches a technology in the instructions you received. Prefer llms.txt, but if llms.txt proves inadequate, check to see if other llms-full.txt or llms-mini.txt exist. When done, ask the user if they want to use non-MCP tools to search for documentation on any sources this tool could not find.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_api_spec_sources",
        "description": "This tool lists all available source urls where an OpenAPI spec can be fetched.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "fetch_llms_txt",
        "description": "Fetches the content of one or more llms.txt urls. Some llms.txt files compile a list of urls to other llms.txt file locations because listing their full documentation would bloat context. If the documentation you're looking for does not exist in the llms.txt, look for reference links to other llms.txt files and follow those.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "input": {
              "anyOf": [
                {
                  "type": "object",
                  "required": [
                    "url"
                  ],
                  "properties": {
                    "url": {
                      "type": "string",
                      "format": "uri"
                    }
                  },
                  "additionalProperties": false
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uri"
                  }
                }
              ]
            }
          },
          "required": [
            "input"
          ]
        }
      },
      {
        "name": "fetch_openapi_spec",
        "description": "Fetches the content of one or more OpenAPI spec urls.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "input": {
              "anyOf": [
                {
                  "type": "object",
                  "required": [
                    "url"
                  ],
                  "properties": {
                    "url": {
                      "type": "string",
                      "format": "uri"
                    }
                  },
                  "additionalProperties": false
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uri"
                  }
                }
              ]
            }
          },
          "required": [
            "input"
          ]
        }
      }
    ]
  },
  {
    "name": "tacticlaunch-mcp-linear",
    "title": "Linear",
    "description": "A Model Context Protocol server that enables AI assistants to interact with Linear project management systems, allowing users to retrieve, create, and update issues, projects, and teams through natural language.",
    "icon": "https://avatars.githubusercontent.com/tacticlaunch",
    "isOfficial": false,
    "homepage": "https://github.com/tacticlaunch/mcp-linear",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@tacticlaunch/mcp-linear"
      ],
      "env": {
        "LINEAR_API_TOKEN": "<linear-api-token>"
      }
    },
    "parameters": [
      {
        "name": "LINEAR_API_TOKEN",
        "description": "Your Linear API token",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "linear_getViewer",
        "description": "Get information about the currently authenticated user",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "linear_getOrganization",
        "description": "Get information about the current Linear organization",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "linear_getUsers",
        "description": "Get a list of users in the Linear organization",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "linear_getLabels",
        "description": "Get a list of issue labels from Linear",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "linear_getTeams",
        "description": "Get a list of teams from Linear",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "linear_getWorkflowStates",
        "description": "Get workflow states for a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "teamId": {
              "type": "string",
              "description": "ID of the team to get workflow states for"
            },
            "includeArchived": {
              "type": "boolean",
              "description": "Whether to include archived states (default: false)"
            }
          },
          "required": [
            "teamId"
          ]
        }
      },
      {
        "name": "linear_getProjects",
        "description": "Get a list of projects from Linear",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "linear_createProject",
        "description": "Create a new project in Linear",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Name of the project"
            },
            "state": {
              "type": "string",
              "description": "Initial state of the project (e.g., 'planned', 'started', 'paused', 'completed', 'canceled')"
            },
            "content": {
              "type": "string",
              "description": "Content of the project (Markdown supported)"
            },
            "teamIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "IDs of the teams this project belongs to"
            },
            "description": {
              "type": "string",
              "description": "Short summary of the project"
            }
          },
          "required": [
            "name",
            "teamIds"
          ]
        }
      },
      {
        "name": "linear_updateProject",
        "description": "Update an existing project in Linear",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID of the project to update"
            },
            "name": {
              "type": "string",
              "description": "New name of the project"
            },
            "state": {
              "type": "string",
              "description": "New state of the project (e.g., 'planned', 'started', 'paused', 'completed', 'canceled')"
            },
            "content": {
              "type": "string",
              "description": "New content of the project (Markdown supported)"
            },
            "description": {
              "type": "string",
              "description": "New short summary of the project"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "linear_addIssueToProject",
        "description": "Add an existing issue to a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to add to the project"
            },
            "projectId": {
              "type": "string",
              "description": "ID of the project to add the issue to"
            }
          },
          "required": [
            "issueId",
            "projectId"
          ]
        }
      },
      {
        "name": "linear_getProjectIssues",
        "description": "Get all issues associated with a project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of issues to return (default: 25)"
            },
            "projectId": {
              "type": "string",
              "description": "ID of the project to get issues for"
            }
          },
          "required": [
            "projectId"
          ]
        }
      },
      {
        "name": "linear_getCycles",
        "description": "Get a list of all cycles",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of cycles to return (default: 25)"
            },
            "teamId": {
              "type": "string",
              "description": "ID of the team to get cycles for (optional)"
            }
          }
        }
      },
      {
        "name": "linear_getActiveCycle",
        "description": "Get the currently active cycle for a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "teamId": {
              "type": "string",
              "description": "ID of the team to get the active cycle for"
            }
          },
          "required": [
            "teamId"
          ]
        }
      },
      {
        "name": "linear_addIssueToCycle",
        "description": "Add an issue to a cycle",
        "inputSchema": {
          "type": "object",
          "properties": {
            "cycleId": {
              "type": "string",
              "description": "ID of the cycle to add the issue to"
            },
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to add to the cycle"
            }
          },
          "required": [
            "issueId",
            "cycleId"
          ]
        }
      },
      {
        "name": "linear_getIssues",
        "description": "Get a list of recent issues from Linear",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of issues to return (default: 10)"
            }
          }
        }
      },
      {
        "name": "linear_getIssueById",
        "description": "Get a specific issue by ID or identifier (e.g., ABC-123)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The ID or identifier of the issue (e.g., ABC-123)"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "linear_searchIssues",
        "description": "Search for issues with various filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of issues to return (default: 10)"
            },
            "query": {
              "type": "string",
              "description": "Text to search for in issue title or description"
            },
            "states": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter issues by state name (e.g., 'Todo', 'In Progress', 'Done')"
            },
            "teamId": {
              "type": "string",
              "description": "Filter issues by team ID"
            },
            "projectId": {
              "type": "string",
              "description": "Filter issues by project ID"
            },
            "assigneeId": {
              "type": "string",
              "description": "Filter issues by assignee ID"
            }
          },
          "required": []
        }
      },
      {
        "name": "linear_createIssue",
        "description": "Create a new issue in Linear",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "description": "Title of the issue"
            },
            "teamId": {
              "type": "string",
              "description": "ID of the team the issue belongs to"
            },
            "cycleId": {
              "type": "string",
              "description": "ID of the cycle to add the issue to"
            },
            "dueDate": {
              "type": "string",
              "description": "The date at which the issue is due (YYYY-MM-DD format)"
            },
            "stateId": {
              "type": "string",
              "description": "ID of the workflow state for the issue"
            },
            "estimate": {
              "type": "number",
              "description": "The estimated complexity/points for the issue"
            },
            "labelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "IDs of the labels to attach to the issue"
            },
            "parentId": {
              "type": "string",
              "description": "ID of the parent issue (to create as a sub-task)"
            },
            "priority": {
              "type": "number",
              "description": "Priority of the issue (0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low)"
            },
            "projectId": {
              "type": "string",
              "description": "ID of the project the issue belongs to"
            },
            "sortOrder": {
              "type": "number",
              "description": "The position of the issue in relation to other issues"
            },
            "assigneeId": {
              "type": "string",
              "description": "ID of the user to assign the issue to"
            },
            "templateId": {
              "type": "string",
              "description": "ID of a template to use for creating the issue"
            },
            "description": {
              "type": "string",
              "description": "Description of the issue (Markdown supported)"
            },
            "subscriberIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "IDs of the users to subscribe to the issue"
            }
          },
          "required": [
            "title",
            "teamId"
          ]
        }
      },
      {
        "name": "linear_updateIssue",
        "description": "Update an existing issue in Linear",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "ID or identifier of the issue to update (e.g., ABC-123)"
            },
            "title": {
              "type": "string",
              "description": "New title for the issue"
            },
            "teamId": {
              "type": "string",
              "description": "ID of the team to move the issue to"
            },
            "cycleId": {
              "type": "string",
              "description": "ID of the cycle to move the issue to, or null to remove from current cycle"
            },
            "dueDate": {
              "type": "string",
              "description": "The new due date for the issue (YYYY-MM-DD format), or null to remove"
            },
            "stateId": {
              "type": "string",
              "description": "ID of the new state for the issue"
            },
            "estimate": {
              "type": "number",
              "description": "The estimated complexity/points for the issue"
            },
            "labelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "IDs of the labels to set on the issue (replacing existing labels)"
            },
            "parentId": {
              "type": "string",
              "description": "ID of the parent issue, or null to convert to a regular issue"
            },
            "priority": {
              "type": "number",
              "description": "New priority for the issue (0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low)"
            },
            "projectId": {
              "type": "string",
              "description": "ID of the project to move the issue to"
            },
            "sortOrder": {
              "type": "number",
              "description": "The position of the issue in relation to other issues"
            },
            "assigneeId": {
              "type": "string",
              "description": "ID of the user to assign the issue to, or null to unassign"
            },
            "description": {
              "type": "string",
              "description": "New description for the issue (Markdown supported)"
            },
            "addedLabelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "IDs of labels to add to the issue (without removing existing ones)"
            },
            "subscriberIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "IDs of the users to subscribe to the issue (replacing existing subscribers)"
            },
            "removedLabelIds": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "IDs of labels to remove from the issue"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "linear_createComment",
        "description": "Add a comment to an issue in Linear",
        "inputSchema": {
          "type": "object",
          "properties": {
            "body": {
              "type": "string",
              "description": "Text of the comment (Markdown supported)"
            },
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to comment on (e.g., ABC-123)"
            }
          },
          "required": [
            "issueId",
            "body"
          ]
        }
      },
      {
        "name": "linear_addIssueLabel",
        "description": "Add a label to an issue in Linear",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to add the label to (e.g., ABC-123)"
            },
            "labelId": {
              "type": "string",
              "description": "ID of the label to add to the issue"
            }
          },
          "required": [
            "issueId",
            "labelId"
          ]
        }
      },
      {
        "name": "linear_removeIssueLabel",
        "description": "Remove a label from an issue in Linear",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to remove the label from (e.g., ABC-123)"
            },
            "labelId": {
              "type": "string",
              "description": "ID of the label to remove from the issue"
            }
          },
          "required": [
            "issueId",
            "labelId"
          ]
        }
      },
      {
        "name": "linear_assignIssue",
        "description": "Assign an issue to a user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to assign (e.g., ABC-123)"
            },
            "assigneeId": {
              "type": "string",
              "description": "ID of the user to assign the issue to, or null to unassign"
            }
          },
          "required": [
            "issueId",
            "assigneeId"
          ]
        }
      },
      {
        "name": "linear_subscribeToIssue",
        "description": "Subscribe to issue updates",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to subscribe to (e.g., ABC-123)"
            }
          },
          "required": [
            "issueId"
          ]
        }
      },
      {
        "name": "linear_convertIssueToSubtask",
        "description": "Convert an issue to a subtask",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to convert (e.g., ABC-123)"
            },
            "parentIssueId": {
              "type": "string",
              "description": "ID or identifier of the parent issue (e.g., ABC-456)"
            }
          },
          "required": [
            "issueId",
            "parentIssueId"
          ]
        }
      },
      {
        "name": "linear_createIssueRelation",
        "description": "Create relations between issues (blocks, is blocked by, etc.)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "blocks",
                "blocked_by",
                "related",
                "duplicate",
                "duplicate_of"
              ],
              "type": "string",
              "description": "Type of relation: 'blocks', 'blocked_by', 'related', 'duplicate', 'duplicate_of'"
            },
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the first issue (e.g., ABC-123)"
            },
            "relatedIssueId": {
              "type": "string",
              "description": "ID or identifier of the second issue (e.g., ABC-456)"
            }
          },
          "required": [
            "issueId",
            "relatedIssueId",
            "type"
          ]
        }
      },
      {
        "name": "linear_archiveIssue",
        "description": "Archive an issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to archive (e.g., ABC-123)"
            }
          },
          "required": [
            "issueId"
          ]
        }
      },
      {
        "name": "linear_setIssuePriority",
        "description": "Set the priority of an issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue (e.g., ABC-123)"
            },
            "priority": {
              "enum": [
                0,
                1,
                2,
                3,
                4
              ],
              "type": "number",
              "description": "Priority level (0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low)"
            }
          },
          "required": [
            "issueId",
            "priority"
          ]
        }
      },
      {
        "name": "linear_transferIssue",
        "description": "Transfer an issue to another team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "teamId": {
              "type": "string",
              "description": "ID of the team to transfer the issue to"
            },
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to transfer (e.g., ABC-123)"
            }
          },
          "required": [
            "issueId",
            "teamId"
          ]
        }
      },
      {
        "name": "linear_duplicateIssue",
        "description": "Duplicate an issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to duplicate (e.g., ABC-123)"
            }
          },
          "required": [
            "issueId"
          ]
        }
      },
      {
        "name": "linear_getIssueHistory",
        "description": "Get the history of changes made to an issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of history events to return (default: 10)"
            },
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue (e.g., ABC-123)"
            }
          },
          "required": [
            "issueId"
          ]
        }
      },
      {
        "name": "linear_getComments",
        "description": "Get all comments for an issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "description": "Maximum number of comments to return (default: 25)"
            },
            "issueId": {
              "type": "string",
              "description": "ID or identifier of the issue to get comments from (e.g., ABC-123)"
            }
          },
          "required": [
            "issueId"
          ]
        }
      }
    ]
  },
  {
    "name": "tadasant-mcp-server-stability-ai",
    "title": "Stability AI MCP Server",
    "description": "An MCP Server that integrates with Stability AI's API to provide high-quality image generation, editing, and manipulation capabilities including background removal, outpainting, search-and-replace, and upscaling.",
    "icon": "https://avatars.githubusercontent.com/tadasant",
    "isOfficial": false,
    "homepage": "https://github.com/tadasant/mcp-server-stability-ai",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-server-stability-ai"
      ],
      "env": {
        "GCS_PROJECT_ID": "<gcs-project-id>",
        "GCS_BUCKET_NAME": "<gcs-bucket-name>",
        "GCS_PRIVATE_KEY": "<gcs-private-key>",
        "GCS_CLIENT_EMAIL": "<gcs-client-email>",
        "STABILITY_AI_API_KEY": "<stability-ai-api-key>",
        "IMAGE_STORAGE_DIRECTORY": "<image-storage-directory>"
      }
    },
    "parameters": [
      {
        "name": "GCS_PROJECT_ID",
        "description": "Google Cloud Project ID for storing images (when using SSE mode)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GCS_BUCKET_NAME",
        "description": "Google Cloud Storage bucket name for storing images (when using SSE mode)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GCS_PRIVATE_KEY",
        "description": "Google Cloud Service Account private key for storing images (when using SSE mode)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "GCS_CLIENT_EMAIL",
        "description": "Google Cloud Service Account client email for storing images (when using SSE mode)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "STABILITY_AI_API_KEY",
        "description": "Your Stability AI API key. Get one at platform.stability.ai",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "IMAGE_STORAGE_DIRECTORY",
        "description": "Directory where generated images will be saved",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "tanigami-mcp-server-perplexity",
    "title": "Perplexity MCP Server",
    "description": "Interacting with Perplexity API.",
    "icon": "https://avatars.githubusercontent.com/tanigami",
    "isOfficial": false,
    "homepage": "https://github.com/tanigami/mcp-server-perplexity",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-server-perplexity"
      ],
      "env": {
        "PERPLEXITY_API_KEY": "<perplexity-api-key>"
      }
    },
    "parameters": [
      {
        "name": "PERPLEXITY_API_KEY",
        "description": "Your Perplexity API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "ask_perplexity",
        "description": "\nPerplexity equips agents with a specialized tool for efficiently\ngathering source-backed information from the internet, ideal for\nscenarios requiring research, fact-checking, or contextual data to\ninform decisions and responses.\nEach response includes citations, which provide transparent references\nto the sources used for the generated answer, and choices, which\ncontain the model's suggested responses, enabling users to access\nreliable information and diverse perspectives.\nThis function may encounter timeout errors due to long processing times,\nbut retrying the operation can lead to successful completion.\n[Response structure]\n- id: An ID generated uniquely for each response.\n- model: The model used to generate the response.\n- object: The object type, which always equals `chat.completion`.\n- created: The Unix timestamp (in seconds) of when the completion was\n  created.\n- citations[]: Citations for the generated answer.\n- choices[]: The list of completion choices the model generated for the\n  input prompt.\n- usage: Usage statistics for the completion request.\n",
        "inputSchema": {
          "type": "object",
          "properties": {
            "model": {
              "enum": [
                "llama-3.1-sonar-small-128k-online"
              ],
              "type": "string",
              "description": "The name of the model that will complete your prompt."
            },
            "messages": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "content",
                  "role"
                ],
                "properties": {
                  "role": {
                    "enum": [
                      "system",
                      "user",
                      "assistant"
                    ],
                    "type": "string",
                    "description": "The role of the speaker in this turn of conversation. After the (optional) system message, user and assistant roles should alternate with user then assistant, ending in user."
                  },
                  "content": {
                    "type": "string",
                    "description": "The contents of the message in this turn of conversation."
                  }
                }
              },
              "description": "A list of messages comprising the conversation so far."
            }
          },
          "required": [
            "model",
            "messages"
          ]
        }
      }
    ]
  },
  {
    "name": "tavily-ai-tavily-mcp",
    "title": "Tavily MCP Server",
    "description": "This server enables AI systems to integrate with Tavily's search and data extraction tools, providing real-time web information access and domain-specific searches.",
    "icon": "https://avatars.githubusercontent.com/tavily-ai",
    "isOfficial": true,
    "homepage": "https://github.com/tavily-ai/tavily-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "tavily-mcp"
      ],
      "env": {
        "TAVILY_API_KEY": "<tavily-api-key>"
      }
    },
    "parameters": [
      {
        "name": "TAVILY_API_KEY",
        "description": "Your Tavily API key obtained from app.tavily.com/home",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "tavily-search",
        "description": "A powerful web search tool that provides comprehensive, real-time results using Tavily's AI search engine. Returns relevant web content with customizable parameters for result count, content type, and domain filtering. Ideal for gathering current information, news, and detailed web content analysis.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "days": {
              "type": "number",
              "default": 3,
              "description": "The number of days back from the current date to include in the search results. This specifies the time frame of data to be retrieved. Please note that this feature is only available when using the 'news' search topic"
            },
            "query": {
              "type": "string",
              "description": "Search query"
            },
            "topic": {
              "enum": [
                "general",
                "news"
              ],
              "type": "string",
              "default": "general",
              "description": "The category of the search. This will determine which of our agents will be used for the search"
            },
            "time_range": {
              "enum": [
                "day",
                "week",
                "month",
                "year",
                "d",
                "w",
                "m",
                "y"
              ],
              "type": "string",
              "description": "The time range back from the current date to include in the search results. This feature is available for both 'general' and 'news' search topics"
            },
            "max_results": {
              "type": "number",
              "default": 10,
              "maximum": 20,
              "minimum": 5,
              "description": "The maximum number of search results to return"
            },
            "search_depth": {
              "enum": [
                "basic",
                "advanced"
              ],
              "type": "string",
              "default": "basic",
              "description": "The depth of the search. It can be 'basic' or 'advanced'"
            },
            "include_images": {
              "type": "boolean",
              "default": false,
              "description": "Include a list of query-related images in the response"
            },
            "exclude_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "List of domains to specifically exclude, if the user asks to exclude a domain set this to the domain of the site"
            },
            "include_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "A list of domains to specifically include in the search results, if the user asks to search on specific sites set this to the domain of the site"
            },
            "include_raw_content": {
              "type": "boolean",
              "default": false,
              "description": "Include the cleaned and parsed HTML content of each search result"
            },
            "include_image_descriptions": {
              "type": "boolean",
              "default": false,
              "description": "Include a list of query-related images and their descriptions in the response"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "tavily-extract",
        "description": "A powerful web content extraction tool that retrieves and processes raw content from specified URLs, ideal for data collection, content analysis, and research tasks.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of URLs to extract content from"
            },
            "extract_depth": {
              "enum": [
                "basic",
                "advanced"
              ],
              "type": "string",
              "default": "basic",
              "description": "Depth of extraction - 'basic' or 'advanced', if usrls are linkedin use 'advanced' or if explicitly told to use advanced"
            },
            "include_images": {
              "type": "boolean",
              "default": false,
              "description": "Include a list of images extracted from the urls in the response"
            }
          },
          "required": [
            "urls"
          ]
        }
      },
      {
        "name": "tavily-crawl",
        "description": "A powerful web crawler that initiates a structured web crawl starting from a specified base URL. The crawler expands from that point like a tree, following internal links across pages. You can control how deep and wide it goes, and guide it to focus on specific sections of the site.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The root URL to begin the crawl"
            },
            "limit": {
              "type": "integer",
              "default": 50,
              "minimum": 1,
              "description": "Total number of links the crawler will process before stopping"
            },
            "query": {
              "type": "string",
              "description": "Natural language instructions for the crawler"
            },
            "max_depth": {
              "type": "integer",
              "default": 1,
              "minimum": 1,
              "description": "Max depth of the crawl. Defines how far from the base URL the crawler can explore."
            },
            "categories": {
              "type": "array",
              "items": {
                "enum": [
                  "Careers",
                  "Blog",
                  "Documentation",
                  "About",
                  "Pricing",
                  "Community",
                  "Developers",
                  "Contact",
                  "Media"
                ],
                "type": "string"
              },
              "default": [],
              "description": "Filter URLs using predefined categories like documentation, blog, api, etc"
            },
            "max_breadth": {
              "type": "integer",
              "default": 20,
              "minimum": 1,
              "description": "Max number of links to follow per level of the tree (i.e., per page)"
            },
            "select_paths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Regex patterns to select only URLs with specific path patterns (e.g., /docs/.*, /api/v1.*)"
            },
            "extract_depth": {
              "enum": [
                "basic",
                "advanced"
              ],
              "type": "string",
              "default": "basic",
              "description": "Advanced extraction retrieves more data, including tables and embedded content, with higher success but may increase latency"
            },
            "allow_external": {
              "type": "boolean",
              "default": false,
              "description": "Whether to allow following links that go to external domains"
            },
            "select_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Regex patterns to select crawling to specific domains or subdomains (e.g., ^docs\\.example\\.com$)"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "tavily-map",
        "description": "A powerful web mapping tool that creates a structured map of website URLs, allowing you to discover and analyze site structure, content organization, and navigation paths. Perfect for site audits, content discovery, and understanding website architecture.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The root URL to begin the mapping"
            },
            "limit": {
              "type": "integer",
              "default": 50,
              "minimum": 1,
              "description": "Total number of links the crawler will process before stopping"
            },
            "query": {
              "type": "string",
              "description": "Natural language instructions for the crawler"
            },
            "max_depth": {
              "type": "integer",
              "default": 1,
              "minimum": 1,
              "description": "Max depth of the mapping. Defines how far from the base URL the crawler can explore"
            },
            "categories": {
              "type": "array",
              "items": {
                "enum": [
                  "Careers",
                  "Blog",
                  "Documentation",
                  "About",
                  "Pricing",
                  "Community",
                  "Developers",
                  "Contact",
                  "Media"
                ],
                "type": "string"
              },
              "default": [],
              "description": "Filter URLs using predefined categories like documentation, blog, api, etc"
            },
            "max_breadth": {
              "type": "integer",
              "default": 20,
              "minimum": 1,
              "description": "Max number of links to follow per level of the tree (i.e., per page)"
            },
            "select_paths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Regex patterns to select only URLs with specific path patterns (e.g., /docs/.*, /api/v1.*)"
            },
            "allow_external": {
              "type": "boolean",
              "default": false,
              "description": "Whether to allow following links that go to external domains"
            },
            "select_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [],
              "description": "Regex patterns to select crawling to specific domains or subdomains (e.g., ^docs\\.example\\.com$)"
            }
          },
          "required": [
            "url"
          ]
        }
      }
    ]
  },
  {
    "name": "terryso-meta_tag_genie",
    "title": "MetaTag Genie",
    "description": "MetaTag Genie",
    "icon": "https://avatars.githubusercontent.com/terryso",
    "isOfficial": false,
    "homepage": "https://github.com/terryso/meta_tag_genie",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "metatag-genie"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "writeImageMetadata",
        "description": "Writes metadata (tags, description, people, location) to an image file.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "minLength": 1
            },
            "metadata": {
              "type": "object",
              "properties": {
                "tags": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "people": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "location": {
                  "type": "string"
                },
                "description": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            "overwrite": {
              "type": "boolean",
              "default": true
            }
          },
          "required": [
            "filePath",
            "metadata"
          ]
        }
      }
    ]
  },
  {
    "name": "terryso-tv-recommender-mcp-server",
    "title": "tv-recommender-mcp-server",
    "description": "tv-recommender-mcp-server",
    "icon": "https://avatars.githubusercontent.com/terryso",
    "isOfficial": false,
    "homepage": "https://github.com/terryso/tv-recommender-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "tv-recommender-mcp-server"
      ],
      "env": {
        "TMDB_API_KEY": "<tmdb-api-key>"
      }
    },
    "parameters": [
      {
        "name": "TMDB_API_KEY",
        "description": "Your API key for The Movie Database (TMDb)",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_recommendations_by_genre",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "genre": {
              "type": "string",
              "description": "电视剧类型，如\"喜剧\"、\"科幻\"、\"悬疑\"等，支持中英文"
            }
          },
          "required": [
            "genre"
          ]
        }
      },
      {
        "name": "get_similar_shows",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "show_title": {
              "type": "string",
              "description": "剧集名称，如\"怪奇物语\"、\"绝命毒师\"等"
            }
          },
          "required": [
            "show_title"
          ]
        }
      },
      {
        "name": "get_show_details",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "show_title": {
              "type": "string",
              "description": "剧集名称，用于获取详细信息"
            }
          },
          "required": [
            "show_title"
          ]
        }
      },
      {
        "name": "get_watch_providers",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "show_title": {
              "type": "string",
              "description": "剧集名称，如\"怪奇物语\"、\"绝命毒师\"等"
            },
            "country_code": {
              "type": "string",
              "description": "可选的国家/地区代码，如\"US\"、\"CN\"等，默认为\"US\""
            }
          },
          "required": [
            "show_title"
          ]
        }
      },
      {
        "name": "discover_shows",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "description": "页码，默认为1"
            },
            "sort_by": {
              "type": "string",
              "description": "排序方式，如\"popularity.desc\""
            },
            "with_genres": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "类型数组，如[\"喜剧\", \"科幻\"]"
            },
            "with_keywords": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "关键词数组，如[\"机器人\", \"太空\"]"
            },
            "with_networks": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "电视网络ID数组，如[213]表示Netflix"
            },
            "vote_average_gte": {
              "type": "number",
              "description": "最低评分，如8.0"
            },
            "first_air_date_year": {
              "type": "number",
              "description": "首播年份，如2022"
            },
            "with_original_language": {
              "type": "string",
              "description": "原始语言，如\"en\"表示英语"
            }
          }
        }
      },
      {
        "name": "find_shows_by_actor",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "actor_name": {
              "type": "string",
              "description": "演员名称，如\"布莱恩·科兰斯顿\"、\"安东尼·斯塔尔\"等"
            }
          },
          "required": [
            "actor_name"
          ]
        }
      },
      {
        "name": "get_recommendations_by_actor",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 10,
              "description": "返回结果数量限制，默认为10"
            },
            "actor_name": {
              "type": "string",
              "description": "演员名称，如\"布莱恩·科兰斯顿\"、\"安东尼·斯塔尔\"等"
            }
          },
          "required": [
            "actor_name"
          ]
        }
      },
      {
        "name": "get_actor_details_and_credits",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "actor_name": {
              "type": "string",
              "description": "演员名称，如\"布莱恩·科兰斯顿\"、\"安东尼·斯塔尔\"等"
            }
          },
          "required": [
            "actor_name"
          ]
        }
      },
      {
        "name": "get_show_reviews",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1,
              "description": "页码，默认为1"
            },
            "show_title": {
              "type": "string",
              "description": "剧集名称，用于获取评论"
            }
          },
          "required": [
            "show_title"
          ]
        }
      },
      {
        "name": "get_popular_shows",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1,
              "description": "页码，默认为1"
            }
          }
        }
      },
      {
        "name": "get_trending_shows",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number",
              "default": 1,
              "description": "页码，默认为1"
            },
            "time_window": {
              "enum": [
                "day",
                "week"
              ],
              "type": "string",
              "default": "week",
              "description": "时间窗口，day表示日趋势，week表示周趋势，默认为week"
            }
          }
        }
      },
      {
        "name": "get_show_videos",
        "description": "",
        "inputSchema": {
          "type": "object",
          "properties": {
            "show_title": {
              "type": "string",
              "description": "剧集名称，用于获取预告片和视频"
            }
          },
          "required": [
            "show_title"
          ]
        }
      }
    ]
  },
  {
    "name": "bhouston-mcp-server-text-editor",
    "title": "mcp-server-text-editor",
    "description": "An open source implementation of the Claude built-in text editor tool versions:\n\ntext\\_editor\\_20241022 (Claude 3.5 Sonnet)\ntext\\_editor\\_20250124 (Claude 3.7 Sonnet)",
    "icon": "https://avatars.githubusercontent.com/bhouston",
    "isOfficial": false,
    "homepage": "https://github.com/bhouston/mcp-server-text-editor",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-server-text-editor"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "text_editor",
        "description": "View, create, and edit files with persistent state across command calls.  This tool is identical with Claude's built in text editor tool called text_editor_20241022",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Absolute path to file or directory, e.g. `/repo/file.py` or `/repo`."
            },
            "command": {
              "enum": [
                "view",
                "create",
                "str_replace",
                "insert",
                "undo_edit"
              ],
              "type": "string",
              "description": "The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`."
            },
            "new_str": {
              "type": "string",
              "description": "Optional parameter of `str_replace` command containing the new string (if not given, no string will be added). Required parameter of `insert` command containing the string to insert."
            },
            "old_str": {
              "type": "string",
              "description": "Required parameter of `str_replace` command containing the string in `path` to replace."
            },
            "file_text": {
              "type": "string",
              "description": "Required parameter of `create` command, with the content of the file to be created."
            },
            "view_range": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file."
            },
            "description": {
              "type": "string",
              "description": "The reason you are using the text editor (max 80 chars)"
            },
            "insert_line": {
              "type": "number",
              "description": "Required parameter of `insert` command. The `new_str` will be inserted AFTER the line `insert_line` of `path`."
            }
          },
          "required": [
            "command",
            "path",
            "description"
          ]
        }
      }
    ]
  },
  {
    "name": "thedaviddias-mcp-llms-txt-explorer",
    "title": "MCP LLMS.txt Explorer",
    "description": "A server that helps discover and analyze websites implementing the llms.txt standard, allowing users to check if websites have llms.txt files and list known compliant websites.",
    "icon": "https://avatars.githubusercontent.com/thedaviddias",
    "isOfficial": false,
    "homepage": "https://github.com/thedaviddias/mcp-llms-txt-explorer",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@thedaviddias/mcp-llms-txt-explorer"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "check_website",
        "description": "Check if a website has llms.txt files",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the website to check"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      {
        "name": "list_websites",
        "description": "List known websites with llms.txt files",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filter_llms_txt": {
              "type": "boolean",
              "description": "Only show websites with llms.txt"
            },
            "filter_llms_full_txt": {
              "type": "boolean",
              "description": "Only show websites with llms-full.txt"
            }
          }
        }
      }
    ]
  },
  {
    "name": "flight505-mcp-think-tank",
    "title": "MCP Think Tank",
    "description": "Provides AI assistants with enhanced reasoning capabilities through structured thinking, persistent knowledge graph memory, and intelligent tool orchestration for complex problem-solving.",
    "icon": "https://avatars.githubusercontent.com/flight505",
    "isOfficial": false,
    "homepage": "https://github.com/flight505/mcp-think-tank",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-think-tank"
      ],
      "env": {
        "AUTO_LINK": "<auto-link>",
        "LOG_LEVEL": "<log-level>",
        "MCP_DEBUG": "<mcp-debug>",
        "TOOL_LIMIT": "<tool-limit>",
        "EXA_API_KEY": "<exa-api-key>",
        "MEMORY_PATH": "<memory-path>",
        "MCP_LOG_FILE": "<mcp-log-file>",
        "CACHE_CONTENT": "<cache-content>",
        "MCP_LISTEN_PORT": "<mcp-listen-port>",
        "TOOL_CACHE_SIZE": "<tool-cache-size>",
        "CACHE_TOOL_CALLS": "<cache-tool-calls>",
        "CONTENT_CACHE_TTL": "<content-cache-ttl>",
        "CONTENT_CACHE_SIZE": "<content-cache-size>",
        "MAX_OPERATION_TIME": "<max-operation-time>",
        "MIN_SIMILARITY_SCORE": "<min-similarity-score>"
      }
    },
    "parameters": [
      {
        "name": "AUTO_LINK",
        "description": "Enable automatic entity linking in knowledge graph",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "LOG_LEVEL",
        "description": "Set logging level (debug, info, warn, error)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_DEBUG",
        "description": "Enable debug logging",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TOOL_LIMIT",
        "description": "Maximum number of tool calls per session",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "EXA_API_KEY",
        "description": "API key for Exa web search (required for exa_search and exa_answer tools)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "MEMORY_PATH",
        "description": "Path to the memory storage file",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_LOG_FILE",
        "description": "Enable/disable file logging",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CACHE_CONTENT",
        "description": "Enable/disable content-based caching for file/URL operations",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_LISTEN_PORT",
        "description": "Set custom port for MCP server",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "TOOL_CACHE_SIZE",
        "description": "Maximum number of cached tool calls",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CACHE_TOOL_CALLS",
        "description": "Enable/disable duplicate tool call caching",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CONTENT_CACHE_TTL",
        "description": "Time-to-live for cached content in milliseconds",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CONTENT_CACHE_SIZE",
        "description": "Maximum number of items in content cache",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MAX_OPERATION_TIME",
        "description": "Maximum time for batch operations in milliseconds",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MIN_SIMILARITY_SCORE",
        "description": "Threshold for entity matching",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "upsert_entities",
        "description": "Create new entities or update existing ones in the knowledge graph using an upsert pattern",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entities": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "name",
                  "entityType",
                  "observations"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Unique identifier for the entity"
                  },
                  "update": {
                    "type": "boolean",
                    "default": false,
                    "description": "If true, will fully replace an existing entity; if false, will only create if entity doesn't exist"
                  },
                  "context": {
                    "type": "string",
                    "description": "Optional context or situation relevant to this entity (e.g., project, meeting, or scenario)"
                  },
                  "entityType": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Type classification of the entity"
                  },
                  "observations": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "Facts or observations about the entity"
                  }
                },
                "additionalProperties": false
              },
              "description": "Array of entities to create or update"
            }
          },
          "required": [
            "entities"
          ]
        }
      },
      {
        "name": "create_relations",
        "description": "Create multiple new relations between entities in the knowledge graph. Relations should be in active voice",
        "inputSchema": {
          "type": "object",
          "properties": {
            "relations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "from",
                  "to",
                  "relationType"
                ],
                "properties": {
                  "to": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Target entity name"
                  },
                  "from": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Source entity name"
                  },
                  "relationType": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Type of relationship (in active voice)"
                  }
                },
                "additionalProperties": false
              },
              "description": "Array of relations to create"
            }
          },
          "required": [
            "relations"
          ]
        }
      },
      {
        "name": "add_observations",
        "description": "Add new observations to existing entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "observations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "entityName",
                  "contents"
                ],
                "properties": {
                  "contents": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "Observations to add to the entity"
                  },
                  "entityName": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Name of the entity to add observations to"
                  }
                },
                "additionalProperties": false
              },
              "description": "Array of entity observations to add"
            }
          },
          "required": [
            "observations"
          ]
        }
      },
      {
        "name": "delete_entities",
        "description": "Delete multiple entities and their associated relations from the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "entityNames": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 1
              },
              "description": "Array of entity names to delete"
            }
          },
          "required": [
            "entityNames"
          ]
        }
      },
      {
        "name": "delete_observations",
        "description": "Delete specific observations from entities in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "deletions": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "entityName",
                  "observations"
                ],
                "properties": {
                  "entityName": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Name of the entity to remove observations from"
                  },
                  "observations": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "Observations to remove from the entity"
                  }
                },
                "additionalProperties": false
              },
              "description": "Array of entity observations to delete"
            }
          },
          "required": [
            "deletions"
          ]
        }
      },
      {
        "name": "delete_relations",
        "description": "Delete multiple relations from the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "relations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "from",
                  "to",
                  "relationType"
                ],
                "properties": {
                  "to": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Target entity name"
                  },
                  "from": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Source entity name"
                  },
                  "relationType": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Type of relationship (in active voice)"
                  }
                },
                "additionalProperties": false
              },
              "description": "Array of relations to delete"
            }
          },
          "required": [
            "relations"
          ]
        }
      },
      {
        "name": "read_graph",
        "description": "Read the entire knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dummy": {
              "type": "string",
              "description": "Placeholder parameter - this tool doesn't require parameters but returns the complete knowledge graph with entities and relationships"
            }
          }
        }
      },
      {
        "name": "search_nodes",
        "description": "Search for nodes in the knowledge graph based on a query",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "minLength": 1,
              "description": "Search query to find matching entities"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "open_nodes",
        "description": "Open specific nodes in the knowledge graph by their names",
        "inputSchema": {
          "type": "object",
          "properties": {
            "names": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 1
              },
              "description": "Array of entity names to retrieve"
            }
          },
          "required": [
            "names"
          ]
        }
      },
      {
        "name": "update_relations",
        "description": "Update multiple existing relations in the knowledge graph",
        "inputSchema": {
          "type": "object",
          "properties": {
            "relations": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "from",
                  "to",
                  "relationType"
                ],
                "properties": {
                  "to": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Target entity name"
                  },
                  "from": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Source entity name"
                  },
                  "relationType": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Type of relationship (in active voice)"
                  }
                },
                "additionalProperties": false
              },
              "description": "Array of relations to update"
            }
          },
          "required": [
            "relations"
          ]
        }
      },
      {
        "name": "memory_query",
        "description": "Query the memory store with advanced filters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "Tag to filter observations by"
            },
            "after": {
              "type": "string",
              "description": "ISO date to filter observations after"
            },
            "agent": {
              "type": "string",
              "description": "Agent that created the observations"
            },
            "limit": {
              "type": "number",
              "description": "Maximum number of results to return"
            },
            "before": {
              "type": "string",
              "description": "ISO date to filter observations before"
            },
            "keyword": {
              "type": "string",
              "description": "Text to search for in observations"
            }
          }
        }
      },
      {
        "name": "think",
        "description": "Use the tool to think about something. It will not obtain new information or change the database, but just append the thought to the log. Use it when complex reasoning or some cache memory is needed. Consider including: problem definition, relevant context, analysis steps, self-reflection on your reasoning, and conclusions. Adapt this structure as needed for your specific thought process.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional tags to help categorize and find this thought later"
            },
            "context": {
              "type": "string",
              "description": "Optional context or situation relevant to this thought (e.g., project, meeting, or scenario)"
            },
            "category": {
              "type": "string",
              "description": "Optional category for the thought (e.g., \"problem-solving\", \"analysis\", \"planning\")"
            },
            "formatType": {
              "enum": [
                "auto",
                "general",
                "problem",
                "comparison"
              ],
              "type": "string",
              "default": "auto",
              "description": "The type of formatting to apply"
            },
            "currentStep": {
              "type": "number",
              "description": "The current step number in the thinking process"
            },
            "selfReflect": {
              "type": "boolean",
              "default": false,
              "description": "Whether to perform a self-reflection pass after generating the answer"
            },
            "formatOutput": {
              "type": "boolean",
              "default": true,
              "description": "Whether to apply markdown formatting to the output"
            },
            "plannedSteps": {
              "type": "number",
              "description": "The total number of steps planned for this thinking process"
            },
            "allowResearch": {
              "type": "boolean",
              "default": false,
              "description": "Whether to allow research via external tools during the reasoning process"
            },
            "reflectPrompt": {
              "type": "string",
              "description": "Custom prompt for the self-reflection stage"
            },
            "researchQuery": {
              "type": "string",
              "description": "Optional research query to execute during the reasoning process"
            },
            "storeInMemory": {
              "type": "boolean",
              "default": false,
              "description": "Whether to store this thought in the knowledge graph memory"
            },
            "associateWithEntity": {
              "type": "string",
              "description": "Optional entity name to associate this thought with"
            },
            "structuredReasoning": {
              "type": "string",
              "minLength": 10,
              "description": "A structured thought process to work through complex problems. Use this as a dedicated space for reasoning step-by-step."
            }
          },
          "required": [
            "structuredReasoning"
          ]
        }
      },
      {
        "name": "plan_tasks",
        "description": "Create multiple tasks from a plan. Generates IDs and syncs with knowledge graph.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_tasks",
        "description": "List tasks with optional filtering by status and priority.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "next_task",
        "description": "Get the next highest priority todo task and mark it as in-progress.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "complete_task",
        "description": "Mark a task as completed.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "update_tasks",
        "description": "Update multiple tasks with new values.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "show_memory_path",
        "description": "Return absolute path of the active knowledge-graph file.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "random_string": {
              "type": "string",
              "description": "Dummy parameter for no-parameter tools"
            }
          }
        }
      },
      {
        "name": "exa_search",
        "description": "Search the web using Exa API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "auto",
                "keyword",
                "neural"
              ],
              "type": "string",
              "default": "auto",
              "description": "Search type: auto (default), keyword (exact matching), or neural (semantic search)"
            },
            "query": {
              "type": "string",
              "description": "The search query to execute"
            },
            "category": {
              "enum": [
                "general",
                "company",
                "research paper",
                "news",
                "pdf",
                "github",
                "tweet",
                "personal site",
                "linkedin profile",
                "financial report"
              ],
              "type": "string",
              "default": "general",
              "description": "Filter results by content category"
            },
            "live_crawl": {
              "enum": [
                "always",
                "fallback"
              ],
              "type": "string",
              "default": "always",
              "description": "When to use live crawling: 'always' or 'fallback' (when cached not available)"
            },
            "num_results": {
              "type": "number",
              "default": 5,
              "maximum": 100,
              "minimum": 1,
              "description": "Number of results to return (1-100)"
            },
            "exclude_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Exclude results from these domains"
            },
            "include_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Only include results from these domains"
            },
            "end_published_date": {
              "type": "string",
              "description": "Filter results published before this date (ISO format)"
            },
            "start_published_date": {
              "type": "string",
              "description": "Filter results published after this date (ISO format)"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "exa_answer",
        "description": "Ask a question and get a sourced answer via Exa /answer API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "question": {
              "type": "string",
              "minLength": 5,
              "description": "The question to ask and get an answer with sources"
            },
            "max_citations": {
              "type": "number",
              "default": 5,
              "maximum": 10,
              "minimum": 1,
              "description": "Maximum number of citations to include in the answer (1-10)"
            }
          },
          "required": [
            "question"
          ]
        }
      }
    ]
  },
  {
    "name": "cgize-claude-mcp-think-tool",
    "title": "MCP Think Tool Server",
    "description": "Implements Anthropic's 'think' tool for Claude, providing a dedicated space for structured reasoning during complex problem-solving tasks that improves performance in reasoning chains and policy adherence.",
    "icon": "https://avatars.githubusercontent.com/cgize",
    "isOfficial": false,
    "homepage": "https://github.com/cgize/claude-mcp-think-tool",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@cgize/mcp-think-tool"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "think",
        "description": "Use this tool to think about something. It will not obtain new information or change anything, but just append the thought to the log. Use it when complex reasoning or cache memory is needed, especially during long chains of tool calls, policy adherence scenarios, or sequential decision making.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "thought": {
              "type": "string",
              "description": "A thought to think about. This can be structured reasoning, step-by-step analysis, policy verification, or any other mental process that helps with problem-solving."
            }
          },
          "required": [
            "thought"
          ]
        }
      },
      {
        "name": "get_thoughts",
        "description": "Retrieve all thoughts recorded in the current session to review your reasoning process.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "clear_thoughts",
        "description": "Clear all thoughts recorded in the current session. Use this to start fresh if the thinking process needs to be reset.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_thought_stats",
        "description": "Get statistics about the thoughts recorded in the current session to analyze your thinking process.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  },
  {
    "name": "superseoworld-mcp-spotify",
    "title": "MCP Spotify Server",
    "description": "Enables interaction with Spotify's music catalog via the Spotify Web API, supporting searches, artist information retrieval, playlist management, and automatic token handling.",
    "icon": "https://avatars.githubusercontent.com/superseoworld",
    "isOfficial": false,
    "homepage": "https://github.com/superseoworld/mcp-spotify",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@thomaswawra/server-spotify"
      ],
      "env": {
        "SPOTIFY_CLIENT_ID": "<spotify-client-id>",
        "SPOTIFY_CLIENT_SECRET": "<spotify-client-secret>"
      }
    },
    "parameters": [
      {
        "name": "SPOTIFY_CLIENT_ID",
        "description": "Your Spotify API Client ID obtained from the Spotify Developer Dashboard",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "SPOTIFY_CLIENT_SECRET",
        "description": "Your Spotify API Client Secret obtained from the Spotify Developer Dashboard",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_access_token",
        "description": "Get a valid Spotify access token for API requests",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "search",
        "description": "Search for tracks, albums, artists, or playlists",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "track",
                "album",
                "artist",
                "playlist"
              ],
              "type": "string",
              "description": "Type of item to search for"
            },
            "limit": {
              "type": "number",
              "default": 20,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of results (1-50)"
            },
            "query": {
              "type": "string",
              "description": "Search query"
            }
          },
          "required": [
            "query",
            "type"
          ]
        }
      },
      {
        "name": "get_artist",
        "description": "Get Spotify catalog information for an artist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI for the artist"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_multiple_artists",
        "description": "Get Spotify catalog information for multiple artists",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "maxItems": 50,
              "description": "Array of Spotify artist IDs or URIs (max 50)"
            }
          },
          "required": [
            "ids"
          ]
        }
      },
      {
        "name": "get_artist_top_tracks",
        "description": "Get Spotify catalog information about an artist's top tracks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI for the artist"
            },
            "market": {
              "type": "string",
              "description": "Optional. An ISO 3166-1 alpha-2 country code"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_artist_related_artists",
        "description": "Get Spotify catalog information about artists similar to a given artist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI for the artist"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_artist_albums",
        "description": "Get Spotify catalog information about an artist's albums",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI for the artist"
            },
            "limit": {
              "type": "number",
              "default": 20,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of albums to return (1-50)"
            },
            "offset": {
              "type": "number",
              "default": 0,
              "minimum": 0,
              "description": "The index of the first album to return"
            },
            "include_groups": {
              "type": "array",
              "items": {
                "enum": [
                  "album",
                  "single",
                  "appears_on",
                  "compilation"
                ],
                "type": "string"
              },
              "description": "Optional. Filter by album types"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_album",
        "description": "Get Spotify catalog information for an album",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI for the album"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_album_tracks",
        "description": "Get Spotify catalog information for an album's tracks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI for the album"
            },
            "limit": {
              "type": "number",
              "default": 20,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of tracks to return (1-50)"
            },
            "offset": {
              "type": "number",
              "default": 0,
              "minimum": 0,
              "description": "The index of the first track to return"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_multiple_albums",
        "description": "Get Spotify catalog information for multiple albums",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "maxItems": 20,
              "description": "Array of Spotify album IDs or URIs (max 20)"
            }
          },
          "required": [
            "ids"
          ]
        }
      },
      {
        "name": "get_track",
        "description": "Get Spotify catalog information for a track",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI for the track"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_available_genres",
        "description": "Get a list of available genres for recommendations",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "required": []
        }
      },
      {
        "name": "get_new_releases",
        "description": "Get a list of new album releases featured in Spotify",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 20,
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of releases to return (1-50)"
            },
            "offset": {
              "type": "number",
              "default": 0,
              "minimum": 0,
              "description": "The index of the first release to return"
            },
            "country": {
              "type": "string",
              "description": "Optional. A country code (ISO 3166-1 alpha-2)"
            }
          }
        }
      },
      {
        "name": "get_recommendations",
        "description": "Get track recommendations based on seed tracks, artists, or genres",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "default": 20,
              "maximum": 100,
              "minimum": 1,
              "description": "Maximum number of recommendations (1-100)"
            },
            "seed_genres": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of genre names"
            },
            "seed_tracks": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of Spotify track IDs or URIs"
            },
            "seed_artists": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of Spotify artist IDs or URIs"
            }
          },
          "required": []
        }
      },
      {
        "name": "get_audiobook",
        "description": "Get Spotify catalog information for an audiobook",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI for the audiobook"
            },
            "market": {
              "type": "string",
              "description": "Optional. An ISO 3166-1 alpha-2 country code"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_multiple_audiobooks",
        "description": "Get Spotify catalog information for multiple audiobooks",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "maxItems": 50,
              "description": "Array of Spotify audiobook IDs or URIs (max 50)"
            },
            "market": {
              "type": "string",
              "description": "Optional. An ISO 3166-1 alpha-2 country code"
            }
          },
          "required": [
            "ids"
          ]
        }
      },
      {
        "name": "get_audiobook_chapters",
        "description": "Get Spotify catalog information about an audiobook's chapters",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI for the audiobook"
            },
            "limit": {
              "type": "number",
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of chapters to return (1-50)"
            },
            "market": {
              "type": "string",
              "description": "Optional. An ISO 3166-1 alpha-2 country code"
            },
            "offset": {
              "type": "number",
              "minimum": 0,
              "description": "The index of the first chapter to return"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_playlist",
        "description": "Get a playlist owned by a Spotify user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI of the playlist"
            },
            "market": {
              "type": "string",
              "description": "Optional. An ISO 3166-1 alpha-2 country code"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_playlist_tracks",
        "description": "Get full details of the tracks of a playlist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI of the playlist"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1,
              "description": "Optional. Maximum number of tracks to return (1-100)"
            },
            "fields": {
              "type": "string",
              "description": "Optional. Filters for the query"
            },
            "market": {
              "type": "string",
              "description": "Optional. An ISO 3166-1 alpha-2 country code"
            },
            "offset": {
              "type": "number",
              "minimum": 0,
              "description": "Optional. Index of the first track to return"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "get_playlist_items",
        "description": "Get full details of the items of a playlist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI of the playlist"
            },
            "limit": {
              "type": "number",
              "maximum": 100,
              "minimum": 1,
              "description": "Optional. Maximum number of items to return (1-100)"
            },
            "fields": {
              "type": "string",
              "description": "Optional. Filters for the query"
            },
            "market": {
              "type": "string",
              "description": "Optional. An ISO 3166-1 alpha-2 country code"
            },
            "offset": {
              "type": "number",
              "minimum": 0,
              "description": "Optional. Index of the first item to return"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "modify_playlist",
        "description": "Change a playlist's name and public/private state",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI of the playlist"
            },
            "name": {
              "type": "string",
              "description": "Optional. New name for the playlist"
            },
            "public": {
              "type": "boolean",
              "description": "Optional. If true the playlist will be public"
            },
            "description": {
              "type": "string",
              "description": "Optional. New description for the playlist"
            },
            "collaborative": {
              "type": "boolean",
              "description": "Optional. If true, the playlist will become collaborative"
            }
          },
          "required": [
            "id"
          ]
        }
      },
      {
        "name": "add_tracks_to_playlist",
        "description": "Add one or more tracks to a playlist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI of the playlist"
            },
            "uris": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of Spotify track URIs to add"
            },
            "position": {
              "type": "number",
              "minimum": 0,
              "description": "Optional. The position to insert the tracks (zero-based)"
            }
          },
          "required": [
            "id",
            "uris"
          ]
        }
      },
      {
        "name": "remove_tracks_from_playlist",
        "description": "Remove one or more tracks from a playlist",
        "inputSchema": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "description": "The Spotify ID or URI of the playlist"
            },
            "tracks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "uri"
                ],
                "properties": {
                  "uri": {
                    "type": "string",
                    "description": "Spotify URI of the track to remove"
                  },
                  "positions": {
                    "type": "array",
                    "items": {
                      "type": "number"
                    },
                    "description": "Optional positions of the track to remove"
                  }
                }
              },
              "description": "Array of objects containing Spotify track URIs to remove"
            },
            "snapshot_id": {
              "type": "string",
              "description": "Optional. The playlist's snapshot ID"
            }
          },
          "required": [
            "id",
            "tracks"
          ]
        }
      },
      {
        "name": "get_current_user_playlists",
        "description": "Get a list of the playlists owned or followed by the current Spotify user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "maximum": 50,
              "minimum": 1,
              "description": "Maximum number of playlists to return (1-50)"
            },
            "offset": {
              "type": "number",
              "minimum": 0,
              "description": "The index of the first playlist to return"
            }
          }
        }
      },
      {
        "name": "get_featured_playlists",
        "description": "Get a list of Spotify featured playlists",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "maximum": 50,
              "minimum": 1,
              "description": "Optional. Maximum number of playlists (1-50)"
            },
            "locale": {
              "type": "string",
              "description": "Optional. Desired language (format: es_MX)"
            },
            "offset": {
              "type": "number",
              "minimum": 0,
              "description": "Optional. Index of the first playlist to return"
            }
          }
        }
      },
      {
        "name": "get_category_playlists",
        "description": "Get a list of Spotify playlists tagged with a particular category",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "number",
              "maximum": 50,
              "minimum": 1,
              "description": "Optional. Maximum number of playlists (1-50)"
            },
            "offset": {
              "type": "number",
              "minimum": 0,
              "description": "Optional. Index of the first playlist to return"
            },
            "category_id": {
              "type": "string",
              "description": "The Spotify category ID"
            }
          },
          "required": [
            "category_id"
          ]
        }
      }
    ]
  },
  {
    "name": "tinybirdco-mcp-tinybird",
    "title": "Tinybird MCP server",
    "description": "An MCP server to interact with a Tinybird Workspace from any MCP client.",
    "icon": "https://avatars.githubusercontent.com/tinybirdco",
    "isOfficial": true,
    "homepage": "https://github.com/tinybirdco/mcp-tinybird",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-tinybird"
      ],
      "env": {
        "TB_API_URL": "<tb-api-url>",
        "TB_ADMIN_TOKEN": "<tb-admin-token>"
      }
    },
    "parameters": [
      {
        "name": "TB_API_URL",
        "description": "Your Tinybird API URL",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "TB_ADMIN_TOKEN",
        "description": "Your Tinybird Admin Token",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "manascb1344-together-mcp-server",
    "title": "Image Generation MCP Server",
    "description": "A Model Context Protocol server that enables high-quality image generation using the Flux.1 Schnell model via Together AI with customizable parameters.",
    "icon": "https://avatars.githubusercontent.com/manascb1344",
    "isOfficial": false,
    "homepage": "https://github.com/manascb1344/together-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "together-mcp"
      ],
      "env": {
        "TOGETHER_API_KEY": "<together-api-key>"
      }
    },
    "parameters": [
      {
        "name": "TOGETHER_API_KEY",
        "description": "Your Together AI API key obtained from api.together.xyz",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "generate_image",
        "description": "Generate an image using Together AI API",
        "inputSchema": {
          "type": "object",
          "properties": {
            "n": {
              "type": "number",
              "maximum": 4,
              "minimum": 1,
              "description": "Number of images to generate (default: 1)"
            },
            "model": {
              "type": "string",
              "description": "Model to use for generation (default: black-forest-labs/FLUX.1-schnell-Free)"
            },
            "steps": {
              "type": "number",
              "maximum": 100,
              "minimum": 1,
              "description": "Number of inference steps (default: 1)"
            },
            "width": {
              "type": "number",
              "maximum": 2048,
              "minimum": 128,
              "description": "Image width (default: 1024)"
            },
            "height": {
              "type": "number",
              "maximum": 2048,
              "minimum": 128,
              "description": "Image height (default: 768)"
            },
            "prompt": {
              "type": "string",
              "description": "Text prompt for image generation"
            },
            "image_path": {
              "type": "string",
              "description": "Optional path to save the generated image as PNG"
            },
            "response_format": {
              "enum": [
                "b64_json",
                "url"
              ],
              "type": "string",
              "description": "Response format (default: b64_json)"
            }
          },
          "required": [
            "prompt"
          ]
        }
      }
    ]
  },
  {
    "name": "tokenizin-agency-mcp-nativewind",
    "title": "mcp-nativewind",
    "description": "Rransforms Tailwind components to NativeWind 4.",
    "icon": "https://avatars.githubusercontent.com/tokenizin-agency",
    "isOfficial": false,
    "homepage": "https://github.com/tokenizin-agency/mcp-nativewind",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@tokenizin-com/mcp-server-nativewind"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "tornikegomareli-macos-tools-mcp-server",
    "title": "macOS Tools MCP Server",
    "description": "Provides advanced system monitoring and file search capabilities for macOS, allowing users to track performance metrics and perform enhanced file searches with content analysis and tagging features.",
    "icon": "https://avatars.githubusercontent.com/tornikegomareli",
    "isOfficial": false,
    "homepage": "https://github.com/tornikegomareli/macos-tools-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@tgomareli/macos-tools-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "system_performance",
        "description": "Monitor system performance and analyze resource usage",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "enum": [
                "current",
                "history",
                "processes",
                "optimize"
              ],
              "type": "string",
              "description": "Type of performance analysis"
            },
            "metric": {
              "enum": [
                "cpu",
                "memory",
                "disk",
                "network",
                "all"
              ],
              "type": "string",
              "description": "Specific metric to analyze"
            },
            "timeRange": {
              "type": "string",
              "description": "Time range for historical data (e.g., '1h', '24h', '7d')"
            }
          },
          "required": [
            "action"
          ]
        }
      },
      {
        "name": "enhanced_search",
        "description": "Advanced file search with content analysis and tagging",
        "inputSchema": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "Root directory for search"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tags to search for or apply"
            },
            "query": {
              "type": "string",
              "description": "Search query (supports regex)"
            },
            "action": {
              "enum": [
                "search",
                "tag",
                "untag"
              ],
              "type": "string",
              "description": "Search or manage tags"
            },
            "fileTypes": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "File extensions to include"
            },
            "maxResults": {
              "type": "number",
              "description": "Maximum number of results"
            },
            "searchType": {
              "enum": [
                "content",
                "filename",
                "tags",
                "regex"
              ],
              "type": "string",
              "description": "Type of search to perform"
            }
          },
          "required": [
            "action"
          ]
        }
      }
    ]
  },
  {
    "name": "truss44-mcp-crypto-price",
    "title": "Crypto Price & Market Analysis MCP Server",
    "description": "A Model Context Protocol (MCP) server that provides comprehensive cryptocurrency analysis using the CoinCap API. This server offers real-time price data, market analysis, and historical trends through an easy-to-use interface.",
    "icon": "https://avatars.githubusercontent.com/truss44",
    "isOfficial": false,
    "homepage": "https://github.com/truss44/mcp-crypto-price",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-crypto-price"
      ],
      "env": {
        "COINCAP_API_KEY": "<coincap-api-key>"
      }
    },
    "parameters": [
      {
        "name": "COINCAP_API_KEY",
        "description": "Optional CoinCap API key for higher rate limits",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "get-crypto-price",
        "description": "Get current price and 24h stats for a cryptocurrency",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "description": "Cryptocurrency symbol (e.g., BTC, ETH)"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get-market-analysis",
        "description": "Get detailed market analysis including top exchanges and volume distribution",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "description": "Cryptocurrency symbol (e.g., BTC, ETH)"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get-historical-analysis",
        "description": "Get historical price analysis with customizable timeframe",
        "inputSchema": {
          "type": "object",
          "properties": {
            "days": {
              "type": "number",
              "default": 7,
              "description": "Number of days to analyze (1-30)"
            },
            "symbol": {
              "type": "string",
              "description": "Cryptocurrency symbol (e.g., BTC, ETH)"
            },
            "interval": {
              "type": "string",
              "default": "h1",
              "description": "Time interval (m5, m15, m30, h1, h2, h6, h12, d1)"
            }
          },
          "required": [
            "symbol"
          ]
        }
      }
    ]
  },
  {
    "name": "tumf-mcp-shell-server",
    "title": "mcp-shell-server",
    "description": "A secure shell command execution server implementing the Model Context Protocol (MCP). This server allows remote execution of whitelisted shell commands with support for stdin input.",
    "icon": "https://avatars.githubusercontent.com/tumf",
    "isOfficial": false,
    "homepage": "https://github.com/tumf/mcp-shell-server",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-shell-server"
      ],
      "env": {
        "ALLOW_COMMANDS": "<allow-commands>",
        "ALLOWED_COMMANDS": "<allowed-commands>"
      }
    },
    "parameters": [
      {
        "name": "ALLOW_COMMANDS",
        "description": "Comma-separated list of commands that are allowed to be executed",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ALLOWED_COMMANDS",
        "description": "Alias for ALLOW_COMMANDS - comma-separated list of commands that are allowed to be executed",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "shell_execute",
        "description": "Execute a shell command\nAllowed commands: find, cat, pwd, ls, wc, grep, touch",
        "inputSchema": {
          "type": "object",
          "properties": {
            "stdin": {
              "type": "string",
              "description": "Input to be passed to the command via stdin"
            },
            "command": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Command and its arguments as array"
            },
            "timeout": {
              "type": "integer",
              "minimum": 0,
              "description": "Maximum execution time in seconds"
            },
            "directory": {
              "type": "string",
              "description": "Working directory where the command will be executed"
            }
          },
          "required": [
            "command",
            "directory"
          ]
        }
      }
    ]
  },
  {
    "name": "tumf-mcp-text-editor",
    "title": "mcp-text-editor",
    "description": "A line-oriented text file editor. Optimized for LLM tools with efficient partial file access to minimize token usage.",
    "icon": "https://avatars.githubusercontent.com/tumf",
    "isOfficial": false,
    "homepage": "https://github.com/tumf/mcp-text-editor",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-text-editor"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "turlockmike-apple-notifier-mcp",
    "title": "apple-notifier-mcp",
    "description": "A simple MCP server that can send notifications on mac devices.",
    "icon": "https://avatars.githubusercontent.com/turlockmike",
    "isOfficial": false,
    "homepage": "https://github.com/turlockmike/apple-notifier-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "apple-notifier-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "turlockmike-mcp-rand",
    "title": "MCP Rand",
    "description": "Provides random number generation utilities, including a secure UUID generator powered by Node's crypto module.",
    "icon": "https://avatars.githubusercontent.com/turlockmike",
    "isOfficial": false,
    "homepage": "https://github.com/turlockmike/mcp-rand",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "mcp-rand"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": []
  },
  {
    "name": "umshere-uiflowchartcreator",
    "title": "UIFlowchartCreator",
    "description": "Enables users to create UI flowcharts by generating visualizations of user interfaces and interactions through an easy-to-use API within MCP-compatible systems.",
    "icon": "https://avatars.githubusercontent.com/umshere",
    "isOfficial": false,
    "homepage": "https://github.com/umshere/uiflowchartcreator",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "uiflowchartcreator"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "generate_ui_flow",
        "description": "Generate a UI flow diagram by analyzing React/Angular repositories. This tool scans the codebase to identify components, their relationships, and the overall UI structure.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "repo": {
              "type": "string",
              "description": "GitHub repository name (required if isLocal is false)"
            },
            "owner": {
              "type": "string",
              "description": "GitHub repository owner (required if isLocal is false)"
            },
            "isLocal": {
              "type": "boolean",
              "description": "Whether to analyze a local repository (true) or GitHub repository (false)"
            },
            "repoPath": {
              "type": "string",
              "description": "Path to local repository or empty string for GitHub repos"
            },
            "fileExtensions": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "default": [
                "js",
                "jsx",
                "ts",
                "tsx"
              ],
              "description": "List of file extensions to analyze (e.g., ['js', 'jsx', 'ts', 'tsx'] for React, ['ts', 'html'] for Angular)"
            }
          },
          "required": [
            "repoPath",
            "isLocal"
          ]
        }
      }
    ]
  },
  {
    "name": "utensils-mcp-nixos",
    "title": "mcp-nixos",
    "description": "MCP-NixOS is a Model Context Protocol server that provides real-time, accurate information about NixOS packages, options, Home Manager, and nix-darwin configurations, preventing AI assistants from hallucinating about NixOS resources and enabling them to deliver factual system configuration guidance.",
    "icon": "https://avatars.githubusercontent.com/utensils",
    "isOfficial": false,
    "homepage": "https://github.com/utensils/mcp-nixos",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "mcp-nixos"
      ],
      "env": {
        "KEEP_TEST_CACHE": "<keep-test-cache>",
        "ELASTICSEARCH_URL": "<elasticsearch-url>",
        "MCP_NIXOS_LOG_FILE": "<mcp-nixos-log-file>",
        "MCP_NIXOS_CACHE_DIR": "<mcp-nixos-cache-dir>",
        "MCP_NIXOS_CACHE_TTL": "<mcp-nixos-cache-ttl>",
        "MCP_NIXOS_LOG_LEVEL": "<mcp-nixos-log-level>",
        "MCP_NIXOS_CLEANUP_ORPHANS": "<mcp-nixos-cleanup-orphans>"
      }
    },
    "parameters": [
      {
        "name": "KEEP_TEST_CACHE",
        "description": "Keep test cache directory for debugging (dev-only)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "ELASTICSEARCH_URL",
        "description": "NixOS Elasticsearch API URL",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_NIXOS_LOG_FILE",
        "description": "Where to document said failures",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_NIXOS_CACHE_DIR",
        "description": "Where to store stuff you'll forget about. Default: OS-specific cache locations",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_NIXOS_CACHE_TTL",
        "description": "How long until cache invalidation ruins your day (in seconds, 24h default)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_NIXOS_LOG_LEVEL",
        "description": "How much you want to know about your failures",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "MCP_NIXOS_CLEANUP_ORPHANS",
        "description": "Whether to kill orphaned MCP processes on startup",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "nixos_search",
        "description": "Search NixOS packages, options, or programs.\n\n    Args:\n        query: Search term to look for\n        search_type: Type of search - \"packages\", \"options\", \"programs\", or \"flakes\"\n        limit: Maximum number of results to return (1-100)\n        channel: NixOS channel to search in (e.g., \"unstable\", \"stable\", \"25.05\")\n\n    Returns:\n        Plain text results with bullet points or error message\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 20
            },
            "query": {
              "type": "string",
              "title": "Query"
            },
            "channel": {
              "type": "string",
              "title": "Channel",
              "default": "unstable"
            },
            "search_type": {
              "type": "string",
              "title": "Search Type",
              "default": "packages"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "nixos_info",
        "description": "Get detailed info about a NixOS package or option.\n\n    Args:\n        name: Name of the package or option to look up\n        type: Type of lookup - \"package\" or \"option\"\n        channel: NixOS channel to search in (e.g., \"unstable\", \"stable\", \"25.05\")\n\n    Returns:\n        Plain text details about the package/option or error message\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            },
            "type": {
              "type": "string",
              "title": "Type",
              "default": "package"
            },
            "channel": {
              "type": "string",
              "title": "Channel",
              "default": "unstable"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "nixos_channels",
        "description": "List available NixOS channels with their status.\n\n    Returns:\n        Plain text list showing channel names, versions, and availability\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "nixos_stats",
        "description": "Get NixOS statistics for a channel.\n\n    Args:\n        channel: NixOS channel to get stats for (e.g., \"unstable\", \"stable\", \"25.05\")\n\n    Returns:\n        Plain text statistics including package/option counts\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel": {
              "type": "string",
              "title": "Channel",
              "default": "unstable"
            }
          }
        }
      },
      {
        "name": "home_manager_search",
        "description": "Search Home Manager configuration options.\n\n    Searches through available Home Manager options by name and description.\n\n    Args:\n        query: The search query string to match against option names and descriptions\n        limit: Maximum number of results to return (default: 20, max: 100)\n\n    Returns:\n        Plain text list of matching options with name, type, and description\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 20
            },
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "home_manager_info",
        "description": "Get detailed information about a specific Home Manager option.\n\n    Requires an exact option name match. If not found, suggests similar options.\n\n    Args:\n        name: The exact option name (e.g., 'programs.git.enable')\n\n    Returns:\n        Plain text with option details (name, type, description) or error with suggestions\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "home_manager_stats",
        "description": "Get statistics about Home Manager options.\n\n    Retrieves overall statistics including total options, categories, and top categories.\n\n    Returns:\n        Plain text summary with total options, category count, and top 5 categories\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "home_manager_list_options",
        "description": "List all Home Manager option categories.\n\n    Enumerates all top-level categories with their option counts.\n\n    Returns:\n        Plain text list of categories sorted alphabetically with option counts\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "home_manager_options_by_prefix",
        "description": "Get Home Manager options matching a specific prefix.\n\n    Useful for browsing options under a category or finding exact option names.\n\n    Args:\n        option_prefix: The prefix to match (e.g., 'programs.git' or 'services')\n\n    Returns:\n        Plain text list of options with the given prefix, including descriptions\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "option_prefix": {
              "type": "string",
              "title": "Option Prefix"
            }
          },
          "required": [
            "option_prefix"
          ]
        }
      },
      {
        "name": "darwin_search",
        "description": "Search nix-darwin (macOS) configuration options.\n\n    Searches through available nix-darwin options by name and description.\n\n    Args:\n        query: The search query string to match against option names and descriptions\n        limit: Maximum number of results to return (default: 20, max: 100)\n\n    Returns:\n        Plain text list of matching options with name, type, and description\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 20
            },
            "query": {
              "type": "string",
              "title": "Query"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "darwin_info",
        "description": "Get detailed information about a specific nix-darwin option.\n\n    Requires an exact option name match. If not found, suggests similar options.\n\n    Args:\n        name: The exact option name (e.g., 'system.defaults.dock.autohide')\n\n    Returns:\n        Plain text with option details (name, type, description) or error with suggestions\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "Name"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      {
        "name": "darwin_stats",
        "description": "Get statistics about nix-darwin options.\n\n    Retrieves overall statistics including total options, categories, and top categories.\n\n    Returns:\n        Plain text summary with total options, category count, and top 5 categories\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "darwin_list_options",
        "description": "List all nix-darwin option categories.\n\n    Enumerates all top-level categories with their option counts.\n\n    Returns:\n        Plain text list of categories sorted alphabetically with option counts\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "darwin_options_by_prefix",
        "description": "Get nix-darwin options matching a specific prefix.\n\n    Useful for browsing options under a category or finding exact option names.\n\n    Args:\n        option_prefix: The prefix to match (e.g., 'system.defaults' or 'services')\n\n    Returns:\n        Plain text list of options with the given prefix, including descriptions\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "option_prefix": {
              "type": "string",
              "title": "Option Prefix"
            }
          },
          "required": [
            "option_prefix"
          ]
        }
      },
      {
        "name": "nixos_flakes_stats",
        "description": "Get statistics about available NixOS flakes.\n\n    Retrieves statistics from the flake search index including total packages,\n    unique repositories, flake types, and top contributors.\n\n    Returns:\n        Plain text summary with flake statistics and top contributors\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "nixos_flakes_search",
        "description": "Search NixOS flakes by name, description, owner, or repository.\n\n    Searches the flake index for community-contributed packages and configurations.\n    Flakes are indexed separately from official packages.\n\n    Args:\n        query: The search query (flake name, description, owner, or repository)\n        limit: Maximum number of results to return (default: 20, max: 100)\n        channel: Ignored - flakes use a separate indexing system\n\n    Returns:\n        Plain text list of unique flakes with their packages and metadata\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 20
            },
            "query": {
              "type": "string",
              "title": "Query"
            },
            "channel": {
              "type": "string",
              "title": "Channel",
              "default": "unstable"
            }
          },
          "required": [
            "query"
          ]
        }
      },
      {
        "name": "nixhub_package_versions",
        "description": "Get version history and nixpkgs commit hashes for a specific package from NixHub.io.\n\n    Use this tool when users need specific package versions or commit hashes for reproducible builds.\n\n    Args:\n        package_name: Name of the package to query (e.g., \"firefox\", \"python\")\n        limit: Maximum number of versions to return (default: 10, max: 50)\n\n    Returns:\n        Plain text with package info and version history including commit hashes\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "title": "Limit",
              "default": 10
            },
            "package_name": {
              "type": "string",
              "title": "Package Name"
            }
          },
          "required": [
            "package_name"
          ]
        }
      },
      {
        "name": "nixhub_find_version",
        "description": "Find a specific version of a package in NixHub with smart search.\n\n    Automatically searches with increasing limits to find the requested version.\n\n    Args:\n        package_name: Name of the package to query (e.g., \"ruby\", \"python\")\n        version: Specific version to find (e.g., \"2.6.7\", \"3.5.9\")\n\n    Returns:\n        Plain text with version info and commit hash if found, or helpful message if not\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "version": {
              "type": "string",
              "title": "Version"
            },
            "package_name": {
              "type": "string",
              "title": "Package Name"
            }
          },
          "required": [
            "package_name",
            "version"
          ]
        }
      }
    ]
  },
  {
    "name": "vidhupv-x-mcp",
    "title": "X(Twitter) MCP Server",
    "description": "An MCP server that allows Claude to create, manage and publish X/Twitter posts directly through the chat interface.",
    "icon": "https://avatars.githubusercontent.com/vidhupv",
    "isOfficial": false,
    "homepage": "https://github.com/vidhupv/x-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "x-mcp"
      ],
      "env": {
        "TWITTER_API_KEY": "<twitter-api-key>",
        "TWITTER_API_SECRET": "<twitter-api-secret>",
        "TWITTER_ACCESS_TOKEN": "<twitter-access-token>",
        "TWITTER_ACCESS_TOKEN_SECRET": "<twitter-access-token-secret>"
      }
    },
    "parameters": [
      {
        "name": "TWITTER_API_KEY",
        "description": "Your X/Twitter API key (from X API Developer Portal)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "TWITTER_API_SECRET",
        "description": "Your X/Twitter API secret (from X API Developer Portal)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "TWITTER_ACCESS_TOKEN",
        "description": "Your X/Twitter access token (from X API Developer Portal)",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "TWITTER_ACCESS_TOKEN_SECRET",
        "description": "Your X/Twitter access token secret (from X API Developer Portal)",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "vinsidious-whodis-mcp-server",
    "title": "Whodis MCP Server",
    "description": "A Model Context Protocol server that enables AI assistants to check domain name availability using WHOIS lookups.",
    "icon": "https://avatars.githubusercontent.com/vinsidious",
    "isOfficial": false,
    "homepage": "https://github.com/vinsidious/whodis-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "whodis-mcp-server"
      ],
      "env": {
        "DEBUG": "<debug>"
      }
    },
    "parameters": [
      {
        "name": "DEBUG",
        "description": "Set to true to enable detailed debug logs",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "check-domain-availability",
        "description": "PURPOSE: Checks the availability of one or more domain names.\n        INPUT: An array of domain names.\n        OUTPUT: A JSON object containing two arrays: 'available' (domains that appear to be unregistered) and 'unavailable' (domains that appear to be registered). Note: Availability checks depend on WHOIS server responses and might not be 100% accurate for all TLDs or due to temporary network issues. Domains where lookup failed are omitted.\n        WHEN TO USE: Use this tool when you need to determine if specific domain names can potentially be registered.\n        EXAMPLE: { \"domains\": [\"google.com\", \"example-domain-that-is-likely-free-12345.com\"] }",
        "inputSchema": {
          "type": "object",
          "properties": {
            "domains": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 1
              },
              "minItems": 1,
              "description": "An array of domain names to check for availability"
            }
          },
          "required": [
            "domains"
          ]
        }
      }
    ]
  },
  {
    "name": "wazzan-mcp-coincap-jj",
    "title": "mcp-coincap-jj",
    "description": "A Model Context Protocol (MCP) server that provides comprehensive cryptocurrency analysis using the CoinCap API. This server offers real-time price data, market analysis, and historical trends through an easy-to-use interface. Updated to use Coin Cap API v3",
    "icon": "https://avatars.githubusercontent.com/wazzan",
    "isOfficial": false,
    "homepage": "https://github.com/wazzan/mcp-coincap-jj",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@bujaayjaay/mcp-coincap-jj"
      ],
      "env": {
        "COINCAP_API_KEY": "<coincap-api-key>"
      }
    },
    "parameters": [
      {
        "name": "COINCAP_API_KEY",
        "description": "API key for the CoinCap API v3",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": []
  },
  {
    "name": "modelcontextprotocol-servers-whois-mcp",
    "title": "Whois MCP",
    "description": "Enables AI agents to perform WHOIS lookups to retrieve domain registration details, including ownership, registration dates, and availability status without requiring browser searches.",
    "icon": "https://avatars.githubusercontent.com/modelcontextprotocol-servers",
    "isOfficial": false,
    "homepage": "https://github.com/modelcontextprotocol-servers/whois-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@mcp-server/whois-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "whois_domain",
        "description": "Looksup whois information about the domain",
        "inputSchema": {
          "type": "object",
          "properties": {
            "domain": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "domain"
          ]
        }
      },
      {
        "name": "whois_tld",
        "description": "Looksup whois information about the Top Level Domain (TLD)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tld": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "tld"
          ]
        }
      },
      {
        "name": "whois_ip",
        "description": "Looksup whois information about the IP",
        "inputSchema": {
          "type": "object",
          "properties": {
            "ip": {
              "type": "string",
              "anyOf": [
                {
                  "format": "ipv4"
                },
                {
                  "format": "ipv6"
                }
              ]
            }
          },
          "required": [
            "ip"
          ]
        }
      },
      {
        "name": "whois_as",
        "description": "Looksup whois information about the Autonomous System Number (ASN)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "asn": {
              "type": "string",
              "pattern": "^AS\\d+$"
            }
          },
          "required": [
            "asn"
          ]
        }
      }
    ]
  },
  {
    "name": "winor30-mcp-server-datadog",
    "title": "mcp-server-datadog",
    "description": "The MCP server provides an interface to the Datadog API, enabling seamless management of incidents, monitoring, logs, dashboards, metrics, traces, and hosts. Its extensible design allows easy integration of additional Datadog APIs for future expansions.",
    "icon": "https://avatars.githubusercontent.com/winor30",
    "isOfficial": false,
    "homepage": "https://github.com/winor30/mcp-server-datadog",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@winor30/mcp-server-datadog"
      ],
      "env": {
        "DATADOG_SITE": "<datadog-site>",
        "DATADOG_API_KEY": "<datadog-api-key>",
        "DATADOG_APP_KEY": "<datadog-app-key>"
      }
    },
    "parameters": [
      {
        "name": "DATADOG_SITE",
        "description": "The Datadog site (e.g. datadoghq.eu)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "DATADOG_API_KEY",
        "description": "Your Datadog API key",
        "type": "string",
        "password": false,
        "required": true
      },
      {
        "name": "DATADOG_APP_KEY",
        "description": "Your Datadog Application key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "list_incidents",
        "description": "Get incidents from Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pageSize": {
              "type": "number",
              "default": 10,
              "maximum": 100,
              "minimum": 1
            },
            "pageOffset": {
              "type": "number",
              "default": 0,
              "minimum": 0
            }
          },
          "required": []
        }
      },
      {
        "name": "get_incident",
        "description": "Get an incident from Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "incidentId": {
              "type": "string",
              "minLength": 1
            }
          },
          "required": [
            "incidentId"
          ]
        }
      },
      {
        "name": "get_metrics",
        "description": "Get metrics data from Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "number",
              "description": "End time in epoch seconds"
            },
            "from": {
              "type": "number",
              "description": "Start time in epoch seconds"
            },
            "query": {
              "type": "string",
              "description": "Datadog metrics query string. e.g. \"avg:system.cpu.user{*}"
            }
          },
          "required": [
            "from",
            "to",
            "query"
          ]
        }
      },
      {
        "name": "get_logs",
        "description": "Search and retrieve logs from Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "number",
              "description": "End time in epoch seconds"
            },
            "from": {
              "type": "number",
              "description": "Start time in epoch seconds"
            },
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Maximum number of logs to return. Default is 100."
            },
            "query": {
              "type": "string",
              "default": "",
              "description": "Datadog logs query string"
            }
          },
          "required": [
            "from",
            "to"
          ]
        }
      },
      {
        "name": "get_monitors",
        "description": "Get monitors status from Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Filter monitors by name"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter monitors by tags"
            },
            "groupStates": {
              "type": "array",
              "items": {
                "enum": [
                  "alert",
                  "warn",
                  "no data",
                  "ok"
                ],
                "type": "string"
              },
              "description": "Filter monitors by their states"
            }
          },
          "required": []
        }
      },
      {
        "name": "list_dashboards",
        "description": "Get list of dashboards from Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Filter dashboards by name"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Filter dashboards by tags"
            }
          },
          "required": []
        }
      },
      {
        "name": "get_dashboard",
        "description": "Get a dashboard from Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "dashboardId": {
              "type": "string"
            }
          },
          "required": [
            "dashboardId"
          ]
        }
      },
      {
        "name": "list_traces",
        "description": "Get APM traces from Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "number",
              "description": "End time in epoch seconds"
            },
            "from": {
              "type": "number",
              "description": "Start time in epoch seconds"
            },
            "sort": {
              "enum": [
                "timestamp",
                "-timestamp"
              ],
              "type": "string",
              "default": "-timestamp",
              "description": "Sort order for traces"
            },
            "limit": {
              "type": "number",
              "default": 100,
              "description": "Maximum number of traces to return"
            },
            "query": {
              "type": "string",
              "description": "Datadog APM trace query string"
            },
            "service": {
              "type": "string",
              "description": "Filter by service name"
            },
            "operation": {
              "type": "string",
              "description": "Filter by operation name"
            }
          },
          "required": [
            "query",
            "from",
            "to"
          ]
        }
      },
      {
        "name": "mute_host",
        "description": "Mute a host in Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end": {
              "type": "integer",
              "description": "POSIX timestamp for when the mute should end"
            },
            "message": {
              "type": "string",
              "description": "Message to associate with the muting of this host"
            },
            "hostname": {
              "type": "string",
              "description": "The name of the host to mute"
            },
            "override": {
              "type": "boolean",
              "default": false,
              "description": "If true and the host is already muted, replaces existing end time"
            }
          },
          "required": [
            "hostname"
          ]
        }
      },
      {
        "name": "unmute_host",
        "description": "Unmute a host in Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "hostname": {
              "type": "string",
              "description": "The name of the host to unmute"
            }
          },
          "required": [
            "hostname"
          ]
        }
      },
      {
        "name": "list_hosts",
        "description": "Get list of hosts from Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from": {
              "type": "integer",
              "description": "Search hosts from this UNIX timestamp"
            },
            "count": {
              "type": "integer",
              "maximum": 1000,
              "description": "Max number of hosts to return (max: 1000)"
            },
            "start": {
              "type": "integer",
              "description": "Starting offset for pagination"
            },
            "filter": {
              "type": "string",
              "description": "Filter string for search results"
            },
            "sort_dir": {
              "type": "string",
              "description": "Sort direction (asc/desc)"
            },
            "sort_field": {
              "type": "string",
              "description": "Field to sort hosts by"
            },
            "include_hosts_metadata": {
              "type": "boolean",
              "description": "Include host metadata (version, platform, etc)"
            },
            "include_muted_hosts_data": {
              "type": "boolean",
              "description": "Include muted hosts status and expiry"
            }
          },
          "required": []
        }
      },
      {
        "name": "get_active_hosts_count",
        "description": "Get the total number of active hosts in Datadog (defaults to last 5 minutes)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "from": {
              "type": "integer",
              "default": 7200,
              "description": "Number of seconds from which you want to get total number of active hosts (defaults to 2h)"
            }
          },
          "required": []
        }
      },
      {
        "name": "list_downtimes",
        "description": "List scheduled downtimes from Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "currentOnly": {
              "type": "boolean"
            }
          },
          "required": []
        }
      },
      {
        "name": "schedule_downtime",
        "description": "Schedule a downtime in Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end": {
              "type": "number"
            },
            "scope": {
              "type": "string",
              "minLength": 1
            },
            "start": {
              "type": "number"
            },
            "message": {
              "type": "string"
            },
            "timezone": {
              "type": "string"
            },
            "monitorId": {
              "type": "number"
            },
            "recurrence": {
              "type": "object",
              "required": [
                "type",
                "period"
              ],
              "properties": {
                "type": {
                  "enum": [
                    "days",
                    "weeks",
                    "months",
                    "years"
                  ],
                  "type": "string"
                },
                "until": {
                  "type": "number"
                },
                "period": {
                  "type": "number",
                  "minimum": 1
                },
                "weekDays": {
                  "type": "array",
                  "items": {
                    "enum": [
                      "Mon",
                      "Tue",
                      "Wed",
                      "Thu",
                      "Fri",
                      "Sat",
                      "Sun"
                    ],
                    "type": "string"
                  }
                }
              },
              "additionalProperties": false
            },
            "monitorTags": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "required": [
            "scope"
          ]
        }
      },
      {
        "name": "cancel_downtime",
        "description": "Cancel a scheduled downtime in Datadog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "downtimeId": {
              "type": "number"
            }
          },
          "required": [
            "downtimeId"
          ]
        }
      }
    ]
  },
  {
    "name": "wopal-cn-mcp-hotnews-server",
    "title": "@wopal/mcp-server-hotnews",
    "description": "A Model Context Protocol server that provides real-time hot trending topics from major Chinese social platforms and news sites.",
    "icon": "https://avatars.githubusercontent.com/wopal-cn",
    "isOfficial": true,
    "homepage": "https://github.com/wopal-cn/mcp-hotnews-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@wopal/mcp-server-hotnews"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_hot_news",
        "description": "Get hot trending lists from various platforms",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sources": {
              "type": "array",
              "items": {
                "type": "number",
                "maximum": 9,
                "minimum": 1
              },
              "description": "Available HotNews sources (ID: Platform):\n\n{ID: 1, Platform: \"Zhihu Hot List (知乎热榜)\"},\n{ID: 2, Platform: \"36Kr Hot List (36氪热榜)\"},\n{ID: 3, Platform: \"Baidu Hot Discussion (百度热点)\"},\n{ID: 4, Platform: \"Bilibili Hot List (B站热榜)\"},\n{ID: 5, Platform: \"Weibo Hot Search (微博热搜)\"},\n{ID: 6, Platform: \"Douyin Hot List (抖音热点)\"},\n{ID: 7, Platform: \"Hupu Hot List (虎扑热榜)\"},\n{ID: 8, Platform: \"Douban Hot List (豆瓣热榜)\"},\n{ID: 9, Platform: \"IT News (IT新闻)\"}\n\nExample usage:\n- [3]: Get Baidu Hot Discussion only\n- [1,3,7]: Get hot lists from zhihuHot, Baidu, and huPu\n- [1,2,3,4]: Get hot lists from zhihuHot, 36Kr, Baidu, and Bilibili"
            }
          },
          "required": [
            "sources"
          ]
        }
      }
    ]
  },
  {
    "name": "xiaok-etherscan-mcp",
    "title": "Etherscan MCP",
    "description": "An MCP server that provides access to Etherscan blockchain data APIs, allowing users to query Ethereum blockchain information through natural language.",
    "icon": "https://avatars.githubusercontent.com/xiaok",
    "isOfficial": false,
    "homepage": "https://github.com/xiaok/etherscan-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "etherscan-mcp"
      ],
      "env": {
        "ETHERSCAN_API_KEY": "<etherscan-api-key>"
      }
    },
    "parameters": [
      {
        "name": "ETHERSCAN_API_KEY",
        "description": "Your Etherscan API key",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "account__balance",
        "description": "Returns the Ether balance of a given address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "the `string` representing the address to check for balance"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "account__balancemulti",
        "description": "Get Ether Balance for Multiple Addresses in a Single Call",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "the `strings` representing the addresses to check for balance, separated by `,`\nup to **20 addresses** per call"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "account__txlist",
        "description": "Returns the list of 'Normal' Transactions By Address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "default": "1",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "sort": {
              "type": "string",
              "default": "asc",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "offset": {
              "type": "string",
              "default": "10",
              "description": "the number of transactions displayed per page"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the addresses to check for balance"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "endblock": {
              "type": "string",
              "default": "99999999",
              "description": "the `integer` block number to stop searching for transactions"
            },
            "startblock": {
              "type": "string",
              "default": "0",
              "description": "the `integer` block number to start searching for transactions"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "account__txlistinternal",
        "description": "Returns the list of 'Internal' Transactions by Address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "default": "1",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "sort": {
              "type": "string",
              "default": "asc",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "offset": {
              "type": "string",
              "default": "10",
              "description": "the number of transactions displayed per page"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to get internal txs for"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "endblock": {
              "type": "string",
              "default": "99999999",
              "description": "the `integer` block number to stop searching for transactions"
            },
            "startblock": {
              "type": "string",
              "default": "0",
              "description": "the `integer` block number to start searching for transactions"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "account__txlistinternal_byhash",
        "description": "Returns the list of 'Internal' Transactions by Transaction Hash",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txhash": {
              "type": "string",
              "description": "the `string` representing the transaction hash to get internal txs for"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            }
          },
          "required": [
            "txhash"
          ]
        }
      },
      {
        "name": "account__txlistinternal_byblock",
        "description": "Returns the list of 'Internal' Transactions by Block Range",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "default": "1",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "sort": {
              "type": "string",
              "default": "asc",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "offset": {
              "type": "string",
              "default": "10",
              "description": "the number of transactions displayed per page"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "endblock": {
              "type": "string",
              "description": "the `integer` block number to stop searching for transactions"
            },
            "startblock": {
              "type": "string",
              "description": "the `integer` block number to start searching for transactions"
            }
          },
          "required": [
            "startblock",
            "endblock"
          ]
        }
      },
      {
        "name": "account__tokentx",
        "description": "Returns the list of ERC20 Token Transfer Events by Address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "default": "1",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "sort": {
              "type": "string",
              "default": "asc",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "offset": {
              "type": "string",
              "default": "10",
              "description": "the number of transactions displayed per page"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to get token transfers for"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "endblock": {
              "type": "string",
              "default": "99999999",
              "description": "the `integer` block number to stop searching for transactions"
            },
            "startblock": {
              "type": "string",
              "default": "0",
              "description": "the `integer` block number to start searching for transactions"
            },
            "contractaddress": {
              "type": "string",
              "description": "the `string` representing the token contract address to check for balance"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "account__tokennfttx",
        "description": "Returns the list of ERC721 Token Transfer Events by Address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "default": "1",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "sort": {
              "type": "string",
              "default": "asc",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "offset": {
              "type": "string",
              "default": "10",
              "description": "the number of transactions displayed per page"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to get NFT transfers for"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "endblock": {
              "type": "string",
              "default": "99999999",
              "description": "the `integer` block number to stop searching for transactions"
            },
            "startblock": {
              "type": "string",
              "default": "0",
              "description": "the `integer` block number to start searching for transactions"
            },
            "contractaddress": {
              "type": "string",
              "description": "the `string` representing the NFT contract address to check for balance"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "account__token1155tx",
        "description": "Returns the list of ERC1155 Token Transfer Events by Address",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "default": "1",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "sort": {
              "type": "string",
              "default": "asc",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "offset": {
              "type": "string",
              "default": "10",
              "description": "the number of transactions displayed per page"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to get ERC1155 transfers for"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "endblock": {
              "type": "string",
              "default": "99999999",
              "description": "the `integer` block number to stop searching for transactions"
            },
            "startblock": {
              "type": "string",
              "default": "0",
              "description": "the `integer` block number to start searching for transactions"
            },
            "contractaddress": {
              "type": "string",
              "description": "the `string` representing the ERC1155 contract address to check for balance"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "account__fundedby",
        "description": "Returns the address that funded an address, and its relative age.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "the `string` representing the address that received funding"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "account__getminedblocks",
        "description": "Returns the list of blocks validated by an address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "default": "1",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "offset": {
              "type": "string",
              "default": "10",
              "description": "the number of blocks displayed per page"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to check for validated blocks"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "blocktype": {
              "type": "string",
              "default": "blocks",
              "description": "the `string` pre-defined block type, either `blocks` for canonical blocks or `uncles` for uncle blocks only"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "account__txsBeaconWithdrawal",
        "description": "Returns the beacon chain withdrawals made to an address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "default": "1",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "sort": {
              "type": "string",
              "default": "asc",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "offset": {
              "type": "string",
              "default": "100",
              "description": "the number of withdrawals displayed per page"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to check for beacon withdrawals"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "endblock": {
              "type": "string",
              "default": "99999999",
              "description": "the `integer` block number to stop searching for transactions"
            },
            "startblock": {
              "type": "string",
              "default": "0",
              "description": "the `integer` block number to start searching for transactions"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "contract__getabi",
        "description": "Returns the Contract Application Binary Interface ( ABI ) of a verified smart contract.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "the `contract address` that has a verified source code"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "contract__getsourcecode",
        "description": "Returns the Contract Source Code for Verified Contract Source Codes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "the `contract address` that has a verified source code"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "contract__getcontractcreation",
        "description": "Returns the Contract Creator and Creation Tx Hash.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "contractaddresses": {
              "type": "string",
              "description": "the `contract address` to check for contract creator and creation tx hash, up to 5 at a time"
            }
          },
          "required": [
            "contractaddresses"
          ]
        }
      },
      {
        "name": "contract__checkverifystatus",
        "description": "Returns the success or error status of a contract verification request.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "guid": {
              "type": "string",
              "description": "the unique `guid` received from the verification request"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "guid"
          ]
        }
      },
      {
        "name": "transaction__getstatus",
        "description": "Returns the status code of a contract execution.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txhash": {
              "type": "string",
              "description": "the `string` representing the transaction hash to check the execution status"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            }
          },
          "required": [
            "txhash"
          ]
        }
      },
      {
        "name": "transaction__gettxreceiptstatus",
        "description": "Returns the status code of a transaction execution.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txhash": {
              "type": "string",
              "description": "the `string` representing the transaction hash to check the execution status"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            }
          },
          "required": [
            "txhash"
          ]
        }
      },
      {
        "name": "block__getblockreward",
        "description": "Returns the block reward and 'Uncle' block rewards.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "blockno": {
              "type": "string",
              "description": "the `integer` block number to check block rewards for eg."
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            }
          },
          "required": [
            "blockno"
          ]
        }
      },
      {
        "name": "block__getblockcountdown",
        "description": "Returns the estimated time remaining, in seconds, until a certain block is mined.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "blockno": {
              "type": "string",
              "description": "the `integer` block number to estimate time remaining to be mined eg."
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            }
          },
          "required": [
            "blockno"
          ]
        }
      },
      {
        "name": "block__getblocknobytime",
        "description": "Returns the block number that was mined at a certain timestamp.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "closest": {
              "type": "string",
              "description": "the closest available block to the provided timestamp, either `before` or `after`"
            },
            "timestamp": {
              "type": "string",
              "description": "the `integer` representing the Unix timestamp in **seconds**."
            }
          },
          "required": [
            "timestamp",
            "closest"
          ]
        }
      },
      {
        "name": "block__getblocktxnscount",
        "description": "Returns the number of transactions in a specified block.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "blockno": {
              "type": "string",
              "description": "the `integer` block number to get the transaction count for, eg."
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            }
          },
          "required": [
            "blockno"
          ]
        }
      },
      {
        "name": "logs__getLogsByAddress",
        "description": "Returns the event logs from an address, with optional filtering by block range.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "default": "1",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "offset": {
              "type": "string",
              "default": "1000",
              "description": "the number of transactions displayed per page limited to **1000 records** per query, use the `page` parameter for subsequent records"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to check for logs"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "toBlock": {
              "type": "string",
              "description": "the `integer` block number to stop searching for logs eg. `12879196`"
            },
            "fromBlock": {
              "type": "string",
              "description": "the `integer` block number to start searching for logs eg. `12878196`"
            }
          },
          "required": [
            "address"
          ]
        }
      },
      {
        "name": "logs__getLogsByTopics",
        "description": "Returns the events log in a block range, filtered by topics.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "offset": {
              "type": "string",
              "description": "the number of transactions displayed per page limited to **1000 records** per query, use the `page` parameter for subsequent records"
            },
            "topic0": {
              "type": "string",
              "description": "the topic numbers to search for limited to`topic0`, `topic1`, `topic2`, `topic3`"
            },
            "topic1": {
              "type": "string",
              "description": "the topic numbers to search for limited to`topic0`, `topic1`, `topic2`, `topic3`"
            },
            "topic2": {
              "type": "string",
              "description": "the topic numbers to search for limited to`topic0`, `topic1`, `topic2`, `topic3`"
            },
            "topic3": {
              "type": "string",
              "description": "the topic numbers to search for limited to`topic0`, `topic1`, `topic2`, `topic3`"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "toBlock": {
              "type": "string",
              "description": "the `integer` block number to stop searching for logs eg. `12879196`"
            },
            "fromBlock": {
              "type": "string",
              "description": "the `integer` block number to start searching for logs eg. `12878196`"
            },
            "topic0_1_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            },
            "topic0_2_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            },
            "topic0_3_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            },
            "topic1_2_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            },
            "topic1_3_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            },
            "topic2_3_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            }
          },
          "required": [
            "fromBlock",
            "toBlock"
          ]
        }
      },
      {
        "name": "logs__getLogsByAddressAndTopics",
        "description": "Returns the event logs from an address, filtered by topics and block range.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "string",
              "description": "the `integer` page number, if pagination is enabled"
            },
            "offset": {
              "type": "string",
              "description": "the number of transactions displayed per page limited to **1000 records** per query, use the `page` parameter for subsequent records"
            },
            "topic0": {
              "type": "string",
              "description": "the topic numbers to search for limited to`topic0`, `topic1`, `topic2`, `topic3`"
            },
            "topic1": {
              "type": "string",
              "description": "the topic numbers to search for limited to`topic0`, `topic1`, `topic2`, `topic3`"
            },
            "topic2": {
              "type": "string",
              "description": "the topic numbers to search for limited to`topic0`, `topic1`, `topic2`, `topic3`"
            },
            "topic3": {
              "type": "string",
              "description": "the topic numbers to search for limited to`topic0`, `topic1`, `topic2`, `topic3`"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to check for logs"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "The chain id, default is 1"
            },
            "toBlock": {
              "type": "string",
              "description": "the `integer` block number to stop searching for logs eg. `12879196`"
            },
            "fromBlock": {
              "type": "string",
              "description": "the `integer` block number to start searching for logs eg. `12878196`"
            },
            "topic0_1_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            },
            "topic0_2_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            },
            "topic0_3_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            },
            "topic1_2_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            },
            "topic1_3_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            },
            "topic2_3_opr": {
              "type": "string",
              "description": "the topic operator when multiple topic combinations are used limited to `and` or `or`"
            }
          },
          "required": [
            "fromBlock",
            "toBlock",
            "address"
          ]
        }
      },
      {
        "name": "proxy__eth_blockNumber",
        "description": "Returns the number of most recent block.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          }
        }
      },
      {
        "name": "proxy__eth_getBlockByNumber",
        "description": "Returns information about a block by block number.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "the block number, in hex eg. `0xC36B3C`"
            },
            "boolean": {
              "type": "string",
              "description": "the `boolean` value to show full transaction objects. when `true`, returns full transaction objects and their information, when `false` only returns a list of transactions."
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "tag",
            "boolean"
          ]
        }
      },
      {
        "name": "proxy__eth_getUncleByBlockNumberAndIndex",
        "description": "Returns information about a uncle by block number.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "the block number, in hex eg. `0xC36B3C`"
            },
            "index": {
              "type": "string",
              "description": "the position of the uncle's index in the block, in hex eg. `0x5`"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "tag",
            "index"
          ]
        }
      },
      {
        "name": "proxy__eth_getBlockTransactionCountByNumber",
        "description": "Returns the number of transactions in a block.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "the block number, in hex eg. `0xC36B3C`"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "tag"
          ]
        }
      },
      {
        "name": "proxy__eth_getTransactionByHash",
        "description": "Returns information about a transaction requested by transaction hash.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txhash": {
              "type": "string",
              "description": "the `string` representing the hash of the transaction"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "txhash"
          ]
        }
      },
      {
        "name": "proxy__eth_getTransactionByBlockNumberAndIndex",
        "description": "Returns information about a transaction requested by block number and transaction index position.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "the block number, in hex eg. `0xC36B3C`"
            },
            "index": {
              "type": "string",
              "description": "the position of the uncle's index in the block, in hex eg. `0x5`"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "tag",
            "index"
          ]
        }
      },
      {
        "name": "proxy__eth_getTransactionCount",
        "description": "Returns the number of transactions performed by an address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "the `string` pre-defined block parameter, either `earliest`, `pending` or `latest`"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to get transaction count"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "address",
            "tag"
          ]
        }
      },
      {
        "name": "proxy__eth_getTransactionReceipt",
        "description": "Returns the receipt of a transaction that has been validated.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "txhash": {
              "type": "string",
              "description": "the `string` representing the hash of the transaction"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "txhash"
          ]
        }
      },
      {
        "name": "proxy__eth_call",
        "description": "Executes a new message call immediately without creating a transaction on the block chain.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "string",
              "description": "the `string` representing the address to interact with"
            },
            "tag": {
              "type": "string",
              "description": "the `string` pre-defined block parameter, either `earliest`, `pending` or `latest`"
            },
            "data": {
              "type": "string",
              "description": "the hash of the method signature and encoded parameters"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "to",
            "data",
            "tag"
          ]
        }
      },
      {
        "name": "proxy__eth_getCode",
        "description": "Returns code at a given address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "the `string` pre-defined block parameter, either `earliest`, `pending` or `latest`"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to get code"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          },
          "required": [
            "address",
            "tag"
          ]
        }
      },
      {
        "name": "proxy__eth_getStorageAt",
        "description": "Returns the value from a storage position at a given address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tag": {
              "type": "string",
              "description": "the `string` pre-defined block parameter, either `earliest`, `pending` or `latest`"
            },
            "address": {
              "type": "string",
              "description": "the `string` representing the address to get code"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "position": {
              "type": "string",
              "description": "the hex code of the position in storage, eg `0x0`"
            }
          },
          "required": [
            "address",
            "position",
            "tag"
          ]
        }
      },
      {
        "name": "proxy__eth_gasPrice",
        "description": "Returns the current price per gas in wei.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          }
        }
      },
      {
        "name": "proxy__eth_estimateGas",
        "description": "Makes a call or transaction, which won't be added to the blockchain and returns the used gas.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "to": {
              "type": "string",
              "description": "the `string` representing the address to interact with"
            },
            "gas": {
              "type": "string",
              "description": "the amount of gas provided for the transaction, in hex eg. `0x5f5e0ff`"
            },
            "data": {
              "type": "string",
              "description": "the hash of the method signature and encoded parameters"
            },
            "value": {
              "type": "string",
              "description": "the value sent in this transaction, in hex eg. `0xff22`"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "gasPrice": {
              "type": "string",
              "description": "the gas price paid for each unit of gas, in wei"
            }
          },
          "required": [
            "data",
            "to"
          ]
        }
      },
      {
        "name": "stats__tokensupply",
        "description": "Returns the current amount of an ERC-20 token in circulation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "contractaddress": {
              "type": "string",
              "description": "the `contract address` of the ERC-20 token"
            }
          },
          "required": [
            "contractaddress"
          ]
        }
      },
      {
        "name": "account__tokenbalance",
        "description": "Returns the current balance of an ERC-20 token of an address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "the `string` representing the address to check for token balance"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "contractaddress": {
              "type": "string",
              "description": "the `contract address` of the ERC-20 token"
            }
          },
          "required": [
            "contractaddress",
            "address"
          ]
        }
      },
      {
        "name": "gas__gasestimate",
        "description": "Returns the estimated time, in seconds, for a transaction to be confirmed on the blockchain.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "gasprice": {
              "type": "string",
              "description": "the price paid per unit of gas, in `wei`"
            }
          },
          "required": [
            "gasprice"
          ]
        }
      },
      {
        "name": "gas__gasoracle",
        "description": "Returns the current Safe, Proposed and Fast gas prices.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          }
        }
      },
      {
        "name": "stats__dailyavggaslimit",
        "description": "Returns the historical daily average gas limit of the Ethereum network.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "type": "string",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "enddate": {
              "type": "string",
              "description": "the ending date in `yyyy-MM-dd` format, eg. `2019-02-28`"
            },
            "startdate": {
              "type": "string",
              "description": "the starting date in `yyyy-MM-dd` format, eg. `2019-01-31`"
            }
          },
          "required": [
            "startdate",
            "enddate",
            "sort"
          ]
        }
      },
      {
        "name": "stats__ethsupply",
        "description": "Returns the current amount of Ether in circulation excluding ETH2 Staking rewards and EIP1559 burnt fees.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          }
        }
      },
      {
        "name": "stats__ethsupply2",
        "description": "Returns the current amount of Ether in circulation, ETH2 Staking rewards, EIP1559 burnt fees, and total withdrawn ETH from the beacon chain.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          }
        }
      },
      {
        "name": "stats__ethprice",
        "description": "Returns the latest price of 1 ETH.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          }
        }
      },
      {
        "name": "stats__chainsize",
        "description": "Returns the size of the Ethereum blockchain, in bytes, over a date range.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "type": "string",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "enddate": {
              "type": "string",
              "description": "the ending date in `yyyy-MM-dd` format, eg. `2019-02-28`"
            },
            "syncmode": {
              "type": "string",
              "description": "the type of node to run, either `default` or `archive`"
            },
            "startdate": {
              "type": "string",
              "description": "the starting date in `yyyy-MM-dd` format, eg. `2019-02-01`"
            },
            "clienttype": {
              "type": "string",
              "description": "the Ethereum node client to use, either `geth` or `parity`"
            }
          },
          "required": [
            "startdate",
            "enddate",
            "clienttype",
            "syncmode",
            "sort"
          ]
        }
      },
      {
        "name": "stats__nodecount",
        "description": "Returns the total number of discoverable Ethereum nodes.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            }
          }
        }
      },
      {
        "name": "stats__dailytxnfee",
        "description": "Returns the amount of transaction fees paid to miners per day.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "type": "string",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "enddate": {
              "type": "string",
              "description": "the ending date in `yyyy-MM-dd` format, eg. `2019-02-28`"
            },
            "startdate": {
              "type": "string",
              "description": "the starting date in `yyyy-MM-dd` format, eg. `2019-02-01`"
            }
          },
          "required": [
            "startdate",
            "enddate",
            "sort"
          ]
        }
      },
      {
        "name": "stats__dailynewaddress",
        "description": "Returns the number of new Ethereum addresses created per day.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "type": "string",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "enddate": {
              "type": "string",
              "description": "the ending date in `yyyy-MM-dd` format, eg. `2019-02-28`"
            },
            "startdate": {
              "type": "string",
              "description": "the starting date in `yyyy-MM-dd` format, eg. `2019-02-01`"
            }
          },
          "required": [
            "startdate",
            "enddate",
            "sort"
          ]
        }
      },
      {
        "name": "stats__dailynetutilization",
        "description": "Returns the daily average gas used over gas limit, in percentage.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "type": "string",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "enddate": {
              "type": "string",
              "description": "the ending date in `yyyy-MM-dd` format, eg. `2019-02-28`"
            },
            "startdate": {
              "type": "string",
              "description": "the starting date in `yyyy-MM-dd` format, eg. `2019-02-01`"
            }
          },
          "required": [
            "startdate",
            "enddate",
            "sort"
          ]
        }
      },
      {
        "name": "stats__dailyavghashrate",
        "description": "Returns the historical measure of processing power of the Ethereum network.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "type": "string",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "enddate": {
              "type": "string",
              "description": "the ending date in `yyyy-MM-dd` format, eg. `2019-02-28`"
            },
            "startdate": {
              "type": "string",
              "description": "the starting date in `yyyy-MM-dd` format, eg. `2019-02-01`"
            }
          },
          "required": [
            "startdate",
            "enddate",
            "sort"
          ]
        }
      },
      {
        "name": "stats__dailytx",
        "description": "Returns the number of transactions performed on the Ethereum blockchain per day.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "type": "string",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "enddate": {
              "type": "string",
              "description": "the ending date in `yyyy-MM-dd` format, eg. `2019-02-28`"
            },
            "startdate": {
              "type": "string",
              "description": "the starting date in `yyyy-MM-dd` format, eg. `2019-02-01`"
            }
          },
          "required": [
            "startdate",
            "enddate",
            "sort"
          ]
        }
      },
      {
        "name": "stats__dailyavgnetdifficulty",
        "description": "Returns the historical mining difficulty of the Ethereum network.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "type": "string",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "enddate": {
              "type": "string",
              "description": "the ending date in `yyyy-MM-dd` format, eg. `2019-02-28`"
            },
            "startdate": {
              "type": "string",
              "description": "the starting date in `yyyy-MM-dd` format, eg. `2019-02-01`"
            }
          },
          "required": [
            "startdate",
            "enddate",
            "sort"
          ]
        }
      },
      {
        "name": "stats__ethdailyprice",
        "description": "Returns the historical price of 1 ETH.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "sort": {
              "type": "string",
              "description": "the sorting preference, use `asc` to sort by ascending and `desc` to sort by descending"
            },
            "chainid": {
              "type": "string",
              "default": "1",
              "description": "chain id, default 1 ( Ethereum )"
            },
            "enddate": {
              "type": "string",
              "description": "the ending date in `yyyy-MM-dd` format, eg. `2019-02-28`"
            },
            "startdate": {
              "type": "string",
              "description": "the starting date in `yyyy-MM-dd` format, eg. `2019-02-01`"
            }
          },
          "required": [
            "startdate",
            "enddate",
            "sort"
          ]
        }
      }
    ]
  },
  {
    "name": "xiaolaa2-ableton-copilot-mcp",
    "title": "Ableton Copilot MCP",
    "description": "A Model Context Protocol server that enables real-time interaction with Ableton Live, allowing AI assistants to control song creation, track management, clip operations, and audio recording workflows.",
    "icon": "https://avatars.githubusercontent.com/xiaolaa2",
    "isOfficial": false,
    "homepage": "https://github.com/xiaolaa2/ableton-copilot-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "ableton-copilot-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "list_resources",
        "description": "List Ableton live Browser resources of specified type",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "audio_effects",
                "instruments",
                "plugins",
                "samples",
                "drums",
                "midi_effects",
                "sounds"
              ],
              "type": "string",
              "description": "[string] resources type"
            }
          },
          "required": [
            "type"
          ]
        }
      },
      {
        "name": "load_device",
        "description": "Load a resource which is loadable (audio effect/instrument/plugin/drums/midi effect/sounds) into a track.\n        If track_id is not provided, will load to currently selected track.\n        If no track is selected, instruments will be loaded to the last MIDI track, \n        and audio effects will be loaded to the last MIDI or audio track.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "track_id": {
              "type": "string",
              "description": "[string] track id to load item to"
            },
            "device_id": {
              "type": "string",
              "description": "[string] id of device to load"
            }
          },
          "required": [
            "device_id"
          ]
        }
      },
      {
        "name": "get_clip_properties",
        "description": "Get clip properties by clip id. To get specific properties, set the corresponding property name to true in the properties parameter.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clip_id": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "properties": {
                "gain": {
                  "type": "boolean"
                },
                "name": {
                  "type": "boolean"
                },
                "color": {
                  "type": "boolean"
                },
                "muted": {
                  "type": "boolean"
                },
                "notes": {
                  "type": "boolean"
                },
                "length": {
                  "type": "boolean"
                },
                "looping": {
                  "type": "boolean"
                },
                "warping": {
                  "type": "boolean"
                },
                "end_time": {
                  "type": "boolean"
                },
                "loop_end": {
                  "type": "boolean"
                },
                "position": {
                  "type": "boolean"
                },
                "ram_mode": {
                  "type": "boolean"
                },
                "file_path": {
                  "type": "boolean"
                },
                "warp_mode": {
                  "type": "boolean"
                },
                "end_marker": {
                  "type": "boolean"
                },
                "is_playing": {
                  "type": "boolean"
                },
                "loop_start": {
                  "type": "boolean"
                },
                "pitch_fine": {
                  "type": "boolean"
                },
                "start_time": {
                  "type": "boolean"
                },
                "color_index": {
                  "type": "boolean"
                },
                "launch_mode": {
                  "type": "boolean"
                },
                "is_midi_clip": {
                  "type": "boolean"
                },
                "is_recording": {
                  "type": "boolean"
                },
                "is_triggered": {
                  "type": "boolean"
                },
                "pitch_coarse": {
                  "type": "boolean"
                },
                "start_marker": {
                  "type": "boolean"
                },
                "warp_markers": {
                  "type": "boolean"
                },
                "has_envelopes": {
                  "type": "boolean"
                },
                "is_audio_clip": {
                  "type": "boolean"
                },
                "sample_length": {
                  "type": "boolean"
                },
                "is_overdubbing": {
                  "type": "boolean"
                },
                "selected_notes": {
                  "type": "boolean"
                },
                "velocity_amount": {
                  "type": "boolean"
                },
                "playing_position": {
                  "type": "boolean"
                },
                "gain_display_string": {
                  "type": "boolean"
                },
                "is_arrangement_clip": {
                  "type": "boolean"
                },
                "launch_quantization": {
                  "type": "boolean"
                },
                "signature_numerator": {
                  "type": "boolean"
                },
                "available_warp_modes": {
                  "type": "boolean"
                },
                "will_record_on_start": {
                  "type": "boolean"
                },
                "signature_denominator": {
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "clip_id",
            "properties"
          ]
        }
      },
      {
        "name": "get_clip_notes",
        "description": "Get clip notes by clip id. Returns NoteExtended array for Live 11+ and Note array for Live 10 and below",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clip_id": {
              "type": "string"
            },
            "from_time": {
              "type": "number"
            },
            "time_span": {
              "type": "number"
            },
            "from_pitch": {
              "type": "number",
              "maximum": 127,
              "minimum": 0
            },
            "pitch_span": {
              "type": "number"
            }
          },
          "required": [
            "clip_id",
            "from_pitch",
            "from_time",
            "time_span",
            "pitch_span"
          ]
        }
      },
      {
        "name": "remove_clip_notes",
        "description": "Remove clip notes by clip id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clip_id": {
              "type": "string"
            },
            "from_time": {
              "type": "number"
            },
            "time_span": {
              "type": "number",
              "description": "The number of beats to remove. Must be a value greater than 0."
            },
            "from_pitch": {
              "type": "number",
              "maximum": 127,
              "minimum": 0
            },
            "pitch_span": {
              "type": "number",
              "description": "The number of semitones to remove. Must be a value greater than 0."
            }
          },
          "required": [
            "clip_id",
            "from_pitch",
            "pitch_span",
            "from_time",
            "time_span"
          ]
        }
      },
      {
        "name": "remove_notes_by_ids",
        "description": "Remove notes by clip id and note ids",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clip_id": {
              "type": "string"
            },
            "note_ids": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "note ids, get from get_clip_notes"
            }
          },
          "required": [
            "clip_id",
            "note_ids"
          ]
        }
      },
      {
        "name": "add_notes_to_clip",
        "description": "Add notes to clip by clip id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notes": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "time": {
                    "type": "number",
                    "description": "[float] the note start time in beats of absolute clip time."
                  },
                  "muted": {
                    "type": "boolean",
                    "default": false,
                    "description": "[bool] true = the note is deactivated (false by default)."
                  },
                  "pitch": {
                    "type": "number",
                    "maximum": 127,
                    "minimum": 0,
                    "description": "[int] the MIDI note number, 0...127, 60 is C3."
                  },
                  "duration": {
                    "type": "number",
                    "description": "[float] the note length in beats."
                  },
                  "velocity": {
                    "type": "number",
                    "default": 100,
                    "maximum": 127,
                    "minimum": 0,
                    "description": "[float] the note velocity, 0 ... 127 (100 by default)."
                  }
                },
                "additionalProperties": false
              },
              "description": "[array] the notes to add."
            },
            "clip_id": {
              "type": "string"
            }
          },
          "required": [
            "notes",
            "clip_id"
          ]
        }
      },
      {
        "name": "modify_clip_notes",
        "description": "Modify clip notes by clip id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notes": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "mute": {
                    "type": "boolean",
                    "default": false,
                    "description": "[bool] true = the note is deactivated (false by default)."
                  },
                  "pitch": {
                    "type": "number",
                    "maximum": 127,
                    "minimum": 0,
                    "description": "[int] the MIDI note number, 0...127, 60 is C3."
                  },
                  "note_id": {
                    "type": "number"
                  },
                  "duration": {
                    "type": "number",
                    "description": "[float] the note length in beats."
                  },
                  "velocity": {
                    "type": "number",
                    "default": 100,
                    "maximum": 127,
                    "minimum": 0,
                    "description": "[float] the note velocity, 0 ... 127 (100 by default)."
                  },
                  "start_time": {
                    "type": "number",
                    "description": "[float] the note start time in beats of absolute clip time."
                  },
                  "probability": {
                    "type": "number",
                    "default": 1,
                    "maximum": 1,
                    "minimum": 0,
                    "description": " [float] the chance that the note will be played:\n        1.0 = the note is always played;\n        0.0 = the note is never played."
                  },
                  "release_velocity": {
                    "type": "number",
                    "default": 64,
                    "description": "[float] the note release velocity."
                  },
                  "velocity_deviation": {
                    "type": "number",
                    "default": 0,
                    "description": "[float] the range of velocity values at which the note can be played:\n        0.0 = no deviation; the note will always play at the velocity specified by the velocity property\n        -127.0 to 127.0 = the note will be assigned a velocity value between velocity and velocity + velocity_deviation, inclusive; \n        if the resulting range exceeds the limits of MIDI velocity (0 to 127), then it will be clamped within those limits."
                  }
                },
                "additionalProperties": false
              },
              "description": "[array] the notes to modify."
            },
            "clip_id": {
              "type": "string"
            }
          },
          "required": [
            "notes",
            "clip_id"
          ]
        }
      },
      {
        "name": "replace_clip_notes",
        "description": "Replace all notes in the clip with new notes",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notes": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "time": {
                    "type": "number",
                    "description": "[float] the note start time in beats of absolute clip time."
                  },
                  "muted": {
                    "type": "boolean",
                    "default": false,
                    "description": "[bool] true = the note is deactivated (false by default)."
                  },
                  "pitch": {
                    "type": "number",
                    "maximum": 127,
                    "minimum": 0,
                    "description": "[int] the MIDI note number, 0...127, 60 is C3."
                  },
                  "duration": {
                    "type": "number",
                    "description": "[float] the note length in beats."
                  },
                  "velocity": {
                    "type": "number",
                    "default": 100,
                    "maximum": 127,
                    "minimum": 0,
                    "description": "[float] the note velocity, 0 ... 127 (100 by default)."
                  }
                },
                "additionalProperties": false
              },
              "description": "[array] The new notes to replace existing notes with"
            },
            "clip_id": {
              "type": "string"
            },
            "notes_extended": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "mute": {
                    "type": "boolean",
                    "default": false,
                    "description": "[bool] true = the note is deactivated (false by default)."
                  },
                  "pitch": {
                    "type": "number",
                    "maximum": 127,
                    "minimum": 0,
                    "description": "[int] the MIDI note number, 0...127, 60 is C3."
                  },
                  "note_id": {
                    "type": "number"
                  },
                  "duration": {
                    "type": "number",
                    "description": "[float] the note length in beats."
                  },
                  "velocity": {
                    "type": "number",
                    "default": 100,
                    "maximum": 127,
                    "minimum": 0,
                    "description": "[float] the note velocity, 0 ... 127 (100 by default)."
                  },
                  "start_time": {
                    "type": "number",
                    "description": "[float] the note start time in beats of absolute clip time."
                  },
                  "probability": {
                    "type": "number",
                    "default": 1,
                    "maximum": 1,
                    "minimum": 0,
                    "description": " [float] the chance that the note will be played:\n        1.0 = the note is always played;\n        0.0 = the note is never played."
                  },
                  "release_velocity": {
                    "type": "number",
                    "default": 64,
                    "description": "[float] the note release velocity."
                  },
                  "velocity_deviation": {
                    "type": "number",
                    "default": 0,
                    "description": "[float] the range of velocity values at which the note can be played:\n        0.0 = no deviation; the note will always play at the velocity specified by the velocity property\n        -127.0 to 127.0 = the note will be assigned a velocity value between velocity and velocity + velocity_deviation, inclusive; \n        if the resulting range exceeds the limits of MIDI velocity (0 to 127), then it will be clamped within those limits."
                  }
                },
                "additionalProperties": false
              },
              "description": "[array] Extended note data (Live 11+ only)"
            }
          },
          "required": [
            "clip_id"
          ]
        }
      },
      {
        "name": "set_clips_property",
        "description": "batch set clip property",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clips": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "clip_id",
                  "property"
                ],
                "properties": {
                  "clip_id": {
                    "type": "string"
                  },
                  "property": {
                    "type": "object",
                    "properties": {
                      "gain": {
                        "type": "number"
                      },
                      "name": {
                        "type": "string"
                      },
                      "color": {
                        "type": "number",
                        "description": "The RGB value of the track's color in \n        the form 0x00RRGGBB or (2^16 * red) + (2^8 * green) + blue, where red, \n        green and blue are values from 0 (dark) to 255 (light). Example: Red is (2^16 * 255) = 16711680"
                      },
                      "muted": {
                        "type": "boolean"
                      },
                      "looping": {
                        "type": "boolean",
                        "description": "true = clip is looped. Unwarped audio cannot be looped."
                      },
                      "warping": {
                        "type": "boolean",
                        "description": "Available for audio clips only."
                      },
                      "loop_end": {
                        "type": "number",
                        "description": "[float] For looped clips: loop end. For unlooped clips: clip end."
                      },
                      "position": {
                        "type": "number",
                        "description": "[float] Get and set the clip's loop position. \n        The value will always equal loop_start, \n        however setting this property, unlike setting loop_start, preserves the loop length"
                      },
                      "ram_mode": {
                        "type": "boolean"
                      },
                      "warp_mode": {
                        "type": "number",
                        "description": "[int] The Warp Mode of the clip as an integer index. Available Warp Modes are:\n        0 = Beats Mode\n        1 = Tones Mode\n        2 = Texture Mode\n        3 = Re-Pitch Mode\n        4 = Complex Mode\n        5 = REX Mode\n        6 = Complex Pro Mode\n        Available for audio clips only."
                      },
                      "end_marker": {
                        "type": "number"
                      },
                      "is_playing": {
                        "type": "boolean"
                      },
                      "loop_start": {
                        "type": "number",
                        "description": "[float] For looped clips: loop start.\n        loop_start and loop_end are in absolute clip beat time if clip is MIDI or warped. \n        The 1.1.1 position has beat time 0. If the clip is unwarped audio, they are given in seconds, \n        0 is the time of the first sample in the audio material."
                      },
                      "pitch_fine": {
                        "type": "number",
                        "description": "[float] Extra pitch shift in cents (\"Detune\"), -50 ... 49.\nAvailable for audio clips only."
                      },
                      "launch_mode": {
                        "type": "number"
                      },
                      "pitch_coarse": {
                        "type": "number",
                        "description": "[int] Pitch shift in semitones (\"Transpose\"), -48 ... 48.\nAvailable for audio clips only."
                      },
                      "start_marker": {
                        "type": "number",
                        "description": "[float] The start marker of the clip in beats, \n        independent of the loop state. Cannot be set behind the end marker"
                      },
                      "velocity_amount": {
                        "type": "number"
                      },
                      "launch_quantization": {
                        "type": "number"
                      },
                      "signature_numerator": {
                        "type": "number"
                      },
                      "signature_denominator": {
                        "type": "number"
                      }
                    },
                    "additionalProperties": false
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "clips"
          ]
        }
      },
      {
        "name": "crop_clip",
        "description": "Crops the clip. The region that is cropped depends on whether the clip is looped or not. \n            If looped, the region outside of the loop is removed. If not looped, \n            the region outside the start and end markers is removed.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clip_id": {
              "type": "string"
            }
          },
          "required": [
            "clip_id"
          ]
        }
      },
      {
        "name": "duplicate_clip_loop",
        "description": "Makes the loop twice as long and duplicates notes and envelopes. \n        Duplicates the clip start/end range if the clip is not looped.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clip_id": {
              "type": "string"
            }
          },
          "required": [
            "clip_id"
          ]
        }
      },
      {
        "name": "duplicate_clip_region",
        "description": "Duplicates the notes in the specified region to the destination_time.\n            Only notes of the specified pitch are duplicated if pitch is not -1.\n            If the transposition_amount is not 0, the notes in the region will be\n            transposed by the transposition_amount of semitones.\n            Raises an error on audio clips..",
        "inputSchema": {
          "type": "object",
          "properties": {
            "pitch": {
              "type": "number"
            },
            "clip_id": {
              "type": "string"
            },
            "region_end": {
              "type": "number"
            },
            "region_start": {
              "type": "number"
            },
            "destination_time": {
              "type": "number"
            },
            "transposition_amount": {
              "type": "number"
            }
          },
          "required": [
            "clip_id",
            "region_start",
            "region_end",
            "destination_time",
            "pitch",
            "transposition_amount"
          ]
        }
      },
      {
        "name": "get_device_properties",
        "description": "get device properties. To get specific properties, set the corresponding property name to true in the properties parameter",
        "inputSchema": {
          "type": "object",
          "properties": {
            "device_id": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "boolean"
                },
                "type": {
                  "type": "boolean"
                },
                "is_active": {
                  "type": "boolean"
                },
                "class_name": {
                  "type": "boolean"
                },
                "parameters": {
                  "type": "boolean"
                },
                "can_have_chains": {
                  "type": "boolean"
                },
                "can_have_drum_pads": {
                  "type": "boolean"
                },
                "class_display_name": {
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "device_id",
            "properties"
          ]
        }
      },
      {
        "name": "modify_device_parameter_value",
        "description": "set device parameter value, only support built-in Live devices",
        "inputSchema": {
          "type": "object",
          "properties": {
            "value": {
              "type": "number"
            },
            "parameter_id": {
              "type": "string",
              "description": "parameter id, get from get_device_properties"
            }
          },
          "required": [
            "parameter_id",
            "value"
          ]
        }
      },
      {
        "name": "get_operation_histories",
        "description": "get mcp tools operation histories by page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "page": {
              "type": "number"
            },
            "page_size": {
              "type": "number"
            }
          },
          "required": [
            "page",
            "page_size"
          ]
        }
      },
      {
        "name": "get_snapshot_by_history_id",
        "description": "get snapshot by history id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "history_id": {
              "type": "number",
              "description": "The id of the operation history. Must be a value greater than 0."
            }
          },
          "required": [
            "history_id"
          ]
        }
      },
      {
        "name": "rollback_by_history_id",
        "description": "rollback to the state before the operation corresponding to the history_id was executed, \n        currently supports Note operations",
        "inputSchema": {
          "type": "object",
          "properties": {
            "history_id": {
              "type": "number",
              "description": "The id of the operation history."
            }
          },
          "required": [
            "history_id"
          ]
        }
      },
      {
        "name": "get_song_properties",
        "description": "get song properties. To get specific properties, set the corresponding property name to true in the properties parameter.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "loop": {
              "type": "boolean"
            },
            "name": {
              "type": "boolean"
            },
            "tempo": {
              "type": "boolean"
            },
            "scenes": {
              "type": "boolean"
            },
            "tracks": {
              "type": "boolean"
            },
            "overdub": {
              "type": "boolean"
            },
            "can_redo": {
              "type": "boolean"
            },
            "can_undo": {
              "type": "boolean"
            },
            "nudge_up": {
              "type": "boolean"
            },
            "punch_in": {
              "type": "boolean"
            },
            "metronome": {
              "type": "boolean"
            },
            "punch_out": {
              "type": "boolean"
            },
            "root_note": {
              "type": "boolean"
            },
            "cue_points": {
              "type": "boolean"
            },
            "is_playing": {
              "type": "boolean"
            },
            "loop_start": {
              "type": "boolean"
            },
            "nudge_down": {
              "type": "boolean"
            },
            "scale_name": {
              "type": "boolean"
            },
            "loop_length": {
              "type": "boolean"
            },
            "record_mode": {
              "type": "boolean"
            },
            "song_length": {
              "type": "boolean"
            },
            "master_track": {
              "type": "boolean"
            },
            "swing_amount": {
              "type": "boolean"
            },
            "exclusive_arm": {
              "type": "boolean"
            },
            "groove_amount": {
              "type": "boolean"
            },
            "return_tracks": {
              "type": "boolean"
            },
            "exclusive_solo": {
              "type": "boolean"
            },
            "is_counting_in": {
              "type": "boolean"
            },
            "session_record": {
              "type": "boolean"
            },
            "visible_tracks": {
              "type": "boolean"
            },
            "last_event_time": {
              "type": "boolean"
            },
            "appointed_device": {
              "type": "boolean"
            },
            "back_to_arranger": {
              "type": "boolean"
            },
            "can_capture_midi": {
              "type": "boolean"
            },
            "select_on_launch": {
              "type": "boolean"
            },
            "count_in_duration": {
              "type": "boolean"
            },
            "current_song_time": {
              "type": "boolean"
            },
            "arrangement_overdub": {
              "type": "boolean"
            },
            "signature_numerator": {
              "type": "boolean"
            },
            "can_jump_to_next_cue": {
              "type": "boolean"
            },
            "can_jump_to_prev_cue": {
              "type": "boolean"
            },
            "session_record_status": {
              "type": "boolean"
            },
            "signature_denominator": {
              "type": "boolean"
            },
            "tempo_follower_enabled": {
              "type": "boolean"
            },
            "clip_trigger_quantization": {
              "type": "boolean"
            },
            "session_automation_record": {
              "type": "boolean"
            },
            "midi_recording_quantization": {
              "type": "boolean"
            },
            "re_enable_automation_enabled": {
              "type": "boolean"
            }
          }
        }
      },
      {
        "name": "get_song_view_properties",
        "description": "get song view properties. To get specific properties, set the corresponding property name to true in the properties parameter.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "draw_mode": {
              "type": "boolean",
              "description": "[boolean] whether in draw mode"
            },
            "detail_clip": {
              "type": "boolean",
              "description": "[RawClip] details of currently selected clip"
            },
            "follow_song": {
              "type": "boolean",
              "description": "[boolean] whether following playback position"
            },
            "selected_chain": {
              "type": "boolean",
              "description": "[any] currently selected device chain"
            },
            "selected_scene": {
              "type": "boolean",
              "description": "[RawScene] currently selected scene"
            },
            "selected_track": {
              "type": "boolean",
              "description": "[RawTrack] currently selected track"
            },
            "selected_parameter": {
              "type": "boolean",
              "description": "[RawDeviceParameter] currently selected device parameter"
            },
            "highlighted_clip_slot": {
              "type": "boolean",
              "description": "[RawClipSlot] currently highlighted clip slot"
            }
          }
        }
      },
      {
        "name": "set_song_property",
        "description": "set song basic properties",
        "inputSchema": {
          "type": "object",
          "properties": {
            "loop": {
              "type": "boolean",
              "description": "true = arrangement loop is enabled"
            },
            "tempo": {
              "type": "number",
              "description": "[float] the tempo of the song in BPM"
            },
            "is_playing": {
              "type": "boolean",
              "description": "true = song is currently playing"
            },
            "loop_start": {
              "type": "number",
              "description": "[float] start of the arrangement loop in beats"
            },
            "loop_length": {
              "type": "number",
              "description": "[float] length of the arrangement loop in beats"
            },
            "record_mode": {
              "type": "number",
              "description": "[int] 1 = the Arrangement Record button is on."
            },
            "song_length": {
              "type": "number",
              "description": "[float] the length of the song in beats"
            },
            "swing_amount": {
              "type": "number",
              "description": "[float] The amount of swing applied"
            },
            "exclusive_arm": {
              "type": "number",
              "description": "[int] The exclusive arm state"
            },
            "groove_amount": {
              "type": "number",
              "description": "[float] The amount of groove applied"
            },
            "exclusive_solo": {
              "type": "number",
              "description": "[int] The exclusive solo state"
            },
            "is_counting_in": {
              "type": "boolean",
              "description": "[boolean] true = count-in is active"
            },
            "count_in_duration": {
              "type": "number",
              "description": "[float] The duration of count-in in beats"
            },
            "current_song_time": {
              "type": "number",
              "description": "[float] the current song time in beats"
            },
            "clip_trigger_quantization": {
              "enum": [
                "q_8_bars",
                "q_4_bars",
                "q_2_bars",
                "q_bar",
                "q_half",
                "q_half_triplet",
                "q_quarter",
                "q_quarter_triplet",
                "q_eight",
                "q_eight_triplet",
                "q_sixtenth",
                "q_sixtenth_triplet",
                "q_thirtytwoth",
                "q_no_q"
              ],
              "type": "string",
              "description": "[enum] The quantization value for clip triggering"
            },
            "midi_recording_quantization": {
              "enum": [
                "rec_q_eight",
                "rec_q_eight_eight_triplet",
                "rec_q_eight_triplet",
                "rec_q_no_q",
                "rec_q_quarter",
                "rec_q_sixtenth",
                "rec_q_sixtenth_sixtenth_triplet",
                "rec_q_sixtenth_triplet",
                "rec_q_thirtysecond"
              ],
              "type": "string",
              "description": "[enum] The quantization value for MIDI recording"
            },
            "re_enable_automation_enabled": {
              "type": "number",
              "description": "[int] The state of re-enable automation feature"
            }
          }
        }
      },
      {
        "name": "set_song_view_property",
        "description": "set song view properties",
        "inputSchema": {
          "type": "object",
          "properties": {
            "draw_mode": {
              "type": "boolean",
              "description": "[boolean] whether in draw mode"
            },
            "detail_clip": {
              "type": "string",
              "description": "[string] clip id to select"
            },
            "follow_song": {
              "type": "boolean",
              "description": "[boolean] whether following playback position"
            },
            "selected_scene": {
              "type": "string",
              "description": "[string] scene id to select"
            },
            "selected_track": {
              "type": "string",
              "description": "[string] track id to select"
            },
            "highlighted_clip_slot": {
              "type": "number",
              "description": "[RawClipSlot] currently highlighted clip slot"
            }
          }
        }
      },
      {
        "name": "create_track",
        "description": "create track and return raw track",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "return",
                "audio",
                "midi"
              ],
              "type": "string",
              "description": "the type of track, \"return\", \"audio\", \"midi\""
            },
            "index": {
              "type": "number",
              "default": 0,
              "description": "[int] index of track default 0, range [0, track count]"
            }
          },
          "required": [
            "type"
          ]
        }
      },
      {
        "name": "delete_track",
        "description": "delete track by index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "enum": [
                "return",
                "audio",
                "midi"
              ],
              "type": "string",
              "description": "the type of track, \"return\", \"audio\", \"midi\""
            },
            "index": {
              "type": "number",
              "description": "[int] index of track"
            }
          },
          "required": [
            "index",
            "type"
          ]
        }
      },
      {
        "name": "duplicate_track",
        "description": "duplicate midi or audio track by index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "index": {
              "type": "number",
              "description": "[int] index of track"
            }
          },
          "required": [
            "index"
          ]
        }
      },
      {
        "name": "record_by_time_range",
        "description": "Opens Ableton's audio record button and starts playback from start_time to end_time. \n            Before recording, please:\n            ENSURE: \n            1. Set the recording track to record mode\n            2. Set the recording track's input routing to Resample or a specific audio track/input routing(get from get_track_available_input_routings tool)\n            3. After recording, disable the track's record mode",
        "inputSchema": {
          "type": "object",
          "properties": {
            "end_time": {
              "type": "number",
              "description": "[int] end time of record"
            },
            "start_time": {
              "type": "number",
              "description": "[float] the time in beats of absolute clip time. such as 4 is 4 beats"
            }
          },
          "required": [
            "start_time",
            "end_time"
          ]
        }
      },
      {
        "name": "get_track_properties",
        "description": "get track properties. To get specific properties, set the corresponding property name to true in the properties parameter",
        "inputSchema": {
          "type": "object",
          "properties": {
            "track_id": {
              "type": "string"
            },
            "properties": {
              "type": "object",
              "properties": {
                "arm": {
                  "type": "boolean"
                },
                "mute": {
                  "type": "boolean"
                },
                "name": {
                  "type": "boolean"
                },
                "solo": {
                  "type": "boolean"
                },
                "color": {
                  "type": "boolean"
                },
                "devices": {
                  "type": "boolean"
                },
                "is_frozen": {
                  "type": "boolean"
                },
                "fold_state": {
                  "type": "boolean"
                },
                "is_grouped": {
                  "type": "boolean"
                },
                "is_visible": {
                  "type": "boolean"
                },
                "is_foldable": {
                  "type": "boolean"
                },
                "can_be_armed": {
                  "type": "boolean"
                },
                "implicit_arm": {
                  "type": "boolean"
                },
                "mixer_device": {
                  "type": "boolean"
                },
                "can_be_frozen": {
                  "type": "boolean"
                },
                "has_midi_input": {
                  "type": "boolean"
                },
                "muted_via_solo": {
                  "type": "boolean"
                },
                "can_show_chains": {
                  "type": "boolean"
                },
                "has_audio_input": {
                  "type": "boolean"
                },
                "has_midi_output": {
                  "type": "boolean"
                },
                "canonical_parent": {
                  "type": "boolean"
                },
                "fired_slot_index": {
                  "type": "boolean"
                },
                "has_audio_output": {
                  "type": "boolean"
                },
                "input_meter_left": {
                  "type": "boolean"
                },
                "arrangement_clips": {
                  "type": "boolean"
                },
                "input_meter_level": {
                  "type": "boolean"
                },
                "input_meter_right": {
                  "type": "boolean"
                },
                "is_showing_chains": {
                  "type": "boolean"
                },
                "output_meter_left": {
                  "type": "boolean"
                },
                "output_meter_level": {
                  "type": "boolean"
                },
                "output_meter_right": {
                  "type": "boolean"
                },
                "playing_slot_index": {
                  "type": "boolean"
                },
                "is_part_of_selection": {
                  "type": "boolean"
                },
                "current_input_routing": {
                  "type": "boolean"
                },
                "current_output_routing": {
                  "type": "boolean"
                },
                "current_monitoring_state": {
                  "type": "boolean"
                },
                "current_input_sub_routing": {
                  "type": "boolean"
                },
                "current_output_sub_routing": {
                  "type": "boolean"
                },
                "available_input_routing_types": {
                  "type": "boolean"
                },
                "available_output_routing_types": {
                  "type": "boolean"
                },
                "available_input_routing_channels": {
                  "type": "boolean"
                },
                "available_output_routing_channels": {
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            }
          },
          "required": [
            "track_id",
            "properties"
          ]
        }
      },
      {
        "name": "create_midi_clip",
        "description": "Creates an empty MIDI clip on the track and returns the created clip information",
        "inputSchema": {
          "type": "object",
          "properties": {
            "time": {
              "type": "number",
              "description": "[float] the time in beats of absolute clip time. such as 4 is 4 beats"
            },
            "length": {
              "type": "number",
              "description": "Length is given in beats and must be a greater value than 0.0."
            },
            "track_id": {
              "type": "string"
            }
          },
          "required": [
            "track_id",
            "length",
            "time"
          ]
        }
      },
      {
        "name": "set_tracks_property",
        "description": "batch set tracks property",
        "inputSchema": {
          "type": "object",
          "properties": {
            "tracks": {
              "type": "array",
              "items": {
                "type": "object",
                "required": [
                  "track_id",
                  "property"
                ],
                "properties": {
                  "property": {
                    "type": "object",
                    "properties": {
                      "arm": {
                        "type": "boolean",
                        "description": "true = track is armed for recording. [not in return/master tracks]"
                      },
                      "mute": {
                        "type": "boolean"
                      },
                      "name": {
                        "type": "string"
                      },
                      "solo": {
                        "type": "boolean",
                        "description": "solo = true = track is soloed. "
                      },
                      "color": {
                        "type": "number",
                        "description": "The RGB value of the track's color in \n        the form 0x00RRGGBB or (2^16 * red) + (2^8 * green) + blue, where red, \n        green and blue are values from 0 (dark) to 255 (light). Example: Red is (2^16 * 255) = 16711680"
                      },
                      "fold_state": {
                        "type": "number",
                        "description": "0 = tracks within the Group Track are visible, \n        1 = Group Track is folded and the tracks within the Group Track are hidden[only available if is_foldable = 1"
                      },
                      "implicit_arm": {
                        "type": "boolean"
                      },
                      "mixer_device": {
                        "type": "object",
                        "properties": {
                          "volume": {
                            "type": "number",
                            "maximum": 1,
                            "minimum": 0,
                            "description": "[float] the volume of the device, \n        linear range 0.0 to 1.0. 0.0 is approx -69 dB (mute), 1.0 is +6 dB."
                          },
                          "panning": {
                            "type": "number",
                            "maximum": 1,
                            "minimum": -1,
                            "description": "[float] the pan of the device, -1... 1"
                          },
                          "panning_mode": {
                            "type": "number",
                            "description": "[int] Access to the \n        Track mixer's pan mode: 0 = Stereo, 1 = Split Stereo.."
                          },
                          "track_activator": {
                            "type": "number",
                            "description": "[int] track activation state, 0 = track disabled, 1 = track enabled"
                          },
                          "left_split_stereo": {
                            "type": "number",
                            "maximum": 1,
                            "minimum": 0,
                            "description": "[float] the stereo split of the device, -1... 1. Only works when panning_mode is \"Split Stereo\""
                          },
                          "right_split_stereo": {
                            "type": "number",
                            "maximum": 1,
                            "minimum": 0,
                            "description": "[float] the stereo split of the device, -1... 1. Only works when panning_mode is \"Split Stereo\""
                          }
                        },
                        "additionalProperties": false
                      },
                      "fired_slot_index": {
                        "type": "number"
                      },
                      "is_showing_chains": {
                        "type": "number"
                      },
                      "playing_slot_index": {
                        "type": "number"
                      },
                      "current_input_routing": {
                        "type": "string",
                        "description": "set the input routing ,such as \"Resampling 3-MIDI 4 Audio\""
                      },
                      "input_routing_channel": {
                        "type": "number"
                      },
                      "current_output_routing": {
                        "type": "string"
                      },
                      "current_monitoring_state": {
                        "type": "number"
                      },
                      "current_input_sub_routing": {
                        "type": "string"
                      },
                      "current_output_sub_routing": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "track_id": {
                    "type": "string",
                    "description": "get track id by get_all_tracks"
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "required": [
            "tracks"
          ]
        }
      },
      {
        "name": "duplicate_clip_to_track",
        "description": "duplicate clip to track and return the duplicated clip information",
        "inputSchema": {
          "type": "object",
          "properties": {
            "time": {
              "type": "number"
            },
            "clip_id": {
              "type": "string"
            },
            "track_id": {
              "type": "string"
            }
          },
          "required": [
            "clip_id",
            "track_id",
            "time"
          ]
        }
      },
      {
        "name": "delete_clip",
        "description": "delete clip by id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "clip_id": {
              "type": "string"
            },
            "track_id": {
              "type": "string"
            }
          },
          "required": [
            "track_id",
            "clip_id"
          ]
        }
      },
      {
        "name": "delete_device",
        "description": "delete device by index, start from 0",
        "inputSchema": {
          "type": "object",
          "properties": {
            "index": {
              "type": "number"
            },
            "track_id": {
              "type": "string"
            }
          },
          "required": [
            "track_id",
            "index"
          ]
        }
      },
      {
        "name": "create_audio_clip",
        "description": "Create audio clip on track.\n        Given an absolute path to a valid audio file in a supported format, \n        creates an audio clip that references the file at the specified position in the arrangement view.\n        Prints an error if:\n        - The track is not an audio track\n        - The track is frozen\n        - The track is being recorded into",
        "inputSchema": {
          "type": "object",
          "properties": {
            "position": {
              "type": "number",
              "maximum": 1576800,
              "minimum": 0,
              "description": "position in beats"
            },
            "track_id": {
              "type": "string"
            },
            "file_path": {
              "type": "string",
              "description": "absolute path to audio file"
            }
          },
          "required": [
            "track_id",
            "file_path",
            "position"
          ]
        }
      },
      {
        "name": "init_ableton_js",
        "description": "Initialize ableton-js and copy its MIDI scripts to Ableton Live's MIDI Remote Scripts folder. \n            If ableton-js is already installed, it will update the content.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_application_info",
        "description": "Get Ableton Live application information. To get specific properties, set the corresponding property name to true in the properties parameter. If no properties are specified, returns all available information.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "browser": {
              "type": "boolean",
              "description": "Get browser information"
            },
            "version": {
              "type": "boolean",
              "description": "Get full version string"
            },
            "major_version": {
              "type": "boolean",
              "description": "Get major version number"
            },
            "minor_version": {
              "type": "boolean",
              "description": "Get minor version number"
            },
            "bugfix_version": {
              "type": "boolean",
              "description": "Get bugfix version number"
            },
            "open_dialog_count": {
              "type": "boolean",
              "description": "Get open dialog count"
            },
            "current_dialog_message": {
              "type": "boolean",
              "description": "Get current dialog message"
            },
            "current_dialog_button_count": {
              "type": "boolean",
              "description": "Get current dialog button count"
            }
          }
        }
      }
    ]
  },
  {
    "name": "xiaolaa2-midi-file-mcp",
    "title": "MIDI File MCP",
    "description": "A powerful MCP tool for parsing and manipulating MIDI files that allows users to read, analyze, and modify MIDI files through natural language commands, supporting operations like reading file information, modifying tracks, adding notes, and setting tempo.",
    "icon": "https://avatars.githubusercontent.com/xiaolaa2",
    "isOfficial": false,
    "homepage": "https://github.com/xiaolaa2/midi-file-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "midi-file-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_midi_info",
        "description": "Get midi file info",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file"
            }
          },
          "required": [
            "filePath"
          ]
        }
      },
      {
        "name": "set_tempo",
        "description": "Set tempo for midi file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "bpm": {
              "type": "number",
              "description": "BPM"
            },
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file"
            }
          },
          "required": [
            "filePath",
            "bpm"
          ]
        }
      },
      {
        "name": "get_tracks_info",
        "description": "Get tracks info from midi file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file \n            eg: D:programmingProjectmy-projectmidi-parser-mcp\test.mid"
            }
          },
          "required": [
            "filePath"
          ]
        }
      },
      {
        "name": "get_track_info_by_index",
        "description": "Get track info from midi file by track index. \n    name, instrument, channel, endOfTrackTicks, duration, durationTicks, noteCount",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file"
            },
            "trackIndex": {
              "type": "number",
              "description": "Track index number"
            }
          },
          "required": [
            "filePath",
            "trackIndex"
          ]
        }
      },
      {
        "name": "get_notes_by_index",
        "description": "Get notes from midi file by track index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file"
            },
            "trackIndex": {
              "type": "number",
              "description": "Track index number"
            }
          },
          "required": [
            "filePath",
            "trackIndex"
          ]
        }
      },
      {
        "name": "get_pitchbends_by_index",
        "description": "Get pitchbends from midi file by track index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file"
            },
            "trackIndex": {
              "type": "number",
              "description": "Track index number"
            }
          },
          "required": [
            "filePath",
            "trackIndex"
          ]
        }
      },
      {
        "name": "get_controlchanges_by_index",
        "description": "Get controlchanges from midi file by track index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file"
            },
            "trackIndex": {
              "type": "number",
              "description": "Track index number"
            }
          },
          "required": [
            "filePath",
            "trackIndex"
          ]
        }
      },
      {
        "name": "add_notes_by_index",
        "description": "Add notes to midi file by track index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "notes": {
              "type": "array",
              "items": {
                "allOf": [
                  {
                    "anyOf": [
                      {
                        "type": "object",
                        "required": [
                          "type",
                          "name"
                        ],
                        "properties": {
                          "name": {
                            "type": "string"
                          },
                          "type": {
                            "type": "string",
                            "const": "name"
                          }
                        },
                        "additionalProperties": false
                      },
                      {
                        "type": "object",
                        "required": [
                          "type",
                          "pitch",
                          "octave"
                        ],
                        "properties": {
                          "type": {
                            "type": "string",
                            "const": "pitch"
                          },
                          "pitch": {
                            "type": "string"
                          },
                          "octave": {
                            "type": "number"
                          }
                        },
                        "additionalProperties": false
                      },
                      {
                        "type": "object",
                        "required": [
                          "type",
                          "midi"
                        ],
                        "properties": {
                          "midi": {
                            "type": "number"
                          },
                          "type": {
                            "type": "string",
                            "const": "midi"
                          }
                        },
                        "additionalProperties": false
                      }
                    ]
                  },
                  {
                    "type": "object",
                    "properties": {
                      "velocity": {
                        "type": "number"
                      },
                      "noteOffVelocity": {
                        "type": "number"
                      }
                    }
                  },
                  {
                    "anyOf": [
                      {
                        "type": "object",
                        "required": [
                          "timeType",
                          "time"
                        ],
                        "properties": {
                          "time": {
                            "type": "number"
                          },
                          "duration": {
                            "type": "number"
                          },
                          "timeType": {
                            "type": "string",
                            "const": "seconds"
                          }
                        },
                        "additionalProperties": false
                      },
                      {
                        "type": "object",
                        "required": [
                          "timeType",
                          "ticks"
                        ],
                        "properties": {
                          "ticks": {
                            "type": "number"
                          },
                          "timeType": {
                            "type": "string",
                            "const": "ticks"
                          },
                          "durationTicks": {
                            "type": "number"
                          }
                        },
                        "additionalProperties": false
                      }
                    ]
                  }
                ]
              }
            },
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file"
            },
            "trackIndex": {
              "type": "number",
              "description": "Track index number"
            }
          },
          "required": [
            "filePath",
            "trackIndex",
            "notes"
          ]
        }
      },
      {
        "name": "add_controlchanges_by_index",
        "description": "Add controlchanges to midi file by track index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file"
            },
            "trackIndex": {
              "type": "number",
              "description": "Track index number"
            },
            "controlchanges": {
              "type": "array",
              "items": {
                "allOf": [
                  {
                    "type": "object",
                    "required": [
                      "number",
                      "value"
                    ],
                    "properties": {
                      "value": {
                        "type": "number"
                      },
                      "number": {
                        "type": "number"
                      }
                    }
                  },
                  {
                    "anyOf": [
                      {
                        "type": "object",
                        "required": [
                          "time"
                        ],
                        "properties": {
                          "time": {
                            "type": "number"
                          }
                        },
                        "additionalProperties": false
                      },
                      {
                        "type": "object",
                        "required": [
                          "ticks"
                        ],
                        "properties": {
                          "ticks": {
                            "type": "number"
                          }
                        },
                        "additionalProperties": false
                      }
                    ]
                  }
                ]
              }
            }
          },
          "required": [
            "filePath",
            "trackIndex",
            "controlchanges"
          ]
        }
      },
      {
        "name": "add_pitchbends_by_index",
        "description": "Add pitchbends to midi file by track index",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file"
            },
            "pitchbends": {
              "type": "array",
              "items": {
                "allOf": [
                  {
                    "type": "object",
                    "required": [
                      "value"
                    ],
                    "properties": {
                      "value": {
                        "type": "number"
                      }
                    }
                  },
                  {
                    "anyOf": [
                      {
                        "type": "object",
                        "required": [
                          "time"
                        ],
                        "properties": {
                          "time": {
                            "type": "number"
                          }
                        },
                        "additionalProperties": false
                      },
                      {
                        "type": "object",
                        "required": [
                          "ticks"
                        ],
                        "properties": {
                          "ticks": {
                            "type": "number"
                          }
                        },
                        "additionalProperties": false
                      }
                    ]
                  }
                ]
              }
            },
            "trackIndex": {
              "type": "number",
              "description": "Track index number"
            }
          },
          "required": [
            "filePath",
            "trackIndex",
            "pitchbends"
          ]
        }
      },
      {
        "name": "add_track",
        "description": "Add a new track to midi file and return the new track info",
        "inputSchema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Absoulate File Path to midi file"
            }
          },
          "required": [
            "filePath"
          ]
        }
      }
    ]
  },
  {
    "name": "yuna0x0-hackmd-mcp",
    "title": "HackMD MCP Server",
    "description": "A Model Context Protocol server that enables AI assistants to interact with the HackMD API for managing notes, including creating, reading, updating, and deleting notes.",
    "icon": "https://avatars.githubusercontent.com/yuna0x0",
    "isOfficial": false,
    "homepage": "https://github.com/yuna0x0/hackmd-mcp",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "hackmd-mcp"
      ],
      "env": {
        "HACKMD_API_URL": "<hackmd-api-url>",
        "HACKMD_API_TOKEN": "<hackmd-api-token>"
      }
    },
    "parameters": [
      {
        "name": "HACKMD_API_URL",
        "description": "HackMD API Endpoint URL",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "HACKMD_API_TOKEN",
        "description": "Your HackMD API token obtained from HackMD settings",
        "type": "string",
        "password": false,
        "required": true
      }
    ],
    "tools": [
      {
        "name": "get_user_info",
        "description": "Get information about the authenticated user",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_user_notes",
        "description": "List all notes owned by the user",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "get_note",
        "description": "Get a note by its ID",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string",
              "description": "Note ID"
            }
          },
          "required": [
            "noteId"
          ]
        }
      },
      {
        "name": "create_note",
        "description": "Create a new note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "payload": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "description": "Note title"
                },
                "content": {
                  "type": "string",
                  "description": "Note content"
                },
                "permalink": {
                  "type": "string",
                  "description": "Custom permalink"
                },
                "readPermission": {
                  "enum": [
                    "owner",
                    "signed_in",
                    "guest"
                  ],
                  "type": "string",
                  "description": "Read permission"
                },
                "writePermission": {
                  "enum": [
                    "owner",
                    "signed_in",
                    "guest"
                  ],
                  "type": "string",
                  "description": "Write permission"
                },
                "commentPermission": {
                  "enum": [
                    "disabled",
                    "forbidden",
                    "owners",
                    "signed_in_users",
                    "everyone"
                  ],
                  "type": "string",
                  "description": "Comment permission"
                }
              },
              "description": "Create note options",
              "additionalProperties": false
            }
          },
          "required": [
            "payload"
          ]
        }
      },
      {
        "name": "update_note",
        "description": "Update an existing note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string",
              "description": "Note ID"
            },
            "payload": {
              "type": "object",
              "properties": {
                "content": {
                  "type": "string",
                  "description": "New note content"
                },
                "permalink": {
                  "type": "string",
                  "description": "Custom permalink"
                },
                "readPermission": {
                  "enum": [
                    "owner",
                    "signed_in",
                    "guest"
                  ],
                  "type": "string",
                  "description": "Read permission"
                },
                "writePermission": {
                  "enum": [
                    "owner",
                    "signed_in",
                    "guest"
                  ],
                  "type": "string",
                  "description": "Write permission"
                }
              },
              "description": "Update note options",
              "additionalProperties": false
            }
          },
          "required": [
            "noteId",
            "payload"
          ]
        }
      },
      {
        "name": "delete_note",
        "description": "Delete a note",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string",
              "description": "Note ID"
            }
          },
          "required": [
            "noteId"
          ]
        }
      },
      {
        "name": "get_history",
        "description": "Get user's reading history",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_teams",
        "description": "List all teams accessible to the user",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      },
      {
        "name": "list_team_notes",
        "description": "List all notes in a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "teamPath": {
              "type": "string",
              "description": "Team path"
            }
          },
          "required": [
            "teamPath"
          ]
        }
      },
      {
        "name": "create_team_note",
        "description": "Create a new note in a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "payload": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "description": "Note title"
                },
                "content": {
                  "type": "string",
                  "description": "Note content"
                },
                "permalink": {
                  "type": "string",
                  "description": "Custom permalink"
                },
                "readPermission": {
                  "enum": [
                    "owner",
                    "signed_in",
                    "guest"
                  ],
                  "type": "string",
                  "description": "Read permission"
                },
                "writePermission": {
                  "enum": [
                    "owner",
                    "signed_in",
                    "guest"
                  ],
                  "type": "string",
                  "description": "Write permission"
                },
                "commentPermission": {
                  "enum": [
                    "disabled",
                    "forbidden",
                    "owners",
                    "signed_in_users",
                    "everyone"
                  ],
                  "type": "string",
                  "description": "Comment permission"
                }
              },
              "description": "Create note options",
              "additionalProperties": false
            },
            "teamPath": {
              "type": "string",
              "description": "Team path"
            }
          },
          "required": [
            "teamPath",
            "payload"
          ]
        }
      },
      {
        "name": "update_team_note",
        "description": "Update an existing note in a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string",
              "description": "Note ID"
            },
            "options": {
              "type": "object",
              "properties": {
                "content": {
                  "type": "string",
                  "description": "New note content"
                },
                "permalink": {
                  "type": "string",
                  "description": "Custom permalink"
                },
                "readPermission": {
                  "enum": [
                    "owner",
                    "signed_in",
                    "guest"
                  ],
                  "type": "string",
                  "description": "Read permission"
                },
                "writePermission": {
                  "enum": [
                    "owner",
                    "signed_in",
                    "guest"
                  ],
                  "type": "string",
                  "description": "Write permission"
                }
              },
              "description": "Update note options",
              "additionalProperties": false
            },
            "teamPath": {
              "type": "string",
              "description": "Team path"
            }
          },
          "required": [
            "teamPath",
            "noteId",
            "options"
          ]
        }
      },
      {
        "name": "delete_team_note",
        "description": "Delete a note in a team",
        "inputSchema": {
          "type": "object",
          "properties": {
            "noteId": {
              "type": "string",
              "description": "Note ID"
            },
            "teamPath": {
              "type": "string",
              "description": "Team path"
            }
          },
          "required": [
            "teamPath",
            "noteId"
          ]
        }
      }
    ]
  },
  {
    "name": "dkmaker-mcp-rest-api",
    "title": "mcp-rest-api",
    "description": "A TypeScript-based MCP server that enables testing of REST APIs through Cline. This tool allows you to test and interact with any REST API endpoints directly from your development environment.",
    "icon": "https://avatars.githubusercontent.com/dkmaker",
    "isOfficial": false,
    "homepage": "https://github.com/dkmaker/mcp-rest-api",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "dkmaker-mcp-rest-api"
      ],
      "env": {
        "AUTH_BEARER": "<auth-bearer>",
        "REST_BASE_URL": "<rest-base-url>",
        "AUTH_APIKEY_VALUE": "<auth-apikey-value>",
        "AUTH_BASIC_PASSWORD": "<auth-basic-password>",
        "AUTH_BASIC_USERNAME": "<auth-basic-username>",
        "REST_ENABLE_SSL_VERIFY": "<rest-enable-ssl-verify>",
        "AUTH_APIKEY_HEADER_NAME": "<auth-apikey-header-name>",
        "REST_RESPONSE_SIZE_LIMIT": "<rest-response-size-limit>"
      }
    },
    "parameters": [
      {
        "name": "AUTH_BEARER",
        "description": "Bearer token for token-based authentication",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "REST_BASE_URL",
        "description": "Base URL for the REST API (e.g., https://api.example.com)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "AUTH_APIKEY_VALUE",
        "description": "API key value for API key authentication",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "AUTH_BASIC_PASSWORD",
        "description": "Password for Basic Authentication",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "AUTH_BASIC_USERNAME",
        "description": "Username for Basic Authentication",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "REST_ENABLE_SSL_VERIFY",
        "description": "Enable or disable SSL verification for self-signed certificates",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "AUTH_APIKEY_HEADER_NAME",
        "description": "Header name for API key authentication (e.g., X-API-Key)",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "REST_RESPONSE_SIZE_LIMIT",
        "description": "Maximum response size in bytes",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": []
  },
  {
    "name": "zhiwei5576-excel-mcp-server",
    "title": "Excel MCP Server",
    "description": "Enables seamless reading, writing, and analyzing of Excel files through Model Context Protocol, with features for worksheet management, structure analysis, and automated caching.",
    "icon": "https://avatars.githubusercontent.com/zhiwei5576",
    "isOfficial": false,
    "homepage": "https://github.com/zhiwei5576/excel-mcp-server",
    "transport": {
      "type": "stdio",
      "command": "npx",
      "args": [
        "-y", "@zhiweixu/excel-mcp-server"
      ],
      "env": {
        "LOG_PATH": "<log-path>",
        "CACHE_MAX_AGE": "<cache-max-age>",
        "LOG_RETENTION_DAYS": "<log-retention-days>",
        "LOG_CLEANUP_INTERVAL": "<log-cleanup-interval>",
        "CACHE_CLEANUP_INTERVAL": "<cache-cleanup-interval>"
      }
    },
    "parameters": [
      {
        "name": "LOG_PATH",
        "description": "Log files storage path. If not set, logs will be stored in the 'logs' folder under the application root directory.",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CACHE_MAX_AGE",
        "description": "Cache expiration time in hours",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "LOG_RETENTION_DAYS",
        "description": "Log retention period in days",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "LOG_CLEANUP_INTERVAL",
        "description": "Log cleanup interval in hours",
        "type": "string",
        "password": false,
        "required": false
      },
      {
        "name": "CACHE_CLEANUP_INTERVAL",
        "description": "Cache cleanup interval in hours",
        "type": "string",
        "password": false,
        "required": false
      }
    ],
    "tools": [
      {
        "name": "analyzeExcelStructure",
        "description": "Get Excel file structure including sheet list and column headers in JSON format",
        "inputSchema": {
          "type": "object",
          "properties": {
            "headerRows": {
              "type": "number",
              "default": 1,
              "description": "Number of header rows to read (default: 1)"
            },
            "fileAbsolutePath": {
              "type": "string",
              "description": "The absolute path of the Excel file"
            }
          },
          "required": [
            "fileAbsolutePath"
          ]
        }
      },
      {
        "name": "exportExcelStructure",
        "description": "Export Excel file structure (sheets and headers) to a new Excel template file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "headerRows": {
              "type": "number",
              "default": 1,
              "description": "Number of header rows to analyze (default: 1)"
            },
            "sourceFilePath": {
              "type": "string",
              "description": "The source Excel file path to analyze"
            },
            "targetFilePath": {
              "type": "string",
              "description": "The target Excel file path to save structure"
            }
          },
          "required": [
            "sourceFilePath",
            "targetFilePath"
          ]
        }
      },
      {
        "name": "readSheetNames",
        "description": "Get all sheet names from the Excel file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileAbsolutePath": {
              "type": "string",
              "description": "The absolute path of the Excel file"
            }
          },
          "required": [
            "fileAbsolutePath"
          ]
        }
      },
      {
        "name": "readDataBySheetName",
        "description": "Get data from a specific sheet in the Excel file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "headerRow": {
              "type": "number",
              "default": 1,
              "description": "tThe row number to use as field names (default: 1)"
            },
            "sheetName": {
              "type": "string",
              "description": "tThe name of the sheet to read"
            },
            "dataStartRow": {
              "type": "number",
              "default": 2,
              "description": "The row number to start reading data from (default: 2)"
            },
            "fileAbsolutePath": {
              "type": "string",
              "description": "The absolute path of the Excel file"
            }
          },
          "required": [
            "fileAbsolutePath",
            "sheetName"
          ]
        }
      },
      {
        "name": "readSheetData",
        "description": "Get data from all sheets in the Excel file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "headerRow": {
              "type": "number",
              "default": 1,
              "description": "The row number to use as field names (default: 1)"
            },
            "dataStartRow": {
              "type": "number",
              "default": 2,
              "description": "The row number to start reading data from (default: 2)"
            },
            "fileAbsolutePath": {
              "type": "string",
              "description": "The absolute path of the Excel file"
            }
          },
          "required": [
            "fileAbsolutePath"
          ]
        }
      },
      {
        "name": "writeDataBySheetName",
        "description": "Write data to a specific sheet in the Excel file (overwrites if sheet exists)",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "array",
              "items": {
                "type": "object",
                "additionalProperties": {}
              },
              "description": "Array of objects to write to the sheet"
            },
            "sheetName": {
              "type": "string",
              "description": "The name of the sheet to write"
            },
            "fileAbsolutePath": {
              "type": "string",
              "description": "The absolute path of the Excel file"
            }
          },
          "required": [
            "fileAbsolutePath",
            "sheetName",
            "data"
          ]
        }
      },
      {
        "name": "writeSheetData",
        "description": "Create a new Excel file with provided data",
        "inputSchema": {
          "type": "object",
          "properties": {
            "data": {
              "type": "object",
              "description": "Data object with dynamic sheet names and column names",
              "additionalProperties": {
                "type": "array",
                "items": {
                  "type": "object",
                  "additionalProperties": {}
                }
              }
            },
            "fileAbsolutePath": {
              "type": "string",
              "description": "The absolute path for the new Excel file"
            }
          },
          "required": [
            "fileAbsolutePath",
            "data"
          ]
        }
      },
      {
        "name": "clearFileCache",
        "description": "Clear cached data for the specified Excel file",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fileAbsolutePath": {
              "type": "string",
              "description": "The absolute path of the Excel file to clear from cache"
            }
          },
          "required": [
            "fileAbsolutePath"
          ]
        }
      }
    ]
  },
  {
    "name": "zwldarren-akshare-one-mcp",
    "title": "akshare-one-mcp",
    "description": "akshare-one-mcp",
    "icon": "https://avatars.githubusercontent.com/zwldarren",
    "isOfficial": false,
    "homepage": "https://github.com/zwldarren/akshare-one-mcp",
    "transport": {
      "type": "stdio",
      "command": "uvx",
      "args": [
        "akshare-one-mcp"
      ],
      "env": {}
    },
    "parameters": [],
    "tools": [
      {
        "name": "get_hist_data",
        "description": "Get historical stock market data. 'eastmoney_direct' support all A,B,H shares",
        "inputSchema": {
          "type": "object",
          "properties": {
            "adjust": {
              "enum": [
                "none",
                "qfq",
                "hfq"
              ],
              "type": "string",
              "title": "Adjust",
              "default": "none",
              "description": "Adjustment type"
            },
            "source": {
              "enum": [
                "eastmoney",
                "eastmoney_direct",
                "sina"
              ],
              "type": "string",
              "title": "Source",
              "default": "eastmoney",
              "description": "Data source"
            },
            "symbol": {
              "type": "string",
              "title": "Symbol",
              "description": "Stock symbol/ticker (e.g. '000001')"
            },
            "end_date": {
              "type": "string",
              "title": "End Date",
              "default": "2030-12-31",
              "description": "End date in YYYY-MM-DD format"
            },
            "interval": {
              "enum": [
                "minute",
                "hour",
                "day",
                "week",
                "month",
                "year"
              ],
              "type": "string",
              "title": "Interval",
              "default": "day",
              "description": "Time interval"
            },
            "recent_n": {
              "anyOf": [
                {
                  "type": "integer",
                  "minimum": 1
                },
                {
                  "type": "null"
                }
              ],
              "title": "Recent N",
              "default": 100,
              "description": "Number of most recent records to return"
            },
            "start_date": {
              "type": "string",
              "title": "Start Date",
              "default": "1970-01-01",
              "description": "Start date in YYYY-MM-DD format"
            },
            "indicators_list": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "enum": [
                      "SMA",
                      "EMA",
                      "RSI",
                      "MACD",
                      "BOLL",
                      "STOCH",
                      "ATR",
                      "CCI",
                      "ADX"
                    ],
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Indicators List",
              "default": null,
              "description": "Technical indicators to add"
            },
            "interval_multiplier": {
              "type": "integer",
              "title": "Interval Multiplier",
              "default": 1,
              "minimum": 1,
              "description": "Interval multiplier"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_realtime_data",
        "description": "Get real-time stock market data. 'eastmoney_direct' support all A,B,H shares",
        "inputSchema": {
          "type": "object",
          "properties": {
            "source": {
              "enum": [
                "xueqiu",
                "eastmoney",
                "eastmoney_direct"
              ],
              "type": "string",
              "title": "Source",
              "default": "xueqiu",
              "description": "Data source"
            },
            "symbol": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Symbol",
              "default": null,
              "description": "Stock symbol/ticker (e.g. '000001')"
            }
          }
        }
      },
      {
        "name": "get_news_data",
        "description": "Get stock-related news data.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "title": "Symbol",
              "description": "Stock symbol/ticker (e.g. '000001')"
            },
            "recent_n": {
              "anyOf": [
                {
                  "type": "integer",
                  "minimum": 1
                },
                {
                  "type": "null"
                }
              ],
              "title": "Recent N",
              "default": 10,
              "description": "Number of most recent records to return"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_balance_sheet",
        "description": "Get company balance sheet data.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "title": "Symbol",
              "description": "Stock symbol/ticker (e.g. '000001')"
            },
            "recent_n": {
              "anyOf": [
                {
                  "type": "integer",
                  "minimum": 1
                },
                {
                  "type": "null"
                }
              ],
              "title": "Recent N",
              "default": 10,
              "description": "Number of most recent records to return"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_income_statement",
        "description": "Get company income statement data.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "title": "Symbol",
              "description": "Stock symbol/ticker (e.g. '000001')"
            },
            "recent_n": {
              "anyOf": [
                {
                  "type": "integer",
                  "minimum": 1
                },
                {
                  "type": "null"
                }
              ],
              "title": "Recent N",
              "default": 10,
              "description": "Number of most recent records to return"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_cash_flow",
        "description": "Get company cash flow statement data.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "source": {
              "type": "string",
              "title": "Source",
              "default": "sina",
              "description": "Data source"
            },
            "symbol": {
              "type": "string",
              "title": "Symbol",
              "description": "Stock symbol/ticker (e.g. '000001')"
            },
            "recent_n": {
              "anyOf": [
                {
                  "type": "integer",
                  "minimum": 1
                },
                {
                  "type": "null"
                }
              ],
              "title": "Recent N",
              "default": 10,
              "description": "Number of most recent records to return"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_inner_trade_data",
        "description": "Get company insider trading data.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "symbol": {
              "type": "string",
              "title": "Symbol",
              "description": "Stock symbol/ticker (e.g. '000001')"
            }
          },
          "required": [
            "symbol"
          ]
        }
      },
      {
        "name": "get_time_info",
        "description": "Get current time with ISO format, timestamp, and the last trading day.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  }
];
